
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4826      	ldr	r0, [pc, #152]	; (800025c <endfiniloop+0x6>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	4825      	ldr	r0, [pc, #148]	; (8000260 <endfiniloop+0xa>)
 80001ca:	f64e 5108 	movw	r1, #60680	; 0xed08
 80001ce:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001d2:	6008      	str	r0, [r1, #0]
 80001d4:	2002      	movs	r0, #2
 80001d6:	f380 8814 	msr	CONTROL, r0
 80001da:	f3bf 8f6f 	isb	sy
 80001de:	f00f f83f 	bl	800f260 <__core_init>
 80001e2:	f00c f85d 	bl	800c2a0 <__early_init>
 80001e6:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 80001ea:	491e      	ldr	r1, [pc, #120]	; (8000264 <endfiniloop+0xe>)
 80001ec:	4a1e      	ldr	r2, [pc, #120]	; (8000268 <endfiniloop+0x12>)

080001ee <msloop>:
 80001ee:	4291      	cmp	r1, r2
 80001f0:	bf3c      	itt	cc
 80001f2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f6:	e7fa      	bcc.n	80001ee <msloop>
 80001f8:	491c      	ldr	r1, [pc, #112]	; (800026c <endfiniloop+0x16>)
 80001fa:	4a18      	ldr	r2, [pc, #96]	; (800025c <endfiniloop+0x6>)

080001fc <psloop>:
 80001fc:	4291      	cmp	r1, r2
 80001fe:	bf3c      	itt	cc
 8000200:	f841 0b04 	strcc.w	r0, [r1], #4
 8000204:	e7fa      	bcc.n	80001fc <psloop>
 8000206:	491a      	ldr	r1, [pc, #104]	; (8000270 <endfiniloop+0x1a>)
 8000208:	4a1a      	ldr	r2, [pc, #104]	; (8000274 <endfiniloop+0x1e>)
 800020a:	4b1b      	ldr	r3, [pc, #108]	; (8000278 <endfiniloop+0x22>)

0800020c <dloop>:
 800020c:	429a      	cmp	r2, r3
 800020e:	bf3e      	ittt	cc
 8000210:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000214:	f842 0b04 	strcc.w	r0, [r2], #4
 8000218:	e7f8      	bcc.n	800020c <dloop>
 800021a:	2000      	movs	r0, #0
 800021c:	4917      	ldr	r1, [pc, #92]	; (800027c <endfiniloop+0x26>)
 800021e:	4a18      	ldr	r2, [pc, #96]	; (8000280 <endfiniloop+0x2a>)

08000220 <bloop>:
 8000220:	4291      	cmp	r1, r2
 8000222:	bf3c      	itt	cc
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
 8000228:	e7fa      	bcc.n	8000220 <bloop>
 800022a:	f00e ffd1 	bl	800f1d0 <__init_ram_areas>
 800022e:	f00f f80f 	bl	800f250 <__late_init>
 8000232:	4c14      	ldr	r4, [pc, #80]	; (8000284 <endfiniloop+0x2e>)
 8000234:	4d14      	ldr	r5, [pc, #80]	; (8000288 <endfiniloop+0x32>)

08000236 <initloop>:
 8000236:	42ac      	cmp	r4, r5
 8000238:	da03      	bge.n	8000242 <endinitloop>
 800023a:	f854 1b04 	ldr.w	r1, [r4], #4
 800023e:	4788      	blx	r1
 8000240:	e7f9      	b.n	8000236 <initloop>

08000242 <endinitloop>:
 8000242:	f007 f84d 	bl	80072e0 <main>
 8000246:	4c11      	ldr	r4, [pc, #68]	; (800028c <endfiniloop+0x36>)
 8000248:	4d11      	ldr	r5, [pc, #68]	; (8000290 <endfiniloop+0x3a>)

0800024a <finiloop>:
 800024a:	42ac      	cmp	r4, r5
 800024c:	da03      	bge.n	8000256 <endfiniloop>
 800024e:	f854 1b04 	ldr.w	r1, [r4], #4
 8000252:	4788      	blx	r1
 8000254:	e7f9      	b.n	800024a <finiloop>

08000256 <endfiniloop>:
 8000256:	f00e bff3 	b.w	800f240 <__default_exit>
 800025a:	0000      	.short	0x0000
 800025c:	20000800 	.word	0x20000800
 8000260:	08000000 	.word	0x08000000
 8000264:	20000000 	.word	0x20000000
 8000268:	20000400 	.word	0x20000400
 800026c:	20000400 	.word	0x20000400
 8000270:	080176e8 	.word	0x080176e8
 8000274:	20000800 	.word	0x20000800
 8000278:	20000c60 	.word	0x20000c60
 800027c:	20000c60 	.word	0x20000c60
 8000280:	20028810 	.word	0x20028810
 8000284:	080001c0 	.word	0x080001c0
 8000288:	080001c0 	.word	0x080001c0
 800028c:	080001c0 	.word	0x080001c0
 8000290:	080001c0 	.word	0x080001c0
	...

080002a0 <_port_switch>:
 80002a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002a4:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002a8:	68c3      	ldr	r3, [r0, #12]
 80002aa:	469d      	mov	sp, r3
 80002ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002b0 <_port_thread_start>:
 80002b0:	f00e fd56 	bl	800ed60 <_dbg_check_unlock>
 80002b4:	2300      	movs	r3, #0
 80002b6:	f383 8811 	msr	BASEPRI, r3
 80002ba:	4628      	mov	r0, r5
 80002bc:	47a0      	blx	r4
 80002be:	2000      	movs	r0, #0
 80002c0:	f00e ff0e 	bl	800f0e0 <chThdExit>

080002c4 <_port_switch_from_isr>:
 80002c4:	f00e fd5c 	bl	800ed80 <_dbg_check_lock>
 80002c8:	f00e fb32 	bl	800e930 <chSchDoReschedule>
 80002cc:	f00e fd48 	bl	800ed60 <_dbg_check_unlock>

080002d0 <_port_exit_from_isr>:
 80002d0:	df00      	svc	0
 80002d2:	e7fe      	b.n	80002d2 <_port_exit_from_isr+0x2>
	...

080002e0 <__aeabi_drsub>:
 80002e0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002e4:	e002      	b.n	80002ec <__adddf3>
 80002e6:	bf00      	nop

080002e8 <__aeabi_dsub>:
 80002e8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002ec <__adddf3>:
 80002ec:	b530      	push	{r4, r5, lr}
 80002ee:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002f2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002f6:	ea94 0f05 	teq	r4, r5
 80002fa:	bf08      	it	eq
 80002fc:	ea90 0f02 	teqeq	r0, r2
 8000300:	bf1f      	itttt	ne
 8000302:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000306:	ea55 0c02 	orrsne.w	ip, r5, r2
 800030a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800030e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000312:	f000 80e2 	beq.w	80004da <__adddf3+0x1ee>
 8000316:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800031a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800031e:	bfb8      	it	lt
 8000320:	426d      	neglt	r5, r5
 8000322:	dd0c      	ble.n	800033e <__adddf3+0x52>
 8000324:	442c      	add	r4, r5
 8000326:	ea80 0202 	eor.w	r2, r0, r2
 800032a:	ea81 0303 	eor.w	r3, r1, r3
 800032e:	ea82 0000 	eor.w	r0, r2, r0
 8000332:	ea83 0101 	eor.w	r1, r3, r1
 8000336:	ea80 0202 	eor.w	r2, r0, r2
 800033a:	ea81 0303 	eor.w	r3, r1, r3
 800033e:	2d36      	cmp	r5, #54	; 0x36
 8000340:	bf88      	it	hi
 8000342:	bd30      	pophi	{r4, r5, pc}
 8000344:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000348:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800034c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000350:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000354:	d002      	beq.n	800035c <__adddf3+0x70>
 8000356:	4240      	negs	r0, r0
 8000358:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800035c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000360:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000364:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000368:	d002      	beq.n	8000370 <__adddf3+0x84>
 800036a:	4252      	negs	r2, r2
 800036c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000370:	ea94 0f05 	teq	r4, r5
 8000374:	f000 80a7 	beq.w	80004c6 <__adddf3+0x1da>
 8000378:	f1a4 0401 	sub.w	r4, r4, #1
 800037c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000380:	db0d      	blt.n	800039e <__adddf3+0xb2>
 8000382:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000386:	fa22 f205 	lsr.w	r2, r2, r5
 800038a:	1880      	adds	r0, r0, r2
 800038c:	f141 0100 	adc.w	r1, r1, #0
 8000390:	fa03 f20e 	lsl.w	r2, r3, lr
 8000394:	1880      	adds	r0, r0, r2
 8000396:	fa43 f305 	asr.w	r3, r3, r5
 800039a:	4159      	adcs	r1, r3
 800039c:	e00e      	b.n	80003bc <__adddf3+0xd0>
 800039e:	f1a5 0520 	sub.w	r5, r5, #32
 80003a2:	f10e 0e20 	add.w	lr, lr, #32
 80003a6:	2a01      	cmp	r2, #1
 80003a8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003ac:	bf28      	it	cs
 80003ae:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003b2:	fa43 f305 	asr.w	r3, r3, r5
 80003b6:	18c0      	adds	r0, r0, r3
 80003b8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003c0:	d507      	bpl.n	80003d2 <__adddf3+0xe6>
 80003c2:	f04f 0e00 	mov.w	lr, #0
 80003c6:	f1dc 0c00 	rsbs	ip, ip, #0
 80003ca:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003ce:	eb6e 0101 	sbc.w	r1, lr, r1
 80003d2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003d6:	d31b      	bcc.n	8000410 <__adddf3+0x124>
 80003d8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003dc:	d30c      	bcc.n	80003f8 <__adddf3+0x10c>
 80003de:	0849      	lsrs	r1, r1, #1
 80003e0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003e4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003e8:	f104 0401 	add.w	r4, r4, #1
 80003ec:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003f0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003f4:	f080 809a 	bcs.w	800052c <__adddf3+0x240>
 80003f8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003fc:	bf08      	it	eq
 80003fe:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000402:	f150 0000 	adcs.w	r0, r0, #0
 8000406:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800040a:	ea41 0105 	orr.w	r1, r1, r5
 800040e:	bd30      	pop	{r4, r5, pc}
 8000410:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000414:	4140      	adcs	r0, r0
 8000416:	eb41 0101 	adc.w	r1, r1, r1
 800041a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800041e:	f1a4 0401 	sub.w	r4, r4, #1
 8000422:	d1e9      	bne.n	80003f8 <__adddf3+0x10c>
 8000424:	f091 0f00 	teq	r1, #0
 8000428:	bf04      	itt	eq
 800042a:	4601      	moveq	r1, r0
 800042c:	2000      	moveq	r0, #0
 800042e:	fab1 f381 	clz	r3, r1
 8000432:	bf08      	it	eq
 8000434:	3320      	addeq	r3, #32
 8000436:	f1a3 030b 	sub.w	r3, r3, #11
 800043a:	f1b3 0220 	subs.w	r2, r3, #32
 800043e:	da0c      	bge.n	800045a <__adddf3+0x16e>
 8000440:	320c      	adds	r2, #12
 8000442:	dd08      	ble.n	8000456 <__adddf3+0x16a>
 8000444:	f102 0c14 	add.w	ip, r2, #20
 8000448:	f1c2 020c 	rsb	r2, r2, #12
 800044c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000450:	fa21 f102 	lsr.w	r1, r1, r2
 8000454:	e00c      	b.n	8000470 <__adddf3+0x184>
 8000456:	f102 0214 	add.w	r2, r2, #20
 800045a:	bfd8      	it	le
 800045c:	f1c2 0c20 	rsble	ip, r2, #32
 8000460:	fa01 f102 	lsl.w	r1, r1, r2
 8000464:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000468:	bfdc      	itt	le
 800046a:	ea41 010c 	orrle.w	r1, r1, ip
 800046e:	4090      	lslle	r0, r2
 8000470:	1ae4      	subs	r4, r4, r3
 8000472:	bfa2      	ittt	ge
 8000474:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000478:	4329      	orrge	r1, r5
 800047a:	bd30      	popge	{r4, r5, pc}
 800047c:	ea6f 0404 	mvn.w	r4, r4
 8000480:	3c1f      	subs	r4, #31
 8000482:	da1c      	bge.n	80004be <__adddf3+0x1d2>
 8000484:	340c      	adds	r4, #12
 8000486:	dc0e      	bgt.n	80004a6 <__adddf3+0x1ba>
 8000488:	f104 0414 	add.w	r4, r4, #20
 800048c:	f1c4 0220 	rsb	r2, r4, #32
 8000490:	fa20 f004 	lsr.w	r0, r0, r4
 8000494:	fa01 f302 	lsl.w	r3, r1, r2
 8000498:	ea40 0003 	orr.w	r0, r0, r3
 800049c:	fa21 f304 	lsr.w	r3, r1, r4
 80004a0:	ea45 0103 	orr.w	r1, r5, r3
 80004a4:	bd30      	pop	{r4, r5, pc}
 80004a6:	f1c4 040c 	rsb	r4, r4, #12
 80004aa:	f1c4 0220 	rsb	r2, r4, #32
 80004ae:	fa20 f002 	lsr.w	r0, r0, r2
 80004b2:	fa01 f304 	lsl.w	r3, r1, r4
 80004b6:	ea40 0003 	orr.w	r0, r0, r3
 80004ba:	4629      	mov	r1, r5
 80004bc:	bd30      	pop	{r4, r5, pc}
 80004be:	fa21 f004 	lsr.w	r0, r1, r4
 80004c2:	4629      	mov	r1, r5
 80004c4:	bd30      	pop	{r4, r5, pc}
 80004c6:	f094 0f00 	teq	r4, #0
 80004ca:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004ce:	bf06      	itte	eq
 80004d0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004d4:	3401      	addeq	r4, #1
 80004d6:	3d01      	subne	r5, #1
 80004d8:	e74e      	b.n	8000378 <__adddf3+0x8c>
 80004da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004de:	bf18      	it	ne
 80004e0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004e4:	d029      	beq.n	800053a <__adddf3+0x24e>
 80004e6:	ea94 0f05 	teq	r4, r5
 80004ea:	bf08      	it	eq
 80004ec:	ea90 0f02 	teqeq	r0, r2
 80004f0:	d005      	beq.n	80004fe <__adddf3+0x212>
 80004f2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004f6:	bf04      	itt	eq
 80004f8:	4619      	moveq	r1, r3
 80004fa:	4610      	moveq	r0, r2
 80004fc:	bd30      	pop	{r4, r5, pc}
 80004fe:	ea91 0f03 	teq	r1, r3
 8000502:	bf1e      	ittt	ne
 8000504:	2100      	movne	r1, #0
 8000506:	2000      	movne	r0, #0
 8000508:	bd30      	popne	{r4, r5, pc}
 800050a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800050e:	d105      	bne.n	800051c <__adddf3+0x230>
 8000510:	0040      	lsls	r0, r0, #1
 8000512:	4149      	adcs	r1, r1
 8000514:	bf28      	it	cs
 8000516:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800051a:	bd30      	pop	{r4, r5, pc}
 800051c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000520:	bf3c      	itt	cc
 8000522:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000526:	bd30      	popcc	{r4, r5, pc}
 8000528:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800052c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000530:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000534:	f04f 0000 	mov.w	r0, #0
 8000538:	bd30      	pop	{r4, r5, pc}
 800053a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800053e:	bf1a      	itte	ne
 8000540:	4619      	movne	r1, r3
 8000542:	4610      	movne	r0, r2
 8000544:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000548:	bf1c      	itt	ne
 800054a:	460b      	movne	r3, r1
 800054c:	4602      	movne	r2, r0
 800054e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000552:	bf06      	itte	eq
 8000554:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000558:	ea91 0f03 	teqeq	r1, r3
 800055c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000560:	bd30      	pop	{r4, r5, pc}
 8000562:	bf00      	nop

08000564 <__aeabi_ui2d>:
 8000564:	f090 0f00 	teq	r0, #0
 8000568:	bf04      	itt	eq
 800056a:	2100      	moveq	r1, #0
 800056c:	4770      	bxeq	lr
 800056e:	b530      	push	{r4, r5, lr}
 8000570:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000574:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000578:	f04f 0500 	mov.w	r5, #0
 800057c:	f04f 0100 	mov.w	r1, #0
 8000580:	e750      	b.n	8000424 <__adddf3+0x138>
 8000582:	bf00      	nop

08000584 <__aeabi_i2d>:
 8000584:	f090 0f00 	teq	r0, #0
 8000588:	bf04      	itt	eq
 800058a:	2100      	moveq	r1, #0
 800058c:	4770      	bxeq	lr
 800058e:	b530      	push	{r4, r5, lr}
 8000590:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000594:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000598:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800059c:	bf48      	it	mi
 800059e:	4240      	negmi	r0, r0
 80005a0:	f04f 0100 	mov.w	r1, #0
 80005a4:	e73e      	b.n	8000424 <__adddf3+0x138>
 80005a6:	bf00      	nop

080005a8 <__aeabi_f2d>:
 80005a8:	0042      	lsls	r2, r0, #1
 80005aa:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005ae:	ea4f 0131 	mov.w	r1, r1, rrx
 80005b2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005b6:	bf1f      	itttt	ne
 80005b8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005bc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005c0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005c4:	4770      	bxne	lr
 80005c6:	f092 0f00 	teq	r2, #0
 80005ca:	bf14      	ite	ne
 80005cc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005d0:	4770      	bxeq	lr
 80005d2:	b530      	push	{r4, r5, lr}
 80005d4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005dc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005e0:	e720      	b.n	8000424 <__adddf3+0x138>
 80005e2:	bf00      	nop

080005e4 <__aeabi_ul2d>:
 80005e4:	ea50 0201 	orrs.w	r2, r0, r1
 80005e8:	bf08      	it	eq
 80005ea:	4770      	bxeq	lr
 80005ec:	b530      	push	{r4, r5, lr}
 80005ee:	f04f 0500 	mov.w	r5, #0
 80005f2:	e00a      	b.n	800060a <__aeabi_l2d+0x16>

080005f4 <__aeabi_l2d>:
 80005f4:	ea50 0201 	orrs.w	r2, r0, r1
 80005f8:	bf08      	it	eq
 80005fa:	4770      	bxeq	lr
 80005fc:	b530      	push	{r4, r5, lr}
 80005fe:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000602:	d502      	bpl.n	800060a <__aeabi_l2d+0x16>
 8000604:	4240      	negs	r0, r0
 8000606:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800060a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800060e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000612:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000616:	f43f aedc 	beq.w	80003d2 <__adddf3+0xe6>
 800061a:	f04f 0203 	mov.w	r2, #3
 800061e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000622:	bf18      	it	ne
 8000624:	3203      	addne	r2, #3
 8000626:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800062a:	bf18      	it	ne
 800062c:	3203      	addne	r2, #3
 800062e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000632:	f1c2 0320 	rsb	r3, r2, #32
 8000636:	fa00 fc03 	lsl.w	ip, r0, r3
 800063a:	fa20 f002 	lsr.w	r0, r0, r2
 800063e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000642:	ea40 000e 	orr.w	r0, r0, lr
 8000646:	fa21 f102 	lsr.w	r1, r1, r2
 800064a:	4414      	add	r4, r2
 800064c:	e6c1      	b.n	80003d2 <__adddf3+0xe6>
 800064e:	bf00      	nop

08000650 <__aeabi_dmul>:
 8000650:	b570      	push	{r4, r5, r6, lr}
 8000652:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000656:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800065a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800065e:	bf1d      	ittte	ne
 8000660:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000664:	ea94 0f0c 	teqne	r4, ip
 8000668:	ea95 0f0c 	teqne	r5, ip
 800066c:	f000 f8de 	bleq	800082c <__aeabi_dmul+0x1dc>
 8000670:	442c      	add	r4, r5
 8000672:	ea81 0603 	eor.w	r6, r1, r3
 8000676:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800067a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800067e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000682:	bf18      	it	ne
 8000684:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000688:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800068c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000690:	d038      	beq.n	8000704 <__aeabi_dmul+0xb4>
 8000692:	fba0 ce02 	umull	ip, lr, r0, r2
 8000696:	f04f 0500 	mov.w	r5, #0
 800069a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800069e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80006a2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80006a6:	f04f 0600 	mov.w	r6, #0
 80006aa:	fbe1 5603 	umlal	r5, r6, r1, r3
 80006ae:	f09c 0f00 	teq	ip, #0
 80006b2:	bf18      	it	ne
 80006b4:	f04e 0e01 	orrne.w	lr, lr, #1
 80006b8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006bc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006c0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006c4:	d204      	bcs.n	80006d0 <__aeabi_dmul+0x80>
 80006c6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006ca:	416d      	adcs	r5, r5
 80006cc:	eb46 0606 	adc.w	r6, r6, r6
 80006d0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006d4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006d8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006dc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006e0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006e4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006e8:	bf88      	it	hi
 80006ea:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006ee:	d81e      	bhi.n	800072e <__aeabi_dmul+0xde>
 80006f0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006f4:	bf08      	it	eq
 80006f6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006fa:	f150 0000 	adcs.w	r0, r0, #0
 80006fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000702:	bd70      	pop	{r4, r5, r6, pc}
 8000704:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000708:	ea46 0101 	orr.w	r1, r6, r1
 800070c:	ea40 0002 	orr.w	r0, r0, r2
 8000710:	ea81 0103 	eor.w	r1, r1, r3
 8000714:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000718:	bfc2      	ittt	gt
 800071a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800071e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000722:	bd70      	popgt	{r4, r5, r6, pc}
 8000724:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000728:	f04f 0e00 	mov.w	lr, #0
 800072c:	3c01      	subs	r4, #1
 800072e:	f300 80ab 	bgt.w	8000888 <__aeabi_dmul+0x238>
 8000732:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000736:	bfde      	ittt	le
 8000738:	2000      	movle	r0, #0
 800073a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800073e:	bd70      	pople	{r4, r5, r6, pc}
 8000740:	f1c4 0400 	rsb	r4, r4, #0
 8000744:	3c20      	subs	r4, #32
 8000746:	da35      	bge.n	80007b4 <__aeabi_dmul+0x164>
 8000748:	340c      	adds	r4, #12
 800074a:	dc1b      	bgt.n	8000784 <__aeabi_dmul+0x134>
 800074c:	f104 0414 	add.w	r4, r4, #20
 8000750:	f1c4 0520 	rsb	r5, r4, #32
 8000754:	fa00 f305 	lsl.w	r3, r0, r5
 8000758:	fa20 f004 	lsr.w	r0, r0, r4
 800075c:	fa01 f205 	lsl.w	r2, r1, r5
 8000760:	ea40 0002 	orr.w	r0, r0, r2
 8000764:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000768:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800076c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000770:	fa21 f604 	lsr.w	r6, r1, r4
 8000774:	eb42 0106 	adc.w	r1, r2, r6
 8000778:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800077c:	bf08      	it	eq
 800077e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000782:	bd70      	pop	{r4, r5, r6, pc}
 8000784:	f1c4 040c 	rsb	r4, r4, #12
 8000788:	f1c4 0520 	rsb	r5, r4, #32
 800078c:	fa00 f304 	lsl.w	r3, r0, r4
 8000790:	fa20 f005 	lsr.w	r0, r0, r5
 8000794:	fa01 f204 	lsl.w	r2, r1, r4
 8000798:	ea40 0002 	orr.w	r0, r0, r2
 800079c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007a0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80007a4:	f141 0100 	adc.w	r1, r1, #0
 80007a8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007ac:	bf08      	it	eq
 80007ae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007b2:	bd70      	pop	{r4, r5, r6, pc}
 80007b4:	f1c4 0520 	rsb	r5, r4, #32
 80007b8:	fa00 f205 	lsl.w	r2, r0, r5
 80007bc:	ea4e 0e02 	orr.w	lr, lr, r2
 80007c0:	fa20 f304 	lsr.w	r3, r0, r4
 80007c4:	fa01 f205 	lsl.w	r2, r1, r5
 80007c8:	ea43 0302 	orr.w	r3, r3, r2
 80007cc:	fa21 f004 	lsr.w	r0, r1, r4
 80007d0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007d4:	fa21 f204 	lsr.w	r2, r1, r4
 80007d8:	ea20 0002 	bic.w	r0, r0, r2
 80007dc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007e4:	bf08      	it	eq
 80007e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ea:	bd70      	pop	{r4, r5, r6, pc}
 80007ec:	f094 0f00 	teq	r4, #0
 80007f0:	d10f      	bne.n	8000812 <__aeabi_dmul+0x1c2>
 80007f2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007f6:	0040      	lsls	r0, r0, #1
 80007f8:	eb41 0101 	adc.w	r1, r1, r1
 80007fc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000800:	bf08      	it	eq
 8000802:	3c01      	subeq	r4, #1
 8000804:	d0f7      	beq.n	80007f6 <__aeabi_dmul+0x1a6>
 8000806:	ea41 0106 	orr.w	r1, r1, r6
 800080a:	f095 0f00 	teq	r5, #0
 800080e:	bf18      	it	ne
 8000810:	4770      	bxne	lr
 8000812:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000816:	0052      	lsls	r2, r2, #1
 8000818:	eb43 0303 	adc.w	r3, r3, r3
 800081c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000820:	bf08      	it	eq
 8000822:	3d01      	subeq	r5, #1
 8000824:	d0f7      	beq.n	8000816 <__aeabi_dmul+0x1c6>
 8000826:	ea43 0306 	orr.w	r3, r3, r6
 800082a:	4770      	bx	lr
 800082c:	ea94 0f0c 	teq	r4, ip
 8000830:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000834:	bf18      	it	ne
 8000836:	ea95 0f0c 	teqne	r5, ip
 800083a:	d00c      	beq.n	8000856 <__aeabi_dmul+0x206>
 800083c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000840:	bf18      	it	ne
 8000842:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000846:	d1d1      	bne.n	80007ec <__aeabi_dmul+0x19c>
 8000848:	ea81 0103 	eor.w	r1, r1, r3
 800084c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000850:	f04f 0000 	mov.w	r0, #0
 8000854:	bd70      	pop	{r4, r5, r6, pc}
 8000856:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800085a:	bf06      	itte	eq
 800085c:	4610      	moveq	r0, r2
 800085e:	4619      	moveq	r1, r3
 8000860:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000864:	d019      	beq.n	800089a <__aeabi_dmul+0x24a>
 8000866:	ea94 0f0c 	teq	r4, ip
 800086a:	d102      	bne.n	8000872 <__aeabi_dmul+0x222>
 800086c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000870:	d113      	bne.n	800089a <__aeabi_dmul+0x24a>
 8000872:	ea95 0f0c 	teq	r5, ip
 8000876:	d105      	bne.n	8000884 <__aeabi_dmul+0x234>
 8000878:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800087c:	bf1c      	itt	ne
 800087e:	4610      	movne	r0, r2
 8000880:	4619      	movne	r1, r3
 8000882:	d10a      	bne.n	800089a <__aeabi_dmul+0x24a>
 8000884:	ea81 0103 	eor.w	r1, r1, r3
 8000888:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800088c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000890:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000894:	f04f 0000 	mov.w	r0, #0
 8000898:	bd70      	pop	{r4, r5, r6, pc}
 800089a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800089e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80008a2:	bd70      	pop	{r4, r5, r6, pc}

080008a4 <__aeabi_ddiv>:
 80008a4:	b570      	push	{r4, r5, r6, lr}
 80008a6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80008aa:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80008ae:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80008b2:	bf1d      	ittte	ne
 80008b4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008b8:	ea94 0f0c 	teqne	r4, ip
 80008bc:	ea95 0f0c 	teqne	r5, ip
 80008c0:	f000 f8a7 	bleq	8000a12 <__aeabi_ddiv+0x16e>
 80008c4:	eba4 0405 	sub.w	r4, r4, r5
 80008c8:	ea81 0e03 	eor.w	lr, r1, r3
 80008cc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008d0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008d4:	f000 8088 	beq.w	80009e8 <__aeabi_ddiv+0x144>
 80008d8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008dc:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008e0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008e4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008e8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008ec:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008f0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008f4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008f8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008fc:	429d      	cmp	r5, r3
 80008fe:	bf08      	it	eq
 8000900:	4296      	cmpeq	r6, r2
 8000902:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000906:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800090a:	d202      	bcs.n	8000912 <__aeabi_ddiv+0x6e>
 800090c:	085b      	lsrs	r3, r3, #1
 800090e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000912:	1ab6      	subs	r6, r6, r2
 8000914:	eb65 0503 	sbc.w	r5, r5, r3
 8000918:	085b      	lsrs	r3, r3, #1
 800091a:	ea4f 0232 	mov.w	r2, r2, rrx
 800091e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000922:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 000c 	orrcs.w	r0, r0, ip
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000946:	bf22      	ittt	cs
 8000948:	1ab6      	subcs	r6, r6, r2
 800094a:	4675      	movcs	r5, lr
 800094c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000950:	085b      	lsrs	r3, r3, #1
 8000952:	ea4f 0232 	mov.w	r2, r2, rrx
 8000956:	ebb6 0e02 	subs.w	lr, r6, r2
 800095a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800095e:	bf22      	ittt	cs
 8000960:	1ab6      	subcs	r6, r6, r2
 8000962:	4675      	movcs	r5, lr
 8000964:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000968:	085b      	lsrs	r3, r3, #1
 800096a:	ea4f 0232 	mov.w	r2, r2, rrx
 800096e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000972:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000976:	bf22      	ittt	cs
 8000978:	1ab6      	subcs	r6, r6, r2
 800097a:	4675      	movcs	r5, lr
 800097c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000980:	ea55 0e06 	orrs.w	lr, r5, r6
 8000984:	d018      	beq.n	80009b8 <__aeabi_ddiv+0x114>
 8000986:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800098a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800098e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000992:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000996:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800099a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800099e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80009a2:	d1c0      	bne.n	8000926 <__aeabi_ddiv+0x82>
 80009a4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009a8:	d10b      	bne.n	80009c2 <__aeabi_ddiv+0x11e>
 80009aa:	ea41 0100 	orr.w	r1, r1, r0
 80009ae:	f04f 0000 	mov.w	r0, #0
 80009b2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80009b6:	e7b6      	b.n	8000926 <__aeabi_ddiv+0x82>
 80009b8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009bc:	bf04      	itt	eq
 80009be:	4301      	orreq	r1, r0
 80009c0:	2000      	moveq	r0, #0
 80009c2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009c6:	bf88      	it	hi
 80009c8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009cc:	f63f aeaf 	bhi.w	800072e <__aeabi_dmul+0xde>
 80009d0:	ebb5 0c03 	subs.w	ip, r5, r3
 80009d4:	bf04      	itt	eq
 80009d6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009da:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009de:	f150 0000 	adcs.w	r0, r0, #0
 80009e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009e6:	bd70      	pop	{r4, r5, r6, pc}
 80009e8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009ec:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009f0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009f4:	bfc2      	ittt	gt
 80009f6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009fa:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009fe:	bd70      	popgt	{r4, r5, r6, pc}
 8000a00:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a04:	f04f 0e00 	mov.w	lr, #0
 8000a08:	3c01      	subs	r4, #1
 8000a0a:	e690      	b.n	800072e <__aeabi_dmul+0xde>
 8000a0c:	ea45 0e06 	orr.w	lr, r5, r6
 8000a10:	e68d      	b.n	800072e <__aeabi_dmul+0xde>
 8000a12:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000a16:	ea94 0f0c 	teq	r4, ip
 8000a1a:	bf08      	it	eq
 8000a1c:	ea95 0f0c 	teqeq	r5, ip
 8000a20:	f43f af3b 	beq.w	800089a <__aeabi_dmul+0x24a>
 8000a24:	ea94 0f0c 	teq	r4, ip
 8000a28:	d10a      	bne.n	8000a40 <__aeabi_ddiv+0x19c>
 8000a2a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a2e:	f47f af34 	bne.w	800089a <__aeabi_dmul+0x24a>
 8000a32:	ea95 0f0c 	teq	r5, ip
 8000a36:	f47f af25 	bne.w	8000884 <__aeabi_dmul+0x234>
 8000a3a:	4610      	mov	r0, r2
 8000a3c:	4619      	mov	r1, r3
 8000a3e:	e72c      	b.n	800089a <__aeabi_dmul+0x24a>
 8000a40:	ea95 0f0c 	teq	r5, ip
 8000a44:	d106      	bne.n	8000a54 <__aeabi_ddiv+0x1b0>
 8000a46:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a4a:	f43f aefd 	beq.w	8000848 <__aeabi_dmul+0x1f8>
 8000a4e:	4610      	mov	r0, r2
 8000a50:	4619      	mov	r1, r3
 8000a52:	e722      	b.n	800089a <__aeabi_dmul+0x24a>
 8000a54:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a58:	bf18      	it	ne
 8000a5a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a5e:	f47f aec5 	bne.w	80007ec <__aeabi_dmul+0x19c>
 8000a62:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a66:	f47f af0d 	bne.w	8000884 <__aeabi_dmul+0x234>
 8000a6a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a6e:	f47f aeeb 	bne.w	8000848 <__aeabi_dmul+0x1f8>
 8000a72:	e712      	b.n	800089a <__aeabi_dmul+0x24a>
	...

08000a80 <__gedf2>:
 8000a80:	f04f 3cff 	mov.w	ip, #4294967295
 8000a84:	e006      	b.n	8000a94 <__cmpdf2+0x4>
 8000a86:	bf00      	nop

08000a88 <__ledf2>:
 8000a88:	f04f 0c01 	mov.w	ip, #1
 8000a8c:	e002      	b.n	8000a94 <__cmpdf2+0x4>
 8000a8e:	bf00      	nop

08000a90 <__cmpdf2>:
 8000a90:	f04f 0c01 	mov.w	ip, #1
 8000a94:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a98:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a9c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000aa0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000aa4:	bf18      	it	ne
 8000aa6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000aaa:	d01b      	beq.n	8000ae4 <__cmpdf2+0x54>
 8000aac:	b001      	add	sp, #4
 8000aae:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000ab2:	bf0c      	ite	eq
 8000ab4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000ab8:	ea91 0f03 	teqne	r1, r3
 8000abc:	bf02      	ittt	eq
 8000abe:	ea90 0f02 	teqeq	r0, r2
 8000ac2:	2000      	moveq	r0, #0
 8000ac4:	4770      	bxeq	lr
 8000ac6:	f110 0f00 	cmn.w	r0, #0
 8000aca:	ea91 0f03 	teq	r1, r3
 8000ace:	bf58      	it	pl
 8000ad0:	4299      	cmppl	r1, r3
 8000ad2:	bf08      	it	eq
 8000ad4:	4290      	cmpeq	r0, r2
 8000ad6:	bf2c      	ite	cs
 8000ad8:	17d8      	asrcs	r0, r3, #31
 8000ada:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000ade:	f040 0001 	orr.w	r0, r0, #1
 8000ae2:	4770      	bx	lr
 8000ae4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000ae8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000aec:	d102      	bne.n	8000af4 <__cmpdf2+0x64>
 8000aee:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000af2:	d107      	bne.n	8000b04 <__cmpdf2+0x74>
 8000af4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000af8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000afc:	d1d6      	bne.n	8000aac <__cmpdf2+0x1c>
 8000afe:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b02:	d0d3      	beq.n	8000aac <__cmpdf2+0x1c>
 8000b04:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000b08:	4770      	bx	lr
 8000b0a:	bf00      	nop

08000b0c <__aeabi_cdrcmple>:
 8000b0c:	4684      	mov	ip, r0
 8000b0e:	4610      	mov	r0, r2
 8000b10:	4662      	mov	r2, ip
 8000b12:	468c      	mov	ip, r1
 8000b14:	4619      	mov	r1, r3
 8000b16:	4663      	mov	r3, ip
 8000b18:	e000      	b.n	8000b1c <__aeabi_cdcmpeq>
 8000b1a:	bf00      	nop

08000b1c <__aeabi_cdcmpeq>:
 8000b1c:	b501      	push	{r0, lr}
 8000b1e:	f7ff ffb7 	bl	8000a90 <__cmpdf2>
 8000b22:	2800      	cmp	r0, #0
 8000b24:	bf48      	it	mi
 8000b26:	f110 0f00 	cmnmi.w	r0, #0
 8000b2a:	bd01      	pop	{r0, pc}

08000b2c <__aeabi_dcmpeq>:
 8000b2c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b30:	f7ff fff4 	bl	8000b1c <__aeabi_cdcmpeq>
 8000b34:	bf0c      	ite	eq
 8000b36:	2001      	moveq	r0, #1
 8000b38:	2000      	movne	r0, #0
 8000b3a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b3e:	bf00      	nop

08000b40 <__aeabi_dcmplt>:
 8000b40:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b44:	f7ff ffea 	bl	8000b1c <__aeabi_cdcmpeq>
 8000b48:	bf34      	ite	cc
 8000b4a:	2001      	movcc	r0, #1
 8000b4c:	2000      	movcs	r0, #0
 8000b4e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b52:	bf00      	nop

08000b54 <__aeabi_dcmple>:
 8000b54:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b58:	f7ff ffe0 	bl	8000b1c <__aeabi_cdcmpeq>
 8000b5c:	bf94      	ite	ls
 8000b5e:	2001      	movls	r0, #1
 8000b60:	2000      	movhi	r0, #0
 8000b62:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b66:	bf00      	nop

08000b68 <__aeabi_dcmpge>:
 8000b68:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b6c:	f7ff ffce 	bl	8000b0c <__aeabi_cdrcmple>
 8000b70:	bf94      	ite	ls
 8000b72:	2001      	movls	r0, #1
 8000b74:	2000      	movhi	r0, #0
 8000b76:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b7a:	bf00      	nop

08000b7c <__aeabi_dcmpgt>:
 8000b7c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b80:	f7ff ffc4 	bl	8000b0c <__aeabi_cdrcmple>
 8000b84:	bf34      	ite	cc
 8000b86:	2001      	movcc	r0, #1
 8000b88:	2000      	movcs	r0, #0
 8000b8a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b8e:	bf00      	nop

08000b90 <__aeabi_dcmpun>:
 8000b90:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b94:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b98:	d102      	bne.n	8000ba0 <__aeabi_dcmpun+0x10>
 8000b9a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b9e:	d10a      	bne.n	8000bb6 <__aeabi_dcmpun+0x26>
 8000ba0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000ba4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ba8:	d102      	bne.n	8000bb0 <__aeabi_dcmpun+0x20>
 8000baa:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000bae:	d102      	bne.n	8000bb6 <__aeabi_dcmpun+0x26>
 8000bb0:	f04f 0000 	mov.w	r0, #0
 8000bb4:	4770      	bx	lr
 8000bb6:	f04f 0001 	mov.w	r0, #1
 8000bba:	4770      	bx	lr
 8000bbc:	0000      	movs	r0, r0
	...

08000bc0 <__aeabi_d2uiz>:
 8000bc0:	004a      	lsls	r2, r1, #1
 8000bc2:	d211      	bcs.n	8000be8 <__aeabi_d2uiz+0x28>
 8000bc4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000bc8:	d211      	bcs.n	8000bee <__aeabi_d2uiz+0x2e>
 8000bca:	d50d      	bpl.n	8000be8 <__aeabi_d2uiz+0x28>
 8000bcc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000bd0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000bd4:	d40e      	bmi.n	8000bf4 <__aeabi_d2uiz+0x34>
 8000bd6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000bda:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000bde:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000be2:	fa23 f002 	lsr.w	r0, r3, r2
 8000be6:	4770      	bx	lr
 8000be8:	f04f 0000 	mov.w	r0, #0
 8000bec:	4770      	bx	lr
 8000bee:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000bf2:	d102      	bne.n	8000bfa <__aeabi_d2uiz+0x3a>
 8000bf4:	f04f 30ff 	mov.w	r0, #4294967295
 8000bf8:	4770      	bx	lr
 8000bfa:	f04f 0000 	mov.w	r0, #0
 8000bfe:	4770      	bx	lr

08000c00 <__aeabi_d2f>:
 8000c00:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000c04:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000c08:	bf24      	itt	cs
 8000c0a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000c0e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000c12:	d90d      	bls.n	8000c30 <__aeabi_d2f+0x30>
 8000c14:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000c18:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000c1c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000c20:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000c24:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000c28:	bf08      	it	eq
 8000c2a:	f020 0001 	biceq.w	r0, r0, #1
 8000c2e:	4770      	bx	lr
 8000c30:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000c34:	d121      	bne.n	8000c7a <__aeabi_d2f+0x7a>
 8000c36:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000c3a:	bfbc      	itt	lt
 8000c3c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000c40:	4770      	bxlt	lr
 8000c42:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000c46:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000c4a:	f1c2 0218 	rsb	r2, r2, #24
 8000c4e:	f1c2 0c20 	rsb	ip, r2, #32
 8000c52:	fa10 f30c 	lsls.w	r3, r0, ip
 8000c56:	fa20 f002 	lsr.w	r0, r0, r2
 8000c5a:	bf18      	it	ne
 8000c5c:	f040 0001 	orrne.w	r0, r0, #1
 8000c60:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c64:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000c68:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000c6c:	ea40 000c 	orr.w	r0, r0, ip
 8000c70:	fa23 f302 	lsr.w	r3, r3, r2
 8000c74:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000c78:	e7cc      	b.n	8000c14 <__aeabi_d2f+0x14>
 8000c7a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000c7e:	d107      	bne.n	8000c90 <__aeabi_d2f+0x90>
 8000c80:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000c84:	bf1e      	ittt	ne
 8000c86:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000c8a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000c8e:	4770      	bxne	lr
 8000c90:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000c94:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000c98:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000c9c:	4770      	bx	lr
 8000c9e:	bf00      	nop

08000ca0 <__aeabi_frsub>:
 8000ca0:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000ca4:	e002      	b.n	8000cac <__addsf3>
 8000ca6:	bf00      	nop

08000ca8 <__aeabi_fsub>:
 8000ca8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000cac <__addsf3>:
 8000cac:	0042      	lsls	r2, r0, #1
 8000cae:	bf1f      	itttt	ne
 8000cb0:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000cb4:	ea92 0f03 	teqne	r2, r3
 8000cb8:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000cbc:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000cc0:	d06a      	beq.n	8000d98 <__addsf3+0xec>
 8000cc2:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000cc6:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000cca:	bfc1      	itttt	gt
 8000ccc:	18d2      	addgt	r2, r2, r3
 8000cce:	4041      	eorgt	r1, r0
 8000cd0:	4048      	eorgt	r0, r1
 8000cd2:	4041      	eorgt	r1, r0
 8000cd4:	bfb8      	it	lt
 8000cd6:	425b      	neglt	r3, r3
 8000cd8:	2b19      	cmp	r3, #25
 8000cda:	bf88      	it	hi
 8000cdc:	4770      	bxhi	lr
 8000cde:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000ce2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000ce6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000cea:	bf18      	it	ne
 8000cec:	4240      	negne	r0, r0
 8000cee:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000cf2:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000cf6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000cfa:	bf18      	it	ne
 8000cfc:	4249      	negne	r1, r1
 8000cfe:	ea92 0f03 	teq	r2, r3
 8000d02:	d03f      	beq.n	8000d84 <__addsf3+0xd8>
 8000d04:	f1a2 0201 	sub.w	r2, r2, #1
 8000d08:	fa41 fc03 	asr.w	ip, r1, r3
 8000d0c:	eb10 000c 	adds.w	r0, r0, ip
 8000d10:	f1c3 0320 	rsb	r3, r3, #32
 8000d14:	fa01 f103 	lsl.w	r1, r1, r3
 8000d18:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000d1c:	d502      	bpl.n	8000d24 <__addsf3+0x78>
 8000d1e:	4249      	negs	r1, r1
 8000d20:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000d24:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000d28:	d313      	bcc.n	8000d52 <__addsf3+0xa6>
 8000d2a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000d2e:	d306      	bcc.n	8000d3e <__addsf3+0x92>
 8000d30:	0840      	lsrs	r0, r0, #1
 8000d32:	ea4f 0131 	mov.w	r1, r1, rrx
 8000d36:	f102 0201 	add.w	r2, r2, #1
 8000d3a:	2afe      	cmp	r2, #254	; 0xfe
 8000d3c:	d251      	bcs.n	8000de2 <__addsf3+0x136>
 8000d3e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000d42:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000d46:	bf08      	it	eq
 8000d48:	f020 0001 	biceq.w	r0, r0, #1
 8000d4c:	ea40 0003 	orr.w	r0, r0, r3
 8000d50:	4770      	bx	lr
 8000d52:	0049      	lsls	r1, r1, #1
 8000d54:	eb40 0000 	adc.w	r0, r0, r0
 8000d58:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8000d5c:	f1a2 0201 	sub.w	r2, r2, #1
 8000d60:	d1ed      	bne.n	8000d3e <__addsf3+0x92>
 8000d62:	fab0 fc80 	clz	ip, r0
 8000d66:	f1ac 0c08 	sub.w	ip, ip, #8
 8000d6a:	ebb2 020c 	subs.w	r2, r2, ip
 8000d6e:	fa00 f00c 	lsl.w	r0, r0, ip
 8000d72:	bfaa      	itet	ge
 8000d74:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000d78:	4252      	neglt	r2, r2
 8000d7a:	4318      	orrge	r0, r3
 8000d7c:	bfbc      	itt	lt
 8000d7e:	40d0      	lsrlt	r0, r2
 8000d80:	4318      	orrlt	r0, r3
 8000d82:	4770      	bx	lr
 8000d84:	f092 0f00 	teq	r2, #0
 8000d88:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000d8c:	bf06      	itte	eq
 8000d8e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000d92:	3201      	addeq	r2, #1
 8000d94:	3b01      	subne	r3, #1
 8000d96:	e7b5      	b.n	8000d04 <__addsf3+0x58>
 8000d98:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000d9c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000da0:	bf18      	it	ne
 8000da2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000da6:	d021      	beq.n	8000dec <__addsf3+0x140>
 8000da8:	ea92 0f03 	teq	r2, r3
 8000dac:	d004      	beq.n	8000db8 <__addsf3+0x10c>
 8000dae:	f092 0f00 	teq	r2, #0
 8000db2:	bf08      	it	eq
 8000db4:	4608      	moveq	r0, r1
 8000db6:	4770      	bx	lr
 8000db8:	ea90 0f01 	teq	r0, r1
 8000dbc:	bf1c      	itt	ne
 8000dbe:	2000      	movne	r0, #0
 8000dc0:	4770      	bxne	lr
 8000dc2:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000dc6:	d104      	bne.n	8000dd2 <__addsf3+0x126>
 8000dc8:	0040      	lsls	r0, r0, #1
 8000dca:	bf28      	it	cs
 8000dcc:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000dd0:	4770      	bx	lr
 8000dd2:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000dd6:	bf3c      	itt	cc
 8000dd8:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000ddc:	4770      	bxcc	lr
 8000dde:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000de2:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000de6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000dea:	4770      	bx	lr
 8000dec:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000df0:	bf16      	itet	ne
 8000df2:	4608      	movne	r0, r1
 8000df4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000df8:	4601      	movne	r1, r0
 8000dfa:	0242      	lsls	r2, r0, #9
 8000dfc:	bf06      	itte	eq
 8000dfe:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000e02:	ea90 0f01 	teqeq	r0, r1
 8000e06:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000e0a:	4770      	bx	lr

08000e0c <__aeabi_ui2f>:
 8000e0c:	f04f 0300 	mov.w	r3, #0
 8000e10:	e004      	b.n	8000e1c <__aeabi_i2f+0x8>
 8000e12:	bf00      	nop

08000e14 <__aeabi_i2f>:
 8000e14:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000e18:	bf48      	it	mi
 8000e1a:	4240      	negmi	r0, r0
 8000e1c:	ea5f 0c00 	movs.w	ip, r0
 8000e20:	bf08      	it	eq
 8000e22:	4770      	bxeq	lr
 8000e24:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000e28:	4601      	mov	r1, r0
 8000e2a:	f04f 0000 	mov.w	r0, #0
 8000e2e:	e01c      	b.n	8000e6a <__aeabi_l2f+0x2a>

08000e30 <__aeabi_ul2f>:
 8000e30:	ea50 0201 	orrs.w	r2, r0, r1
 8000e34:	bf08      	it	eq
 8000e36:	4770      	bxeq	lr
 8000e38:	f04f 0300 	mov.w	r3, #0
 8000e3c:	e00a      	b.n	8000e54 <__aeabi_l2f+0x14>
 8000e3e:	bf00      	nop

08000e40 <__aeabi_l2f>:
 8000e40:	ea50 0201 	orrs.w	r2, r0, r1
 8000e44:	bf08      	it	eq
 8000e46:	4770      	bxeq	lr
 8000e48:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000e4c:	d502      	bpl.n	8000e54 <__aeabi_l2f+0x14>
 8000e4e:	4240      	negs	r0, r0
 8000e50:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000e54:	ea5f 0c01 	movs.w	ip, r1
 8000e58:	bf02      	ittt	eq
 8000e5a:	4684      	moveq	ip, r0
 8000e5c:	4601      	moveq	r1, r0
 8000e5e:	2000      	moveq	r0, #0
 8000e60:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000e64:	bf08      	it	eq
 8000e66:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000e6a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000e6e:	fabc f28c 	clz	r2, ip
 8000e72:	3a08      	subs	r2, #8
 8000e74:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000e78:	db10      	blt.n	8000e9c <__aeabi_l2f+0x5c>
 8000e7a:	fa01 fc02 	lsl.w	ip, r1, r2
 8000e7e:	4463      	add	r3, ip
 8000e80:	fa00 fc02 	lsl.w	ip, r0, r2
 8000e84:	f1c2 0220 	rsb	r2, r2, #32
 8000e88:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000e8c:	fa20 f202 	lsr.w	r2, r0, r2
 8000e90:	eb43 0002 	adc.w	r0, r3, r2
 8000e94:	bf08      	it	eq
 8000e96:	f020 0001 	biceq.w	r0, r0, #1
 8000e9a:	4770      	bx	lr
 8000e9c:	f102 0220 	add.w	r2, r2, #32
 8000ea0:	fa01 fc02 	lsl.w	ip, r1, r2
 8000ea4:	f1c2 0220 	rsb	r2, r2, #32
 8000ea8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000eac:	fa21 f202 	lsr.w	r2, r1, r2
 8000eb0:	eb43 0002 	adc.w	r0, r3, r2
 8000eb4:	bf08      	it	eq
 8000eb6:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000eba:	4770      	bx	lr
 8000ebc:	0000      	movs	r0, r0
	...

08000ec0 <__aeabi_fmul>:
 8000ec0:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000ec4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000ec8:	bf1e      	ittt	ne
 8000eca:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000ece:	ea92 0f0c 	teqne	r2, ip
 8000ed2:	ea93 0f0c 	teqne	r3, ip
 8000ed6:	d06f      	beq.n	8000fb8 <__aeabi_fmul+0xf8>
 8000ed8:	441a      	add	r2, r3
 8000eda:	ea80 0c01 	eor.w	ip, r0, r1
 8000ede:	0240      	lsls	r0, r0, #9
 8000ee0:	bf18      	it	ne
 8000ee2:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000ee6:	d01e      	beq.n	8000f26 <__aeabi_fmul+0x66>
 8000ee8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000eec:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000ef0:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000ef4:	fba0 3101 	umull	r3, r1, r0, r1
 8000ef8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000efc:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000f00:	bf3e      	ittt	cc
 8000f02:	0049      	lslcc	r1, r1, #1
 8000f04:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000f08:	005b      	lslcc	r3, r3, #1
 8000f0a:	ea40 0001 	orr.w	r0, r0, r1
 8000f0e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000f12:	2afd      	cmp	r2, #253	; 0xfd
 8000f14:	d81d      	bhi.n	8000f52 <__aeabi_fmul+0x92>
 8000f16:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000f1a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000f1e:	bf08      	it	eq
 8000f20:	f020 0001 	biceq.w	r0, r0, #1
 8000f24:	4770      	bx	lr
 8000f26:	f090 0f00 	teq	r0, #0
 8000f2a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000f2e:	bf08      	it	eq
 8000f30:	0249      	lsleq	r1, r1, #9
 8000f32:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000f36:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000f3a:	3a7f      	subs	r2, #127	; 0x7f
 8000f3c:	bfc2      	ittt	gt
 8000f3e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000f42:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000f46:	4770      	bxgt	lr
 8000f48:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000f4c:	f04f 0300 	mov.w	r3, #0
 8000f50:	3a01      	subs	r2, #1
 8000f52:	dc5d      	bgt.n	8001010 <__aeabi_fmul+0x150>
 8000f54:	f112 0f19 	cmn.w	r2, #25
 8000f58:	bfdc      	itt	le
 8000f5a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000f5e:	4770      	bxle	lr
 8000f60:	f1c2 0200 	rsb	r2, r2, #0
 8000f64:	0041      	lsls	r1, r0, #1
 8000f66:	fa21 f102 	lsr.w	r1, r1, r2
 8000f6a:	f1c2 0220 	rsb	r2, r2, #32
 8000f6e:	fa00 fc02 	lsl.w	ip, r0, r2
 8000f72:	ea5f 0031 	movs.w	r0, r1, rrx
 8000f76:	f140 0000 	adc.w	r0, r0, #0
 8000f7a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000f7e:	bf08      	it	eq
 8000f80:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000f84:	4770      	bx	lr
 8000f86:	f092 0f00 	teq	r2, #0
 8000f8a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000f8e:	bf02      	ittt	eq
 8000f90:	0040      	lsleq	r0, r0, #1
 8000f92:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000f96:	3a01      	subeq	r2, #1
 8000f98:	d0f9      	beq.n	8000f8e <__aeabi_fmul+0xce>
 8000f9a:	ea40 000c 	orr.w	r0, r0, ip
 8000f9e:	f093 0f00 	teq	r3, #0
 8000fa2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000fa6:	bf02      	ittt	eq
 8000fa8:	0049      	lsleq	r1, r1, #1
 8000faa:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000fae:	3b01      	subeq	r3, #1
 8000fb0:	d0f9      	beq.n	8000fa6 <__aeabi_fmul+0xe6>
 8000fb2:	ea41 010c 	orr.w	r1, r1, ip
 8000fb6:	e78f      	b.n	8000ed8 <__aeabi_fmul+0x18>
 8000fb8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000fbc:	ea92 0f0c 	teq	r2, ip
 8000fc0:	bf18      	it	ne
 8000fc2:	ea93 0f0c 	teqne	r3, ip
 8000fc6:	d00a      	beq.n	8000fde <__aeabi_fmul+0x11e>
 8000fc8:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000fcc:	bf18      	it	ne
 8000fce:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000fd2:	d1d8      	bne.n	8000f86 <__aeabi_fmul+0xc6>
 8000fd4:	ea80 0001 	eor.w	r0, r0, r1
 8000fd8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000fdc:	4770      	bx	lr
 8000fde:	f090 0f00 	teq	r0, #0
 8000fe2:	bf17      	itett	ne
 8000fe4:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000fe8:	4608      	moveq	r0, r1
 8000fea:	f091 0f00 	teqne	r1, #0
 8000fee:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000ff2:	d014      	beq.n	800101e <__aeabi_fmul+0x15e>
 8000ff4:	ea92 0f0c 	teq	r2, ip
 8000ff8:	d101      	bne.n	8000ffe <__aeabi_fmul+0x13e>
 8000ffa:	0242      	lsls	r2, r0, #9
 8000ffc:	d10f      	bne.n	800101e <__aeabi_fmul+0x15e>
 8000ffe:	ea93 0f0c 	teq	r3, ip
 8001002:	d103      	bne.n	800100c <__aeabi_fmul+0x14c>
 8001004:	024b      	lsls	r3, r1, #9
 8001006:	bf18      	it	ne
 8001008:	4608      	movne	r0, r1
 800100a:	d108      	bne.n	800101e <__aeabi_fmul+0x15e>
 800100c:	ea80 0001 	eor.w	r0, r0, r1
 8001010:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8001014:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8001018:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800101c:	4770      	bx	lr
 800101e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8001022:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8001026:	4770      	bx	lr

08001028 <__aeabi_fdiv>:
 8001028:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800102c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8001030:	bf1e      	ittt	ne
 8001032:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8001036:	ea92 0f0c 	teqne	r2, ip
 800103a:	ea93 0f0c 	teqne	r3, ip
 800103e:	d069      	beq.n	8001114 <__aeabi_fdiv+0xec>
 8001040:	eba2 0203 	sub.w	r2, r2, r3
 8001044:	ea80 0c01 	eor.w	ip, r0, r1
 8001048:	0249      	lsls	r1, r1, #9
 800104a:	ea4f 2040 	mov.w	r0, r0, lsl #9
 800104e:	d037      	beq.n	80010c0 <__aeabi_fdiv+0x98>
 8001050:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8001054:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8001058:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 800105c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8001060:	428b      	cmp	r3, r1
 8001062:	bf38      	it	cc
 8001064:	005b      	lslcc	r3, r3, #1
 8001066:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 800106a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 800106e:	428b      	cmp	r3, r1
 8001070:	bf24      	itt	cs
 8001072:	1a5b      	subcs	r3, r3, r1
 8001074:	ea40 000c 	orrcs.w	r0, r0, ip
 8001078:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 800107c:	bf24      	itt	cs
 800107e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8001082:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8001086:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 800108a:	bf24      	itt	cs
 800108c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8001090:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8001094:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8001098:	bf24      	itt	cs
 800109a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 800109e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80010a2:	011b      	lsls	r3, r3, #4
 80010a4:	bf18      	it	ne
 80010a6:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80010aa:	d1e0      	bne.n	800106e <__aeabi_fdiv+0x46>
 80010ac:	2afd      	cmp	r2, #253	; 0xfd
 80010ae:	f63f af50 	bhi.w	8000f52 <__aeabi_fmul+0x92>
 80010b2:	428b      	cmp	r3, r1
 80010b4:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80010b8:	bf08      	it	eq
 80010ba:	f020 0001 	biceq.w	r0, r0, #1
 80010be:	4770      	bx	lr
 80010c0:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80010c4:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80010c8:	327f      	adds	r2, #127	; 0x7f
 80010ca:	bfc2      	ittt	gt
 80010cc:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80010d0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80010d4:	4770      	bxgt	lr
 80010d6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80010da:	f04f 0300 	mov.w	r3, #0
 80010de:	3a01      	subs	r2, #1
 80010e0:	e737      	b.n	8000f52 <__aeabi_fmul+0x92>
 80010e2:	f092 0f00 	teq	r2, #0
 80010e6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80010ea:	bf02      	ittt	eq
 80010ec:	0040      	lsleq	r0, r0, #1
 80010ee:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80010f2:	3a01      	subeq	r2, #1
 80010f4:	d0f9      	beq.n	80010ea <__aeabi_fdiv+0xc2>
 80010f6:	ea40 000c 	orr.w	r0, r0, ip
 80010fa:	f093 0f00 	teq	r3, #0
 80010fe:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8001102:	bf02      	ittt	eq
 8001104:	0049      	lsleq	r1, r1, #1
 8001106:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 800110a:	3b01      	subeq	r3, #1
 800110c:	d0f9      	beq.n	8001102 <__aeabi_fdiv+0xda>
 800110e:	ea41 010c 	orr.w	r1, r1, ip
 8001112:	e795      	b.n	8001040 <__aeabi_fdiv+0x18>
 8001114:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8001118:	ea92 0f0c 	teq	r2, ip
 800111c:	d108      	bne.n	8001130 <__aeabi_fdiv+0x108>
 800111e:	0242      	lsls	r2, r0, #9
 8001120:	f47f af7d 	bne.w	800101e <__aeabi_fmul+0x15e>
 8001124:	ea93 0f0c 	teq	r3, ip
 8001128:	f47f af70 	bne.w	800100c <__aeabi_fmul+0x14c>
 800112c:	4608      	mov	r0, r1
 800112e:	e776      	b.n	800101e <__aeabi_fmul+0x15e>
 8001130:	ea93 0f0c 	teq	r3, ip
 8001134:	d104      	bne.n	8001140 <__aeabi_fdiv+0x118>
 8001136:	024b      	lsls	r3, r1, #9
 8001138:	f43f af4c 	beq.w	8000fd4 <__aeabi_fmul+0x114>
 800113c:	4608      	mov	r0, r1
 800113e:	e76e      	b.n	800101e <__aeabi_fmul+0x15e>
 8001140:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8001144:	bf18      	it	ne
 8001146:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 800114a:	d1ca      	bne.n	80010e2 <__aeabi_fdiv+0xba>
 800114c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8001150:	f47f af5c 	bne.w	800100c <__aeabi_fmul+0x14c>
 8001154:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8001158:	f47f af3c 	bne.w	8000fd4 <__aeabi_fmul+0x114>
 800115c:	e75f      	b.n	800101e <__aeabi_fmul+0x15e>
 800115e:	bf00      	nop

08001160 <__gesf2>:
 8001160:	f04f 3cff 	mov.w	ip, #4294967295
 8001164:	e006      	b.n	8001174 <__cmpsf2+0x4>
 8001166:	bf00      	nop

08001168 <__lesf2>:
 8001168:	f04f 0c01 	mov.w	ip, #1
 800116c:	e002      	b.n	8001174 <__cmpsf2+0x4>
 800116e:	bf00      	nop

08001170 <__cmpsf2>:
 8001170:	f04f 0c01 	mov.w	ip, #1
 8001174:	f84d cd04 	str.w	ip, [sp, #-4]!
 8001178:	ea4f 0240 	mov.w	r2, r0, lsl #1
 800117c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8001180:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001184:	bf18      	it	ne
 8001186:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800118a:	d011      	beq.n	80011b0 <__cmpsf2+0x40>
 800118c:	b001      	add	sp, #4
 800118e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8001192:	bf18      	it	ne
 8001194:	ea90 0f01 	teqne	r0, r1
 8001198:	bf58      	it	pl
 800119a:	ebb2 0003 	subspl.w	r0, r2, r3
 800119e:	bf88      	it	hi
 80011a0:	17c8      	asrhi	r0, r1, #31
 80011a2:	bf38      	it	cc
 80011a4:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80011a8:	bf18      	it	ne
 80011aa:	f040 0001 	orrne.w	r0, r0, #1
 80011ae:	4770      	bx	lr
 80011b0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80011b4:	d102      	bne.n	80011bc <__cmpsf2+0x4c>
 80011b6:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80011ba:	d105      	bne.n	80011c8 <__cmpsf2+0x58>
 80011bc:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80011c0:	d1e4      	bne.n	800118c <__cmpsf2+0x1c>
 80011c2:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80011c6:	d0e1      	beq.n	800118c <__cmpsf2+0x1c>
 80011c8:	f85d 0b04 	ldr.w	r0, [sp], #4
 80011cc:	4770      	bx	lr
 80011ce:	bf00      	nop

080011d0 <__aeabi_cfrcmple>:
 80011d0:	4684      	mov	ip, r0
 80011d2:	4608      	mov	r0, r1
 80011d4:	4661      	mov	r1, ip
 80011d6:	e7ff      	b.n	80011d8 <__aeabi_cfcmpeq>

080011d8 <__aeabi_cfcmpeq>:
 80011d8:	b50f      	push	{r0, r1, r2, r3, lr}
 80011da:	f7ff ffc9 	bl	8001170 <__cmpsf2>
 80011de:	2800      	cmp	r0, #0
 80011e0:	bf48      	it	mi
 80011e2:	f110 0f00 	cmnmi.w	r0, #0
 80011e6:	bd0f      	pop	{r0, r1, r2, r3, pc}

080011e8 <__aeabi_fcmpeq>:
 80011e8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80011ec:	f7ff fff4 	bl	80011d8 <__aeabi_cfcmpeq>
 80011f0:	bf0c      	ite	eq
 80011f2:	2001      	moveq	r0, #1
 80011f4:	2000      	movne	r0, #0
 80011f6:	f85d fb08 	ldr.w	pc, [sp], #8
 80011fa:	bf00      	nop

080011fc <__aeabi_fcmplt>:
 80011fc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001200:	f7ff ffea 	bl	80011d8 <__aeabi_cfcmpeq>
 8001204:	bf34      	ite	cc
 8001206:	2001      	movcc	r0, #1
 8001208:	2000      	movcs	r0, #0
 800120a:	f85d fb08 	ldr.w	pc, [sp], #8
 800120e:	bf00      	nop

08001210 <__aeabi_fcmple>:
 8001210:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001214:	f7ff ffe0 	bl	80011d8 <__aeabi_cfcmpeq>
 8001218:	bf94      	ite	ls
 800121a:	2001      	movls	r0, #1
 800121c:	2000      	movhi	r0, #0
 800121e:	f85d fb08 	ldr.w	pc, [sp], #8
 8001222:	bf00      	nop

08001224 <__aeabi_fcmpge>:
 8001224:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001228:	f7ff ffd2 	bl	80011d0 <__aeabi_cfrcmple>
 800122c:	bf94      	ite	ls
 800122e:	2001      	movls	r0, #1
 8001230:	2000      	movhi	r0, #0
 8001232:	f85d fb08 	ldr.w	pc, [sp], #8
 8001236:	bf00      	nop

08001238 <__aeabi_fcmpgt>:
 8001238:	f84d ed08 	str.w	lr, [sp, #-8]!
 800123c:	f7ff ffc8 	bl	80011d0 <__aeabi_cfrcmple>
 8001240:	bf34      	ite	cc
 8001242:	2001      	movcc	r0, #1
 8001244:	2000      	movcs	r0, #0
 8001246:	f85d fb08 	ldr.w	pc, [sp], #8
 800124a:	bf00      	nop
 800124c:	0000      	movs	r0, r0
	...

08001250 <__aeabi_fcmpun>:
 8001250:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8001254:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8001258:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 800125c:	d102      	bne.n	8001264 <__aeabi_fcmpun+0x14>
 800125e:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8001262:	d108      	bne.n	8001276 <__aeabi_fcmpun+0x26>
 8001264:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8001268:	d102      	bne.n	8001270 <__aeabi_fcmpun+0x20>
 800126a:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 800126e:	d102      	bne.n	8001276 <__aeabi_fcmpun+0x26>
 8001270:	f04f 0000 	mov.w	r0, #0
 8001274:	4770      	bx	lr
 8001276:	f04f 0001 	mov.w	r0, #1
 800127a:	4770      	bx	lr
 800127c:	0000      	movs	r0, r0
	...

08001280 <__aeabi_f2uiz>:
 8001280:	0042      	lsls	r2, r0, #1
 8001282:	d20e      	bcs.n	80012a2 <__aeabi_f2uiz+0x22>
 8001284:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8001288:	d30b      	bcc.n	80012a2 <__aeabi_f2uiz+0x22>
 800128a:	f04f 039e 	mov.w	r3, #158	; 0x9e
 800128e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8001292:	d409      	bmi.n	80012a8 <__aeabi_f2uiz+0x28>
 8001294:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8001298:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800129c:	fa23 f002 	lsr.w	r0, r3, r2
 80012a0:	4770      	bx	lr
 80012a2:	f04f 0000 	mov.w	r0, #0
 80012a6:	4770      	bx	lr
 80012a8:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80012ac:	d101      	bne.n	80012b2 <__aeabi_f2uiz+0x32>
 80012ae:	0242      	lsls	r2, r0, #9
 80012b0:	d102      	bne.n	80012b8 <__aeabi_f2uiz+0x38>
 80012b2:	f04f 30ff 	mov.w	r0, #4294967295
 80012b6:	4770      	bx	lr
 80012b8:	f04f 0000 	mov.w	r0, #0
 80012bc:	4770      	bx	lr
 80012be:	bf00      	nop

080012c0 <__aeabi_ldivmod>:
 80012c0:	b97b      	cbnz	r3, 80012e2 <__aeabi_ldivmod+0x22>
 80012c2:	b972      	cbnz	r2, 80012e2 <__aeabi_ldivmod+0x22>
 80012c4:	2900      	cmp	r1, #0
 80012c6:	bfbe      	ittt	lt
 80012c8:	2000      	movlt	r0, #0
 80012ca:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 80012ce:	e006      	blt.n	80012de <__aeabi_ldivmod+0x1e>
 80012d0:	bf08      	it	eq
 80012d2:	2800      	cmpeq	r0, #0
 80012d4:	bf1c      	itt	ne
 80012d6:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 80012da:	f04f 30ff 	movne.w	r0, #4294967295
 80012de:	f000 b9cf 	b.w	8001680 <__aeabi_idiv0>
 80012e2:	f1ad 0c08 	sub.w	ip, sp, #8
 80012e6:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80012ea:	2900      	cmp	r1, #0
 80012ec:	db09      	blt.n	8001302 <__aeabi_ldivmod+0x42>
 80012ee:	2b00      	cmp	r3, #0
 80012f0:	db1a      	blt.n	8001328 <__aeabi_ldivmod+0x68>
 80012f2:	f000 f84d 	bl	8001390 <__udivmoddi4>
 80012f6:	f8dd e004 	ldr.w	lr, [sp, #4]
 80012fa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80012fe:	b004      	add	sp, #16
 8001300:	4770      	bx	lr
 8001302:	4240      	negs	r0, r0
 8001304:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8001308:	2b00      	cmp	r3, #0
 800130a:	db1b      	blt.n	8001344 <__aeabi_ldivmod+0x84>
 800130c:	f000 f840 	bl	8001390 <__udivmoddi4>
 8001310:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001314:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001318:	b004      	add	sp, #16
 800131a:	4240      	negs	r0, r0
 800131c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8001320:	4252      	negs	r2, r2
 8001322:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001326:	4770      	bx	lr
 8001328:	4252      	negs	r2, r2
 800132a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800132e:	f000 f82f 	bl	8001390 <__udivmoddi4>
 8001332:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001336:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800133a:	b004      	add	sp, #16
 800133c:	4240      	negs	r0, r0
 800133e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8001342:	4770      	bx	lr
 8001344:	4252      	negs	r2, r2
 8001346:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800134a:	f000 f821 	bl	8001390 <__udivmoddi4>
 800134e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001352:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001356:	b004      	add	sp, #16
 8001358:	4252      	negs	r2, r2
 800135a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800135e:	4770      	bx	lr

08001360 <__aeabi_uldivmod>:
 8001360:	b953      	cbnz	r3, 8001378 <__aeabi_uldivmod+0x18>
 8001362:	b94a      	cbnz	r2, 8001378 <__aeabi_uldivmod+0x18>
 8001364:	2900      	cmp	r1, #0
 8001366:	bf08      	it	eq
 8001368:	2800      	cmpeq	r0, #0
 800136a:	bf1c      	itt	ne
 800136c:	f04f 31ff 	movne.w	r1, #4294967295
 8001370:	f04f 30ff 	movne.w	r0, #4294967295
 8001374:	f000 b984 	b.w	8001680 <__aeabi_idiv0>
 8001378:	f1ad 0c08 	sub.w	ip, sp, #8
 800137c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8001380:	f000 f806 	bl	8001390 <__udivmoddi4>
 8001384:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001388:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800138c:	b004      	add	sp, #16
 800138e:	4770      	bx	lr

08001390 <__udivmoddi4>:
 8001390:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001394:	468c      	mov	ip, r1
 8001396:	460e      	mov	r6, r1
 8001398:	4604      	mov	r4, r0
 800139a:	9d08      	ldr	r5, [sp, #32]
 800139c:	2b00      	cmp	r3, #0
 800139e:	d150      	bne.n	8001442 <__udivmoddi4+0xb2>
 80013a0:	428a      	cmp	r2, r1
 80013a2:	4617      	mov	r7, r2
 80013a4:	d96c      	bls.n	8001480 <__udivmoddi4+0xf0>
 80013a6:	fab2 fe82 	clz	lr, r2
 80013aa:	f1be 0f00 	cmp.w	lr, #0
 80013ae:	d00b      	beq.n	80013c8 <__udivmoddi4+0x38>
 80013b0:	f1ce 0420 	rsb	r4, lr, #32
 80013b4:	fa20 f404 	lsr.w	r4, r0, r4
 80013b8:	fa01 f60e 	lsl.w	r6, r1, lr
 80013bc:	ea44 0c06 	orr.w	ip, r4, r6
 80013c0:	fa02 f70e 	lsl.w	r7, r2, lr
 80013c4:	fa00 f40e 	lsl.w	r4, r0, lr
 80013c8:	ea4f 4917 	mov.w	r9, r7, lsr #16
 80013cc:	0c22      	lsrs	r2, r4, #16
 80013ce:	fbbc f0f9 	udiv	r0, ip, r9
 80013d2:	fa1f f887 	uxth.w	r8, r7
 80013d6:	fb09 c610 	mls	r6, r9, r0, ip
 80013da:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 80013de:	fb00 f308 	mul.w	r3, r0, r8
 80013e2:	42b3      	cmp	r3, r6
 80013e4:	d909      	bls.n	80013fa <__udivmoddi4+0x6a>
 80013e6:	19f6      	adds	r6, r6, r7
 80013e8:	f100 32ff 	add.w	r2, r0, #4294967295
 80013ec:	f080 8122 	bcs.w	8001634 <__udivmoddi4+0x2a4>
 80013f0:	42b3      	cmp	r3, r6
 80013f2:	f240 811f 	bls.w	8001634 <__udivmoddi4+0x2a4>
 80013f6:	3802      	subs	r0, #2
 80013f8:	443e      	add	r6, r7
 80013fa:	1af6      	subs	r6, r6, r3
 80013fc:	b2a2      	uxth	r2, r4
 80013fe:	fbb6 f3f9 	udiv	r3, r6, r9
 8001402:	fb09 6613 	mls	r6, r9, r3, r6
 8001406:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 800140a:	fb03 f808 	mul.w	r8, r3, r8
 800140e:	45a0      	cmp	r8, r4
 8001410:	d909      	bls.n	8001426 <__udivmoddi4+0x96>
 8001412:	19e4      	adds	r4, r4, r7
 8001414:	f103 32ff 	add.w	r2, r3, #4294967295
 8001418:	f080 810a 	bcs.w	8001630 <__udivmoddi4+0x2a0>
 800141c:	45a0      	cmp	r8, r4
 800141e:	f240 8107 	bls.w	8001630 <__udivmoddi4+0x2a0>
 8001422:	3b02      	subs	r3, #2
 8001424:	443c      	add	r4, r7
 8001426:	ebc8 0404 	rsb	r4, r8, r4
 800142a:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 800142e:	2100      	movs	r1, #0
 8001430:	2d00      	cmp	r5, #0
 8001432:	d062      	beq.n	80014fa <__udivmoddi4+0x16a>
 8001434:	fa24 f40e 	lsr.w	r4, r4, lr
 8001438:	2300      	movs	r3, #0
 800143a:	602c      	str	r4, [r5, #0]
 800143c:	606b      	str	r3, [r5, #4]
 800143e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001442:	428b      	cmp	r3, r1
 8001444:	d907      	bls.n	8001456 <__udivmoddi4+0xc6>
 8001446:	2d00      	cmp	r5, #0
 8001448:	d055      	beq.n	80014f6 <__udivmoddi4+0x166>
 800144a:	2100      	movs	r1, #0
 800144c:	e885 0041 	stmia.w	r5, {r0, r6}
 8001450:	4608      	mov	r0, r1
 8001452:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001456:	fab3 f183 	clz	r1, r3
 800145a:	2900      	cmp	r1, #0
 800145c:	f040 8090 	bne.w	8001580 <__udivmoddi4+0x1f0>
 8001460:	42b3      	cmp	r3, r6
 8001462:	d302      	bcc.n	800146a <__udivmoddi4+0xda>
 8001464:	4282      	cmp	r2, r0
 8001466:	f200 80f8 	bhi.w	800165a <__udivmoddi4+0x2ca>
 800146a:	1a84      	subs	r4, r0, r2
 800146c:	eb66 0603 	sbc.w	r6, r6, r3
 8001470:	2001      	movs	r0, #1
 8001472:	46b4      	mov	ip, r6
 8001474:	2d00      	cmp	r5, #0
 8001476:	d040      	beq.n	80014fa <__udivmoddi4+0x16a>
 8001478:	e885 1010 	stmia.w	r5, {r4, ip}
 800147c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001480:	b912      	cbnz	r2, 8001488 <__udivmoddi4+0xf8>
 8001482:	2701      	movs	r7, #1
 8001484:	fbb7 f7f2 	udiv	r7, r7, r2
 8001488:	fab7 fe87 	clz	lr, r7
 800148c:	f1be 0f00 	cmp.w	lr, #0
 8001490:	d135      	bne.n	80014fe <__udivmoddi4+0x16e>
 8001492:	1bf3      	subs	r3, r6, r7
 8001494:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8001498:	fa1f fc87 	uxth.w	ip, r7
 800149c:	2101      	movs	r1, #1
 800149e:	fbb3 f0f8 	udiv	r0, r3, r8
 80014a2:	0c22      	lsrs	r2, r4, #16
 80014a4:	fb08 3610 	mls	r6, r8, r0, r3
 80014a8:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 80014ac:	fb0c f300 	mul.w	r3, ip, r0
 80014b0:	42b3      	cmp	r3, r6
 80014b2:	d907      	bls.n	80014c4 <__udivmoddi4+0x134>
 80014b4:	19f6      	adds	r6, r6, r7
 80014b6:	f100 32ff 	add.w	r2, r0, #4294967295
 80014ba:	d202      	bcs.n	80014c2 <__udivmoddi4+0x132>
 80014bc:	42b3      	cmp	r3, r6
 80014be:	f200 80ce 	bhi.w	800165e <__udivmoddi4+0x2ce>
 80014c2:	4610      	mov	r0, r2
 80014c4:	1af6      	subs	r6, r6, r3
 80014c6:	b2a2      	uxth	r2, r4
 80014c8:	fbb6 f3f8 	udiv	r3, r6, r8
 80014cc:	fb08 6613 	mls	r6, r8, r3, r6
 80014d0:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 80014d4:	fb0c fc03 	mul.w	ip, ip, r3
 80014d8:	45a4      	cmp	ip, r4
 80014da:	d907      	bls.n	80014ec <__udivmoddi4+0x15c>
 80014dc:	19e4      	adds	r4, r4, r7
 80014de:	f103 32ff 	add.w	r2, r3, #4294967295
 80014e2:	d202      	bcs.n	80014ea <__udivmoddi4+0x15a>
 80014e4:	45a4      	cmp	ip, r4
 80014e6:	f200 80b5 	bhi.w	8001654 <__udivmoddi4+0x2c4>
 80014ea:	4613      	mov	r3, r2
 80014ec:	ebcc 0404 	rsb	r4, ip, r4
 80014f0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80014f4:	e79c      	b.n	8001430 <__udivmoddi4+0xa0>
 80014f6:	4629      	mov	r1, r5
 80014f8:	4628      	mov	r0, r5
 80014fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80014fe:	f1ce 0120 	rsb	r1, lr, #32
 8001502:	fa06 f30e 	lsl.w	r3, r6, lr
 8001506:	fa07 f70e 	lsl.w	r7, r7, lr
 800150a:	fa20 f901 	lsr.w	r9, r0, r1
 800150e:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8001512:	40ce      	lsrs	r6, r1
 8001514:	ea49 0903 	orr.w	r9, r9, r3
 8001518:	fbb6 faf8 	udiv	sl, r6, r8
 800151c:	ea4f 4419 	mov.w	r4, r9, lsr #16
 8001520:	fb08 661a 	mls	r6, r8, sl, r6
 8001524:	fa1f fc87 	uxth.w	ip, r7
 8001528:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
 800152c:	fb0a f20c 	mul.w	r2, sl, ip
 8001530:	429a      	cmp	r2, r3
 8001532:	fa00 f40e 	lsl.w	r4, r0, lr
 8001536:	d90a      	bls.n	800154e <__udivmoddi4+0x1be>
 8001538:	19db      	adds	r3, r3, r7
 800153a:	f10a 31ff 	add.w	r1, sl, #4294967295
 800153e:	f080 8087 	bcs.w	8001650 <__udivmoddi4+0x2c0>
 8001542:	429a      	cmp	r2, r3
 8001544:	f240 8084 	bls.w	8001650 <__udivmoddi4+0x2c0>
 8001548:	f1aa 0a02 	sub.w	sl, sl, #2
 800154c:	443b      	add	r3, r7
 800154e:	1a9b      	subs	r3, r3, r2
 8001550:	fa1f f989 	uxth.w	r9, r9
 8001554:	fbb3 f1f8 	udiv	r1, r3, r8
 8001558:	fb08 3311 	mls	r3, r8, r1, r3
 800155c:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
 8001560:	fb01 f60c 	mul.w	r6, r1, ip
 8001564:	429e      	cmp	r6, r3
 8001566:	d907      	bls.n	8001578 <__udivmoddi4+0x1e8>
 8001568:	19db      	adds	r3, r3, r7
 800156a:	f101 32ff 	add.w	r2, r1, #4294967295
 800156e:	d26b      	bcs.n	8001648 <__udivmoddi4+0x2b8>
 8001570:	429e      	cmp	r6, r3
 8001572:	d969      	bls.n	8001648 <__udivmoddi4+0x2b8>
 8001574:	3902      	subs	r1, #2
 8001576:	443b      	add	r3, r7
 8001578:	1b9b      	subs	r3, r3, r6
 800157a:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 800157e:	e78e      	b.n	800149e <__udivmoddi4+0x10e>
 8001580:	f1c1 0e20 	rsb	lr, r1, #32
 8001584:	fa22 f40e 	lsr.w	r4, r2, lr
 8001588:	408b      	lsls	r3, r1
 800158a:	4323      	orrs	r3, r4
 800158c:	fa20 f70e 	lsr.w	r7, r0, lr
 8001590:	fa06 f401 	lsl.w	r4, r6, r1
 8001594:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8001598:	fa26 f60e 	lsr.w	r6, r6, lr
 800159c:	433c      	orrs	r4, r7
 800159e:	fbb6 f9fc 	udiv	r9, r6, ip
 80015a2:	0c27      	lsrs	r7, r4, #16
 80015a4:	fb0c 6619 	mls	r6, ip, r9, r6
 80015a8:	fa1f f883 	uxth.w	r8, r3
 80015ac:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
 80015b0:	fb09 f708 	mul.w	r7, r9, r8
 80015b4:	42b7      	cmp	r7, r6
 80015b6:	fa02 f201 	lsl.w	r2, r2, r1
 80015ba:	fa00 fa01 	lsl.w	sl, r0, r1
 80015be:	d908      	bls.n	80015d2 <__udivmoddi4+0x242>
 80015c0:	18f6      	adds	r6, r6, r3
 80015c2:	f109 30ff 	add.w	r0, r9, #4294967295
 80015c6:	d241      	bcs.n	800164c <__udivmoddi4+0x2bc>
 80015c8:	42b7      	cmp	r7, r6
 80015ca:	d93f      	bls.n	800164c <__udivmoddi4+0x2bc>
 80015cc:	f1a9 0902 	sub.w	r9, r9, #2
 80015d0:	441e      	add	r6, r3
 80015d2:	1bf6      	subs	r6, r6, r7
 80015d4:	b2a0      	uxth	r0, r4
 80015d6:	fbb6 f4fc 	udiv	r4, r6, ip
 80015da:	fb0c 6614 	mls	r6, ip, r4, r6
 80015de:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
 80015e2:	fb04 f808 	mul.w	r8, r4, r8
 80015e6:	45b8      	cmp	r8, r7
 80015e8:	d907      	bls.n	80015fa <__udivmoddi4+0x26a>
 80015ea:	18ff      	adds	r7, r7, r3
 80015ec:	f104 30ff 	add.w	r0, r4, #4294967295
 80015f0:	d228      	bcs.n	8001644 <__udivmoddi4+0x2b4>
 80015f2:	45b8      	cmp	r8, r7
 80015f4:	d926      	bls.n	8001644 <__udivmoddi4+0x2b4>
 80015f6:	3c02      	subs	r4, #2
 80015f8:	441f      	add	r7, r3
 80015fa:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
 80015fe:	ebc8 0707 	rsb	r7, r8, r7
 8001602:	fba0 8902 	umull	r8, r9, r0, r2
 8001606:	454f      	cmp	r7, r9
 8001608:	4644      	mov	r4, r8
 800160a:	464e      	mov	r6, r9
 800160c:	d314      	bcc.n	8001638 <__udivmoddi4+0x2a8>
 800160e:	d029      	beq.n	8001664 <__udivmoddi4+0x2d4>
 8001610:	b365      	cbz	r5, 800166c <__udivmoddi4+0x2dc>
 8001612:	ebba 0304 	subs.w	r3, sl, r4
 8001616:	eb67 0706 	sbc.w	r7, r7, r6
 800161a:	fa07 fe0e 	lsl.w	lr, r7, lr
 800161e:	40cb      	lsrs	r3, r1
 8001620:	40cf      	lsrs	r7, r1
 8001622:	ea4e 0303 	orr.w	r3, lr, r3
 8001626:	e885 0088 	stmia.w	r5, {r3, r7}
 800162a:	2100      	movs	r1, #0
 800162c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001630:	4613      	mov	r3, r2
 8001632:	e6f8      	b.n	8001426 <__udivmoddi4+0x96>
 8001634:	4610      	mov	r0, r2
 8001636:	e6e0      	b.n	80013fa <__udivmoddi4+0x6a>
 8001638:	ebb8 0402 	subs.w	r4, r8, r2
 800163c:	eb69 0603 	sbc.w	r6, r9, r3
 8001640:	3801      	subs	r0, #1
 8001642:	e7e5      	b.n	8001610 <__udivmoddi4+0x280>
 8001644:	4604      	mov	r4, r0
 8001646:	e7d8      	b.n	80015fa <__udivmoddi4+0x26a>
 8001648:	4611      	mov	r1, r2
 800164a:	e795      	b.n	8001578 <__udivmoddi4+0x1e8>
 800164c:	4681      	mov	r9, r0
 800164e:	e7c0      	b.n	80015d2 <__udivmoddi4+0x242>
 8001650:	468a      	mov	sl, r1
 8001652:	e77c      	b.n	800154e <__udivmoddi4+0x1be>
 8001654:	3b02      	subs	r3, #2
 8001656:	443c      	add	r4, r7
 8001658:	e748      	b.n	80014ec <__udivmoddi4+0x15c>
 800165a:	4608      	mov	r0, r1
 800165c:	e70a      	b.n	8001474 <__udivmoddi4+0xe4>
 800165e:	3802      	subs	r0, #2
 8001660:	443e      	add	r6, r7
 8001662:	e72f      	b.n	80014c4 <__udivmoddi4+0x134>
 8001664:	45c2      	cmp	sl, r8
 8001666:	d3e7      	bcc.n	8001638 <__udivmoddi4+0x2a8>
 8001668:	463e      	mov	r6, r7
 800166a:	e7d1      	b.n	8001610 <__udivmoddi4+0x280>
 800166c:	4629      	mov	r1, r5
 800166e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001672:	bf00      	nop
	...

08001680 <__aeabi_idiv0>:
 8001680:	4770      	bx	lr
 8001682:	bf00      	nop
	...

08001690 <memcpy>:
 8001690:	4684      	mov	ip, r0
 8001692:	ea41 0300 	orr.w	r3, r1, r0
 8001696:	f013 0303 	ands.w	r3, r3, #3
 800169a:	d16d      	bne.n	8001778 <memcpy+0xe8>
 800169c:	3a40      	subs	r2, #64	; 0x40
 800169e:	d341      	bcc.n	8001724 <memcpy+0x94>
 80016a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80016a4:	f840 3b04 	str.w	r3, [r0], #4
 80016a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80016ac:	f840 3b04 	str.w	r3, [r0], #4
 80016b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80016b4:	f840 3b04 	str.w	r3, [r0], #4
 80016b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80016bc:	f840 3b04 	str.w	r3, [r0], #4
 80016c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80016c4:	f840 3b04 	str.w	r3, [r0], #4
 80016c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80016cc:	f840 3b04 	str.w	r3, [r0], #4
 80016d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80016d4:	f840 3b04 	str.w	r3, [r0], #4
 80016d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80016dc:	f840 3b04 	str.w	r3, [r0], #4
 80016e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80016e4:	f840 3b04 	str.w	r3, [r0], #4
 80016e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80016ec:	f840 3b04 	str.w	r3, [r0], #4
 80016f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80016f4:	f840 3b04 	str.w	r3, [r0], #4
 80016f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80016fc:	f840 3b04 	str.w	r3, [r0], #4
 8001700:	f851 3b04 	ldr.w	r3, [r1], #4
 8001704:	f840 3b04 	str.w	r3, [r0], #4
 8001708:	f851 3b04 	ldr.w	r3, [r1], #4
 800170c:	f840 3b04 	str.w	r3, [r0], #4
 8001710:	f851 3b04 	ldr.w	r3, [r1], #4
 8001714:	f840 3b04 	str.w	r3, [r0], #4
 8001718:	f851 3b04 	ldr.w	r3, [r1], #4
 800171c:	f840 3b04 	str.w	r3, [r0], #4
 8001720:	3a40      	subs	r2, #64	; 0x40
 8001722:	d2bd      	bcs.n	80016a0 <memcpy+0x10>
 8001724:	3230      	adds	r2, #48	; 0x30
 8001726:	d311      	bcc.n	800174c <memcpy+0xbc>
 8001728:	f851 3b04 	ldr.w	r3, [r1], #4
 800172c:	f840 3b04 	str.w	r3, [r0], #4
 8001730:	f851 3b04 	ldr.w	r3, [r1], #4
 8001734:	f840 3b04 	str.w	r3, [r0], #4
 8001738:	f851 3b04 	ldr.w	r3, [r1], #4
 800173c:	f840 3b04 	str.w	r3, [r0], #4
 8001740:	f851 3b04 	ldr.w	r3, [r1], #4
 8001744:	f840 3b04 	str.w	r3, [r0], #4
 8001748:	3a10      	subs	r2, #16
 800174a:	d2ed      	bcs.n	8001728 <memcpy+0x98>
 800174c:	320c      	adds	r2, #12
 800174e:	d305      	bcc.n	800175c <memcpy+0xcc>
 8001750:	f851 3b04 	ldr.w	r3, [r1], #4
 8001754:	f840 3b04 	str.w	r3, [r0], #4
 8001758:	3a04      	subs	r2, #4
 800175a:	d2f9      	bcs.n	8001750 <memcpy+0xc0>
 800175c:	3204      	adds	r2, #4
 800175e:	d008      	beq.n	8001772 <memcpy+0xe2>
 8001760:	07d2      	lsls	r2, r2, #31
 8001762:	bf1c      	itt	ne
 8001764:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8001768:	f800 3b01 	strbne.w	r3, [r0], #1
 800176c:	d301      	bcc.n	8001772 <memcpy+0xe2>
 800176e:	880b      	ldrh	r3, [r1, #0]
 8001770:	8003      	strh	r3, [r0, #0]
 8001772:	4660      	mov	r0, ip
 8001774:	4770      	bx	lr
 8001776:	bf00      	nop
 8001778:	2a08      	cmp	r2, #8
 800177a:	d313      	bcc.n	80017a4 <memcpy+0x114>
 800177c:	078b      	lsls	r3, r1, #30
 800177e:	d08d      	beq.n	800169c <memcpy+0xc>
 8001780:	f010 0303 	ands.w	r3, r0, #3
 8001784:	d08a      	beq.n	800169c <memcpy+0xc>
 8001786:	f1c3 0304 	rsb	r3, r3, #4
 800178a:	1ad2      	subs	r2, r2, r3
 800178c:	07db      	lsls	r3, r3, #31
 800178e:	bf1c      	itt	ne
 8001790:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8001794:	f800 3b01 	strbne.w	r3, [r0], #1
 8001798:	d380      	bcc.n	800169c <memcpy+0xc>
 800179a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800179e:	f820 3b02 	strh.w	r3, [r0], #2
 80017a2:	e77b      	b.n	800169c <memcpy+0xc>
 80017a4:	3a04      	subs	r2, #4
 80017a6:	d3d9      	bcc.n	800175c <memcpy+0xcc>
 80017a8:	3a01      	subs	r2, #1
 80017aa:	f811 3b01 	ldrb.w	r3, [r1], #1
 80017ae:	f800 3b01 	strb.w	r3, [r0], #1
 80017b2:	d2f9      	bcs.n	80017a8 <memcpy+0x118>
 80017b4:	780b      	ldrb	r3, [r1, #0]
 80017b6:	7003      	strb	r3, [r0, #0]
 80017b8:	784b      	ldrb	r3, [r1, #1]
 80017ba:	7043      	strb	r3, [r0, #1]
 80017bc:	788b      	ldrb	r3, [r1, #2]
 80017be:	7083      	strb	r3, [r0, #2]
 80017c0:	4660      	mov	r0, ip
 80017c2:	4770      	bx	lr
	...
 80017d0:	eba2 0003 	sub.w	r0, r2, r3
 80017d4:	4770      	bx	lr
 80017d6:	bf00      	nop

080017d8 <strcmp>:
 80017d8:	7802      	ldrb	r2, [r0, #0]
 80017da:	780b      	ldrb	r3, [r1, #0]
 80017dc:	2a01      	cmp	r2, #1
 80017de:	bf28      	it	cs
 80017e0:	429a      	cmpcs	r2, r3
 80017e2:	d1f5      	bne.n	80017d0 <memcpy+0x140>
 80017e4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 80017e8:	ea40 0401 	orr.w	r4, r0, r1
 80017ec:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80017f0:	f06f 0c00 	mvn.w	ip, #0
 80017f4:	ea4f 7244 	mov.w	r2, r4, lsl #29
 80017f8:	b312      	cbz	r2, 8001840 <strcmp+0x68>
 80017fa:	ea80 0401 	eor.w	r4, r0, r1
 80017fe:	f014 0f07 	tst.w	r4, #7
 8001802:	d16a      	bne.n	80018da <strcmp+0x102>
 8001804:	f000 0407 	and.w	r4, r0, #7
 8001808:	f020 0007 	bic.w	r0, r0, #7
 800180c:	f004 0503 	and.w	r5, r4, #3
 8001810:	f021 0107 	bic.w	r1, r1, #7
 8001814:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8001818:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800181c:	f014 0f04 	tst.w	r4, #4
 8001820:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8001824:	fa0c f405 	lsl.w	r4, ip, r5
 8001828:	ea62 0204 	orn	r2, r2, r4
 800182c:	ea66 0604 	orn	r6, r6, r4
 8001830:	d00a      	beq.n	8001848 <strcmp+0x70>
 8001832:	ea63 0304 	orn	r3, r3, r4
 8001836:	4662      	mov	r2, ip
 8001838:	ea67 0704 	orn	r7, r7, r4
 800183c:	4666      	mov	r6, ip
 800183e:	e003      	b.n	8001848 <strcmp+0x70>
 8001840:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8001844:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8001848:	fa82 f54c 	uadd8	r5, r2, ip
 800184c:	ea82 0406 	eor.w	r4, r2, r6
 8001850:	faa4 f48c 	sel	r4, r4, ip
 8001854:	bb6c      	cbnz	r4, 80018b2 <strcmp+0xda>
 8001856:	fa83 f54c 	uadd8	r5, r3, ip
 800185a:	ea83 0507 	eor.w	r5, r3, r7
 800185e:	faa5 f58c 	sel	r5, r5, ip
 8001862:	b995      	cbnz	r5, 800188a <strcmp+0xb2>
 8001864:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 8001868:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 800186c:	fa82 f54c 	uadd8	r5, r2, ip
 8001870:	ea82 0406 	eor.w	r4, r2, r6
 8001874:	faa4 f48c 	sel	r4, r4, ip
 8001878:	fa83 f54c 	uadd8	r5, r3, ip
 800187c:	ea83 0507 	eor.w	r5, r3, r7
 8001880:	faa5 f58c 	sel	r5, r5, ip
 8001884:	4325      	orrs	r5, r4
 8001886:	d0db      	beq.n	8001840 <strcmp+0x68>
 8001888:	b99c      	cbnz	r4, 80018b2 <strcmp+0xda>
 800188a:	ba2d      	rev	r5, r5
 800188c:	fab5 f485 	clz	r4, r5
 8001890:	f024 0407 	bic.w	r4, r4, #7
 8001894:	fa27 f104 	lsr.w	r1, r7, r4
 8001898:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800189c:	fa23 f304 	lsr.w	r3, r3, r4
 80018a0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80018a4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80018a8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80018ac:	eba0 0001 	sub.w	r0, r0, r1
 80018b0:	4770      	bx	lr
 80018b2:	ba24      	rev	r4, r4
 80018b4:	fab4 f484 	clz	r4, r4
 80018b8:	f024 0407 	bic.w	r4, r4, #7
 80018bc:	fa26 f104 	lsr.w	r1, r6, r4
 80018c0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80018c4:	fa22 f204 	lsr.w	r2, r2, r4
 80018c8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 80018cc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80018d0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80018d4:	eba0 0001 	sub.w	r0, r0, r1
 80018d8:	4770      	bx	lr
 80018da:	f014 0f03 	tst.w	r4, #3
 80018de:	d13c      	bne.n	800195a <strcmp+0x182>
 80018e0:	f010 0403 	ands.w	r4, r0, #3
 80018e4:	d128      	bne.n	8001938 <strcmp+0x160>
 80018e6:	f850 2b08 	ldr.w	r2, [r0], #8
 80018ea:	f851 3b08 	ldr.w	r3, [r1], #8
 80018ee:	fa82 f54c 	uadd8	r5, r2, ip
 80018f2:	ea82 0503 	eor.w	r5, r2, r3
 80018f6:	faa5 f58c 	sel	r5, r5, ip
 80018fa:	b95d      	cbnz	r5, 8001914 <strcmp+0x13c>
 80018fc:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8001900:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8001904:	fa82 f54c 	uadd8	r5, r2, ip
 8001908:	ea82 0503 	eor.w	r5, r2, r3
 800190c:	faa5 f58c 	sel	r5, r5, ip
 8001910:	2d00      	cmp	r5, #0
 8001912:	d0e8      	beq.n	80018e6 <strcmp+0x10e>
 8001914:	ba2d      	rev	r5, r5
 8001916:	fab5 f485 	clz	r4, r5
 800191a:	f024 0407 	bic.w	r4, r4, #7
 800191e:	fa23 f104 	lsr.w	r1, r3, r4
 8001922:	fa22 f204 	lsr.w	r2, r2, r4
 8001926:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800192a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800192e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001932:	eba0 0001 	sub.w	r0, r0, r1
 8001936:	4770      	bx	lr
 8001938:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800193c:	f020 0003 	bic.w	r0, r0, #3
 8001940:	f850 2b08 	ldr.w	r2, [r0], #8
 8001944:	f021 0103 	bic.w	r1, r1, #3
 8001948:	f851 3b08 	ldr.w	r3, [r1], #8
 800194c:	fa0c f404 	lsl.w	r4, ip, r4
 8001950:	ea62 0204 	orn	r2, r2, r4
 8001954:	ea63 0304 	orn	r3, r3, r4
 8001958:	e7c9      	b.n	80018ee <strcmp+0x116>
 800195a:	f010 0403 	ands.w	r4, r0, #3
 800195e:	d01a      	beq.n	8001996 <strcmp+0x1be>
 8001960:	eba1 0104 	sub.w	r1, r1, r4
 8001964:	f020 0003 	bic.w	r0, r0, #3
 8001968:	07e4      	lsls	r4, r4, #31
 800196a:	f850 2b04 	ldr.w	r2, [r0], #4
 800196e:	d006      	beq.n	800197e <strcmp+0x1a6>
 8001970:	d20f      	bcs.n	8001992 <strcmp+0x1ba>
 8001972:	788b      	ldrb	r3, [r1, #2]
 8001974:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 8001978:	1ae4      	subs	r4, r4, r3
 800197a:	d106      	bne.n	800198a <strcmp+0x1b2>
 800197c:	b12b      	cbz	r3, 800198a <strcmp+0x1b2>
 800197e:	78cb      	ldrb	r3, [r1, #3]
 8001980:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 8001984:	1ae4      	subs	r4, r4, r3
 8001986:	d100      	bne.n	800198a <strcmp+0x1b2>
 8001988:	b91b      	cbnz	r3, 8001992 <strcmp+0x1ba>
 800198a:	4620      	mov	r0, r4
 800198c:	f85d 4b10 	ldr.w	r4, [sp], #16
 8001990:	4770      	bx	lr
 8001992:	f101 0104 	add.w	r1, r1, #4
 8001996:	f850 2b04 	ldr.w	r2, [r0], #4
 800199a:	07cc      	lsls	r4, r1, #31
 800199c:	f021 0103 	bic.w	r1, r1, #3
 80019a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80019a4:	d848      	bhi.n	8001a38 <strcmp+0x260>
 80019a6:	d224      	bcs.n	80019f2 <strcmp+0x21a>
 80019a8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 80019ac:	fa82 f54c 	uadd8	r5, r2, ip
 80019b0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 80019b4:	faa5 f58c 	sel	r5, r5, ip
 80019b8:	d10a      	bne.n	80019d0 <strcmp+0x1f8>
 80019ba:	b965      	cbnz	r5, 80019d6 <strcmp+0x1fe>
 80019bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80019c0:	ea84 0402 	eor.w	r4, r4, r2
 80019c4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 80019c8:	d10e      	bne.n	80019e8 <strcmp+0x210>
 80019ca:	f850 2b04 	ldr.w	r2, [r0], #4
 80019ce:	e7eb      	b.n	80019a8 <strcmp+0x1d0>
 80019d0:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80019d4:	e055      	b.n	8001a82 <strcmp+0x2aa>
 80019d6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 80019da:	d14d      	bne.n	8001a78 <strcmp+0x2a0>
 80019dc:	7808      	ldrb	r0, [r1, #0]
 80019de:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80019e2:	f1c0 0000 	rsb	r0, r0, #0
 80019e6:	4770      	bx	lr
 80019e8:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80019ec:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80019f0:	e047      	b.n	8001a82 <strcmp+0x2aa>
 80019f2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 80019f6:	fa82 f54c 	uadd8	r5, r2, ip
 80019fa:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 80019fe:	faa5 f58c 	sel	r5, r5, ip
 8001a02:	d10a      	bne.n	8001a1a <strcmp+0x242>
 8001a04:	b965      	cbnz	r5, 8001a20 <strcmp+0x248>
 8001a06:	f851 3b04 	ldr.w	r3, [r1], #4
 8001a0a:	ea84 0402 	eor.w	r4, r4, r2
 8001a0e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8001a12:	d10c      	bne.n	8001a2e <strcmp+0x256>
 8001a14:	f850 2b04 	ldr.w	r2, [r0], #4
 8001a18:	e7eb      	b.n	80019f2 <strcmp+0x21a>
 8001a1a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8001a1e:	e030      	b.n	8001a82 <strcmp+0x2aa>
 8001a20:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8001a24:	d128      	bne.n	8001a78 <strcmp+0x2a0>
 8001a26:	880b      	ldrh	r3, [r1, #0]
 8001a28:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8001a2c:	e029      	b.n	8001a82 <strcmp+0x2aa>
 8001a2e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8001a32:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8001a36:	e024      	b.n	8001a82 <strcmp+0x2aa>
 8001a38:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 8001a3c:	fa82 f54c 	uadd8	r5, r2, ip
 8001a40:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8001a44:	faa5 f58c 	sel	r5, r5, ip
 8001a48:	d10a      	bne.n	8001a60 <strcmp+0x288>
 8001a4a:	b965      	cbnz	r5, 8001a66 <strcmp+0x28e>
 8001a4c:	f851 3b04 	ldr.w	r3, [r1], #4
 8001a50:	ea84 0402 	eor.w	r4, r4, r2
 8001a54:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 8001a58:	d109      	bne.n	8001a6e <strcmp+0x296>
 8001a5a:	f850 2b04 	ldr.w	r2, [r0], #4
 8001a5e:	e7eb      	b.n	8001a38 <strcmp+0x260>
 8001a60:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8001a64:	e00d      	b.n	8001a82 <strcmp+0x2aa>
 8001a66:	f015 0fff 	tst.w	r5, #255	; 0xff
 8001a6a:	d105      	bne.n	8001a78 <strcmp+0x2a0>
 8001a6c:	680b      	ldr	r3, [r1, #0]
 8001a6e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8001a72:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8001a76:	e004      	b.n	8001a82 <strcmp+0x2aa>
 8001a78:	f04f 0000 	mov.w	r0, #0
 8001a7c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001a80:	4770      	bx	lr
 8001a82:	ba12      	rev	r2, r2
 8001a84:	ba1b      	rev	r3, r3
 8001a86:	fa82 f44c 	uadd8	r4, r2, ip
 8001a8a:	ea82 0403 	eor.w	r4, r2, r3
 8001a8e:	faa4 f58c 	sel	r5, r4, ip
 8001a92:	fab5 f485 	clz	r4, r5
 8001a96:	fa02 f204 	lsl.w	r2, r2, r4
 8001a9a:	fa03 f304 	lsl.w	r3, r3, r4
 8001a9e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8001aa2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001aa6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 8001aaa:	4770      	bx	lr
 8001aac:	0000      	movs	r0, r0
	...

08001ab0 <strlen>:
 8001ab0:	f890 f000 	pld	[r0]
 8001ab4:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 8001ab8:	f020 0107 	bic.w	r1, r0, #7
 8001abc:	f06f 0c00 	mvn.w	ip, #0
 8001ac0:	f010 0407 	ands.w	r4, r0, #7
 8001ac4:	f891 f020 	pld	[r1, #32]
 8001ac8:	f040 8049 	bne.w	8001b5e <strlen+0xae>
 8001acc:	f04f 0400 	mov.w	r4, #0
 8001ad0:	f06f 0007 	mvn.w	r0, #7
 8001ad4:	e9d1 2300 	ldrd	r2, r3, [r1]
 8001ad8:	f891 f040 	pld	[r1, #64]	; 0x40
 8001adc:	f100 0008 	add.w	r0, r0, #8
 8001ae0:	fa82 f24c 	uadd8	r2, r2, ip
 8001ae4:	faa4 f28c 	sel	r2, r4, ip
 8001ae8:	fa83 f34c 	uadd8	r3, r3, ip
 8001aec:	faa2 f38c 	sel	r3, r2, ip
 8001af0:	bb4b      	cbnz	r3, 8001b46 <strlen+0x96>
 8001af2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8001af6:	fa82 f24c 	uadd8	r2, r2, ip
 8001afa:	f100 0008 	add.w	r0, r0, #8
 8001afe:	faa4 f28c 	sel	r2, r4, ip
 8001b02:	fa83 f34c 	uadd8	r3, r3, ip
 8001b06:	faa2 f38c 	sel	r3, r2, ip
 8001b0a:	b9e3      	cbnz	r3, 8001b46 <strlen+0x96>
 8001b0c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 8001b10:	fa82 f24c 	uadd8	r2, r2, ip
 8001b14:	f100 0008 	add.w	r0, r0, #8
 8001b18:	faa4 f28c 	sel	r2, r4, ip
 8001b1c:	fa83 f34c 	uadd8	r3, r3, ip
 8001b20:	faa2 f38c 	sel	r3, r2, ip
 8001b24:	b97b      	cbnz	r3, 8001b46 <strlen+0x96>
 8001b26:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 8001b2a:	f101 0120 	add.w	r1, r1, #32
 8001b2e:	fa82 f24c 	uadd8	r2, r2, ip
 8001b32:	f100 0008 	add.w	r0, r0, #8
 8001b36:	faa4 f28c 	sel	r2, r4, ip
 8001b3a:	fa83 f34c 	uadd8	r3, r3, ip
 8001b3e:	faa2 f38c 	sel	r3, r2, ip
 8001b42:	2b00      	cmp	r3, #0
 8001b44:	d0c6      	beq.n	8001ad4 <strlen+0x24>
 8001b46:	2a00      	cmp	r2, #0
 8001b48:	bf04      	itt	eq
 8001b4a:	3004      	addeq	r0, #4
 8001b4c:	461a      	moveq	r2, r3
 8001b4e:	ba12      	rev	r2, r2
 8001b50:	fab2 f282 	clz	r2, r2
 8001b54:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 8001b58:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 8001b5c:	4770      	bx	lr
 8001b5e:	e9d1 2300 	ldrd	r2, r3, [r1]
 8001b62:	f004 0503 	and.w	r5, r4, #3
 8001b66:	f1c4 0000 	rsb	r0, r4, #0
 8001b6a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8001b6e:	f014 0f04 	tst.w	r4, #4
 8001b72:	f891 f040 	pld	[r1, #64]	; 0x40
 8001b76:	fa0c f505 	lsl.w	r5, ip, r5
 8001b7a:	ea62 0205 	orn	r2, r2, r5
 8001b7e:	bf1c      	itt	ne
 8001b80:	ea63 0305 	ornne	r3, r3, r5
 8001b84:	4662      	movne	r2, ip
 8001b86:	f04f 0400 	mov.w	r4, #0
 8001b8a:	e7a9      	b.n	8001ae0 <strlen+0x30>
 8001b8c:	0000      	movs	r0, r0
	...

08001b90 <moduleTRACKING>:
}

/**
  * Tracking Module (Thread)
  */
THD_FUNCTION(moduleTRACKING, arg) {
 8001b90:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
	(void)arg;

	// Print initialization message
	TRACE_INFO("TRAC > Startup module TRACKING MANAGER");
 8001b94:	481d      	ldr	r0, [pc, #116]	; (8001c0c <moduleTRACKING+0x7c>)
 8001b96:	4c1e      	ldr	r4, [pc, #120]	; (8001c10 <moduleTRACKING+0x80>)
}

/**
  * Tracking Module (Thread)
  */
THD_FUNCTION(moduleTRACKING, arg) {
 8001b98:	b0f9      	sub	sp, #484	; 0x1e4
	(void)arg;

	// Print initialization message
	TRACE_INFO("TRAC > Startup module TRACKING MANAGER");
 8001b9a:	f00d f9a9 	bl	800eef0 <chMtxLock>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001b9e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001ba2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001ba6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001ba8:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001baa:	4b1a      	ldr	r3, [pc, #104]	; (8001c14 <moduleTRACKING+0x84>)
 8001bac:	fb00 f101 	mul.w	r1, r0, r1
 8001bb0:	fba4 5101 	umull	r5, r1, r4, r1
 8001bb4:	0b89      	lsrs	r1, r1, #14
 8001bb6:	fba3 5301 	umull	r5, r3, r3, r1
 8001bba:	fba4 4202 	umull	r4, r2, r4, r2
 8001bbe:	099b      	lsrs	r3, r3, #6
 8001bc0:	fb00 1313 	mls	r3, r0, r3, r1
 8001bc4:	0b92      	lsrs	r2, r2, #14
 8001bc6:	4914      	ldr	r1, [pc, #80]	; (8001c18 <moduleTRACKING+0x88>)
 8001bc8:	4814      	ldr	r0, [pc, #80]	; (8001c1c <moduleTRACKING+0x8c>)
 8001bca:	f010 fd89 	bl	80126e0 <chprintf.constprop.35>
 8001bce:	4a14      	ldr	r2, [pc, #80]	; (8001c20 <moduleTRACKING+0x90>)
 8001bd0:	4914      	ldr	r1, [pc, #80]	; (8001c24 <moduleTRACKING+0x94>)
 8001bd2:	4812      	ldr	r0, [pc, #72]	; (8001c1c <moduleTRACKING+0x8c>)
 8001bd4:	f010 fd84 	bl	80126e0 <chprintf.constprop.35>
 8001bd8:	234c      	movs	r3, #76	; 0x4c
 8001bda:	4a13      	ldr	r2, [pc, #76]	; (8001c28 <moduleTRACKING+0x98>)
 8001bdc:	4913      	ldr	r1, [pc, #76]	; (8001c2c <moduleTRACKING+0x9c>)
 8001bde:	480f      	ldr	r0, [pc, #60]	; (8001c1c <moduleTRACKING+0x8c>)
 8001be0:	f010 fd7e 	bl	80126e0 <chprintf.constprop.35>
 8001be4:	4912      	ldr	r1, [pc, #72]	; (8001c30 <moduleTRACKING+0xa0>)
 8001be6:	480d      	ldr	r0, [pc, #52]	; (8001c1c <moduleTRACKING+0x8c>)
 8001be8:	f010 fd7a 	bl	80126e0 <chprintf.constprop.35>
 8001bec:	4911      	ldr	r1, [pc, #68]	; (8001c34 <moduleTRACKING+0xa4>)
 8001bee:	480b      	ldr	r0, [pc, #44]	; (8001c1c <moduleTRACKING+0x8c>)
 8001bf0:	f010 fd76 	bl	80126e0 <chprintf.constprop.35>
 8001bf4:	4910      	ldr	r1, [pc, #64]	; (8001c38 <moduleTRACKING+0xa8>)
 8001bf6:	4809      	ldr	r0, [pc, #36]	; (8001c1c <moduleTRACKING+0x8c>)
 8001bf8:	f010 fd72 	bl	80126e0 <chprintf.constprop.35>
 8001bfc:	4803      	ldr	r0, [pc, #12]	; (8001c0c <moduleTRACKING+0x7c>)
 8001bfe:	f00d f917 	bl	800ee30 <chMtxUnlock>

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];
 8001c02:	4a0e      	ldr	r2, [pc, #56]	; (8001c3c <moduleTRACKING+0xac>)
 8001c04:	490e      	ldr	r1, [pc, #56]	; (8001c40 <moduleTRACKING+0xb0>)

	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
 8001c06:	4b0f      	ldr	r3, [pc, #60]	; (8001c44 <moduleTRACKING+0xb4>)

	// Print initialization message
	TRACE_INFO("TRAC > Startup module TRACKING MANAGER");

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];
 8001c08:	6011      	str	r1, [r2, #0]
 8001c0a:	e026      	b.n	8001c5a <moduleTRACKING+0xca>
 8001c0c:	20027b2c 	.word	0x20027b2c
 8001c10:	d1b71759 	.word	0xd1b71759
 8001c14:	10624dd3 	.word	0x10624dd3
 8001c18:	08013c50 	.word	0x08013c50
 8001c1c:	20027e60 	.word	0x20027e60
 8001c20:	08013cfc 	.word	0x08013cfc
 8001c24:	08013c5c 	.word	0x08013c5c
 8001c28:	08013c6c 	.word	0x08013c6c
 8001c2c:	08013c78 	.word	0x08013c78
 8001c30:	08013d00 	.word	0x08013d00
 8001c34:	08013c84 	.word	0x08013c84
 8001c38:	08013cac 	.word	0x08013cac
 8001c3c:	20027e3c 	.word	0x20027e3c
 8001c40:	20000c64 	.word	0x20000c64
 8001c44:	080c0000 	.word	0x080c0000
	{
		logTrackPoint_t pt;
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
			break;
		logEntryCounter++;
 8001c48:	4ab8      	ldr	r2, [pc, #736]	; (8001f2c <moduleTRACKING+0x39c>)
 8001c4a:	49b8      	ldr	r1, [pc, #736]	; (8001f2c <moduleTRACKING+0x39c>)
 8001c4c:	6812      	ldr	r2, [r2, #0]

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];

	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
 8001c4e:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
	{
		logTrackPoint_t pt;
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
			break;
		logEntryCounter++;
 8001c52:	f102 0201 	add.w	r2, r2, #1
 8001c56:	600a      	str	r2, [r1, #0]

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];

	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
 8001c58:	d004      	beq.n	8001c64 <moduleTRACKING+0xd4>
	{
		logTrackPoint_t pt;
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
 8001c5a:	681a      	ldr	r2, [r3, #0]
 8001c5c:	3201      	adds	r2, #1

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];

	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
 8001c5e:	f103 0310 	add.w	r3, r3, #16
	{
		logTrackPoint_t pt;
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
 8001c62:	d1f1      	bne.n	8001c48 <moduleTRACKING+0xb8>
 8001c64:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
			break;
		logEntryCounter++;
	}
	TRACE_WARN("TRAC > Next log entry ID=%d", logEntryCounter);
 8001c68:	48b1      	ldr	r0, [pc, #708]	; (8001f30 <moduleTRACKING+0x3a0>)
 8001c6a:	4eb2      	ldr	r6, [pc, #712]	; (8001f34 <moduleTRACKING+0x3a4>)
 8001c6c:	4cb2      	ldr	r4, [pc, #712]	; (8001f38 <moduleTRACKING+0x3a8>)
	// Initial fill by PAC1720 and BME280 and RTC

	// Time
	ptime_t rtc;
	getTime(&rtc);
	lastTrackPoint->time.year = rtc.year;
 8001c6e:	f8df 8304 	ldr.w	r8, [pc, #772]	; 8001f74 <moduleTRACKING+0x3e4>
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
			break;
		logEntryCounter++;
	}
	TRACE_WARN("TRAC > Next log entry ID=%d", logEntryCounter);
 8001c72:	f00d f93d 	bl	800eef0 <chMtxLock>
 8001c76:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001c78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001c7a:	49b0      	ldr	r1, [pc, #704]	; (8001f3c <moduleTRACKING+0x3ac>)
 8001c7c:	48b0      	ldr	r0, [pc, #704]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001c7e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8001c82:	fb05 f303 	mul.w	r3, r5, r3
 8001c86:	fba6 e303 	umull	lr, r3, r6, r3
 8001c8a:	0b9b      	lsrs	r3, r3, #14
 8001c8c:	fba4 ce03 	umull	ip, lr, r4, r3
 8001c90:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8001c94:	fba6 c202 	umull	ip, r2, r6, r2
 8001c98:	fb05 331e 	mls	r3, r5, lr, r3
 8001c9c:	0b92      	lsrs	r2, r2, #14
 8001c9e:	f010 fd1f 	bl	80126e0 <chprintf.constprop.35>
 8001ca2:	4aa8      	ldr	r2, [pc, #672]	; (8001f44 <moduleTRACKING+0x3b4>)
 8001ca4:	49a8      	ldr	r1, [pc, #672]	; (8001f48 <moduleTRACKING+0x3b8>)
 8001ca6:	48a6      	ldr	r0, [pc, #664]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001ca8:	f010 fd1a 	bl	80126e0 <chprintf.constprop.35>
 8001cac:	235a      	movs	r3, #90	; 0x5a
 8001cae:	4aa7      	ldr	r2, [pc, #668]	; (8001f4c <moduleTRACKING+0x3bc>)
 8001cb0:	49a7      	ldr	r1, [pc, #668]	; (8001f50 <moduleTRACKING+0x3c0>)
 8001cb2:	48a3      	ldr	r0, [pc, #652]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001cb4:	f010 fd14 	bl	80126e0 <chprintf.constprop.35>
 8001cb8:	49a6      	ldr	r1, [pc, #664]	; (8001f54 <moduleTRACKING+0x3c4>)
 8001cba:	48a1      	ldr	r0, [pc, #644]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001cbc:	f010 fd10 	bl	80126e0 <chprintf.constprop.35>
 8001cc0:	4b9a      	ldr	r3, [pc, #616]	; (8001f2c <moduleTRACKING+0x39c>)
 8001cc2:	49a5      	ldr	r1, [pc, #660]	; (8001f58 <moduleTRACKING+0x3c8>)
 8001cc4:	681a      	ldr	r2, [r3, #0]
 8001cc6:	489e      	ldr	r0, [pc, #632]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001cc8:	f010 fd0a 	bl	80126e0 <chprintf.constprop.35>
 8001ccc:	49a3      	ldr	r1, [pc, #652]	; (8001f5c <moduleTRACKING+0x3cc>)
 8001cce:	489c      	ldr	r0, [pc, #624]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001cd0:	f010 fd06 	bl	80126e0 <chprintf.constprop.35>
 8001cd4:	4896      	ldr	r0, [pc, #600]	; (8001f30 <moduleTRACKING+0x3a0>)
 8001cd6:	f00d f8ab 	bl	800ee30 <chMtxUnlock>

	// Initial fill by PAC1720 and BME280 and RTC

	// Time
	ptime_t rtc;
	getTime(&rtc);
 8001cda:	a83d      	add	r0, sp, #244	; 0xf4
 8001cdc:	f008 faa8 	bl	800a230 <getTime>
    return TRUE;
}

int flashRead(flashaddr_t address, char* buffer, size_t size)
{
    memcpy(buffer, (char*)address, size);
 8001ce0:	4b92      	ldr	r3, [pc, #584]	; (8001f2c <moduleTRACKING+0x39c>)
	lastTrackPoint->time.year = rtc.year;
 8001ce2:	f8d8 2000 	ldr.w	r2, [r8]
 8001ce6:	681b      	ldr	r3, [r3, #0]
 8001ce8:	f8bd 00f4 	ldrh.w	r0, [sp, #244]	; 0xf4
	lastTrackPoint->time.month = rtc.month;
 8001cec:	f89d 10f6 	ldrb.w	r1, [sp, #246]	; 0xf6
	// Initial fill by PAC1720 and BME280 and RTC

	// Time
	ptime_t rtc;
	getTime(&rtc);
	lastTrackPoint->time.year = rtc.year;
 8001cf0:	8090      	strh	r0, [r2, #4]
 8001cf2:	3b01      	subs	r3, #1
 8001cf4:	f3c3 030d 	ubfx	r3, r3, #0, #14
	lastTrackPoint->time.month = rtc.month;
 8001cf8:	7191      	strb	r1, [r2, #6]
 8001cfa:	f503 0300 	add.w	r3, r3, #8388608	; 0x800000
	lastTrackPoint->time.day = rtc.day;
 8001cfe:	f89d 10f7 	ldrb.w	r1, [sp, #247]	; 0xf7
 8001d02:	71d1      	strb	r1, [r2, #7]
	lastTrackPoint->time.hour = rtc.hour;
 8001d04:	f89d e0f8 	ldrb.w	lr, [sp, #248]	; 0xf8
	lastTrackPoint->time.minute = rtc.minute;
 8001d08:	f89d 00f9 	ldrb.w	r0, [sp, #249]	; 0xf9
	lastTrackPoint->time.second = rtc.second;
 8001d0c:	f89d 10fa 	ldrb.w	r1, [sp, #250]	; 0xfa
	ptime_t rtc;
	getTime(&rtc);
	lastTrackPoint->time.year = rtc.year;
	lastTrackPoint->time.month = rtc.month;
	lastTrackPoint->time.day = rtc.day;
	lastTrackPoint->time.hour = rtc.hour;
 8001d10:	f882 e008 	strb.w	lr, [r2, #8]
 8001d14:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
 8001d18:	011b      	lsls	r3, r3, #4
	lastTrackPoint->time.minute = rtc.minute;
 8001d1a:	7250      	strb	r0, [r2, #9]
	lastTrackPoint->time.second = rtc.second;
 8001d1c:	7291      	strb	r1, [r2, #10]
 8001d1e:	e893 4002 	ldmia.w	r3, {r1, lr}
 8001d22:	6898      	ldr	r0, [r3, #8]
 8001d24:	68db      	ldr	r3, [r3, #12]

	// Last GPS fix
	lastTrackPoint->gps_lock = 0;
	lastTrackPoint->gps_lat = lastLogPoint.gps_lat;
	lastTrackPoint->gps_lon = lastLogPoint.gps_lon;
	lastTrackPoint->gps_alt = lastLogPoint.gps_alt;
 8001d26:	6193      	str	r3, [r2, #24]
	logTrackPoint_t lastLogPoint;
	uint32_t address = LOG_FLASH_ADDR + ((logEntryCounter-1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t))) * sizeof(logTrackPoint_t);
	flashRead(address, (char*)&lastLogPoint, sizeof(logTrackPoint_t));

	// Last GPS fix
	lastTrackPoint->gps_lock = 0;
 8001d28:	2300      	movs	r3, #0
 8001d2a:	7393      	strb	r3, [r2, #14]
	lastTrackPoint->gps_lat = lastLogPoint.gps_lat;
	lastTrackPoint->gps_lon = lastLogPoint.gps_lon;
	lastTrackPoint->gps_alt = lastLogPoint.gps_alt;
	lastTrackPoint->gps_sats = 0;
 8001d2c:	7713      	strb	r3, [r2, #28]
	lastTrackPoint->gps_ttff = 0;
 8001d2e:	7753      	strb	r3, [r2, #29]

	// Debug last stored GPS position
	if(lastLogPoint.time != 0xFFFFFFFF) {
 8001d30:	3101      	adds	r1, #1
		TRACE_INFO(
 8001d32:	4b8b      	ldr	r3, [pc, #556]	; (8001f60 <moduleTRACKING+0x3d0>)
	flashRead(address, (char*)&lastLogPoint, sizeof(logTrackPoint_t));

	// Last GPS fix
	lastTrackPoint->gps_lock = 0;
	lastTrackPoint->gps_lat = lastLogPoint.gps_lat;
	lastTrackPoint->gps_lon = lastLogPoint.gps_lon;
 8001d34:	6150      	str	r0, [r2, #20]
	uint32_t address = LOG_FLASH_ADDR + ((logEntryCounter-1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t))) * sizeof(logTrackPoint_t);
	flashRead(address, (char*)&lastLogPoint, sizeof(logTrackPoint_t));

	// Last GPS fix
	lastTrackPoint->gps_lock = 0;
	lastTrackPoint->gps_lat = lastLogPoint.gps_lat;
 8001d36:	f8c2 e010 	str.w	lr, [r2, #16]
	lastTrackPoint->gps_sats = 0;
	lastTrackPoint->gps_ttff = 0;

	// Debug last stored GPS position
	if(lastLogPoint.time != 0xFFFFFFFF) {
		TRACE_INFO(
 8001d3a:	487d      	ldr	r0, [pc, #500]	; (8001f30 <moduleTRACKING+0x3a0>)
 8001d3c:	9332      	str	r3, [sp, #200]	; 0xc8
	lastTrackPoint->gps_alt = lastLogPoint.gps_alt;
	lastTrackPoint->gps_sats = 0;
	lastTrackPoint->gps_ttff = 0;

	// Debug last stored GPS position
	if(lastLogPoint.time != 0xFFFFFFFF) {
 8001d3e:	f001 8749 	beq.w	8003bd4 <moduleTRACKING+0x2044>
		TRACE_INFO(
 8001d42:	f00d f8d5 	bl	800eef0 <chMtxLock>
 8001d46:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001d48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001d4a:	497c      	ldr	r1, [pc, #496]	; (8001f3c <moduleTRACKING+0x3ac>)
 8001d4c:	4f85      	ldr	r7, [pc, #532]	; (8001f64 <moduleTRACKING+0x3d4>)
 8001d4e:	fb05 f303 	mul.w	r3, r5, r3
 8001d52:	fba6 0303 	umull	r0, r3, r6, r3
 8001d56:	0b9b      	lsrs	r3, r3, #14
 8001d58:	fba4 4003 	umull	r4, r0, r4, r3
 8001d5c:	0980      	lsrs	r0, r0, #6
 8001d5e:	fba6 4202 	umull	r4, r2, r6, r2
 8001d62:	fb05 3310 	mls	r3, r5, r0, r3
 8001d66:	0b92      	lsrs	r2, r2, #14
 8001d68:	4875      	ldr	r0, [pc, #468]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001d6a:	f010 fcb9 	bl	80126e0 <chprintf.constprop.35>
 8001d6e:	4a7e      	ldr	r2, [pc, #504]	; (8001f68 <moduleTRACKING+0x3d8>)
 8001d70:	4975      	ldr	r1, [pc, #468]	; (8001f48 <moduleTRACKING+0x3b8>)
 8001d72:	4873      	ldr	r0, [pc, #460]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001d74:	f010 fcb4 	bl	80126e0 <chprintf.constprop.35>
 8001d78:	2380      	movs	r3, #128	; 0x80
 8001d7a:	4a74      	ldr	r2, [pc, #464]	; (8001f4c <moduleTRACKING+0x3bc>)
 8001d7c:	4974      	ldr	r1, [pc, #464]	; (8001f50 <moduleTRACKING+0x3c0>)
 8001d7e:	4870      	ldr	r0, [pc, #448]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001d80:	f010 fcae 	bl	80126e0 <chprintf.constprop.35>
 8001d84:	4973      	ldr	r1, [pc, #460]	; (8001f54 <moduleTRACKING+0x3c4>)
 8001d86:	486e      	ldr	r0, [pc, #440]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001d88:	f010 fcaa 	bl	80126e0 <chprintf.constprop.35>
 8001d8c:	f8d8 2000 	ldr.w	r2, [r8]
 8001d90:	4976      	ldr	r1, [pc, #472]	; (8001f6c <moduleTRACKING+0x3dc>)
 8001d92:	6910      	ldr	r0, [r2, #16]
 8001d94:	6953      	ldr	r3, [r2, #20]
 8001d96:	6992      	ldr	r2, [r2, #24]
 8001d98:	9205      	str	r2, [sp, #20]
 8001d9a:	2800      	cmp	r0, #0
 8001d9c:	bfd4      	ite	le
 8001d9e:	f04f 32ff 	movle.w	r2, #4294967295
 8001da2:	2201      	movgt	r2, #1
 8001da4:	2b00      	cmp	r3, #0
 8001da6:	fb00 f202 	mul.w	r2, r0, r2
 8001daa:	bfd4      	ite	le
 8001dac:	f04f 35ff 	movle.w	r5, #4294967295
 8001db0:	2501      	movgt	r5, #1
 8001db2:	fb03 f605 	mul.w	r6, r3, r5
 8001db6:	fb81 4502 	smull	r4, r5, r1, r2
 8001dba:	17d4      	asrs	r4, r2, #31
 8001dbc:	ebc4 54a5 	rsb	r4, r4, r5, asr #22
 8001dc0:	4d67      	ldr	r5, [pc, #412]	; (8001f60 <moduleTRACKING+0x3d0>)
 8001dc2:	9504      	str	r5, [sp, #16]
 8001dc4:	fb07 2414 	mls	r4, r7, r4, r2
 8001dc8:	fb81 2506 	smull	r2, r5, r1, r6
 8001dcc:	17f2      	asrs	r2, r6, #31
 8001dce:	ebc2 52a5 	rsb	r2, r2, r5, asr #22
 8001dd2:	fb07 6512 	mls	r5, r7, r2, r6
 8001dd6:	fb81 6203 	smull	r6, r2, r1, r3
 8001dda:	17db      	asrs	r3, r3, #31
 8001ddc:	ebc3 52a2 	rsb	r2, r3, r2, asr #22
 8001de0:	fb81 6100 	smull	r6, r1, r1, r0
 8001de4:	17c3      	asrs	r3, r0, #31
 8001de6:	9202      	str	r2, [sp, #8]
 8001de8:	4a5d      	ldr	r2, [pc, #372]	; (8001f60 <moduleTRACKING+0x3d0>)
 8001dea:	9400      	str	r4, [sp, #0]
 8001dec:	ebc3 53a1 	rsb	r3, r3, r1, asr #22
 8001df0:	9503      	str	r5, [sp, #12]
 8001df2:	9201      	str	r2, [sp, #4]
 8001df4:	495e      	ldr	r1, [pc, #376]	; (8001f70 <moduleTRACKING+0x3e0>)
 8001df6:	4852      	ldr	r0, [pc, #328]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001df8:	f010 fc72 	bl	80126e0 <chprintf.constprop.35>
			TRACE_TAB, lastTrackPoint->gps_lat/10000000, (lastTrackPoint->gps_lat > 0 ? 1:-1)*lastTrackPoint->gps_lat%10000000,
			TRACE_TAB, lastTrackPoint->gps_lon/10000000, (lastTrackPoint->gps_lon > 0 ? 1:-1)*lastTrackPoint->gps_lon%10000000,
			TRACE_TAB, lastTrackPoint->gps_alt
		);
	} else {
		TRACE_INFO("TRAC > No GPS position in memory");
 8001dfc:	4957      	ldr	r1, [pc, #348]	; (8001f5c <moduleTRACKING+0x3cc>)
 8001dfe:	4850      	ldr	r0, [pc, #320]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001e00:	f010 fc6e 	bl	80126e0 <chprintf.constprop.35>
 8001e04:	484a      	ldr	r0, [pc, #296]	; (8001f30 <moduleTRACKING+0x3a0>)
 8001e06:	f00d f813 	bl	800ee30 <chMtxUnlock>
	}

	// Voltage/Current
	lastTrackPoint->adc_solar = getSolarVoltageMV();
 8001e0a:	4b5a      	ldr	r3, [pc, #360]	; (8001f74 <moduleTRACKING+0x3e4>)
 8001e0c:	461d      	mov	r5, r3
 8001e0e:	681c      	ldr	r4, [r3, #0]
 8001e10:	f008 fe1e 	bl	800aa50 <getSolarVoltageMV>
 8001e14:	83e0      	strh	r0, [r4, #30]
	lastTrackPoint->adc_battery = getBatteryVoltageMV();
 8001e16:	682c      	ldr	r4, [r5, #0]
 8001e18:	f008 fe2a 	bl	800aa70 <getBatteryVoltageMV>
 8001e1c:	8420      	strh	r0, [r4, #32]
	lastTrackPoint->adc_charge = pac1720_getPowerCharge();
 8001e1e:	682c      	ldr	r4, [r5, #0]
 8001e20:	f00d fdee 	bl	800fa00 <pac1720_getPowerCharge>
 8001e24:	8460      	strh	r0, [r4, #34]	; 0x22
	lastTrackPoint->adc_discharge = pac1720_getPowerDischarge();
 8001e26:	682c      	ldr	r4, [r5, #0]
 8001e28:	f00d fe02 	bl	800fa30 <pac1720_getPowerDischarge>
 8001e2c:	84a0      	strh	r0, [r4, #36]	; 0x24

	bme280_t bmeInt;
	bme280_t bmeExt;

	// Atmosphere condition
	if(BME280_isAvailable(BME280_ADDRESS_INT)) {
 8001e2e:	2077      	movs	r0, #119	; 0x77
 8001e30:	f00d ff76 	bl	800fd20 <BME280_isAvailable>
 8001e34:	4604      	mov	r4, r0
 8001e36:	2800      	cmp	r0, #0
 8001e38:	f001 868c 	beq.w	8003b54 <moduleTRACKING+0x1fc4>
		BME280_Init(&bmeInt, BME280_ADDRESS_INT);
 8001e3c:	2177      	movs	r1, #119	; 0x77
 8001e3e:	a855      	add	r0, sp, #340	; 0x154
 8001e40:	f00d fec6 	bl	800fbd0 <BME280_Init>
		lastTrackPoint->int_press = BME280_getPressure(&bmeInt, 256);
 8001e44:	a855      	add	r0, sp, #340	; 0x154
 8001e46:	682c      	ldr	r4, [r5, #0]
 8001e48:	f00b f96a 	bl	800d120 <BME280_getPressure.constprop.24>
 8001e4c:	62a0      	str	r0, [r4, #40]	; 0x28
		lastTrackPoint->int_hum = BME280_getHumidity(&bmeInt);
 8001e4e:	a855      	add	r0, sp, #340	; 0x154
 8001e50:	682c      	ldr	r4, [r5, #0]
 8001e52:	f00d fe2d 	bl	800fab0 <BME280_getHumidity>
 8001e56:	85a0      	strh	r0, [r4, #44]	; 0x2c
		lastTrackPoint->int_temp = BME280_getTemperature(&bmeInt);
 8001e58:	a855      	add	r0, sp, #340	; 0x154
 8001e5a:	682c      	ldr	r4, [r5, #0]
 8001e5c:	f00d fe80 	bl	800fb60 <BME280_getTemperature>
 8001e60:	85e0      	strh	r0, [r4, #46]	; 0x2e
		lastTrackPoint->int_hum = 0;
		lastTrackPoint->int_temp = 0;
	}

	// External BME280
	if(BME280_isAvailable(BME280_ADDRESS_EXT)) {
 8001e62:	2076      	movs	r0, #118	; 0x76
 8001e64:	f00d ff5c 	bl	800fd20 <BME280_isAvailable>
 8001e68:	4604      	mov	r4, r0
 8001e6a:	2800      	cmp	r0, #0
 8001e6c:	f001 8610 	beq.w	8003a90 <moduleTRACKING+0x1f00>
		BME280_Init(&bmeExt, BME280_ADDRESS_EXT);
 8001e70:	2176      	movs	r1, #118	; 0x76
 8001e72:	a84a      	add	r0, sp, #296	; 0x128
 8001e74:	f00d feac 	bl	800fbd0 <BME280_Init>
		lastTrackPoint->ext_press = BME280_getPressure(&bmeExt, 256);
 8001e78:	4b3e      	ldr	r3, [pc, #248]	; (8001f74 <moduleTRACKING+0x3e4>)
 8001e7a:	a84a      	add	r0, sp, #296	; 0x128
 8001e7c:	681c      	ldr	r4, [r3, #0]
 8001e7e:	f00b f94f 	bl	800d120 <BME280_getPressure.constprop.24>
		lastTrackPoint->ext_hum = BME280_getHumidity(&bmeExt);
 8001e82:	4b3c      	ldr	r3, [pc, #240]	; (8001f74 <moduleTRACKING+0x3e4>)
	}

	// External BME280
	if(BME280_isAvailable(BME280_ADDRESS_EXT)) {
		BME280_Init(&bmeExt, BME280_ADDRESS_EXT);
		lastTrackPoint->ext_press = BME280_getPressure(&bmeExt, 256);
 8001e84:	6320      	str	r0, [r4, #48]	; 0x30
		lastTrackPoint->ext_hum = BME280_getHumidity(&bmeExt);
 8001e86:	a84a      	add	r0, sp, #296	; 0x128
 8001e88:	681c      	ldr	r4, [r3, #0]
 8001e8a:	f00d fe11 	bl	800fab0 <BME280_getHumidity>
		lastTrackPoint->ext_temp = BME280_getTemperature(&bmeExt);
 8001e8e:	4b39      	ldr	r3, [pc, #228]	; (8001f74 <moduleTRACKING+0x3e4>)

	// External BME280
	if(BME280_isAvailable(BME280_ADDRESS_EXT)) {
		BME280_Init(&bmeExt, BME280_ADDRESS_EXT);
		lastTrackPoint->ext_press = BME280_getPressure(&bmeExt, 256);
		lastTrackPoint->ext_hum = BME280_getHumidity(&bmeExt);
 8001e90:	86a0      	strh	r0, [r4, #52]	; 0x34
		lastTrackPoint->ext_temp = BME280_getTemperature(&bmeExt);
 8001e92:	a84a      	add	r0, sp, #296	; 0x128
 8001e94:	681c      	ldr	r4, [r3, #0]
 8001e96:	f00d fe63 	bl	800fb60 <BME280_getTemperature>
 8001e9a:	86e0      	strh	r0, [r4, #54]	; 0x36
 8001e9c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001ea0:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 8001f7c <moduleTRACKING+0x3ec>
 8001ea4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001ea6:	9325      	str	r3, [sp, #148]	; 0x94
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8001ea8:	f8df a088 	ldr.w	sl, [pc, #136]	; 8001f34 <moduleTRACKING+0x3a4>
 8001eac:	f8df 9088 	ldr.w	r9, [pc, #136]	; 8001f38 <moduleTRACKING+0x3a8>
	(void)arg;

	// Print initialization message
	TRACE_INFO("TRAC > Startup module TRACKING MANAGER");

	uint32_t id = 1;
 8001eb0:	2301      	movs	r3, #1
 8001eb2:	9331      	str	r3, [sp, #196]	; 0xc4
 8001eb4:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8001eb8:	481d      	ldr	r0, [pc, #116]	; (8001f30 <moduleTRACKING+0x3a0>)
 8001eba:	f00d f819 	bl	800eef0 <chMtxLock>
 8001ebe:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8001ec0:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8001ec2:	491e      	ldr	r1, [pc, #120]	; (8001f3c <moduleTRACKING+0x3ac>)
 8001ec4:	481e      	ldr	r0, [pc, #120]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001ec6:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8001eca:	fb06 f404 	mul.w	r4, r6, r4
 8001ece:	fbaa 3404 	umull	r3, r4, sl, r4
 8001ed2:	0ba4      	lsrs	r4, r4, #14
 8001ed4:	fba9 7304 	umull	r7, r3, r9, r4
 8001ed8:	fbaa 7202 	umull	r7, r2, sl, r2
 8001edc:	099b      	lsrs	r3, r3, #6
 8001ede:	fb06 4313 	mls	r3, r6, r3, r4
 8001ee2:	0b92      	lsrs	r2, r2, #14
 8001ee4:	f010 fbfc 	bl	80126e0 <chprintf.constprop.35>
 8001ee8:	4a1f      	ldr	r2, [pc, #124]	; (8001f68 <moduleTRACKING+0x3d8>)
 8001eea:	4917      	ldr	r1, [pc, #92]	; (8001f48 <moduleTRACKING+0x3b8>)
 8001eec:	4814      	ldr	r0, [pc, #80]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001eee:	f010 fbf7 	bl	80126e0 <chprintf.constprop.35>
 8001ef2:	23ab      	movs	r3, #171	; 0xab
 8001ef4:	4a15      	ldr	r2, [pc, #84]	; (8001f4c <moduleTRACKING+0x3bc>)
 8001ef6:	4916      	ldr	r1, [pc, #88]	; (8001f50 <moduleTRACKING+0x3c0>)
 8001ef8:	4811      	ldr	r0, [pc, #68]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001efa:	f010 fbf1 	bl	80126e0 <chprintf.constprop.35>
 8001efe:	4915      	ldr	r1, [pc, #84]	; (8001f54 <moduleTRACKING+0x3c4>)
 8001f00:	480f      	ldr	r0, [pc, #60]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001f02:	f010 fbed 	bl	80126e0 <chprintf.constprop.35>
 8001f06:	491c      	ldr	r1, [pc, #112]	; (8001f78 <moduleTRACKING+0x3e8>)
 8001f08:	480d      	ldr	r0, [pc, #52]	; (8001f40 <moduleTRACKING+0x3b0>)
 8001f0a:	f010 fbe9 	bl	80126e0 <chprintf.constprop.35>
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8001f0e:	9b31      	ldr	r3, [sp, #196]	; 0xc4
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8001f10:	4912      	ldr	r1, [pc, #72]	; (8001f5c <moduleTRACKING+0x3cc>)
 8001f12:	480b      	ldr	r0, [pc, #44]	; (8001f40 <moduleTRACKING+0x3b0>)
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8001f14:	f003 0201 	and.w	r2, r3, #1
 8001f18:	4617      	mov	r7, r2
 8001f1a:	9230      	str	r2, [sp, #192]	; 0xc0
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8001f1c:	f010 fbe0 	bl	80126e0 <chprintf.constprop.35>
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8001f20:	00fa      	lsls	r2, r7, #3
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8001f22:	4803      	ldr	r0, [pc, #12]	; (8001f30 <moduleTRACKING+0x3a0>)
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8001f24:	922f      	str	r2, [sp, #188]	; 0xbc
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8001f26:	f00c ff83 	bl	800ee30 <chMtxUnlock>
 8001f2a:	e029      	b.n	8001f80 <moduleTRACKING+0x3f0>
 8001f2c:	20000c60 	.word	0x20000c60
 8001f30:	20027b2c 	.word	0x20027b2c
 8001f34:	d1b71759 	.word	0xd1b71759
 8001f38:	10624dd3 	.word	0x10624dd3
 8001f3c:	08013c50 	.word	0x08013c50
 8001f40:	20027e60 	.word	0x20027e60
 8001f44:	08013cb0 	.word	0x08013cb0
 8001f48:	08013c5c 	.word	0x08013c5c
 8001f4c:	08013c6c 	.word	0x08013c6c
 8001f50:	08013c78 	.word	0x08013c78
 8001f54:	08013d00 	.word	0x08013d00
 8001f58:	08013cb8 	.word	0x08013cb8
 8001f5c:	08013cac 	.word	0x08013cac
 8001f60:	08013cd4 	.word	0x08013cd4
 8001f64:	00989680 	.word	0x00989680
 8001f68:	08013cfc 	.word	0x08013cfc
 8001f6c:	6b5fca6b 	.word	0x6b5fca6b
 8001f70:	08013d04 	.word	0x08013d04
 8001f74:	20027e3c 	.word	0x20027e3c
 8001f78:	08013df4 	.word	0x08013df4
 8001f7c:	2002789c 	.word	0x2002789c
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer
 8001f80:	49b4      	ldr	r1, [pc, #720]	; (8002254 <moduleTRACKING+0x6c4>)
 8001f82:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8001f84:	600b      	str	r3, [r1, #0]

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8001f86:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point
 8001f88:	9b31      	ldr	r3, [sp, #196]	; 0xc4
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8001f8a:	49b3      	ldr	r1, [pc, #716]	; (8002258 <moduleTRACKING+0x6c8>)
 8001f8c:	1bd2      	subs	r2, r2, r7
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point
 8001f8e:	3b01      	subs	r3, #1

		// Search for GPS satellites
		gpsFix_t gpsFix = {{0,0,0,0,0,0,0},0,0,0,0,0};
 8001f90:	2400      	movs	r4, #0
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point
 8001f92:	f003 0301 	and.w	r3, r3, #1
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8001f96:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point
 8001f9a:	9335      	str	r3, [sp, #212]	; 0xd4
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8001f9c:	9233      	str	r2, [sp, #204]	; 0xcc
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point

		// Search for GPS satellites
		gpsFix_t gpsFix = {{0,0,0,0,0,0,0},0,0,0,0,0};
 8001f9e:	9444      	str	r4, [sp, #272]	; 0x110
 8001fa0:	9445      	str	r4, [sp, #276]	; 0x114
 8001fa2:	9446      	str	r4, [sp, #280]	; 0x118
 8001fa4:	9447      	str	r4, [sp, #284]	; 0x11c
 8001fa6:	9448      	str	r4, [sp, #288]	; 0x120
 8001fa8:	9449      	str	r4, [sp, #292]	; 0x124

		// Switch on GPS is enough power is available
		uint16_t batt = getBatteryVoltageMV();
 8001faa:	f008 fd61 	bl	800aa70 <getBatteryVoltageMV>
		if(batt >= GPS_ON_VBAT)
 8001fae:	f640 33b7 	movw	r3, #2999	; 0xbb7
 8001fb2:	4298      	cmp	r0, r3
 8001fb4:	f240 8444 	bls.w	8002840 <moduleTRACKING+0xcb0>
	return gps_receive_ack(0x06, 0x09, 1000);
}*/

bool GPS_Init(void) {
	// Initialize pins
	TRACE_INFO("GPS  > Init pins");
 8001fb8:	48a8      	ldr	r0, [pc, #672]	; (800225c <moduleTRACKING+0x6cc>)
	palSetPadMode(PORT(GPS_RESET), PIN(GPS_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// GPS reset
 8001fba:	4fa9      	ldr	r7, [pc, #676]	; (8002260 <moduleTRACKING+0x6d0>)
	palSetPadMode(PORT(GPS_EN), PIN(GPS_EN), PAL_MODE_OUTPUT_PUSHPULL);			// GPS off
 8001fbc:	f8df b2e4 	ldr.w	fp, [pc, #740]	; 80022a4 <moduleTRACKING+0x714>
	return gps_receive_ack(0x06, 0x09, 1000);
}*/

bool GPS_Init(void) {
	// Initialize pins
	TRACE_INFO("GPS  > Init pins");
 8001fc0:	f00c ff96 	bl	800eef0 <chMtxLock>
 8001fc4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8001fc6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8001fc8:	49a6      	ldr	r1, [pc, #664]	; (8002264 <moduleTRACKING+0x6d4>)
 8001fca:	48a7      	ldr	r0, [pc, #668]	; (8002268 <moduleTRACKING+0x6d8>)
 8001fcc:	fb06 fe03 	mul.w	lr, r6, r3
 8001fd0:	fbaa 3e0e 	umull	r3, lr, sl, lr
 8001fd4:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 8001fd8:	fba9 c30e 	umull	ip, r3, r9, lr
 8001fdc:	fbaa c202 	umull	ip, r2, sl, r2
 8001fe0:	099b      	lsrs	r3, r3, #6
 8001fe2:	fb06 e313 	mls	r3, r6, r3, lr
 8001fe6:	0b92      	lsrs	r2, r2, #14
 8001fe8:	f010 fb7a 	bl	80126e0 <chprintf.constprop.35>
 8001fec:	4a9f      	ldr	r2, [pc, #636]	; (800226c <moduleTRACKING+0x6dc>)
 8001fee:	49a0      	ldr	r1, [pc, #640]	; (8002270 <moduleTRACKING+0x6e0>)
 8001ff0:	489d      	ldr	r0, [pc, #628]	; (8002268 <moduleTRACKING+0x6d8>)
 8001ff2:	f010 fb75 	bl	80126e0 <chprintf.constprop.35>
 8001ff6:	f44f 73e6 	mov.w	r3, #460	; 0x1cc
 8001ffa:	4a9e      	ldr	r2, [pc, #632]	; (8002274 <moduleTRACKING+0x6e4>)
 8001ffc:	499e      	ldr	r1, [pc, #632]	; (8002278 <moduleTRACKING+0x6e8>)
 8001ffe:	489a      	ldr	r0, [pc, #616]	; (8002268 <moduleTRACKING+0x6d8>)
 8002000:	f010 fb6e 	bl	80126e0 <chprintf.constprop.35>
 8002004:	499d      	ldr	r1, [pc, #628]	; (800227c <moduleTRACKING+0x6ec>)
 8002006:	4898      	ldr	r0, [pc, #608]	; (8002268 <moduleTRACKING+0x6d8>)
 8002008:	f010 fb6a 	bl	80126e0 <chprintf.constprop.35>
 800200c:	499c      	ldr	r1, [pc, #624]	; (8002280 <moduleTRACKING+0x6f0>)
 800200e:	4896      	ldr	r0, [pc, #600]	; (8002268 <moduleTRACKING+0x6d8>)
 8002010:	f010 fb66 	bl	80126e0 <chprintf.constprop.35>
 8002014:	499b      	ldr	r1, [pc, #620]	; (8002284 <moduleTRACKING+0x6f4>)
 8002016:	4894      	ldr	r0, [pc, #592]	; (8002268 <moduleTRACKING+0x6d8>)
 8002018:	f010 fb62 	bl	80126e0 <chprintf.constprop.35>
 800201c:	488f      	ldr	r0, [pc, #572]	; (800225c <moduleTRACKING+0x6cc>)
 800201e:	f00c ff07 	bl	800ee30 <chMtxUnlock>
	palSetPadMode(PORT(GPS_RESET), PIN(GPS_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// GPS reset
 8002022:	2201      	movs	r2, #1
 8002024:	4638      	mov	r0, r7
 8002026:	4611      	mov	r1, r2
 8002028:	f00a f9aa 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(GPS_EN), PIN(GPS_EN), PAL_MODE_OUTPUT_PUSHPULL);			// GPS off
 800202c:	4658      	mov	r0, fp
 800202e:	2201      	movs	r2, #1
 8002030:	2104      	movs	r1, #4
 8002032:	f00a f9a5 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(GPS_TIMEPULSE), PIN(GPS_TIMEPULSE), PAL_MODE_INPUT);		// GPS timepulse
 8002036:	4622      	mov	r2, r4
 8002038:	4638      	mov	r0, r7
 800203a:	2102      	movs	r1, #2
 800203c:	f00a f9a0 	bl	800c380 <_pal_lld_setgroupmode>

	// Switch MOSFET
	TRACE_INFO("GPS  > Switch on");
 8002040:	4886      	ldr	r0, [pc, #536]	; (800225c <moduleTRACKING+0x6cc>)
 8002042:	f00c ff55 	bl	800eef0 <chMtxLock>
 8002046:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8002048:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800204a:	4986      	ldr	r1, [pc, #536]	; (8002264 <moduleTRACKING+0x6d4>)
 800204c:	4886      	ldr	r0, [pc, #536]	; (8002268 <moduleTRACKING+0x6d8>)
 800204e:	fb06 fe03 	mul.w	lr, r6, r3
 8002052:	fbaa 3e0e 	umull	r3, lr, sl, lr
 8002056:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 800205a:	fba9 c30e 	umull	ip, r3, r9, lr
 800205e:	fbaa c202 	umull	ip, r2, sl, r2
 8002062:	099b      	lsrs	r3, r3, #6
 8002064:	fb06 e313 	mls	r3, r6, r3, lr
 8002068:	0b92      	lsrs	r2, r2, #14
 800206a:	f010 fb39 	bl	80126e0 <chprintf.constprop.35>
 800206e:	4a7f      	ldr	r2, [pc, #508]	; (800226c <moduleTRACKING+0x6dc>)
 8002070:	497f      	ldr	r1, [pc, #508]	; (8002270 <moduleTRACKING+0x6e0>)
 8002072:	487d      	ldr	r0, [pc, #500]	; (8002268 <moduleTRACKING+0x6d8>)
 8002074:	f010 fb34 	bl	80126e0 <chprintf.constprop.35>
 8002078:	f44f 73e9 	mov.w	r3, #466	; 0x1d2
 800207c:	4a7d      	ldr	r2, [pc, #500]	; (8002274 <moduleTRACKING+0x6e4>)
 800207e:	497e      	ldr	r1, [pc, #504]	; (8002278 <moduleTRACKING+0x6e8>)
 8002080:	4879      	ldr	r0, [pc, #484]	; (8002268 <moduleTRACKING+0x6d8>)
 8002082:	f010 fb2d 	bl	80126e0 <chprintf.constprop.35>
 8002086:	497d      	ldr	r1, [pc, #500]	; (800227c <moduleTRACKING+0x6ec>)
 8002088:	4877      	ldr	r0, [pc, #476]	; (8002268 <moduleTRACKING+0x6d8>)
 800208a:	f010 fb29 	bl	80126e0 <chprintf.constprop.35>
 800208e:	497e      	ldr	r1, [pc, #504]	; (8002288 <moduleTRACKING+0x6f8>)
 8002090:	4875      	ldr	r0, [pc, #468]	; (8002268 <moduleTRACKING+0x6d8>)
 8002092:	f010 fb25 	bl	80126e0 <chprintf.constprop.35>
 8002096:	497b      	ldr	r1, [pc, #492]	; (8002284 <moduleTRACKING+0x6f4>)
 8002098:	4873      	ldr	r0, [pc, #460]	; (8002268 <moduleTRACKING+0x6d8>)
 800209a:	f010 fb21 	bl	80126e0 <chprintf.constprop.35>
 800209e:	486f      	ldr	r0, [pc, #444]	; (800225c <moduleTRACKING+0x6cc>)
 80020a0:	f00c fec6 	bl	800ee30 <chMtxUnlock>
	palSetPad(PORT(GPS_RESET), PIN(GPS_RESET));	// Pull up GPS reset
	palSetPad(PORT(GPS_EN), PIN(GPS_EN));		// Switch on GPS
 80020a4:	2304      	movs	r3, #4
	palSetPadMode(PORT(GPS_EN), PIN(GPS_EN), PAL_MODE_OUTPUT_PUSHPULL);			// GPS off
	palSetPadMode(PORT(GPS_TIMEPULSE), PIN(GPS_TIMEPULSE), PAL_MODE_INPUT);		// GPS timepulse

	// Switch MOSFET
	TRACE_INFO("GPS  > Switch on");
	palSetPad(PORT(GPS_RESET), PIN(GPS_RESET));	// Pull up GPS reset
 80020a6:	2201      	movs	r2, #1
 80020a8:	833a      	strh	r2, [r7, #24]
	palSetPad(PORT(GPS_EN), PIN(GPS_EN));		// Switch on GPS
	
	// Wait for GPS startup
	chThdSleepMilliseconds(3000);
 80020aa:	f64e 2060 	movw	r0, #60000	; 0xea60
	palSetPadMode(PORT(GPS_TIMEPULSE), PIN(GPS_TIMEPULSE), PAL_MODE_INPUT);		// GPS timepulse

	// Switch MOSFET
	TRACE_INFO("GPS  > Switch on");
	palSetPad(PORT(GPS_RESET), PIN(GPS_RESET));	// Pull up GPS reset
	palSetPad(PORT(GPS_EN), PIN(GPS_EN));		// Switch on GPS
 80020ae:	f8ab 3018 	strh.w	r3, [fp, #24]
	
	// Wait for GPS startup
	chThdSleepMilliseconds(3000);
 80020b2:	f00c ffed 	bl	800f090 <chThdSleep>

	uint8_t status = 1;

	// Configure GPS
	TRACE_INFO("GPS  > Initialize GPS");
 80020b6:	4869      	ldr	r0, [pc, #420]	; (800225c <moduleTRACKING+0x6cc>)
 80020b8:	f00c ff1a 	bl	800eef0 <chMtxLock>
 80020bc:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80020be:	6a6f      	ldr	r7, [r5, #36]	; 0x24
 80020c0:	4968      	ldr	r1, [pc, #416]	; (8002264 <moduleTRACKING+0x6d4>)
 80020c2:	4869      	ldr	r0, [pc, #420]	; (8002268 <moduleTRACKING+0x6d8>)
 80020c4:	fb06 f707 	mul.w	r7, r6, r7
 80020c8:	fbaa 3707 	umull	r3, r7, sl, r7
 80020cc:	0bbf      	lsrs	r7, r7, #14
 80020ce:	fba9 e307 	umull	lr, r3, r9, r7
 80020d2:	fbaa e202 	umull	lr, r2, sl, r2
 80020d6:	099b      	lsrs	r3, r3, #6
 80020d8:	fb06 7313 	mls	r3, r6, r3, r7
 80020dc:	0b92      	lsrs	r2, r2, #14
 80020de:	f010 faff 	bl	80126e0 <chprintf.constprop.35>
 80020e2:	4a62      	ldr	r2, [pc, #392]	; (800226c <moduleTRACKING+0x6dc>)
 80020e4:	4962      	ldr	r1, [pc, #392]	; (8002270 <moduleTRACKING+0x6e0>)
 80020e6:	4860      	ldr	r0, [pc, #384]	; (8002268 <moduleTRACKING+0x6d8>)
 80020e8:	f010 fafa 	bl	80126e0 <chprintf.constprop.35>
 80020ec:	f44f 73ee 	mov.w	r3, #476	; 0x1dc
 80020f0:	4a60      	ldr	r2, [pc, #384]	; (8002274 <moduleTRACKING+0x6e4>)
 80020f2:	4961      	ldr	r1, [pc, #388]	; (8002278 <moduleTRACKING+0x6e8>)
 80020f4:	485c      	ldr	r0, [pc, #368]	; (8002268 <moduleTRACKING+0x6d8>)
 80020f6:	f010 faf3 	bl	80126e0 <chprintf.constprop.35>
 80020fa:	4960      	ldr	r1, [pc, #384]	; (800227c <moduleTRACKING+0x6ec>)
 80020fc:	485a      	ldr	r0, [pc, #360]	; (8002268 <moduleTRACKING+0x6d8>)
 80020fe:	f010 faef 	bl	80126e0 <chprintf.constprop.35>
 8002102:	4962      	ldr	r1, [pc, #392]	; (800228c <moduleTRACKING+0x6fc>)
 8002104:	4858      	ldr	r0, [pc, #352]	; (8002268 <moduleTRACKING+0x6d8>)
 8002106:	f010 faeb 	bl	80126e0 <chprintf.constprop.35>
 800210a:	495e      	ldr	r1, [pc, #376]	; (8002284 <moduleTRACKING+0x6f4>)
 800210c:	4856      	ldr	r0, [pc, #344]	; (8002268 <moduleTRACKING+0x6d8>)
 800210e:	f010 fae7 	bl	80126e0 <chprintf.constprop.35>
 8002112:	4852      	ldr	r0, [pc, #328]	; (800225c <moduleTRACKING+0x6cc>)
 8002114:	f00c fe8c 	bl	800ee30 <chMtxUnlock>
 *
 * returns if ACKed by GPS
 *
 */
uint8_t gps_disable_nmea_output(void) {
	uint8_t nonmea[] = {
 8002118:	4b5d      	ldr	r3, [pc, #372]	; (8002290 <moduleTRACKING+0x700>)
 800211a:	6818      	ldr	r0, [r3, #0]
 800211c:	6859      	ldr	r1, [r3, #4]
 800211e:	689a      	ldr	r2, [r3, #8]
 8002120:	68db      	ldr	r3, [r3, #12]
 8002122:	af6b      	add	r7, sp, #428	; 0x1ac
 8002124:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8002126:	4b5a      	ldr	r3, [pc, #360]	; (8002290 <moduleTRACKING+0x700>)
 8002128:	6918      	ldr	r0, [r3, #16]
 800212a:	6959      	ldr	r1, [r3, #20]
 800212c:	699a      	ldr	r2, [r3, #24]
 800212e:	c707      	stmia	r7!, {r0, r1, r2}
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	I2C_writeN(UBLOX_MAX_ADDRESS, cmd, length);
 8002130:	211c      	movs	r1, #28
 8002132:	a86b      	add	r0, sp, #428	; 0x1ac
 8002134:	f00c fa1c 	bl	800e570 <I2C_writeN.constprop.22>
		0x00, 0x00,							// reserved
		0xaa, 0x79							// checksum
	};

	gps_transmit_string(nonmea, sizeof(nonmea));
	return gps_receive_ack(0x06, 0x00, 1000);
 8002138:	4620      	mov	r0, r4
 800213a:	f00b fbc9 	bl	800d8d0 <gps_receive_ack.constprop.21>

	uint8_t status = 1;

	// Configure GPS
	TRACE_INFO("GPS  > Initialize GPS");
	if(gps_disable_nmea_output()) {
 800213e:	2800      	cmp	r0, #0
 8002140:	f000 86fc 	beq.w	8002f3c <moduleTRACKING+0x13ac>
		TRACE_INFO("GPS  > Disable NMEA output OK");
 8002144:	4845      	ldr	r0, [pc, #276]	; (800225c <moduleTRACKING+0x6cc>)
 8002146:	f00c fed3 	bl	800eef0 <chMtxLock>
 800214a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800214c:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800214e:	4945      	ldr	r1, [pc, #276]	; (8002264 <moduleTRACKING+0x6d4>)
 8002150:	fb06 f000 	mul.w	r0, r6, r0
 8002154:	fbaa 3000 	umull	r3, r0, sl, r0
 8002158:	0b80      	lsrs	r0, r0, #14
 800215a:	fba9 4300 	umull	r4, r3, r9, r0
 800215e:	fbaa 4202 	umull	r4, r2, sl, r2
 8002162:	099b      	lsrs	r3, r3, #6
 8002164:	fb06 0313 	mls	r3, r6, r3, r0
 8002168:	0b92      	lsrs	r2, r2, #14
 800216a:	483f      	ldr	r0, [pc, #252]	; (8002268 <moduleTRACKING+0x6d8>)
 800216c:	f010 fab8 	bl	80126e0 <chprintf.constprop.35>
 8002170:	4a3e      	ldr	r2, [pc, #248]	; (800226c <moduleTRACKING+0x6dc>)
 8002172:	493f      	ldr	r1, [pc, #252]	; (8002270 <moduleTRACKING+0x6e0>)
 8002174:	483c      	ldr	r0, [pc, #240]	; (8002268 <moduleTRACKING+0x6d8>)
 8002176:	f010 fab3 	bl	80126e0 <chprintf.constprop.35>
 800217a:	f44f 73ef 	mov.w	r3, #478	; 0x1de
 800217e:	4a3d      	ldr	r2, [pc, #244]	; (8002274 <moduleTRACKING+0x6e4>)
 8002180:	493d      	ldr	r1, [pc, #244]	; (8002278 <moduleTRACKING+0x6e8>)
 8002182:	4839      	ldr	r0, [pc, #228]	; (8002268 <moduleTRACKING+0x6d8>)
 8002184:	f010 faac 	bl	80126e0 <chprintf.constprop.35>
 8002188:	493c      	ldr	r1, [pc, #240]	; (800227c <moduleTRACKING+0x6ec>)
 800218a:	4837      	ldr	r0, [pc, #220]	; (8002268 <moduleTRACKING+0x6d8>)
 800218c:	f010 faa8 	bl	80126e0 <chprintf.constprop.35>
 8002190:	4940      	ldr	r1, [pc, #256]	; (8002294 <moduleTRACKING+0x704>)
 8002192:	4835      	ldr	r0, [pc, #212]	; (8002268 <moduleTRACKING+0x6d8>)
 8002194:	f010 faa4 	bl	80126e0 <chprintf.constprop.35>
 8002198:	493a      	ldr	r1, [pc, #232]	; (8002284 <moduleTRACKING+0x6f4>)
 800219a:	4833      	ldr	r0, [pc, #204]	; (8002268 <moduleTRACKING+0x6d8>)
 800219c:	f010 faa0 	bl	80126e0 <chprintf.constprop.35>
 80021a0:	482e      	ldr	r0, [pc, #184]	; (800225c <moduleTRACKING+0x6cc>)
 80021a2:	f00c fe45 	bl	800ee30 <chMtxUnlock>
 *
 * returns if ACKed by GPS
 *
 */
uint8_t gps_set_airborne_model(void) {
	uint8_t model6[] = {
 80021a6:	4c3c      	ldr	r4, [pc, #240]	; (8002298 <moduleTRACKING+0x708>)
 80021a8:	ae6b      	add	r6, sp, #428	; 0x1ac
 80021aa:	f104 0720 	add.w	r7, r4, #32
 80021ae:	6820      	ldr	r0, [r4, #0]
 80021b0:	6861      	ldr	r1, [r4, #4]
 80021b2:	68a2      	ldr	r2, [r4, #8]
 80021b4:	68e3      	ldr	r3, [r4, #12]
 80021b6:	4635      	mov	r5, r6
 80021b8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80021ba:	3410      	adds	r4, #16
 80021bc:	42bc      	cmp	r4, r7
 80021be:	462e      	mov	r6, r5
 80021c0:	d1f5      	bne.n	80021ae <moduleTRACKING+0x61e>
 80021c2:	6820      	ldr	r0, [r4, #0]
 80021c4:	6861      	ldr	r1, [r4, #4]
 80021c6:	68a2      	ldr	r2, [r4, #8]
 80021c8:	c607      	stmia	r6!, {r0, r1, r2}
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	I2C_writeN(UBLOX_MAX_ADDRESS, cmd, length);
 80021ca:	212c      	movs	r1, #44	; 0x2c
 80021cc:	a86b      	add	r0, sp, #428	; 0x1ac
 80021ce:	f00c f9cf 	bl	800e570 <I2C_writeN.constprop.22>
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 	// reserved
		0x1a, 0x28								// checksum
	};

	gps_transmit_string(model6, sizeof(model6));
	return gps_receive_ack(0x06, 0x24, 1000);
 80021d2:	2024      	movs	r0, #36	; 0x24
 80021d4:	f00b fb7c 	bl	800d8d0 <gps_receive_ack.constprop.21>
		TRACE_ERROR("GPS  > Set GPS only FAILED");
		status = 0;
	}
	#endif

	if(gps_set_airborne_model()) {
 80021d8:	2800      	cmp	r0, #0
 80021da:	f000 8673 	beq.w	8002ec4 <moduleTRACKING+0x1334>
		TRACE_INFO("GPS  > Set airborne model OK");
 80021de:	481f      	ldr	r0, [pc, #124]	; (800225c <moduleTRACKING+0x6cc>)
 80021e0:	f00c fe86 	bl	800eef0 <chMtxLock>
 80021e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80021e8:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 80021ec:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80021ee:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80021f0:	491c      	ldr	r1, [pc, #112]	; (8002264 <moduleTRACKING+0x6d4>)
 80021f2:	fb04 f000 	mul.w	r0, r4, r0
 80021f6:	fbaa 3000 	umull	r3, r0, sl, r0
 80021fa:	0b80      	lsrs	r0, r0, #14
 80021fc:	fba9 5300 	umull	r5, r3, r9, r0
 8002200:	fbaa 5202 	umull	r5, r2, sl, r2
 8002204:	099b      	lsrs	r3, r3, #6
 8002206:	fb04 0313 	mls	r3, r4, r3, r0
 800220a:	0b92      	lsrs	r2, r2, #14
 800220c:	4816      	ldr	r0, [pc, #88]	; (8002268 <moduleTRACKING+0x6d8>)
 800220e:	f010 fa67 	bl	80126e0 <chprintf.constprop.35>
 8002212:	4a16      	ldr	r2, [pc, #88]	; (800226c <moduleTRACKING+0x6dc>)
 8002214:	4916      	ldr	r1, [pc, #88]	; (8002270 <moduleTRACKING+0x6e0>)
 8002216:	4814      	ldr	r0, [pc, #80]	; (8002268 <moduleTRACKING+0x6d8>)
 8002218:	f010 fa62 	bl	80126e0 <chprintf.constprop.35>
 800221c:	f240 13ef 	movw	r3, #495	; 0x1ef
 8002220:	4a14      	ldr	r2, [pc, #80]	; (8002274 <moduleTRACKING+0x6e4>)
 8002222:	4915      	ldr	r1, [pc, #84]	; (8002278 <moduleTRACKING+0x6e8>)
 8002224:	4810      	ldr	r0, [pc, #64]	; (8002268 <moduleTRACKING+0x6d8>)
 8002226:	f010 fa5b 	bl	80126e0 <chprintf.constprop.35>
 800222a:	4914      	ldr	r1, [pc, #80]	; (800227c <moduleTRACKING+0x6ec>)
 800222c:	480e      	ldr	r0, [pc, #56]	; (8002268 <moduleTRACKING+0x6d8>)
 800222e:	f010 fa57 	bl	80126e0 <chprintf.constprop.35>
 8002232:	491a      	ldr	r1, [pc, #104]	; (800229c <moduleTRACKING+0x70c>)
 8002234:	480c      	ldr	r0, [pc, #48]	; (8002268 <moduleTRACKING+0x6d8>)
 8002236:	f010 fa53 	bl	80126e0 <chprintf.constprop.35>
 800223a:	4912      	ldr	r1, [pc, #72]	; (8002284 <moduleTRACKING+0x6f4>)
 800223c:	480a      	ldr	r0, [pc, #40]	; (8002268 <moduleTRACKING+0x6d8>)
 800223e:	f010 fa4f 	bl	80126e0 <chprintf.constprop.35>
 8002242:	4806      	ldr	r0, [pc, #24]	; (800225c <moduleTRACKING+0x6cc>)
 8002244:	f00c fdf4 	bl	800ee30 <chMtxUnlock>
 *
 * returns if ACKed by GPS
 *
 */
uint8_t gps_set_power_save(void) {
	uint8_t powersave[] = {
 8002248:	4c15      	ldr	r4, [pc, #84]	; (80022a0 <moduleTRACKING+0x710>)
 800224a:	ae6b      	add	r6, sp, #428	; 0x1ac
 800224c:	f104 0730 	add.w	r7, r4, #48	; 0x30
 8002250:	e02a      	b.n	80022a8 <moduleTRACKING+0x718>
 8002252:	bf00      	nop
 8002254:	20027724 	.word	0x20027724
 8002258:	20000c64 	.word	0x20000c64
 800225c:	20027b2c 	.word	0x20027b2c
 8002260:	40020400 	.word	0x40020400
 8002264:	08013c50 	.word	0x08013c50
 8002268:	20027e60 	.word	0x20027e60
 800226c:	08013cfc 	.word	0x08013cfc
 8002270:	08013c5c 	.word	0x08013c5c
 8002274:	08013e24 	.word	0x08013e24
 8002278:	08013c78 	.word	0x08013c78
 800227c:	08013d00 	.word	0x08013d00
 8002280:	08013e2c 	.word	0x08013e2c
 8002284:	08013cac 	.word	0x08013cac
 8002288:	08013e40 	.word	0x08013e40
 800228c:	08013e54 	.word	0x08013e54
 8002290:	08013b00 	.word	0x08013b00
 8002294:	08013e6c 	.word	0x08013e6c
 8002298:	08013b1c 	.word	0x08013b1c
 800229c:	08013eb0 	.word	0x08013eb0
 80022a0:	08013b48 	.word	0x08013b48
 80022a4:	40020000 	.word	0x40020000
 80022a8:	6820      	ldr	r0, [r4, #0]
 80022aa:	6861      	ldr	r1, [r4, #4]
 80022ac:	68a2      	ldr	r2, [r4, #8]
 80022ae:	68e3      	ldr	r3, [r4, #12]
 80022b0:	4635      	mov	r5, r6
 80022b2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80022b4:	3410      	adds	r4, #16
 80022b6:	42bc      	cmp	r4, r7
 80022b8:	462e      	mov	r6, r5
 80022ba:	d1f5      	bne.n	80022a8 <moduleTRACKING+0x718>
 80022bc:	6820      	ldr	r0, [r4, #0]
 80022be:	6028      	str	r0, [r5, #0]
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	I2C_writeN(UBLOX_MAX_ADDRESS, cmd, length);
 80022c0:	2134      	movs	r1, #52	; 0x34
 80022c2:	a86b      	add	r0, sp, #428	; 0x1ac
 80022c4:	f00c f954 	bl	800e570 <I2C_writeN.constprop.22>
		0x00, 0x00, 0x00, 0x00,				// reserved 11
		0xef, 0x29
	};

	gps_transmit_string(powersave, sizeof(powersave));
	return gps_receive_ack(0x06, 0x3B, 1000);
 80022c8:	203b      	movs	r0, #59	; 0x3b
 80022ca:	f00b fb01 	bl	800d8d0 <gps_receive_ack.constprop.21>
		TRACE_INFO("GPS  > Set airborne model OK");
	} else {
		TRACE_ERROR("GPS  > Set airborne model FAILED");
		status = 0;
	}
	if(gps_set_power_save()) {
 80022ce:	2800      	cmp	r0, #0
 80022d0:	f000 8578 	beq.w	8002dc4 <moduleTRACKING+0x1234>
		TRACE_INFO("GPS  > Configure power save OK");
 80022d4:	4843      	ldr	r0, [pc, #268]	; (80023e4 <moduleTRACKING+0x854>)
 80022d6:	f00c fe0b 	bl	800eef0 <chMtxLock>
 80022da:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80022de:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 80022e2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80022e4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80022e6:	4940      	ldr	r1, [pc, #256]	; (80023e8 <moduleTRACKING+0x858>)
 80022e8:	fb04 f000 	mul.w	r0, r4, r0
 80022ec:	fbaa 3000 	umull	r3, r0, sl, r0
 80022f0:	0b80      	lsrs	r0, r0, #14
 80022f2:	fba9 5300 	umull	r5, r3, r9, r0
 80022f6:	fbaa 5202 	umull	r5, r2, sl, r2
 80022fa:	099b      	lsrs	r3, r3, #6
 80022fc:	fb04 0313 	mls	r3, r4, r3, r0
 8002300:	0b92      	lsrs	r2, r2, #14
 8002302:	483a      	ldr	r0, [pc, #232]	; (80023ec <moduleTRACKING+0x85c>)
 8002304:	f010 f9ec 	bl	80126e0 <chprintf.constprop.35>
 8002308:	4a39      	ldr	r2, [pc, #228]	; (80023f0 <moduleTRACKING+0x860>)
 800230a:	493a      	ldr	r1, [pc, #232]	; (80023f4 <moduleTRACKING+0x864>)
 800230c:	4837      	ldr	r0, [pc, #220]	; (80023ec <moduleTRACKING+0x85c>)
 800230e:	f010 f9e7 	bl	80126e0 <chprintf.constprop.35>
 8002312:	f240 13f5 	movw	r3, #501	; 0x1f5
 8002316:	4a38      	ldr	r2, [pc, #224]	; (80023f8 <moduleTRACKING+0x868>)
 8002318:	4938      	ldr	r1, [pc, #224]	; (80023fc <moduleTRACKING+0x86c>)
 800231a:	4834      	ldr	r0, [pc, #208]	; (80023ec <moduleTRACKING+0x85c>)
 800231c:	f010 f9e0 	bl	80126e0 <chprintf.constprop.35>
 8002320:	4937      	ldr	r1, [pc, #220]	; (8002400 <moduleTRACKING+0x870>)
 8002322:	4832      	ldr	r0, [pc, #200]	; (80023ec <moduleTRACKING+0x85c>)
 8002324:	f010 f9dc 	bl	80126e0 <chprintf.constprop.35>
 8002328:	4936      	ldr	r1, [pc, #216]	; (8002404 <moduleTRACKING+0x874>)
 800232a:	4830      	ldr	r0, [pc, #192]	; (80023ec <moduleTRACKING+0x85c>)
 800232c:	f010 f9d8 	bl	80126e0 <chprintf.constprop.35>
 8002330:	4935      	ldr	r1, [pc, #212]	; (8002408 <moduleTRACKING+0x878>)
 8002332:	482e      	ldr	r0, [pc, #184]	; (80023ec <moduleTRACKING+0x85c>)
 8002334:	f010 f9d4 	bl	80126e0 <chprintf.constprop.35>
 8002338:	482a      	ldr	r0, [pc, #168]	; (80023e4 <moduleTRACKING+0x854>)
 800233a:	f00c fd79 	bl	800ee30 <chMtxUnlock>
 * gps_power_save
 *
 * enables or disables the power save mode (which was configured before)
 */
uint8_t gps_power_save(int on) {
	uint8_t recvmgmt[] = {
 800233e:	4b33      	ldr	r3, [pc, #204]	; (800240c <moduleTRACKING+0x87c>)
 8002340:	6818      	ldr	r0, [r3, #0]
 8002342:	6859      	ldr	r1, [r3, #4]
 8002344:	ab6b      	add	r3, sp, #428	; 0x1ac
 8002346:	c303      	stmia	r3!, {r0, r1}
		0xB5, 0x62, 0x06, 0x11, 2, 0,	// UBX-CFG-RXM
		0x08, 0x01,						// reserved, enable power save mode
		0x22, 0x92
	};
	if (!on) {
		recvmgmt[7] = 0x00;		// continuous mode
 8002348:	2000      	movs	r0, #0
		recvmgmt[8] = 0x21;		// new checksum
 800234a:	2221      	movs	r2, #33	; 0x21
		recvmgmt[9] = 0x91;
 800234c:	2391      	movs	r3, #145	; 0x91
		0xB5, 0x62, 0x06, 0x11, 2, 0,	// UBX-CFG-RXM
		0x08, 0x01,						// reserved, enable power save mode
		0x22, 0x92
	};
	if (!on) {
		recvmgmt[7] = 0x00;		// continuous mode
 800234e:	f88d 01b3 	strb.w	r0, [sp, #435]	; 0x1b3
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	I2C_writeN(UBLOX_MAX_ADDRESS, cmd, length);
 8002352:	210a      	movs	r1, #10
 8002354:	a86b      	add	r0, sp, #428	; 0x1ac
		0x08, 0x01,						// reserved, enable power save mode
		0x22, 0x92
	};
	if (!on) {
		recvmgmt[7] = 0x00;		// continuous mode
		recvmgmt[8] = 0x21;		// new checksum
 8002356:	f88d 21b4 	strb.w	r2, [sp, #436]	; 0x1b4
		recvmgmt[9] = 0x91;
 800235a:	f88d 31b5 	strb.w	r3, [sp, #437]	; 0x1b5
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	I2C_writeN(UBLOX_MAX_ADDRESS, cmd, length);
 800235e:	f00c f907 	bl	800e570 <I2C_writeN.constprop.22>
		recvmgmt[8] = 0x21;		// new checksum
		recvmgmt[9] = 0x91;
	}

	gps_transmit_string(recvmgmt, sizeof(recvmgmt));
	return gps_receive_ack(0x06, 0x11, 1000);
 8002362:	2011      	movs	r0, #17
 8002364:	f00b fab4 	bl	800d8d0 <gps_receive_ack.constprop.21>
		TRACE_INFO("GPS  > Configure power save OK");
	} else {
		TRACE_ERROR("GPS  > Configure power save FAILED");
		status = 0;
	}
	if(gps_power_save(0)) {
 8002368:	2800      	cmp	r0, #0
 800236a:	f041 80a2 	bne.w	80034b2 <moduleTRACKING+0x1922>
		TRACE_INFO("GPS  > Disable power save OK");
	} else {
		TRACE_ERROR("GPS  > Disable power save FAILED");
 800236e:	481d      	ldr	r0, [pc, #116]	; (80023e4 <moduleTRACKING+0x854>)
 8002370:	f00c fdbe 	bl	800eef0 <chMtxLock>
 8002374:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002378:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 800237c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800237e:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002380:	4919      	ldr	r1, [pc, #100]	; (80023e8 <moduleTRACKING+0x858>)
 8002382:	fb04 f000 	mul.w	r0, r4, r0
 8002386:	fbaa 3000 	umull	r3, r0, sl, r0
 800238a:	0b80      	lsrs	r0, r0, #14
 800238c:	fba9 5300 	umull	r5, r3, r9, r0
 8002390:	fbaa 5202 	umull	r5, r2, sl, r2
 8002394:	099b      	lsrs	r3, r3, #6
 8002396:	fb04 0313 	mls	r3, r4, r3, r0
 800239a:	0b92      	lsrs	r2, r2, #14
 800239c:	4813      	ldr	r0, [pc, #76]	; (80023ec <moduleTRACKING+0x85c>)
 800239e:	f010 f99f 	bl	80126e0 <chprintf.constprop.35>
 80023a2:	4a1b      	ldr	r2, [pc, #108]	; (8002410 <moduleTRACKING+0x880>)
 80023a4:	4913      	ldr	r1, [pc, #76]	; (80023f4 <moduleTRACKING+0x864>)
 80023a6:	4811      	ldr	r0, [pc, #68]	; (80023ec <moduleTRACKING+0x85c>)
 80023a8:	f010 f99a 	bl	80126e0 <chprintf.constprop.35>
 80023ac:	f240 13fd 	movw	r3, #509	; 0x1fd
 80023b0:	4a11      	ldr	r2, [pc, #68]	; (80023f8 <moduleTRACKING+0x868>)
 80023b2:	4912      	ldr	r1, [pc, #72]	; (80023fc <moduleTRACKING+0x86c>)
 80023b4:	480d      	ldr	r0, [pc, #52]	; (80023ec <moduleTRACKING+0x85c>)
 80023b6:	f010 f993 	bl	80126e0 <chprintf.constprop.35>
 80023ba:	4911      	ldr	r1, [pc, #68]	; (8002400 <moduleTRACKING+0x870>)
 80023bc:	480b      	ldr	r0, [pc, #44]	; (80023ec <moduleTRACKING+0x85c>)
 80023be:	f010 f98f 	bl	80126e0 <chprintf.constprop.35>
 80023c2:	4914      	ldr	r1, [pc, #80]	; (8002414 <moduleTRACKING+0x884>)
 80023c4:	4809      	ldr	r0, [pc, #36]	; (80023ec <moduleTRACKING+0x85c>)
 80023c6:	f010 f98b 	bl	80126e0 <chprintf.constprop.35>
 80023ca:	490f      	ldr	r1, [pc, #60]	; (8002408 <moduleTRACKING+0x878>)
 80023cc:	4807      	ldr	r0, [pc, #28]	; (80023ec <moduleTRACKING+0x85c>)
 80023ce:	f010 f987 	bl	80126e0 <chprintf.constprop.35>
 80023d2:	4804      	ldr	r0, [pc, #16]	; (80023e4 <moduleTRACKING+0x854>)
 80023d4:	f00c fd2c 	bl	800ee30 <chMtxUnlock>
 80023d8:	f240 11fd 	movw	r1, #509	; 0x1fd
 80023dc:	4806      	ldr	r0, [pc, #24]	; (80023f8 <moduleTRACKING+0x868>)
 80023de:	f00d fdbf 	bl	800ff60 <log_error>
 80023e2:	e138      	b.n	8002656 <moduleTRACKING+0xac6>
 80023e4:	20027b2c 	.word	0x20027b2c
 80023e8:	08013c50 	.word	0x08013c50
 80023ec:	20027e60 	.word	0x20027e60
 80023f0:	08013cfc 	.word	0x08013cfc
 80023f4:	08013c5c 	.word	0x08013c5c
 80023f8:	08013e24 	.word	0x08013e24
 80023fc:	08013c78 	.word	0x08013c78
 8002400:	08013d00 	.word	0x08013d00
 8002404:	08013ef4 	.word	0x08013ef4
 8002408:	08013cac 	.word	0x08013cac
 800240c:	08013b7c 	.word	0x08013b7c
 8002410:	08013d9c 	.word	0x08013d9c
 8002414:	08013f58 	.word	0x08013f58
	uint8_t posllh[] = {0xB5, 0x62, 0x01, 0x02, 0x00, 0x00, 0x03, 0x0A};
	gps_transmit_string(posllh, sizeof(posllh));

	resp = gps_receive_payload(0x01, 0x02, response, 5000);
	if(!resp) { // Failed to aquire GPS data
		TRACE_ERROR("GPS  > POSLLH Polling FAILED");
 8002418:	48b2      	ldr	r0, [pc, #712]	; (80026e4 <moduleTRACKING+0xb54>)
 800241a:	f00c fd69 	bl	800eef0 <chMtxLock>
 800241e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002422:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8002426:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002428:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800242a:	49af      	ldr	r1, [pc, #700]	; (80026e8 <moduleTRACKING+0xb58>)
 800242c:	fb05 f000 	mul.w	r0, r5, r0
 8002430:	fbaa 3000 	umull	r3, r0, sl, r0
 8002434:	0b80      	lsrs	r0, r0, #14
 8002436:	fba9 6300 	umull	r6, r3, r9, r0
 800243a:	fbaa 6202 	umull	r6, r2, sl, r2
 800243e:	099b      	lsrs	r3, r3, #6
 8002440:	fb05 0313 	mls	r3, r5, r3, r0
 8002444:	0b92      	lsrs	r2, r2, #14
 8002446:	48a9      	ldr	r0, [pc, #676]	; (80026ec <moduleTRACKING+0xb5c>)
 8002448:	f010 f94a 	bl	80126e0 <chprintf.constprop.35>
 800244c:	4aa8      	ldr	r2, [pc, #672]	; (80026f0 <moduleTRACKING+0xb60>)
 800244e:	49a9      	ldr	r1, [pc, #676]	; (80026f4 <moduleTRACKING+0xb64>)
 8002450:	48a6      	ldr	r0, [pc, #664]	; (80026ec <moduleTRACKING+0xb5c>)
 8002452:	f010 f945 	bl	80126e0 <chprintf.constprop.35>
 8002456:	23ed      	movs	r3, #237	; 0xed
 8002458:	4aa7      	ldr	r2, [pc, #668]	; (80026f8 <moduleTRACKING+0xb68>)
 800245a:	49a8      	ldr	r1, [pc, #672]	; (80026fc <moduleTRACKING+0xb6c>)
 800245c:	48a3      	ldr	r0, [pc, #652]	; (80026ec <moduleTRACKING+0xb5c>)
 800245e:	f010 f93f 	bl	80126e0 <chprintf.constprop.35>
 8002462:	49a7      	ldr	r1, [pc, #668]	; (8002700 <moduleTRACKING+0xb70>)
 8002464:	48a1      	ldr	r0, [pc, #644]	; (80026ec <moduleTRACKING+0xb5c>)
 8002466:	f010 f93b 	bl	80126e0 <chprintf.constprop.35>
 800246a:	49a6      	ldr	r1, [pc, #664]	; (8002704 <moduleTRACKING+0xb74>)
 800246c:	489f      	ldr	r0, [pc, #636]	; (80026ec <moduleTRACKING+0xb5c>)
 800246e:	f010 f937 	bl	80126e0 <chprintf.constprop.35>
 8002472:	49a5      	ldr	r1, [pc, #660]	; (8002708 <moduleTRACKING+0xb78>)
 8002474:	489d      	ldr	r0, [pc, #628]	; (80026ec <moduleTRACKING+0xb5c>)
 8002476:	f010 f933 	bl	80126e0 <chprintf.constprop.35>
 800247a:	489a      	ldr	r0, [pc, #616]	; (80026e4 <moduleTRACKING+0xb54>)
 800247c:	f00c fcd8 	bl	800ee30 <chMtxUnlock>
 8002480:	21ed      	movs	r1, #237	; 0xed
 8002482:	489d      	ldr	r0, [pc, #628]	; (80026f8 <moduleTRACKING+0xb68>)
 8002484:	f00d fd6c 	bl	800ff60 <log_error>
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[4]) + ((uint32_t)(response[5]) << 8) + ((uint32_t)(response[6]) << 16) + ((uint32_t)(response[7]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 8002488:	f898 1012 	ldrb.w	r1, [r8, #18]
 800248c:	f898 3011 	ldrb.w	r3, [r8, #17]
 8002490:	f898 2010 	ldrb.w	r2, [r8, #16]
 8002494:	f898 0013 	ldrb.w	r0, [r8, #19]
	} else {
		TRACE_INFO("GPS  > POSLLH Polling OK");
	}

	fix->lat = (int32_t) (
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
 8002498:	f898 5009 	ldrb.w	r5, [r8, #9]
 800249c:	952a      	str	r5, [sp, #168]	; 0xa8
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[4]) + ((uint32_t)(response[5]) << 8) + ((uint32_t)(response[6]) << 16) + ((uint32_t)(response[7]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 800249e:	0409      	lsls	r1, r1, #16
 80024a0:	eb01 2303 	add.w	r3, r1, r3, lsl #8
 80024a4:	4413      	add	r3, r2
	} else {
		TRACE_INFO("GPS  > POSLLH Polling OK");
	}

	fix->lat = (int32_t) (
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
 80024a6:	f898 500a 	ldrb.w	r5, [r8, #10]
 80024aa:	9526      	str	r5, [sp, #152]	; 0x98
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[4]) + ((uint32_t)(response[5]) << 8) + ((uint32_t)(response[6]) << 16) + ((uint32_t)(response[7]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 80024ac:	eb03 6300 	add.w	r3, r3, r0, lsl #24
 80024b0:	fb89 1203 	smull	r1, r2, r9, r3
	} else {
		TRACE_INFO("GPS  > POSLLH Polling OK");
	}

	fix->lat = (int32_t) (
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
 80024b4:	f898 500b 	ldrb.w	r5, [r8, #11]
 80024b8:	9527      	str	r5, [sp, #156]	; 0x9c
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[4]) + ((uint32_t)(response[5]) << 8) + ((uint32_t)(response[6]) << 16) + ((uint32_t)(response[7]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 80024ba:	17db      	asrs	r3, r3, #31

	fix->lat = (int32_t) (
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[4]) + ((uint32_t)(response[5]) << 8) + ((uint32_t)(response[6]) << 16) + ((uint32_t)(response[7]) << 24)
 80024bc:	f898 5004 	ldrb.w	r5, [r8, #4]
 80024c0:	952b      	str	r5, [sp, #172]	; 0xac
			);
	int32_t alt_tmp = (((int32_t) 
 80024c2:	ebc3 13a2 	rsb	r3, r3, r2, asr #6

	fix->lat = (int32_t) (
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[4]) + ((uint32_t)(response[5]) << 8) + ((uint32_t)(response[6]) << 16) + ((uint32_t)(response[7]) << 24)
 80024c6:	f898 2006 	ldrb.w	r2, [r8, #6]
 80024ca:	f898 5005 	ldrb.w	r5, [r8, #5]
 80024ce:	922d      	str	r2, [sp, #180]	; 0xb4
			);
	int32_t alt_tmp = (((int32_t) 
			((uint32_t)(response[16]) + ((uint32_t)(response[17]) << 8) + ((uint32_t)(response[18]) << 16) + ((uint32_t)(response[19]) << 24))
			) / 1000);
	if (alt_tmp <= 0) {
 80024d0:	2b00      	cmp	r3, #0

	fix->lat = (int32_t) (
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[4]) + ((uint32_t)(response[5]) << 8) + ((uint32_t)(response[6]) << 16) + ((uint32_t)(response[7]) << 24)
 80024d2:	f898 2007 	ldrb.w	r2, [r8, #7]
	} else {
		TRACE_INFO("GPS  > POSLLH Polling OK");
	}

	fix->lat = (int32_t) (
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
 80024d6:	f898 7008 	ldrb.w	r7, [r8, #8]
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[4]) + ((uint32_t)(response[5]) << 8) + ((uint32_t)(response[6]) << 16) + ((uint32_t)(response[7]) << 24)
 80024da:	952c      	str	r5, [sp, #176]	; 0xb0
 80024dc:	922e      	str	r2, [sp, #184]	; 0xb8
			);
	int32_t alt_tmp = (((int32_t) 
			((uint32_t)(response[16]) + ((uint32_t)(response[17]) << 8) + ((uint32_t)(response[18]) << 16) + ((uint32_t)(response[19]) << 24))
			) / 1000);
	if (alt_tmp <= 0) {
 80024de:	f340 8194 	ble.w	800280a <moduleTRACKING+0xc7a>
 80024e2:	f24c 3250 	movw	r2, #50000	; 0xc350
 80024e6:	4293      	cmp	r3, r2
 80024e8:	bfa8      	it	ge
 80024ea:	4613      	movge	r3, r2
 80024ec:	9329      	str	r3, [sp, #164]	; 0xa4
	} else {
		fix->alt = (uint16_t)alt_tmp;
	}

	// SOL (Navigation Solution Information)
	uint8_t sol[] = {0xB5, 0x62, 0x01, 0x06, 0x00, 0x00, 0x07, 0x16};
 80024ee:	4b87      	ldr	r3, [pc, #540]	; (800270c <moduleTRACKING+0xb7c>)
 80024f0:	6818      	ldr	r0, [r3, #0]
 80024f2:	6859      	ldr	r1, [r3, #4]
 80024f4:	ab60      	add	r3, sp, #384	; 0x180
 80024f6:	c303      	stmia	r3!, {r0, r1}
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	I2C_writeN(UBLOX_MAX_ADDRESS, cmd, length);
 80024f8:	2108      	movs	r1, #8
 80024fa:	a860      	add	r0, sp, #384	; 0x180
 80024fc:	f00c f838 	bl	800e570 <I2C_writeN.constprop.22>

	// SOL (Navigation Solution Information)
	uint8_t sol[] = {0xB5, 0x62, 0x01, 0x06, 0x00, 0x00, 0x07, 0x16};
	gps_transmit_string(sol, sizeof(sol));

	resp = gps_receive_payload(0x01, 0x06, response, 5000);
 8002500:	2006      	movs	r0, #6
 8002502:	f00a ff4d 	bl	800d3a0 <gps_receive_payload.constprop.23>
	if(!resp) { // Failed to aquire GPS data
 8002506:	2800      	cmp	r0, #0
 8002508:	f040 810e 	bne.w	8002728 <moduleTRACKING+0xb98>
		TRACE_ERROR("GPS  > SOL Polling FAILED");
 800250c:	4875      	ldr	r0, [pc, #468]	; (80026e4 <moduleTRACKING+0xb54>)
 800250e:	f00c fcef 	bl	800eef0 <chMtxLock>
 8002512:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002516:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800251a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800251c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800251e:	4972      	ldr	r1, [pc, #456]	; (80026e8 <moduleTRACKING+0xb58>)
 8002520:	fb05 f000 	mul.w	r0, r5, r0
 8002524:	fbaa 3000 	umull	r3, r0, sl, r0
 8002528:	0b80      	lsrs	r0, r0, #14
 800252a:	fba9 6300 	umull	r6, r3, r9, r0
 800252e:	fbaa 6202 	umull	r6, r2, sl, r2
 8002532:	099b      	lsrs	r3, r3, #6
 8002534:	fb05 0313 	mls	r3, r5, r3, r0
 8002538:	0b92      	lsrs	r2, r2, #14
 800253a:	486c      	ldr	r0, [pc, #432]	; (80026ec <moduleTRACKING+0xb5c>)
 800253c:	f010 f8d0 	bl	80126e0 <chprintf.constprop.35>
 8002540:	4a6b      	ldr	r2, [pc, #428]	; (80026f0 <moduleTRACKING+0xb60>)
 8002542:	496c      	ldr	r1, [pc, #432]	; (80026f4 <moduleTRACKING+0xb64>)
 8002544:	4869      	ldr	r0, [pc, #420]	; (80026ec <moduleTRACKING+0xb5c>)
 8002546:	f010 f8cb 	bl	80126e0 <chprintf.constprop.35>
 800254a:	f44f 7385 	mov.w	r3, #266	; 0x10a
 800254e:	4a6a      	ldr	r2, [pc, #424]	; (80026f8 <moduleTRACKING+0xb68>)
 8002550:	496a      	ldr	r1, [pc, #424]	; (80026fc <moduleTRACKING+0xb6c>)
 8002552:	4866      	ldr	r0, [pc, #408]	; (80026ec <moduleTRACKING+0xb5c>)
 8002554:	f010 f8c4 	bl	80126e0 <chprintf.constprop.35>
 8002558:	4969      	ldr	r1, [pc, #420]	; (8002700 <moduleTRACKING+0xb70>)
 800255a:	4864      	ldr	r0, [pc, #400]	; (80026ec <moduleTRACKING+0xb5c>)
 800255c:	f010 f8c0 	bl	80126e0 <chprintf.constprop.35>
 8002560:	496b      	ldr	r1, [pc, #428]	; (8002710 <moduleTRACKING+0xb80>)
 8002562:	4862      	ldr	r0, [pc, #392]	; (80026ec <moduleTRACKING+0xb5c>)
 8002564:	f010 f8bc 	bl	80126e0 <chprintf.constprop.35>
 8002568:	4967      	ldr	r1, [pc, #412]	; (8002708 <moduleTRACKING+0xb78>)
 800256a:	4860      	ldr	r0, [pc, #384]	; (80026ec <moduleTRACKING+0xb5c>)
 800256c:	f010 f8b8 	bl	80126e0 <chprintf.constprop.35>
 8002570:	485c      	ldr	r0, [pc, #368]	; (80026e4 <moduleTRACKING+0xb54>)
 8002572:	f00c fc5d 	bl	800ee30 <chMtxUnlock>
 8002576:	f44f 7185 	mov.w	r1, #266	; 0x10a
 800257a:	485f      	ldr	r0, [pc, #380]	; (80026f8 <moduleTRACKING+0xb68>)
 800257c:	f00d fcf0 	bl	800ff60 <log_error>

	fix->type = response[10];
	fix->num_svs = response[47];

	// TIMEUTC (UTC Time Solution)
	uint8_t timeutc[] = {0xB5, 0x62, 0x01, 0x21, 0x00, 0x00, 0x22, 0x67};
 8002580:	4b64      	ldr	r3, [pc, #400]	; (8002714 <moduleTRACKING+0xb84>)
		respall = false;
	} else {
		TRACE_INFO("GPS  > SOL Polling OK");
	}

	fix->type = response[10];
 8002582:	f898 b00a 	ldrb.w	fp, [r8, #10]
	fix->num_svs = response[47];

	// TIMEUTC (UTC Time Solution)
	uint8_t timeutc[] = {0xB5, 0x62, 0x01, 0x21, 0x00, 0x00, 0x22, 0x67};
 8002586:	6818      	ldr	r0, [r3, #0]
 8002588:	6859      	ldr	r1, [r3, #4]
	} else {
		TRACE_INFO("GPS  > SOL Polling OK");
	}

	fix->type = response[10];
	fix->num_svs = response[47];
 800258a:	f898 502f 	ldrb.w	r5, [r8, #47]	; 0x2f

	// TIMEUTC (UTC Time Solution)
	uint8_t timeutc[] = {0xB5, 0x62, 0x01, 0x21, 0x00, 0x00, 0x22, 0x67};
 800258e:	ab6b      	add	r3, sp, #428	; 0x1ac
 8002590:	c303      	stmia	r3!, {r0, r1}
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	I2C_writeN(UBLOX_MAX_ADDRESS, cmd, length);
 8002592:	2108      	movs	r1, #8
 8002594:	a86b      	add	r0, sp, #428	; 0x1ac
 8002596:	f00b ffeb 	bl	800e570 <I2C_writeN.constprop.22>

	// TIMEUTC (UTC Time Solution)
	uint8_t timeutc[] = {0xB5, 0x62, 0x01, 0x21, 0x00, 0x00, 0x22, 0x67};
	gps_transmit_string(timeutc, sizeof(timeutc));

	resp = gps_receive_payload(0x01, 0x21, response, 5000);
 800259a:	2021      	movs	r0, #33	; 0x21
 800259c:	f00a ff00 	bl	800d3a0 <gps_receive_payload.constprop.23>
	if(!resp) { // Failed to aquire GPS data
 80025a0:	2800      	cmp	r0, #0
 80025a2:	f000 80f7 	beq.w	8002794 <moduleTRACKING+0xc04>
		TRACE_ERROR("GPS  > TIMEUTC Polling FAILED");
		respall = false;
	} else {
		TRACE_INFO("GPS  > TIMEUTC Polling OK");
 80025a6:	484f      	ldr	r0, [pc, #316]	; (80026e4 <moduleTRACKING+0xb54>)
 80025a8:	f00c fca2 	bl	800eef0 <chMtxLock>
 80025ac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80025b0:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 80025b4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80025b6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80025b8:	494b      	ldr	r1, [pc, #300]	; (80026e8 <moduleTRACKING+0xb58>)
 80025ba:	fb06 f000 	mul.w	r0, r6, r0
 80025be:	fbaa 3000 	umull	r3, r0, sl, r0
 80025c2:	0b80      	lsrs	r0, r0, #14
 80025c4:	fba9 e300 	umull	lr, r3, r9, r0
 80025c8:	fbaa e202 	umull	lr, r2, sl, r2
 80025cc:	099b      	lsrs	r3, r3, #6
 80025ce:	fb06 0313 	mls	r3, r6, r3, r0
 80025d2:	0b92      	lsrs	r2, r2, #14
 80025d4:	4845      	ldr	r0, [pc, #276]	; (80026ec <moduleTRACKING+0xb5c>)
 80025d6:	f010 f883 	bl	80126e0 <chprintf.constprop.35>
 80025da:	4a4f      	ldr	r2, [pc, #316]	; (8002718 <moduleTRACKING+0xb88>)
 80025dc:	4945      	ldr	r1, [pc, #276]	; (80026f4 <moduleTRACKING+0xb64>)
 80025de:	4843      	ldr	r0, [pc, #268]	; (80026ec <moduleTRACKING+0xb5c>)
 80025e0:	f010 f87e 	bl	80126e0 <chprintf.constprop.35>
 80025e4:	f44f 738e 	mov.w	r3, #284	; 0x11c
 80025e8:	4a43      	ldr	r2, [pc, #268]	; (80026f8 <moduleTRACKING+0xb68>)
 80025ea:	4944      	ldr	r1, [pc, #272]	; (80026fc <moduleTRACKING+0xb6c>)
 80025ec:	483f      	ldr	r0, [pc, #252]	; (80026ec <moduleTRACKING+0xb5c>)
 80025ee:	f010 f877 	bl	80126e0 <chprintf.constprop.35>
 80025f2:	4943      	ldr	r1, [pc, #268]	; (8002700 <moduleTRACKING+0xb70>)
 80025f4:	483d      	ldr	r0, [pc, #244]	; (80026ec <moduleTRACKING+0xb5c>)
 80025f6:	f010 f873 	bl	80126e0 <chprintf.constprop.35>
 80025fa:	4948      	ldr	r1, [pc, #288]	; (800271c <moduleTRACKING+0xb8c>)
 80025fc:	483b      	ldr	r0, [pc, #236]	; (80026ec <moduleTRACKING+0xb5c>)
 80025fe:	f010 f86f 	bl	80126e0 <chprintf.constprop.35>
 8002602:	4941      	ldr	r1, [pc, #260]	; (8002708 <moduleTRACKING+0xb78>)
 8002604:	4839      	ldr	r0, [pc, #228]	; (80026ec <moduleTRACKING+0xb5c>)
 8002606:	f010 f86b 	bl	80126e0 <chprintf.constprop.35>
 800260a:	4836      	ldr	r0, [pc, #216]	; (80026e4 <moduleTRACKING+0xb54>)
 800260c:	f00c fc10 	bl	800ee30 <chMtxUnlock>
	}

	fix->time.year = response[12] + (response[13] << 8);
	fix->time.month = response[14];
	fix->time.day = response[15];
	fix->time.hour = response[16];
 8002610:	f898 3010 	ldrb.w	r3, [r8, #16]
		respall = false;
	} else {
		TRACE_INFO("GPS  > TIMEUTC Polling OK");
	}

	fix->time.year = response[12] + (response[13] << 8);
 8002614:	f898 200c 	ldrb.w	r2, [r8, #12]
 8002618:	f898 100d 	ldrb.w	r1, [r8, #13]
	fix->time.month = response[14];
 800261c:	f898 000e 	ldrb.w	r0, [r8, #14]
	fix->time.day = response[15];
 8002620:	f898 600f 	ldrb.w	r6, [r8, #15]
	fix->time.hour = response[16];
 8002624:	9328      	str	r3, [sp, #160]	; 0xa0

			// Search for lock as long enough power is available
			do {
				batt = getBatteryVoltageMV();
				gps_get_fix(&gpsFix);
			} while(!isGPSLocked(&gpsFix) && batt >= GPS_OFF_VBAT && chVTGetSystemTimeX() <= time + S2ST(TRACK_CYCLE_TIME-5)); // Do as long no GPS lock and within timeout, timeout=cycle-1sec (-1sec in order to keep synchronization)
 8002626:	f1bb 0f03 	cmp.w	fp, #3
	fix->time.minute = response[17];
 800262a:	f898 e011 	ldrb.w	lr, [r8, #17]
	fix->time.second = response[18];
 800262e:	f898 c012 	ldrb.w	ip, [r8, #18]
 8002632:	f000 8403 	beq.w	8002e3c <moduleTRACKING+0x12ac>
 8002636:	f640 0397 	movw	r3, #2199	; 0x897
 800263a:	429c      	cmp	r4, r3
 800263c:	f240 84cc 	bls.w	8002fd8 <moduleTRACKING+0x1448>
 8002640:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8002644:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8002646:	6a64      	ldr	r4, [r4, #36]	; 0x24
 8002648:	f503 130c 	add.w	r3, r3, #2293760	; 0x230000
 800264c:	f503 53c3 	add.w	r3, r3, #6240	; 0x1860
 8002650:	429c      	cmp	r4, r3
 8002652:	f200 8723 	bhi.w	800349c <moduleTRACKING+0x190c>
			// Switch on GPS
			GPS_Init();

			// Search for lock as long enough power is available
			do {
				batt = getBatteryVoltageMV();
 8002656:	f008 fa0b 	bl	800aa70 <getBatteryVoltageMV>

	bool respall = true; // Validity over all GPS requests
	bool resp;

	// POSLLH (Geodetic Position Solution)
	uint8_t posllh[] = {0xB5, 0x62, 0x01, 0x02, 0x00, 0x00, 0x03, 0x0A};
 800265a:	4b31      	ldr	r3, [pc, #196]	; (8002720 <moduleTRACKING+0xb90>)
 800265c:	4604      	mov	r4, r0
 800265e:	6859      	ldr	r1, [r3, #4]
 8002660:	6818      	ldr	r0, [r3, #0]
 8002662:	ab40      	add	r3, sp, #256	; 0x100
 8002664:	c303      	stmia	r3!, {r0, r1}
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	I2C_writeN(UBLOX_MAX_ADDRESS, cmd, length);
 8002666:	2108      	movs	r1, #8
 8002668:	a840      	add	r0, sp, #256	; 0x100
 800266a:	f00b ff81 	bl	800e570 <I2C_writeN.constprop.22>

	// POSLLH (Geodetic Position Solution)
	uint8_t posllh[] = {0xB5, 0x62, 0x01, 0x02, 0x00, 0x00, 0x03, 0x0A};
	gps_transmit_string(posllh, sizeof(posllh));

	resp = gps_receive_payload(0x01, 0x02, response, 5000);
 800266e:	2002      	movs	r0, #2
 8002670:	f00a fe96 	bl	800d3a0 <gps_receive_payload.constprop.23>
	if(!resp) { // Failed to aquire GPS data
 8002674:	2800      	cmp	r0, #0
 8002676:	f43f aecf 	beq.w	8002418 <moduleTRACKING+0x888>
		TRACE_ERROR("GPS  > POSLLH Polling FAILED");
		respall = false;
	} else {
		TRACE_INFO("GPS  > POSLLH Polling OK");
 800267a:	481a      	ldr	r0, [pc, #104]	; (80026e4 <moduleTRACKING+0xb54>)
 800267c:	f00c fc38 	bl	800eef0 <chMtxLock>
 8002680:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002684:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8002688:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800268a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800268c:	4916      	ldr	r1, [pc, #88]	; (80026e8 <moduleTRACKING+0xb58>)
 800268e:	fb05 f000 	mul.w	r0, r5, r0
 8002692:	fbaa 3000 	umull	r3, r0, sl, r0
 8002696:	0b80      	lsrs	r0, r0, #14
 8002698:	fba9 6300 	umull	r6, r3, r9, r0
 800269c:	fbaa 6202 	umull	r6, r2, sl, r2
 80026a0:	099b      	lsrs	r3, r3, #6
 80026a2:	fb05 0313 	mls	r3, r5, r3, r0
 80026a6:	0b92      	lsrs	r2, r2, #14
 80026a8:	4810      	ldr	r0, [pc, #64]	; (80026ec <moduleTRACKING+0xb5c>)
 80026aa:	f010 f819 	bl	80126e0 <chprintf.constprop.35>
 80026ae:	4a1a      	ldr	r2, [pc, #104]	; (8002718 <moduleTRACKING+0xb88>)
 80026b0:	4910      	ldr	r1, [pc, #64]	; (80026f4 <moduleTRACKING+0xb64>)
 80026b2:	480e      	ldr	r0, [pc, #56]	; (80026ec <moduleTRACKING+0xb5c>)
 80026b4:	f010 f814 	bl	80126e0 <chprintf.constprop.35>
 80026b8:	23f0      	movs	r3, #240	; 0xf0
 80026ba:	4a0f      	ldr	r2, [pc, #60]	; (80026f8 <moduleTRACKING+0xb68>)
 80026bc:	490f      	ldr	r1, [pc, #60]	; (80026fc <moduleTRACKING+0xb6c>)
 80026be:	480b      	ldr	r0, [pc, #44]	; (80026ec <moduleTRACKING+0xb5c>)
 80026c0:	f010 f80e 	bl	80126e0 <chprintf.constprop.35>
 80026c4:	490e      	ldr	r1, [pc, #56]	; (8002700 <moduleTRACKING+0xb70>)
 80026c6:	4809      	ldr	r0, [pc, #36]	; (80026ec <moduleTRACKING+0xb5c>)
 80026c8:	f010 f80a 	bl	80126e0 <chprintf.constprop.35>
 80026cc:	4915      	ldr	r1, [pc, #84]	; (8002724 <moduleTRACKING+0xb94>)
 80026ce:	4807      	ldr	r0, [pc, #28]	; (80026ec <moduleTRACKING+0xb5c>)
 80026d0:	f010 f806 	bl	80126e0 <chprintf.constprop.35>
 80026d4:	490c      	ldr	r1, [pc, #48]	; (8002708 <moduleTRACKING+0xb78>)
 80026d6:	4805      	ldr	r0, [pc, #20]	; (80026ec <moduleTRACKING+0xb5c>)
 80026d8:	f010 f802 	bl	80126e0 <chprintf.constprop.35>
 80026dc:	4801      	ldr	r0, [pc, #4]	; (80026e4 <moduleTRACKING+0xb54>)
 80026de:	f00c fba7 	bl	800ee30 <chMtxUnlock>
 80026e2:	e6d1      	b.n	8002488 <moduleTRACKING+0x8f8>
 80026e4:	20027b2c 	.word	0x20027b2c
 80026e8:	08013c50 	.word	0x08013c50
 80026ec:	20027e60 	.word	0x20027e60
 80026f0:	08013d9c 	.word	0x08013d9c
 80026f4:	08013c5c 	.word	0x08013c5c
 80026f8:	08013e24 	.word	0x08013e24
 80026fc:	08013c78 	.word	0x08013c78
 8002700:	08013d00 	.word	0x08013d00
 8002704:	08013f7c 	.word	0x08013f7c
 8002708:	08013cac 	.word	0x08013cac
 800270c:	08013b90 	.word	0x08013b90
 8002710:	08013fb8 	.word	0x08013fb8
 8002714:	08013b98 	.word	0x08013b98
 8002718:	08013cfc 	.word	0x08013cfc
 800271c:	0801400c 	.word	0x0801400c
 8002720:	08013b88 	.word	0x08013b88
 8002724:	08013f9c 	.word	0x08013f9c
	resp = gps_receive_payload(0x01, 0x06, response, 5000);
	if(!resp) { // Failed to aquire GPS data
		TRACE_ERROR("GPS  > SOL Polling FAILED");
		respall = false;
	} else {
		TRACE_INFO("GPS  > SOL Polling OK");
 8002728:	4839      	ldr	r0, [pc, #228]	; (8002810 <moduleTRACKING+0xc80>)
 800272a:	f00c fbe1 	bl	800eef0 <chMtxLock>
 800272e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002732:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8002736:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002738:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800273a:	4936      	ldr	r1, [pc, #216]	; (8002814 <moduleTRACKING+0xc84>)
 800273c:	fb05 f000 	mul.w	r0, r5, r0
 8002740:	fbaa 3000 	umull	r3, r0, sl, r0
 8002744:	0b80      	lsrs	r0, r0, #14
 8002746:	fba9 6300 	umull	r6, r3, r9, r0
 800274a:	fbaa 6202 	umull	r6, r2, sl, r2
 800274e:	099b      	lsrs	r3, r3, #6
 8002750:	fb05 0313 	mls	r3, r5, r3, r0
 8002754:	0b92      	lsrs	r2, r2, #14
 8002756:	4830      	ldr	r0, [pc, #192]	; (8002818 <moduleTRACKING+0xc88>)
 8002758:	f00f ffc2 	bl	80126e0 <chprintf.constprop.35>
 800275c:	4a2f      	ldr	r2, [pc, #188]	; (800281c <moduleTRACKING+0xc8c>)
 800275e:	4930      	ldr	r1, [pc, #192]	; (8002820 <moduleTRACKING+0xc90>)
 8002760:	482d      	ldr	r0, [pc, #180]	; (8002818 <moduleTRACKING+0xc88>)
 8002762:	f00f ffbd 	bl	80126e0 <chprintf.constprop.35>
 8002766:	f240 130d 	movw	r3, #269	; 0x10d
 800276a:	4a2e      	ldr	r2, [pc, #184]	; (8002824 <moduleTRACKING+0xc94>)
 800276c:	492e      	ldr	r1, [pc, #184]	; (8002828 <moduleTRACKING+0xc98>)
 800276e:	482a      	ldr	r0, [pc, #168]	; (8002818 <moduleTRACKING+0xc88>)
 8002770:	f00f ffb6 	bl	80126e0 <chprintf.constprop.35>
 8002774:	492d      	ldr	r1, [pc, #180]	; (800282c <moduleTRACKING+0xc9c>)
 8002776:	4828      	ldr	r0, [pc, #160]	; (8002818 <moduleTRACKING+0xc88>)
 8002778:	f00f ffb2 	bl	80126e0 <chprintf.constprop.35>
 800277c:	492c      	ldr	r1, [pc, #176]	; (8002830 <moduleTRACKING+0xca0>)
 800277e:	4826      	ldr	r0, [pc, #152]	; (8002818 <moduleTRACKING+0xc88>)
 8002780:	f00f ffae 	bl	80126e0 <chprintf.constprop.35>
 8002784:	492b      	ldr	r1, [pc, #172]	; (8002834 <moduleTRACKING+0xca4>)
 8002786:	4824      	ldr	r0, [pc, #144]	; (8002818 <moduleTRACKING+0xc88>)
 8002788:	f00f ffaa 	bl	80126e0 <chprintf.constprop.35>
 800278c:	4820      	ldr	r0, [pc, #128]	; (8002810 <moduleTRACKING+0xc80>)
 800278e:	f00c fb4f 	bl	800ee30 <chMtxUnlock>
 8002792:	e6f5      	b.n	8002580 <moduleTRACKING+0x9f0>
	uint8_t timeutc[] = {0xB5, 0x62, 0x01, 0x21, 0x00, 0x00, 0x22, 0x67};
	gps_transmit_string(timeutc, sizeof(timeutc));

	resp = gps_receive_payload(0x01, 0x21, response, 5000);
	if(!resp) { // Failed to aquire GPS data
		TRACE_ERROR("GPS  > TIMEUTC Polling FAILED");
 8002794:	481e      	ldr	r0, [pc, #120]	; (8002810 <moduleTRACKING+0xc80>)
 8002796:	f00c fbab 	bl	800eef0 <chMtxLock>
 800279a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800279e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 80027a2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80027a4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80027a6:	491b      	ldr	r1, [pc, #108]	; (8002814 <moduleTRACKING+0xc84>)
 80027a8:	fb06 f000 	mul.w	r0, r6, r0
 80027ac:	fbaa 3000 	umull	r3, r0, sl, r0
 80027b0:	0b80      	lsrs	r0, r0, #14
 80027b2:	fba9 e300 	umull	lr, r3, r9, r0
 80027b6:	fbaa e202 	umull	lr, r2, sl, r2
 80027ba:	099b      	lsrs	r3, r3, #6
 80027bc:	fb06 0313 	mls	r3, r6, r3, r0
 80027c0:	0b92      	lsrs	r2, r2, #14
 80027c2:	4815      	ldr	r0, [pc, #84]	; (8002818 <moduleTRACKING+0xc88>)
 80027c4:	f00f ff8c 	bl	80126e0 <chprintf.constprop.35>
 80027c8:	4a1b      	ldr	r2, [pc, #108]	; (8002838 <moduleTRACKING+0xca8>)
 80027ca:	4915      	ldr	r1, [pc, #84]	; (8002820 <moduleTRACKING+0xc90>)
 80027cc:	4812      	ldr	r0, [pc, #72]	; (8002818 <moduleTRACKING+0xc88>)
 80027ce:	f00f ff87 	bl	80126e0 <chprintf.constprop.35>
 80027d2:	f240 1319 	movw	r3, #281	; 0x119
 80027d6:	4a13      	ldr	r2, [pc, #76]	; (8002824 <moduleTRACKING+0xc94>)
 80027d8:	4913      	ldr	r1, [pc, #76]	; (8002828 <moduleTRACKING+0xc98>)
 80027da:	480f      	ldr	r0, [pc, #60]	; (8002818 <moduleTRACKING+0xc88>)
 80027dc:	f00f ff80 	bl	80126e0 <chprintf.constprop.35>
 80027e0:	4912      	ldr	r1, [pc, #72]	; (800282c <moduleTRACKING+0xc9c>)
 80027e2:	480d      	ldr	r0, [pc, #52]	; (8002818 <moduleTRACKING+0xc88>)
 80027e4:	f00f ff7c 	bl	80126e0 <chprintf.constprop.35>
 80027e8:	4914      	ldr	r1, [pc, #80]	; (800283c <moduleTRACKING+0xcac>)
 80027ea:	480b      	ldr	r0, [pc, #44]	; (8002818 <moduleTRACKING+0xc88>)
 80027ec:	f00f ff78 	bl	80126e0 <chprintf.constprop.35>
 80027f0:	4910      	ldr	r1, [pc, #64]	; (8002834 <moduleTRACKING+0xca4>)
 80027f2:	4809      	ldr	r0, [pc, #36]	; (8002818 <moduleTRACKING+0xc88>)
 80027f4:	f00f ff74 	bl	80126e0 <chprintf.constprop.35>
 80027f8:	4805      	ldr	r0, [pc, #20]	; (8002810 <moduleTRACKING+0xc80>)
 80027fa:	f00c fb19 	bl	800ee30 <chMtxUnlock>
 80027fe:	f240 1119 	movw	r1, #281	; 0x119
 8002802:	4808      	ldr	r0, [pc, #32]	; (8002824 <moduleTRACKING+0xc94>)
 8002804:	f00d fbac 	bl	800ff60 <log_error>
 8002808:	e702      	b.n	8002610 <moduleTRACKING+0xa80>
			);
	int32_t alt_tmp = (((int32_t) 
			((uint32_t)(response[16]) + ((uint32_t)(response[17]) << 8) + ((uint32_t)(response[18]) << 16) + ((uint32_t)(response[19]) << 24))
			) / 1000);
	if (alt_tmp <= 0) {
		fix->alt = 1;
 800280a:	2301      	movs	r3, #1
 800280c:	9329      	str	r3, [sp, #164]	; 0xa4
 800280e:	e66e      	b.n	80024ee <moduleTRACKING+0x95e>
 8002810:	20027b2c 	.word	0x20027b2c
 8002814:	08013c50 	.word	0x08013c50
 8002818:	20027e60 	.word	0x20027e60
 800281c:	08013cfc 	.word	0x08013cfc
 8002820:	08013c5c 	.word	0x08013c5c
 8002824:	08013e24 	.word	0x08013e24
 8002828:	08013c78 	.word	0x08013c78
 800282c:	08013d00 	.word	0x08013d00
 8002830:	08013fd4 	.word	0x08013fd4
 8002834:	08013cac 	.word	0x08013cac
 8002838:	08013d9c 	.word	0x08013d9c
 800283c:	08013fec 	.word	0x08013fec

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point

		// Search for GPS satellites
		gpsFix_t gpsFix = {{0,0,0,0,0,0,0},0,0,0,0,0};
 8002840:	46a3      	mov	fp, r4
 8002842:	9434      	str	r4, [sp, #208]	; 0xd0
			tp->gps_sats = gpsFix.num_svs;

		} else { // GPS lost (keep GPS switched on)

			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");
 8002844:	48b4      	ldr	r0, [pc, #720]	; (8002b18 <moduleTRACKING+0xf88>)
 8002846:	f00c fb53 	bl	800eef0 <chMtxLock>
 800284a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800284e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8002852:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002854:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002856:	49b1      	ldr	r1, [pc, #708]	; (8002b1c <moduleTRACKING+0xf8c>)
 8002858:	fb04 f000 	mul.w	r0, r4, r0
 800285c:	fbaa 3000 	umull	r3, r0, sl, r0
 8002860:	0b80      	lsrs	r0, r0, #14
 8002862:	fba9 5300 	umull	r5, r3, r9, r0
 8002866:	fbaa 5202 	umull	r5, r2, sl, r2
 800286a:	099b      	lsrs	r3, r3, #6
 800286c:	fb04 0313 	mls	r3, r4, r3, r0
 8002870:	0b92      	lsrs	r2, r2, #14
 8002872:	48ab      	ldr	r0, [pc, #684]	; (8002b20 <moduleTRACKING+0xf90>)
 8002874:	f00f ff34 	bl	80126e0 <chprintf.constprop.35>
 8002878:	4aaa      	ldr	r2, [pc, #680]	; (8002b24 <moduleTRACKING+0xf94>)
 800287a:	49ab      	ldr	r1, [pc, #684]	; (8002b28 <moduleTRACKING+0xf98>)
 800287c:	48a8      	ldr	r0, [pc, #672]	; (8002b20 <moduleTRACKING+0xf90>)
 800287e:	f00f ff2f 	bl	80126e0 <chprintf.constprop.35>
 8002882:	23e4      	movs	r3, #228	; 0xe4
 8002884:	4aa9      	ldr	r2, [pc, #676]	; (8002b2c <moduleTRACKING+0xf9c>)
 8002886:	49aa      	ldr	r1, [pc, #680]	; (8002b30 <moduleTRACKING+0xfa0>)
 8002888:	48a5      	ldr	r0, [pc, #660]	; (8002b20 <moduleTRACKING+0xf90>)
 800288a:	f00f ff29 	bl	80126e0 <chprintf.constprop.35>
 800288e:	49a9      	ldr	r1, [pc, #676]	; (8002b34 <moduleTRACKING+0xfa4>)
 8002890:	48a3      	ldr	r0, [pc, #652]	; (8002b20 <moduleTRACKING+0xf90>)
 8002892:	f00f ff25 	bl	80126e0 <chprintf.constprop.35>
 8002896:	49a8      	ldr	r1, [pc, #672]	; (8002b38 <moduleTRACKING+0xfa8>)
 8002898:	48a1      	ldr	r0, [pc, #644]	; (8002b20 <moduleTRACKING+0xf90>)
 800289a:	f00f ff21 	bl	80126e0 <chprintf.constprop.35>
 800289e:	49a7      	ldr	r1, [pc, #668]	; (8002b3c <moduleTRACKING+0xfac>)
 80028a0:	489f      	ldr	r0, [pc, #636]	; (8002b20 <moduleTRACKING+0xf90>)
 80028a2:	f00f ff1d 	bl	80126e0 <chprintf.constprop.35>
 80028a6:	489c      	ldr	r0, [pc, #624]	; (8002b18 <moduleTRACKING+0xf88>)
 80028a8:	f00c fac2 	bl	800ee30 <chMtxUnlock>

			// Take time from internal RTC
			getTime(&rtc);
 80028ac:	a83d      	add	r0, sp, #244	; 0xf4
 80028ae:	f007 fcbf 	bl	800a230 <getTime>
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
 80028b2:	9b35      	ldr	r3, [sp, #212]	; 0xd4
			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
 80028b4:	9930      	ldr	r1, [sp, #192]	; 0xc0
 80028b6:	f8bd 50f4 	ldrh.w	r5, [sp, #244]	; 0xf4
			tp->time.month = rtc.month;
 80028ba:	f89d 40f6 	ldrb.w	r4, [sp, #246]	; 0xf6
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
 80028be:	00da      	lsls	r2, r3, #3
 80028c0:	1ad2      	subs	r2, r2, r3
 80028c2:	4b9f      	ldr	r3, [pc, #636]	; (8002b40 <moduleTRACKING+0xfb0>)
 80028c4:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
 80028c8:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
 80028ca:	6910      	ldr	r0, [r2, #16]
			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
 80028cc:	1a5b      	subs	r3, r3, r1
 80028ce:	499c      	ldr	r1, [pc, #624]	; (8002b40 <moduleTRACKING+0xfb0>)
 80028d0:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
 80028d4:	f89d 10f7 	ldrb.w	r1, [sp, #247]	; 0xf7
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
 80028d8:	6118      	str	r0, [r3, #16]
			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
			tp->time.hour = rtc.hour;
 80028da:	f89d 00f8 	ldrb.w	r0, [sp, #248]	; 0xf8
			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
 80028de:	809d      	strh	r5, [r3, #4]
			tp->time.month = rtc.month;
 80028e0:	719c      	strb	r4, [r3, #6]
			tp->time.day = rtc.day;
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
 80028e2:	f89d 50f9 	ldrb.w	r5, [sp, #249]	; 0xf9
			tp->time.second = rtc.second;
 80028e6:	f89d 40fa 	ldrb.w	r4, [sp, #250]	; 0xfa

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
 80028ea:	71d9      	strb	r1, [r3, #7]
			tp->time.hour = rtc.hour;
 80028ec:	7218      	strb	r0, [r3, #8]
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
			tp->gps_lon = ltp->gps_lon;
 80028ee:	6951      	ldr	r1, [r2, #20]
			tp->gps_alt = ltp->gps_alt;
 80028f0:	6992      	ldr	r2, [r2, #24]
			getTime(&rtc);
			tp->time.year = rtc.year;
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
 80028f2:	725d      	strb	r5, [r3, #9]
			tp->gps_lat = ltp->gps_lat;
			tp->gps_lon = ltp->gps_lon;
			tp->gps_alt = ltp->gps_alt;

			// Mark gpsloss
			tp->gps_lock = false;
 80028f4:	2000      	movs	r0, #0
			tp->time.year = rtc.year;
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;
 80028f6:	729c      	strb	r4, [r3, #10]

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
			tp->gps_lon = ltp->gps_lon;
 80028f8:	6159      	str	r1, [r3, #20]
			tp->gps_alt = ltp->gps_alt;
 80028fa:	619a      	str	r2, [r3, #24]

			// Mark gpsloss
			tp->gps_lock = false;
 80028fc:	7398      	strb	r0, [r3, #14]
			tp->gps_sats = 0;
 80028fe:	7718      	strb	r0, [r3, #28]

		}

		tp->id = id; // Serial ID
 8002900:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8002902:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8002904:	9931      	ldr	r1, [sp, #196]	; 0xc4
		return 0; // PAC1720 not available (maybe Vcc too low)
}

int16_t pac1720_getAverageChargePower(void) {
	// Return current value if time interval too short
	if(!pac1720_charge_counter)
 8002906:	4c8f      	ldr	r4, [pc, #572]	; (8002b44 <moduleTRACKING+0xfb4>)
 8002908:	1a9d      	subs	r5, r3, r2
 800290a:	4a8d      	ldr	r2, [pc, #564]	; (8002b40 <moduleTRACKING+0xfb0>)
 800290c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002910:	f842 1035 	str.w	r1, [r2, r5, lsl #3]
 8002914:	6a5b      	ldr	r3, [r3, #36]	; 0x24
		tp->gps_ttff = ST2S(chVTGetSystemTimeX() - time); // Time to first fix
 8002916:	9a25      	ldr	r2, [sp, #148]	; 0x94
 8002918:	f503 439c 	add.w	r3, r3, #19968	; 0x4e00
 800291c:	331f      	adds	r3, #31
 800291e:	1a9b      	subs	r3, r3, r2
			tp->gps_lock = false;
			tp->gps_sats = 0;

		}

		tp->id = id; // Serial ID
 8002920:	4a87      	ldr	r2, [pc, #540]	; (8002b40 <moduleTRACKING+0xfb0>)
 8002922:	eb02 05c5 	add.w	r5, r2, r5, lsl #3
		tp->gps_ttff = ST2S(chVTGetSystemTimeX() - time); // Time to first fix
 8002926:	fbaa 2303 	umull	r2, r3, sl, r3
 800292a:	0b9b      	lsrs	r3, r3, #14
 800292c:	776b      	strb	r3, [r5, #29]

		// Power management
		tp->adc_solar = getSolarVoltageMV();
 800292e:	f008 f88f 	bl	800aa50 <getSolarVoltageMV>
 8002932:	83e8      	strh	r0, [r5, #30]
		tp->adc_battery = getBatteryVoltageMV();
 8002934:	f008 f89c 	bl	800aa70 <getBatteryVoltageMV>
 8002938:	6821      	ldr	r1, [r4, #0]
 800293a:	8428      	strh	r0, [r5, #32]
 800293c:	b911      	cbnz	r1, 8002944 <moduleTRACKING+0xdb4>
		pac1720_getPowerCharge();
 800293e:	f00d f85f 	bl	800fa00 <pac1720_getPowerCharge>
 8002942:	6821      	ldr	r1, [r4, #0]

	// Calculate average power
	int16_t ret = pac1720_charge / pac1720_charge_counter;
 8002944:	4b80      	ldr	r3, [pc, #512]	; (8002b48 <moduleTRACKING+0xfb8>)
		tp->adc_charge = pac1720_getAverageChargePower();
 8002946:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8002948:	681b      	ldr	r3, [r3, #0]
 800294a:	fb93 f1f1 	sdiv	r1, r3, r1
 800294e:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
	return ret;
}

int16_t pac1720_getAverageDischargePower(void) {
	// Return current value if time interval too short
	if(!pac1720_discharge_counter)
 8002950:	4c7e      	ldr	r4, [pc, #504]	; (8002b4c <moduleTRACKING+0xfbc>)
 8002952:	1a9a      	subs	r2, r3, r2
 8002954:	4b7a      	ldr	r3, [pc, #488]	; (8002b40 <moduleTRACKING+0xfb0>)
 8002956:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 800295a:	4b7c      	ldr	r3, [pc, #496]	; (8002b4c <moduleTRACKING+0xfbc>)
 800295c:	8451      	strh	r1, [r2, #34]	; 0x22

	// Calculate average power
	int16_t ret = pac1720_charge / pac1720_charge_counter;

	// Reset current measurement
	pac1720_charge = 0;
 800295e:	4a7a      	ldr	r2, [pc, #488]	; (8002b48 <moduleTRACKING+0xfb8>)
	return ret;
}

int16_t pac1720_getAverageDischargePower(void) {
	// Return current value if time interval too short
	if(!pac1720_discharge_counter)
 8002960:	6818      	ldr	r0, [r3, #0]

	// Calculate average power
	int16_t ret = pac1720_charge / pac1720_charge_counter;

	// Reset current measurement
	pac1720_charge = 0;
 8002962:	2300      	movs	r3, #0
 8002964:	6013      	str	r3, [r2, #0]
	pac1720_charge_counter = 0;
 8002966:	4a77      	ldr	r2, [pc, #476]	; (8002b44 <moduleTRACKING+0xfb4>)
 8002968:	6013      	str	r3, [r2, #0]
	return ret;
}

int16_t pac1720_getAverageDischargePower(void) {
	// Return current value if time interval too short
	if(!pac1720_discharge_counter)
 800296a:	b910      	cbnz	r0, 8002972 <moduleTRACKING+0xde2>
		pac1720_getPowerDischarge();
 800296c:	f00d f860 	bl	800fa30 <pac1720_getPowerDischarge>
 8002970:	6820      	ldr	r0, [r4, #0]
		tp->adc_discharge = pac1720_getAverageDischargePower();
 8002972:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
 8002974:	9930      	ldr	r1, [sp, #192]	; 0xc0

	// Calculate average power
	int16_t ret = pac1720_discharge / pac1720_discharge_counter;
 8002976:	4b76      	ldr	r3, [pc, #472]	; (8002b50 <moduleTRACKING+0xfc0>)
 8002978:	1a54      	subs	r4, r2, r1
 800297a:	4a71      	ldr	r2, [pc, #452]	; (8002b40 <moduleTRACKING+0xfb0>)
 800297c:	681b      	ldr	r3, [r3, #0]
 800297e:	fb93 f3f0 	sdiv	r3, r3, r0
 8002982:	eb02 04c4 	add.w	r4, r2, r4, lsl #3

	// Reset current measurement
	pac1720_discharge = 0;
 8002986:	2200      	movs	r2, #0
 8002988:	84a3      	strh	r3, [r4, #36]	; 0x24
 800298a:	4b71      	ldr	r3, [pc, #452]	; (8002b50 <moduleTRACKING+0xfc0>)
 800298c:	601a      	str	r2, [r3, #0]
	pac1720_discharge_counter = 0;
 800298e:	4b6f      	ldr	r3, [pc, #444]	; (8002b4c <moduleTRACKING+0xfbc>)

		bme280_t bmeInt;
		bme280_t bmeExt;

		// Atmosphere condition
		if(BME280_isAvailable(BME280_ADDRESS_INT)) {
 8002990:	2077      	movs	r0, #119	; 0x77
 8002992:	601a      	str	r2, [r3, #0]
 8002994:	f00d f9c4 	bl	800fd20 <BME280_isAvailable>
 8002998:	4605      	mov	r5, r0
 800299a:	2800      	cmp	r0, #0
 800299c:	f000 81d4 	beq.w	8002d48 <moduleTRACKING+0x11b8>
			BME280_Init(&bmeInt, BME280_ADDRESS_INT);
 80029a0:	2177      	movs	r1, #119	; 0x77
 80029a2:	a860      	add	r0, sp, #384	; 0x180
 80029a4:	f00d f914 	bl	800fbd0 <BME280_Init>
			tp->int_press = BME280_getPressure(&bmeInt, 256);
 80029a8:	a860      	add	r0, sp, #384	; 0x180
 80029aa:	f00a fbb9 	bl	800d120 <BME280_getPressure.constprop.24>
 80029ae:	62a0      	str	r0, [r4, #40]	; 0x28
			tp->int_hum = BME280_getHumidity(&bmeInt);
 80029b0:	a860      	add	r0, sp, #384	; 0x180
 80029b2:	f00d f87d 	bl	800fab0 <BME280_getHumidity>
 80029b6:	85a0      	strh	r0, [r4, #44]	; 0x2c
			tp->int_temp = BME280_getTemperature(&bmeInt);
 80029b8:	a860      	add	r0, sp, #384	; 0x180
 80029ba:	f00d f8d1 	bl	800fb60 <BME280_getTemperature>
 80029be:	85e0      	strh	r0, [r4, #46]	; 0x2e
			tp->int_hum = 0;
			tp->int_temp = 0;
		}

		// External BME280
		if(BME280_isAvailable(BME280_ADDRESS_EXT)) {
 80029c0:	2076      	movs	r0, #118	; 0x76
 80029c2:	f00d f9ad 	bl	800fd20 <BME280_isAvailable>
 80029c6:	4604      	mov	r4, r0
 80029c8:	2800      	cmp	r0, #0
 80029ca:	f000 817e 	beq.w	8002cca <moduleTRACKING+0x113a>
			BME280_Init(&bmeExt, BME280_ADDRESS_EXT);
 80029ce:	2176      	movs	r1, #118	; 0x76
 80029d0:	a86b      	add	r0, sp, #428	; 0x1ac
 80029d2:	f00d f8fd 	bl	800fbd0 <BME280_Init>
			tp->ext_press = BME280_getPressure(&bmeExt, 256);
 80029d6:	a86b      	add	r0, sp, #428	; 0x1ac
 80029d8:	f00a fba2 	bl	800d120 <BME280_getPressure.constprop.24>
 80029dc:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 80029de:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 80029e0:	1a9c      	subs	r4, r3, r2
 80029e2:	4b57      	ldr	r3, [pc, #348]	; (8002b40 <moduleTRACKING+0xfb0>)
 80029e4:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 80029e8:	6320      	str	r0, [r4, #48]	; 0x30
			tp->ext_hum = BME280_getHumidity(&bmeExt);
 80029ea:	a86b      	add	r0, sp, #428	; 0x1ac
 80029ec:	f00d f860 	bl	800fab0 <BME280_getHumidity>
 80029f0:	86a0      	strh	r0, [r4, #52]	; 0x34
			tp->ext_temp = BME280_getTemperature(&bmeExt);
 80029f2:	a86b      	add	r0, sp, #428	; 0x1ac
 80029f4:	f00d f8b4 	bl	800fb60 <BME280_getTemperature>
 80029f8:	86e0      	strh	r0, [r4, #54]	; 0x36
			tp->ext_hum = 0;
			tp->ext_temp = 0;
		}

		// Trace data
		TRACE_INFO(	"TRAC > New tracking point available (ID=%d)\r\n"
 80029fa:	4847      	ldr	r0, [pc, #284]	; (8002b18 <moduleTRACKING+0xf88>)
 80029fc:	4f55      	ldr	r7, [pc, #340]	; (8002b54 <moduleTRACKING+0xfc4>)
 80029fe:	f00c fa77 	bl	800eef0 <chMtxLock>
 8002a02:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002a06:	4945      	ldr	r1, [pc, #276]	; (8002b1c <moduleTRACKING+0xf8c>)
 8002a08:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002a0a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8002a0c:	4844      	ldr	r0, [pc, #272]	; (8002b20 <moduleTRACKING+0xf90>)
 8002a0e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8002a12:	fb03 f404 	mul.w	r4, r3, r4
 8002a16:	fbaa 3404 	umull	r3, r4, sl, r4
 8002a1a:	0ba4      	lsrs	r4, r4, #14
 8002a1c:	fba9 5304 	umull	r5, r3, r9, r4
 8002a20:	fbaa 5202 	umull	r5, r2, sl, r2
 8002a24:	099b      	lsrs	r3, r3, #6
 8002a26:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8002a2a:	fb05 4313 	mls	r3, r5, r3, r4
 8002a2e:	0b92      	lsrs	r2, r2, #14
 8002a30:	f00f fe56 	bl	80126e0 <chprintf.constprop.35>
 8002a34:	4a48      	ldr	r2, [pc, #288]	; (8002b58 <moduleTRACKING+0xfc8>)
 8002a36:	493c      	ldr	r1, [pc, #240]	; (8002b28 <moduleTRACKING+0xf98>)
 8002a38:	4839      	ldr	r0, [pc, #228]	; (8002b20 <moduleTRACKING+0xf90>)
 8002a3a:	f00f fe51 	bl	80126e0 <chprintf.constprop.35>
 8002a3e:	f240 132f 	movw	r3, #303	; 0x12f
 8002a42:	4a3a      	ldr	r2, [pc, #232]	; (8002b2c <moduleTRACKING+0xf9c>)
 8002a44:	493a      	ldr	r1, [pc, #232]	; (8002b30 <moduleTRACKING+0xfa0>)
 8002a46:	4836      	ldr	r0, [pc, #216]	; (8002b20 <moduleTRACKING+0xf90>)
 8002a48:	f00f fe4a 	bl	80126e0 <chprintf.constprop.35>
 8002a4c:	4939      	ldr	r1, [pc, #228]	; (8002b34 <moduleTRACKING+0xfa4>)
 8002a4e:	4834      	ldr	r0, [pc, #208]	; (8002b20 <moduleTRACKING+0xf90>)
 8002a50:	f00f fe46 	bl	80126e0 <chprintf.constprop.35>
 8002a54:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8002a56:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8002a58:	1a9a      	subs	r2, r3, r2
 8002a5a:	4b39      	ldr	r3, [pc, #228]	; (8002b40 <moduleTRACKING+0xfb0>)
 8002a5c:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
 8002a60:	4b3e      	ldr	r3, [pc, #248]	; (8002b5c <moduleTRACKING+0xfcc>)
 8002a62:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 8002a64:	f9b4 002e 	ldrsh.w	r0, [r4, #46]	; 0x2e
 8002a68:	f9b4 c036 	ldrsh.w	ip, [r4, #54]	; 0x36
 8002a6c:	9026      	str	r0, [sp, #152]	; 0x98
 8002a6e:	460d      	mov	r5, r1
 8002a70:	8ea1      	ldrh	r1, [r4, #52]	; 0x34
 8002a72:	9529      	str	r5, [sp, #164]	; 0xa4
 8002a74:	460e      	mov	r6, r1
 8002a76:	4932      	ldr	r1, [pc, #200]	; (8002b40 <moduleTRACKING+0xfb0>)
 8002a78:	962a      	str	r6, [sp, #168]	; 0xa8
 8002a7a:	f851 2032 	ldr.w	r2, [r1, r2, lsl #3]
 8002a7e:	9932      	ldr	r1, [sp, #200]	; 0xc8
 8002a80:	911d      	str	r1, [sp, #116]	; 0x74
 8002a82:	6921      	ldr	r1, [r4, #16]
 8002a84:	f8b4 e01e 	ldrh.w	lr, [r4, #30]
 8002a88:	fba3 0505 	umull	r0, r5, r3, r5
 8002a8c:	6960      	ldr	r0, [r4, #20]
 8002a8e:	2900      	cmp	r1, #0
 8002a90:	bfd4      	ite	le
 8002a92:	f04f 31ff 	movle.w	r1, #4294967295
 8002a96:	2101      	movgt	r1, #1
 8002a98:	2800      	cmp	r0, #0
 8002a9a:	4630      	mov	r0, r6
 8002a9c:	fba3 0600 	umull	r0, r6, r3, r0
 8002aa0:	ea4f 06d6 	mov.w	r6, r6, lsr #3
 8002aa4:	962b      	str	r6, [sp, #172]	; 0xac
 8002aa6:	9e32      	ldr	r6, [sp, #200]	; 0xc8
 8002aa8:	8c20      	ldrh	r0, [r4, #32]
 8002aaa:	9616      	str	r6, [sp, #88]	; 0x58
 8002aac:	9028      	str	r0, [sp, #160]	; 0xa0
 8002aae:	6920      	ldr	r0, [r4, #16]
 8002ab0:	9e29      	ldr	r6, [sp, #164]	; 0xa4
 8002ab2:	fb00 f101 	mul.w	r1, r0, r1
 8002ab6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8002ab8:	9127      	str	r1, [sp, #156]	; 0x9c
 8002aba:	ea4f 05d5 	mov.w	r5, r5, lsr #3
 8002abe:	fba3 0100 	umull	r0, r1, r3, r0
 8002ac2:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8002ac4:	951b      	str	r5, [sp, #108]	; 0x6c
 8002ac6:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8002aca:	eba6 0545 	sub.w	r5, r6, r5, lsl #1
 8002ace:	9e26      	ldr	r6, [sp, #152]	; 0x98
 8002ad0:	fba3 0300 	umull	r0, r3, r3, r0
 8002ad4:	b2ad      	uxth	r5, r5
 8002ad6:	4630      	mov	r0, r6
 8002ad8:	951c      	str	r5, [sp, #112]	; 0x70
 8002ada:	fb87 0500 	smull	r0, r5, r7, r0
 8002ade:	fb87 070c 	smull	r0, r7, r7, ip
 8002ae2:	ea4f 70e6 	mov.w	r0, r6, asr #31
 8002ae6:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 8002aea:	9029      	str	r0, [sp, #164]	; 0xa4
 8002aec:	ea4f 75ec 	mov.w	r5, ip, asr #31
 8002af0:	6960      	ldr	r0, [r4, #20]
 8002af2:	ebc5 1767 	rsb	r7, r5, r7, asr #5
 8002af6:	bfd4      	ite	le
 8002af8:	f04f 35ff 	movle.w	r5, #4294967295
 8002afc:	2501      	movgt	r5, #1
 8002afe:	fb00 f005 	mul.w	r0, r0, r5
 8002b02:	9d2b      	ldr	r5, [sp, #172]	; 0xac
 8002b04:	902c      	str	r0, [sp, #176]	; 0xb0
 8002b06:	eb05 0685 	add.w	r6, r5, r5, lsl #2
 8002b0a:	9522      	str	r5, [sp, #136]	; 0x88
 8002b0c:	9d2a      	ldr	r5, [sp, #168]	; 0xa8
 8002b0e:	eba5 0646 	sub.w	r6, r5, r6, lsl #1
 8002b12:	b2b6      	uxth	r6, r6
 8002b14:	e024      	b.n	8002b60 <moduleTRACKING+0xfd0>
 8002b16:	bf00      	nop
 8002b18:	20027b2c 	.word	0x20027b2c
 8002b1c:	08013c50 	.word	0x08013c50
 8002b20:	20027e60 	.word	0x20027e60
 8002b24:	08013cb0 	.word	0x08013cb0
 8002b28:	08013c5c 	.word	0x08013c5c
 8002b2c:	08013c6c 	.word	0x08013c6c
 8002b30:	08013c78 	.word	0x08013c78
 8002b34:	08013d00 	.word	0x08013d00
 8002b38:	08014168 	.word	0x08014168
 8002b3c:	08013cac 	.word	0x08013cac
 8002b40:	20000c64 	.word	0x20000c64
 8002b44:	20027b50 	.word	0x20027b50
 8002b48:	20027b44 	.word	0x20027b44
 8002b4c:	20027b4c 	.word	0x20027b4c
 8002b50:	20027b48 	.word	0x20027b48
 8002b54:	51eb851f 	.word	0x51eb851f
 8002b58:	08013cfc 	.word	0x08013cfc
 8002b5c:	cccccccd 	.word	0xcccccccd
 8002b60:	9623      	str	r6, [sp, #140]	; 0x8c
 8002b62:	9e29      	ldr	r6, [sp, #164]	; 0xa4
 8002b64:	4630      	mov	r0, r6
 8002b66:	9e26      	ldr	r6, [sp, #152]	; 0x98
 8002b68:	2564      	movs	r5, #100	; 0x64
 8002b6a:	fb05 cc17 	mls	ip, r5, r7, ip
 8002b6e:	fb05 6010 	mls	r0, r5, r0, r6
 8002b72:	08c9      	lsrs	r1, r1, #3
 8002b74:	f9bd 50a4 	ldrsh.w	r5, [sp, #164]	; 0xa4
 8002b78:	9117      	str	r1, [sp, #92]	; 0x5c
 8002b7a:	9519      	str	r5, [sp, #100]	; 0x64
 8002b7c:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8002b7e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8002b82:	fa0f f68c 	sxth.w	r6, ip
 8002b86:	eba5 0141 	sub.w	r1, r5, r1, lsl #1
 8002b8a:	fba9 c50e 	umull	ip, r5, r9, lr
 8002b8e:	09ad      	lsrs	r5, r5, #6
 8002b90:	9512      	str	r5, [sp, #72]	; 0x48
 8002b92:	9118      	str	r1, [sp, #96]	; 0x60
 8002b94:	46ac      	mov	ip, r5
 8002b96:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8002b9a:	fb05 ee1c 	mls	lr, r5, ip, lr
 8002b9e:	08db      	lsrs	r3, r3, #3
 8002ba0:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8002ba2:	f8cd e0a4 	str.w	lr, [sp, #164]	; 0xa4
 8002ba6:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8002baa:	eba5 0141 	sub.w	r1, r5, r1, lsl #1
 8002bae:	9d27      	ldr	r5, [sp, #156]	; 0x9c
 8002bb0:	b200      	sxth	r0, r0
 8002bb2:	901a      	str	r0, [sp, #104]	; 0x68
 8002bb4:	46ae      	mov	lr, r5
 8002bb6:	9827      	ldr	r0, [sp, #156]	; 0x9c
 8002bb8:	4dad      	ldr	r5, [pc, #692]	; (8002e70 <moduleTRACKING+0x12e0>)
 8002bba:	17c0      	asrs	r0, r0, #31
 8002bbc:	fb85 e50e 	smull	lr, r5, r5, lr
 8002bc0:	ebc0 5ea5 	rsb	lr, r0, r5, asr #22
 8002bc4:	f9b4 0024 	ldrsh.w	r0, [r4, #36]	; 0x24
 8002bc8:	931e      	str	r3, [sp, #120]	; 0x78
 8002bca:	88a3      	ldrh	r3, [r4, #4]
 8002bcc:	9300      	str	r3, [sp, #0]
 8002bce:	911f      	str	r1, [sp, #124]	; 0x7c
 8002bd0:	79a1      	ldrb	r1, [r4, #6]
 8002bd2:	9621      	str	r6, [sp, #132]	; 0x84
 8002bd4:	b23f      	sxth	r7, r7
 8002bd6:	7a23      	ldrb	r3, [r4, #8]
 8002bd8:	4da6      	ldr	r5, [pc, #664]	; (8002e74 <moduleTRACKING+0x12e4>)
 8002bda:	9720      	str	r7, [sp, #128]	; 0x80
 8002bdc:	9f27      	ldr	r7, [sp, #156]	; 0x9c
 8002bde:	7a66      	ldrb	r6, [r4, #9]
 8002be0:	9015      	str	r0, [sp, #84]	; 0x54
 8002be2:	fb05 7e1e 	mls	lr, r5, lr, r7
 8002be6:	9d28      	ldr	r5, [sp, #160]	; 0xa0
 8002be8:	79e0      	ldrb	r0, [r4, #7]
 8002bea:	46ac      	mov	ip, r5
 8002bec:	fba9 c70c 	umull	ip, r7, r9, ip
 8002bf0:	09bf      	lsrs	r7, r7, #6
 8002bf2:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
 8002bf6:	9710      	str	r7, [sp, #64]	; 0x40
 8002bf8:	fb0c 5517 	mls	r5, ip, r7, r5
 8002bfc:	f9b4 7022 	ldrsh.w	r7, [r4, #34]	; 0x22
 8002c00:	9527      	str	r5, [sp, #156]	; 0x9c
 8002c02:	9714      	str	r7, [sp, #80]	; 0x50
 8002c04:	9303      	str	r3, [sp, #12]
 8002c06:	9f2c      	ldr	r7, [sp, #176]	; 0xb0
 8002c08:	4b99      	ldr	r3, [pc, #612]	; (8002e70 <moduleTRACKING+0x12e0>)
 8002c0a:	9005      	str	r0, [sp, #20]
 8002c0c:	9604      	str	r6, [sp, #16]
 8002c0e:	9002      	str	r0, [sp, #8]
 8002c10:	fb83 c307 	smull	ip, r3, r3, r7
 8002c14:	17f8      	asrs	r0, r7, #31
 8002c16:	ebc0 53a3 	rsb	r3, r0, r3, asr #22
 8002c1a:	6920      	ldr	r0, [r4, #16]
 8002c1c:	9d32      	ldr	r5, [sp, #200]	; 0xc8
 8002c1e:	4684      	mov	ip, r0
 8002c20:	4893      	ldr	r0, [pc, #588]	; (8002e70 <moduleTRACKING+0x12e0>)
 8002c22:	fb80 0c0c 	smull	r0, ip, r0, ip
 8002c26:	6920      	ldr	r0, [r4, #16]
 8002c28:	9101      	str	r1, [sp, #4]
 8002c2a:	6961      	ldr	r1, [r4, #20]
 8002c2c:	460e      	mov	r6, r1
 8002c2e:	4990      	ldr	r1, [pc, #576]	; (8002e70 <moduleTRACKING+0x12e0>)
 8002c30:	fb81 1606 	smull	r1, r6, r1, r6
 8002c34:	6961      	ldr	r1, [r4, #20]
 8002c36:	9506      	str	r5, [sp, #24]
 8002c38:	17c9      	asrs	r1, r1, #31
 8002c3a:	9126      	str	r1, [sp, #152]	; 0x98
 8002c3c:	498d      	ldr	r1, [pc, #564]	; (8002e74 <moduleTRACKING+0x12e4>)
 8002c3e:	fb01 7313 	mls	r3, r1, r3, r7
 8002c42:	930a      	str	r3, [sp, #40]	; 0x28
 8002c44:	17c0      	asrs	r0, r0, #31
 8002c46:	f8bd 30a4 	ldrh.w	r3, [sp, #164]	; 0xa4
 8002c4a:	9313      	str	r3, [sp, #76]	; 0x4c
 8002c4c:	ebc0 53ac 	rsb	r3, r0, ip, asr #22
 8002c50:	9307      	str	r3, [sp, #28]
 8002c52:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8002c54:	f8bd 709c 	ldrh.w	r7, [sp, #156]	; 0x9c
 8002c58:	4987      	ldr	r1, [pc, #540]	; (8002e78 <moduleTRACKING+0x12e8>)
 8002c5a:	4888      	ldr	r0, [pc, #544]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002c5c:	ebc3 56a6 	rsb	r6, r3, r6, asr #22
 8002c60:	7f63      	ldrb	r3, [r4, #29]
 8002c62:	930e      	str	r3, [sp, #56]	; 0x38
 8002c64:	f894 c01c 	ldrb.w	ip, [r4, #28]
 8002c68:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 8002c6c:	f8cd e020 	str.w	lr, [sp, #32]
 8002c70:	950f      	str	r5, [sp, #60]	; 0x3c
 8002c72:	950c      	str	r5, [sp, #48]	; 0x30
 8002c74:	9711      	str	r7, [sp, #68]	; 0x44
 8002c76:	9609      	str	r6, [sp, #36]	; 0x24
 8002c78:	4b81      	ldr	r3, [pc, #516]	; (8002e80 <moduleTRACKING+0x12f0>)
 8002c7a:	69a5      	ldr	r5, [r4, #24]
 8002c7c:	950b      	str	r5, [sp, #44]	; 0x2c
 8002c7e:	f00f fd2f 	bl	80126e0 <chprintf.constprop.35>
 8002c82:	4980      	ldr	r1, [pc, #512]	; (8002e84 <moduleTRACKING+0x12f4>)
 8002c84:	487d      	ldr	r0, [pc, #500]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002c86:	f00f fd2b 	bl	80126e0 <chprintf.constprop.35>
 8002c8a:	487f      	ldr	r0, [pc, #508]	; (8002e88 <moduleTRACKING+0x12f8>)
 8002c8c:	f00c f8d0 	bl	800ee30 <chMtxUnlock>
 8002c90:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002c94:	6a59      	ldr	r1, [r3, #36]	; 0x24
					TRACE_TAB, tp->int_press/10, tp->int_press%10, tp->int_temp/100, tp->int_temp%100, tp->int_hum/10, tp->int_hum%10,
					TRACE_TAB, tp->ext_press/10, tp->ext_press%10, tp->ext_temp/100, tp->ext_temp%100, tp->ext_hum/10, tp->ext_hum%10
		);

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
 8002c96:	4b7d      	ldr	r3, [pc, #500]	; (8002e8c <moduleTRACKING+0x12fc>)
 8002c98:	681a      	ldr	r2, [r3, #0]
 8002c9a:	4291      	cmp	r1, r2
			tp->ext_hum = 0;
			tp->ext_temp = 0;
		}

		// Trace data
		TRACE_INFO(	"TRAC > New tracking point available (ID=%d)\r\n"
 8002c9c:	f104 0304 	add.w	r3, r4, #4
					TRACE_TAB, tp->int_press/10, tp->int_press%10, tp->int_temp/100, tp->int_temp%100, tp->int_hum/10, tp->int_hum%10,
					TRACE_TAB, tp->ext_press/10, tp->ext_press%10, tp->ext_temp/100, tp->ext_temp%100, tp->ext_hum/10, tp->ext_hum%10
		);

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
 8002ca0:	d303      	bcc.n	8002caa <moduleTRACKING+0x111a>
 8002ca2:	f1bb 0f03 	cmp.w	fp, #3
 8002ca6:	f000 843b 	beq.w	8003520 <moduleTRACKING+0x1990>
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
		}

		// Switch last recent track point
		lastTrackPoint = tp;
 8002caa:	4b79      	ldr	r3, [pc, #484]	; (8002e90 <moduleTRACKING+0x1300>)
		id++;

		time = chThdSleepUntilWindowed(time, time + S2ST(TRACK_CYCLE_TIME)); // Wait until time + cycletime
 8002cac:	9825      	ldr	r0, [sp, #148]	; 0x94
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
		}

		// Switch last recent track point
		lastTrackPoint = tp;
 8002cae:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 8002cb0:	601a      	str	r2, [r3, #0]
		id++;
 8002cb2:	9b31      	ldr	r3, [sp, #196]	; 0xc4

		time = chThdSleepUntilWindowed(time, time + S2ST(TRACK_CYCLE_TIME)); // Wait until time + cycletime
 8002cb4:	f500 1112 	add.w	r1, r0, #2392064	; 0x248000
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
		}

		// Switch last recent track point
		lastTrackPoint = tp;
		id++;
 8002cb8:	3301      	adds	r3, #1

		time = chThdSleepUntilWindowed(time, time + S2ST(TRACK_CYCLE_TIME)); // Wait until time + cycletime
 8002cba:	f501 51f8 	add.w	r1, r1, #7936	; 0x1f00
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
		}

		// Switch last recent track point
		lastTrackPoint = tp;
		id++;
 8002cbe:	9331      	str	r3, [sp, #196]	; 0xc4

		time = chThdSleepUntilWindowed(time, time + S2ST(TRACK_CYCLE_TIME)); // Wait until time + cycletime
 8002cc0:	f00c f9ae 	bl	800f020 <chThdSleepUntilWindowed>
 8002cc4:	9025      	str	r0, [sp, #148]	; 0x94
 8002cc6:	f7ff b8f5 	b.w	8001eb4 <moduleTRACKING+0x324>
			BME280_Init(&bmeExt, BME280_ADDRESS_EXT);
			tp->ext_press = BME280_getPressure(&bmeExt, 256);
			tp->ext_hum = BME280_getHumidity(&bmeExt);
			tp->ext_temp = BME280_getTemperature(&bmeExt);
		} else { // No external BME280 found
			TRACE_WARN("TRAC > External BME280 not available");
 8002cca:	486f      	ldr	r0, [pc, #444]	; (8002e88 <moduleTRACKING+0x12f8>)
 8002ccc:	f00c f910 	bl	800eef0 <chMtxLock>
 8002cd0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002cd4:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8002cd8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002cda:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002cdc:	496d      	ldr	r1, [pc, #436]	; (8002e94 <moduleTRACKING+0x1304>)
 8002cde:	fb05 f000 	mul.w	r0, r5, r0
 8002ce2:	fbaa 3000 	umull	r3, r0, sl, r0
 8002ce6:	0b80      	lsrs	r0, r0, #14
 8002ce8:	fba9 6300 	umull	r6, r3, r9, r0
 8002cec:	fbaa 6202 	umull	r6, r2, sl, r2
 8002cf0:	099b      	lsrs	r3, r3, #6
 8002cf2:	fb05 0313 	mls	r3, r5, r3, r0
 8002cf6:	0b92      	lsrs	r2, r2, #14
 8002cf8:	4860      	ldr	r0, [pc, #384]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002cfa:	f00f fcf1 	bl	80126e0 <chprintf.constprop.35>
 8002cfe:	4a66      	ldr	r2, [pc, #408]	; (8002e98 <moduleTRACKING+0x1308>)
 8002d00:	4966      	ldr	r1, [pc, #408]	; (8002e9c <moduleTRACKING+0x130c>)
 8002d02:	485e      	ldr	r0, [pc, #376]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d04:	f00f fcec 	bl	80126e0 <chprintf.constprop.35>
 8002d08:	f44f 738d 	mov.w	r3, #282	; 0x11a
 8002d0c:	4a64      	ldr	r2, [pc, #400]	; (8002ea0 <moduleTRACKING+0x1310>)
 8002d0e:	4965      	ldr	r1, [pc, #404]	; (8002ea4 <moduleTRACKING+0x1314>)
 8002d10:	485a      	ldr	r0, [pc, #360]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d12:	f00f fce5 	bl	80126e0 <chprintf.constprop.35>
 8002d16:	4964      	ldr	r1, [pc, #400]	; (8002ea8 <moduleTRACKING+0x1318>)
 8002d18:	4858      	ldr	r0, [pc, #352]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d1a:	f00f fce1 	bl	80126e0 <chprintf.constprop.35>
 8002d1e:	4963      	ldr	r1, [pc, #396]	; (8002eac <moduleTRACKING+0x131c>)
 8002d20:	4856      	ldr	r0, [pc, #344]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d22:	f00f fcdd 	bl	80126e0 <chprintf.constprop.35>
 8002d26:	4957      	ldr	r1, [pc, #348]	; (8002e84 <moduleTRACKING+0x12f4>)
 8002d28:	4854      	ldr	r0, [pc, #336]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d2a:	f00f fcd9 	bl	80126e0 <chprintf.constprop.35>
 8002d2e:	4856      	ldr	r0, [pc, #344]	; (8002e88 <moduleTRACKING+0x12f8>)
 8002d30:	f00c f87e 	bl	800ee30 <chMtxUnlock>
			tp->ext_press = 0;
 8002d34:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8002d36:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8002d38:	1a9b      	subs	r3, r3, r2
 8002d3a:	4a5d      	ldr	r2, [pc, #372]	; (8002eb0 <moduleTRACKING+0x1320>)
 8002d3c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8002d40:	631c      	str	r4, [r3, #48]	; 0x30
			tp->ext_hum = 0;
 8002d42:	869c      	strh	r4, [r3, #52]	; 0x34
			tp->ext_temp = 0;
 8002d44:	86dc      	strh	r4, [r3, #54]	; 0x36
 8002d46:	e658      	b.n	80029fa <moduleTRACKING+0xe6a>
			BME280_Init(&bmeInt, BME280_ADDRESS_INT);
			tp->int_press = BME280_getPressure(&bmeInt, 256);
			tp->int_hum = BME280_getHumidity(&bmeInt);
			tp->int_temp = BME280_getTemperature(&bmeInt);
		} else { // No internal BME280 found
			TRACE_ERROR("TRAC > Internal BME280 not available");
 8002d48:	484f      	ldr	r0, [pc, #316]	; (8002e88 <moduleTRACKING+0x12f8>)
 8002d4a:	f00c f8d1 	bl	800eef0 <chMtxLock>
 8002d4e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002d52:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8002d56:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002d58:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002d5a:	494e      	ldr	r1, [pc, #312]	; (8002e94 <moduleTRACKING+0x1304>)
 8002d5c:	fb06 f000 	mul.w	r0, r6, r0
 8002d60:	fbaa 3000 	umull	r3, r0, sl, r0
 8002d64:	0b80      	lsrs	r0, r0, #14
 8002d66:	fba9 7300 	umull	r7, r3, r9, r0
 8002d6a:	fbaa 7202 	umull	r7, r2, sl, r2
 8002d6e:	099b      	lsrs	r3, r3, #6
 8002d70:	fb06 0313 	mls	r3, r6, r3, r0
 8002d74:	0b92      	lsrs	r2, r2, #14
 8002d76:	4841      	ldr	r0, [pc, #260]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d78:	f00f fcb2 	bl	80126e0 <chprintf.constprop.35>
 8002d7c:	4a4d      	ldr	r2, [pc, #308]	; (8002eb4 <moduleTRACKING+0x1324>)
 8002d7e:	4947      	ldr	r1, [pc, #284]	; (8002e9c <moduleTRACKING+0x130c>)
 8002d80:	483e      	ldr	r0, [pc, #248]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d82:	f00f fcad 	bl	80126e0 <chprintf.constprop.35>
 8002d86:	f240 130d 	movw	r3, #269	; 0x10d
 8002d8a:	4a45      	ldr	r2, [pc, #276]	; (8002ea0 <moduleTRACKING+0x1310>)
 8002d8c:	4945      	ldr	r1, [pc, #276]	; (8002ea4 <moduleTRACKING+0x1314>)
 8002d8e:	483b      	ldr	r0, [pc, #236]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d90:	f00f fca6 	bl	80126e0 <chprintf.constprop.35>
 8002d94:	4944      	ldr	r1, [pc, #272]	; (8002ea8 <moduleTRACKING+0x1318>)
 8002d96:	4839      	ldr	r0, [pc, #228]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002d98:	f00f fca2 	bl	80126e0 <chprintf.constprop.35>
 8002d9c:	4946      	ldr	r1, [pc, #280]	; (8002eb8 <moduleTRACKING+0x1328>)
 8002d9e:	4837      	ldr	r0, [pc, #220]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002da0:	f00f fc9e 	bl	80126e0 <chprintf.constprop.35>
 8002da4:	4937      	ldr	r1, [pc, #220]	; (8002e84 <moduleTRACKING+0x12f4>)
 8002da6:	4835      	ldr	r0, [pc, #212]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002da8:	f00f fc9a 	bl	80126e0 <chprintf.constprop.35>
 8002dac:	4836      	ldr	r0, [pc, #216]	; (8002e88 <moduleTRACKING+0x12f8>)
 8002dae:	f00c f83f 	bl	800ee30 <chMtxUnlock>
 8002db2:	f240 110d 	movw	r1, #269	; 0x10d
 8002db6:	483a      	ldr	r0, [pc, #232]	; (8002ea0 <moduleTRACKING+0x1310>)
 8002db8:	f00d f8d2 	bl	800ff60 <log_error>
			tp->int_press = 0;
 8002dbc:	62a5      	str	r5, [r4, #40]	; 0x28
			tp->int_hum = 0;
 8002dbe:	85a5      	strh	r5, [r4, #44]	; 0x2c
			tp->int_temp = 0;
 8002dc0:	85e5      	strh	r5, [r4, #46]	; 0x2e
 8002dc2:	e5fd      	b.n	80029c0 <moduleTRACKING+0xe30>
		status = 0;
	}
	if(gps_set_power_save()) {
		TRACE_INFO("GPS  > Configure power save OK");
	} else {
		TRACE_ERROR("GPS  > Configure power save FAILED");
 8002dc4:	4830      	ldr	r0, [pc, #192]	; (8002e88 <moduleTRACKING+0x12f8>)
 8002dc6:	f00c f893 	bl	800eef0 <chMtxLock>
 8002dca:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002dce:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8002dd2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002dd4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002dd6:	492f      	ldr	r1, [pc, #188]	; (8002e94 <moduleTRACKING+0x1304>)
 8002dd8:	fb04 f000 	mul.w	r0, r4, r0
 8002ddc:	fbaa 3000 	umull	r3, r0, sl, r0
 8002de0:	0b80      	lsrs	r0, r0, #14
 8002de2:	fba9 5300 	umull	r5, r3, r9, r0
 8002de6:	fbaa 5202 	umull	r5, r2, sl, r2
 8002dea:	099b      	lsrs	r3, r3, #6
 8002dec:	fb04 0313 	mls	r3, r4, r3, r0
 8002df0:	0b92      	lsrs	r2, r2, #14
 8002df2:	4822      	ldr	r0, [pc, #136]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002df4:	f00f fc74 	bl	80126e0 <chprintf.constprop.35>
 8002df8:	4a2e      	ldr	r2, [pc, #184]	; (8002eb4 <moduleTRACKING+0x1324>)
 8002dfa:	4928      	ldr	r1, [pc, #160]	; (8002e9c <moduleTRACKING+0x130c>)
 8002dfc:	481f      	ldr	r0, [pc, #124]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002dfe:	f00f fc6f 	bl	80126e0 <chprintf.constprop.35>
 8002e02:	f240 13f7 	movw	r3, #503	; 0x1f7
 8002e06:	4a2d      	ldr	r2, [pc, #180]	; (8002ebc <moduleTRACKING+0x132c>)
 8002e08:	4926      	ldr	r1, [pc, #152]	; (8002ea4 <moduleTRACKING+0x1314>)
 8002e0a:	481c      	ldr	r0, [pc, #112]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002e0c:	f00f fc68 	bl	80126e0 <chprintf.constprop.35>
 8002e10:	4925      	ldr	r1, [pc, #148]	; (8002ea8 <moduleTRACKING+0x1318>)
 8002e12:	481a      	ldr	r0, [pc, #104]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002e14:	f00f fc64 	bl	80126e0 <chprintf.constprop.35>
 8002e18:	4929      	ldr	r1, [pc, #164]	; (8002ec0 <moduleTRACKING+0x1330>)
 8002e1a:	4818      	ldr	r0, [pc, #96]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002e1c:	f00f fc60 	bl	80126e0 <chprintf.constprop.35>
 8002e20:	4918      	ldr	r1, [pc, #96]	; (8002e84 <moduleTRACKING+0x12f4>)
 8002e22:	4816      	ldr	r0, [pc, #88]	; (8002e7c <moduleTRACKING+0x12ec>)
 8002e24:	f00f fc5c 	bl	80126e0 <chprintf.constprop.35>
 8002e28:	4817      	ldr	r0, [pc, #92]	; (8002e88 <moduleTRACKING+0x12f8>)
 8002e2a:	f00c f801 	bl	800ee30 <chMtxUnlock>
 8002e2e:	f240 11f7 	movw	r1, #503	; 0x1f7
 8002e32:	4822      	ldr	r0, [pc, #136]	; (8002ebc <moduleTRACKING+0x132c>)
 8002e34:	f00d f894 	bl	800ff60 <log_error>
 8002e38:	f7ff ba81 	b.w	800233e <moduleTRACKING+0x7ae>

			// Search for lock as long enough power is available
			do {
				batt = getBatteryVoltageMV();
				gps_get_fix(&gpsFix);
			} while(!isGPSLocked(&gpsFix) && batt >= GPS_OFF_VBAT && chVTGetSystemTimeX() <= time + S2ST(TRACK_CYCLE_TIME-5)); // Do as long no GPS lock and within timeout, timeout=cycle-1sec (-1sec in order to keep synchronization)
 8002e3c:	2d04      	cmp	r5, #4
 8002e3e:	f67f abfa 	bls.w	8002636 <moduleTRACKING+0xaa6>

			if(batt < GPS_OFF_VBAT) // Switch off GPS at low batt
 8002e42:	f640 0397 	movw	r3, #2199	; 0x897
 8002e46:	429c      	cmp	r4, r3
 8002e48:	9637      	str	r6, [sp, #220]	; 0xdc
 8002e4a:	9534      	str	r5, [sp, #208]	; 0xd0
 8002e4c:	463e      	mov	r6, r7
 8002e4e:	9036      	str	r0, [sp, #216]	; 0xd8
 8002e50:	9f26      	ldr	r7, [sp, #152]	; 0x98
 8002e52:	f8cd c0e0 	str.w	ip, [sp, #224]	; 0xe0
 8002e56:	f8cd e098 	str.w	lr, [sp, #152]	; 0x98
 8002e5a:	9d27      	ldr	r5, [sp, #156]	; 0x9c
 8002e5c:	f240 80c6 	bls.w	8002fec <moduleTRACKING+0x145c>
				GPS_Deinit();
		}

		if(isGPSLocked(&gpsFix)) { // GPS locked
 8002e60:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 8002e62:	2b04      	cmp	r3, #4
 8002e64:	f200 80d0 	bhi.w	8003008 <moduleTRACKING+0x1478>
 8002e68:	f04f 0b03 	mov.w	fp, #3
 8002e6c:	e4ea      	b.n	8002844 <moduleTRACKING+0xcb4>
 8002e6e:	bf00      	nop
 8002e70:	6b5fca6b 	.word	0x6b5fca6b
 8002e74:	00989680 	.word	0x00989680
 8002e78:	08014190 	.word	0x08014190
 8002e7c:	20027e60 	.word	0x20027e60
 8002e80:	08013cd4 	.word	0x08013cd4
 8002e84:	08013cac 	.word	0x08013cac
 8002e88:	20027b2c 	.word	0x20027b2c
 8002e8c:	20000cd4 	.word	0x20000cd4
 8002e90:	20027e3c 	.word	0x20027e3c
 8002e94:	08013c50 	.word	0x08013c50
 8002e98:	08013cb0 	.word	0x08013cb0
 8002e9c:	08013c5c 	.word	0x08013c5c
 8002ea0:	08013c6c 	.word	0x08013c6c
 8002ea4:	08013c78 	.word	0x08013c78
 8002ea8:	08013d00 	.word	0x08013d00
 8002eac:	08013dcc 	.word	0x08013dcc
 8002eb0:	20000c64 	.word	0x20000c64
 8002eb4:	08013d9c 	.word	0x08013d9c
 8002eb8:	08013da4 	.word	0x08013da4
 8002ebc:	08013e24 	.word	0x08013e24
 8002ec0:	08013f14 	.word	0x08013f14
	#endif

	if(gps_set_airborne_model()) {
		TRACE_INFO("GPS  > Set airborne model OK");
	} else {
		TRACE_ERROR("GPS  > Set airborne model FAILED");
 8002ec4:	4839      	ldr	r0, [pc, #228]	; (8002fac <moduleTRACKING+0x141c>)
 8002ec6:	f00c f813 	bl	800eef0 <chMtxLock>
 8002eca:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ece:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8002ed2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002ed4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002ed6:	4936      	ldr	r1, [pc, #216]	; (8002fb0 <moduleTRACKING+0x1420>)
 8002ed8:	fb04 f000 	mul.w	r0, r4, r0
 8002edc:	fbaa 3000 	umull	r3, r0, sl, r0
 8002ee0:	0b80      	lsrs	r0, r0, #14
 8002ee2:	fba9 5300 	umull	r5, r3, r9, r0
 8002ee6:	fbaa 5202 	umull	r5, r2, sl, r2
 8002eea:	099b      	lsrs	r3, r3, #6
 8002eec:	fb04 0313 	mls	r3, r4, r3, r0
 8002ef0:	0b92      	lsrs	r2, r2, #14
 8002ef2:	4830      	ldr	r0, [pc, #192]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002ef4:	f00f fbf4 	bl	80126e0 <chprintf.constprop.35>
 8002ef8:	4a2f      	ldr	r2, [pc, #188]	; (8002fb8 <moduleTRACKING+0x1428>)
 8002efa:	4930      	ldr	r1, [pc, #192]	; (8002fbc <moduleTRACKING+0x142c>)
 8002efc:	482d      	ldr	r0, [pc, #180]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002efe:	f00f fbef 	bl	80126e0 <chprintf.constprop.35>
 8002f02:	f240 13f1 	movw	r3, #497	; 0x1f1
 8002f06:	4a2e      	ldr	r2, [pc, #184]	; (8002fc0 <moduleTRACKING+0x1430>)
 8002f08:	492e      	ldr	r1, [pc, #184]	; (8002fc4 <moduleTRACKING+0x1434>)
 8002f0a:	482a      	ldr	r0, [pc, #168]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f0c:	f00f fbe8 	bl	80126e0 <chprintf.constprop.35>
 8002f10:	492d      	ldr	r1, [pc, #180]	; (8002fc8 <moduleTRACKING+0x1438>)
 8002f12:	4828      	ldr	r0, [pc, #160]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f14:	f00f fbe4 	bl	80126e0 <chprintf.constprop.35>
 8002f18:	492c      	ldr	r1, [pc, #176]	; (8002fcc <moduleTRACKING+0x143c>)
 8002f1a:	4826      	ldr	r0, [pc, #152]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f1c:	f00f fbe0 	bl	80126e0 <chprintf.constprop.35>
 8002f20:	492b      	ldr	r1, [pc, #172]	; (8002fd0 <moduleTRACKING+0x1440>)
 8002f22:	4824      	ldr	r0, [pc, #144]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f24:	f00f fbdc 	bl	80126e0 <chprintf.constprop.35>
 8002f28:	4820      	ldr	r0, [pc, #128]	; (8002fac <moduleTRACKING+0x141c>)
 8002f2a:	f00b ff81 	bl	800ee30 <chMtxUnlock>
 8002f2e:	f240 11f1 	movw	r1, #497	; 0x1f1
 8002f32:	4823      	ldr	r0, [pc, #140]	; (8002fc0 <moduleTRACKING+0x1430>)
 8002f34:	f00d f814 	bl	800ff60 <log_error>
 8002f38:	f7ff b986 	b.w	8002248 <moduleTRACKING+0x6b8>
	// Configure GPS
	TRACE_INFO("GPS  > Initialize GPS");
	if(gps_disable_nmea_output()) {
		TRACE_INFO("GPS  > Disable NMEA output OK");
	} else {
		TRACE_ERROR("GPS  > Disable NMEA output FAILED");
 8002f3c:	481b      	ldr	r0, [pc, #108]	; (8002fac <moduleTRACKING+0x141c>)
 8002f3e:	f00b ffd7 	bl	800eef0 <chMtxLock>
 8002f42:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8002f44:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8002f46:	491a      	ldr	r1, [pc, #104]	; (8002fb0 <moduleTRACKING+0x1420>)
 8002f48:	fb06 f000 	mul.w	r0, r6, r0
 8002f4c:	fbaa 3000 	umull	r3, r0, sl, r0
 8002f50:	0b80      	lsrs	r0, r0, #14
 8002f52:	fba9 4300 	umull	r4, r3, r9, r0
 8002f56:	fbaa 4202 	umull	r4, r2, sl, r2
 8002f5a:	099b      	lsrs	r3, r3, #6
 8002f5c:	fb06 0313 	mls	r3, r6, r3, r0
 8002f60:	0b92      	lsrs	r2, r2, #14
 8002f62:	4814      	ldr	r0, [pc, #80]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f64:	f00f fbbc 	bl	80126e0 <chprintf.constprop.35>
 8002f68:	4a13      	ldr	r2, [pc, #76]	; (8002fb8 <moduleTRACKING+0x1428>)
 8002f6a:	4914      	ldr	r1, [pc, #80]	; (8002fbc <moduleTRACKING+0x142c>)
 8002f6c:	4811      	ldr	r0, [pc, #68]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f6e:	f00f fbb7 	bl	80126e0 <chprintf.constprop.35>
 8002f72:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8002f76:	4a12      	ldr	r2, [pc, #72]	; (8002fc0 <moduleTRACKING+0x1430>)
 8002f78:	4912      	ldr	r1, [pc, #72]	; (8002fc4 <moduleTRACKING+0x1434>)
 8002f7a:	480e      	ldr	r0, [pc, #56]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f7c:	f00f fbb0 	bl	80126e0 <chprintf.constprop.35>
 8002f80:	4911      	ldr	r1, [pc, #68]	; (8002fc8 <moduleTRACKING+0x1438>)
 8002f82:	480c      	ldr	r0, [pc, #48]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f84:	f00f fbac 	bl	80126e0 <chprintf.constprop.35>
 8002f88:	4912      	ldr	r1, [pc, #72]	; (8002fd4 <moduleTRACKING+0x1444>)
 8002f8a:	480a      	ldr	r0, [pc, #40]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f8c:	f00f fba8 	bl	80126e0 <chprintf.constprop.35>
 8002f90:	490f      	ldr	r1, [pc, #60]	; (8002fd0 <moduleTRACKING+0x1440>)
 8002f92:	4808      	ldr	r0, [pc, #32]	; (8002fb4 <moduleTRACKING+0x1424>)
 8002f94:	f00f fba4 	bl	80126e0 <chprintf.constprop.35>
 8002f98:	4804      	ldr	r0, [pc, #16]	; (8002fac <moduleTRACKING+0x141c>)
 8002f9a:	f00b ff49 	bl	800ee30 <chMtxUnlock>
 8002f9e:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
 8002fa2:	4807      	ldr	r0, [pc, #28]	; (8002fc0 <moduleTRACKING+0x1430>)
 8002fa4:	f00c ffdc 	bl	800ff60 <log_error>
 8002fa8:	f7ff b8fd 	b.w	80021a6 <moduleTRACKING+0x616>
 8002fac:	20027b2c 	.word	0x20027b2c
 8002fb0:	08013c50 	.word	0x08013c50
 8002fb4:	20027e60 	.word	0x20027e60
 8002fb8:	08013d9c 	.word	0x08013d9c
 8002fbc:	08013c5c 	.word	0x08013c5c
 8002fc0:	08013e24 	.word	0x08013e24
 8002fc4:	08013c78 	.word	0x08013c78
 8002fc8:	08013d00 	.word	0x08013d00
 8002fcc:	08013ed0 	.word	0x08013ed0
 8002fd0:	08013cac 	.word	0x08013cac
 8002fd4:	08013e8c 	.word	0x08013e8c
 8002fd8:	9534      	str	r5, [sp, #208]	; 0xd0
 8002fda:	9d27      	ldr	r5, [sp, #156]	; 0x9c
 8002fdc:	9637      	str	r6, [sp, #220]	; 0xdc
 8002fde:	9036      	str	r0, [sp, #216]	; 0xd8
 8002fe0:	463e      	mov	r6, r7
 8002fe2:	f8cd c0e0 	str.w	ip, [sp, #224]	; 0xe0
 8002fe6:	9f26      	ldr	r7, [sp, #152]	; 0x98
 8002fe8:	f8cd e098 	str.w	lr, [sp, #152]	; 0x98
 8002fec:	9139      	str	r1, [sp, #228]	; 0xe4
 8002fee:	9227      	str	r2, [sp, #156]	; 0x9c
				batt = getBatteryVoltageMV();
				gps_get_fix(&gpsFix);
			} while(!isGPSLocked(&gpsFix) && batt >= GPS_OFF_VBAT && chVTGetSystemTimeX() <= time + S2ST(TRACK_CYCLE_TIME-5)); // Do as long no GPS lock and within timeout, timeout=cycle-1sec (-1sec in order to keep synchronization)

			if(batt < GPS_OFF_VBAT) // Switch off GPS at low batt
				GPS_Deinit();
 8002ff0:	f007 f8c6 	bl	800a180 <GPS_Deinit>
 8002ff4:	9939      	ldr	r1, [sp, #228]	; 0xe4
 8002ff6:	9a27      	ldr	r2, [sp, #156]	; 0x9c
		}

		if(isGPSLocked(&gpsFix)) { // GPS locked
 8002ff8:	f1bb 0f03 	cmp.w	fp, #3
 8002ffc:	f47f ac22 	bne.w	8002844 <moduleTRACKING+0xcb4>
 8003000:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 8003002:	2b04      	cmp	r3, #4
 8003004:	f67f af30 	bls.w	8002e68 <moduleTRACKING+0x12d8>
		respall = false;
	} else {
		TRACE_INFO("GPS  > POSLLH Polling OK");
	}

	fix->lat = (int32_t) (
 8003008:	062d      	lsls	r5, r5, #24
 800300a:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 800300c:	eb05 4707 	add.w	r7, r5, r7, lsl #16
 8003010:	4437      	add	r7, r6
 8003012:	eb07 2303 	add.w	r3, r7, r3, lsl #8
		respall = false;
	} else {
		TRACE_INFO("GPS  > TIMEUTC Polling OK");
	}

	fix->time.year = response[12] + (response[13] << 8);
 8003016:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 800301a:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
		respall = false;
	} else {
		TRACE_INFO("GPS  > POSLLH Polling OK");
	}

	fix->lat = (int32_t) (
 800301e:	461d      	mov	r5, r3
		respall = false;
	} else {
		TRACE_INFO("GPS  > TIMEUTC Polling OK");
	}

	fix->time.year = response[12] + (response[13] << 8);
 8003020:	b293      	uxth	r3, r2
 8003022:	932a      	str	r3, [sp, #168]	; 0xa8

			// Switch off GPS
			GPS_Deinit();
 8003024:	f007 f8ac 	bl	800a180 <GPS_Deinit>

			// Debug
			TRACE_INFO("TRAC > GPS sampling finished GPS LOCK");
 8003028:	48b8      	ldr	r0, [pc, #736]	; (800330c <moduleTRACKING+0x177c>)
 800302a:	f00b ff61 	bl	800eef0 <chMtxLock>
 800302e:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8003030:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8003032:	49b7      	ldr	r1, [pc, #732]	; (8003310 <moduleTRACKING+0x1780>)
 8003034:	48b7      	ldr	r0, [pc, #732]	; (8003314 <moduleTRACKING+0x1784>)
 8003036:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
 800303a:	fb0b f303 	mul.w	r3, fp, r3
 800303e:	fbaa 4303 	umull	r4, r3, sl, r3
 8003042:	0b9b      	lsrs	r3, r3, #14
 8003044:	fba9 7403 	umull	r7, r4, r9, r3
 8003048:	fbaa 7202 	umull	r7, r2, sl, r2
 800304c:	09a4      	lsrs	r4, r4, #6
 800304e:	fb0b 3314 	mls	r3, fp, r4, r3
 8003052:	0b92      	lsrs	r2, r2, #14
 8003054:	f00f fb44 	bl	80126e0 <chprintf.constprop.35>
 8003058:	4aaf      	ldr	r2, [pc, #700]	; (8003318 <moduleTRACKING+0x1788>)
 800305a:	49b0      	ldr	r1, [pc, #704]	; (800331c <moduleTRACKING+0x178c>)
 800305c:	48ad      	ldr	r0, [pc, #692]	; (8003314 <moduleTRACKING+0x1784>)
 800305e:	f00f fb3f 	bl	80126e0 <chprintf.constprop.35>
 8003062:	23cb      	movs	r3, #203	; 0xcb
 8003064:	4aae      	ldr	r2, [pc, #696]	; (8003320 <moduleTRACKING+0x1790>)
 8003066:	49af      	ldr	r1, [pc, #700]	; (8003324 <moduleTRACKING+0x1794>)
 8003068:	48aa      	ldr	r0, [pc, #680]	; (8003314 <moduleTRACKING+0x1784>)
 800306a:	f00f fb39 	bl	80126e0 <chprintf.constprop.35>
 800306e:	49ae      	ldr	r1, [pc, #696]	; (8003328 <moduleTRACKING+0x1798>)
 8003070:	48a8      	ldr	r0, [pc, #672]	; (8003314 <moduleTRACKING+0x1784>)
 8003072:	f00f fb35 	bl	80126e0 <chprintf.constprop.35>
 8003076:	49ad      	ldr	r1, [pc, #692]	; (800332c <moduleTRACKING+0x179c>)
 8003078:	48a6      	ldr	r0, [pc, #664]	; (8003314 <moduleTRACKING+0x1784>)
 800307a:	f00f fb31 	bl	80126e0 <chprintf.constprop.35>
 800307e:	49ac      	ldr	r1, [pc, #688]	; (8003330 <moduleTRACKING+0x17a0>)
 8003080:	48a4      	ldr	r0, [pc, #656]	; (8003314 <moduleTRACKING+0x1784>)
 8003082:	f00f fb2d 	bl	80126e0 <chprintf.constprop.35>
 8003086:	48a1      	ldr	r0, [pc, #644]	; (800330c <moduleTRACKING+0x177c>)
 8003088:	f00b fed2 	bl	800ee30 <chMtxUnlock>
			TRACE_GPSFIX(&gpsFix);
 800308c:	489f      	ldr	r0, [pc, #636]	; (800330c <moduleTRACKING+0x177c>)
 800308e:	f00b ff2f 	bl	800eef0 <chMtxLock>
 8003092:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8003094:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8003096:	499e      	ldr	r1, [pc, #632]	; (8003310 <moduleTRACKING+0x1780>)
 8003098:	489e      	ldr	r0, [pc, #632]	; (8003314 <moduleTRACKING+0x1784>)
 800309a:	fb0b f303 	mul.w	r3, fp, r3
 800309e:	fbaa 4303 	umull	r4, r3, sl, r3
 80030a2:	0b9b      	lsrs	r3, r3, #14
 80030a4:	fba9 7403 	umull	r7, r4, r9, r3
 80030a8:	fbaa 7202 	umull	r7, r2, sl, r2
 80030ac:	09a4      	lsrs	r4, r4, #6
 80030ae:	fb0b 3314 	mls	r3, fp, r4, r3
 80030b2:	0b92      	lsrs	r2, r2, #14
 80030b4:	f00f fb14 	bl	80126e0 <chprintf.constprop.35>
 80030b8:	4a97      	ldr	r2, [pc, #604]	; (8003318 <moduleTRACKING+0x1788>)
 80030ba:	4998      	ldr	r1, [pc, #608]	; (800331c <moduleTRACKING+0x178c>)
 80030bc:	4895      	ldr	r0, [pc, #596]	; (8003314 <moduleTRACKING+0x1784>)
 80030be:	4f9d      	ldr	r7, [pc, #628]	; (8003334 <moduleTRACKING+0x17a4>)
 80030c0:	f00f fb0e 	bl	80126e0 <chprintf.constprop.35>
 80030c4:	23cc      	movs	r3, #204	; 0xcc
 80030c6:	4a96      	ldr	r2, [pc, #600]	; (8003320 <moduleTRACKING+0x1790>)
 80030c8:	4996      	ldr	r1, [pc, #600]	; (8003324 <moduleTRACKING+0x1794>)
 80030ca:	4892      	ldr	r0, [pc, #584]	; (8003314 <moduleTRACKING+0x1784>)
 80030cc:	f00f fb08 	bl	80126e0 <chprintf.constprop.35>
 80030d0:	4995      	ldr	r1, [pc, #596]	; (8003328 <moduleTRACKING+0x1798>)
 80030d2:	4890      	ldr	r0, [pc, #576]	; (8003314 <moduleTRACKING+0x1784>)
 80030d4:	f00f fb04 	bl	80126e0 <chprintf.constprop.35>
	}

	fix->lat = (int32_t) (
			(uint32_t)(response[8]) + ((uint32_t)(response[9]) << 8) + ((uint32_t)(response[10]) << 16) + ((uint32_t)(response[11]) << 24)
			);
	fix->lon = (int32_t) (
 80030d8:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 80030da:	f8df e28c 	ldr.w	lr, [pc, #652]	; 8003368 <moduleTRACKING+0x17d8>
 80030de:	0613      	lsls	r3, r2, #24
 80030e0:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 80030e2:	eb03 4302 	add.w	r3, r3, r2, lsl #16
 80030e6:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 80030e8:	4413      	add	r3, r2
 80030ea:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 80030ec:	2d00      	cmp	r5, #0
 80030ee:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80030f2:	4628      	mov	r0, r5
 80030f4:	bfd4      	ite	le
 80030f6:	f04f 31ff 	movle.w	r1, #4294967295
 80030fa:	2101      	movgt	r1, #1
 80030fc:	2b00      	cmp	r3, #0
 80030fe:	bfd4      	ite	le
 8003100:	f04f 32ff 	movle.w	r2, #4294967295
 8003104:	2201      	movgt	r2, #1
 8003106:	fb00 f101 	mul.w	r1, r0, r1
 800310a:	461d      	mov	r5, r3
 800310c:	9527      	str	r5, [sp, #156]	; 0x9c
 800310e:	fb05 f202 	mul.w	r2, r5, r2
 8003112:	fb87 7501 	smull	r7, r5, r7, r1
 8003116:	9f29      	ldr	r7, [sp, #164]	; 0xa4
 8003118:	970e      	str	r7, [sp, #56]	; 0x38
 800311a:	4f86      	ldr	r7, [pc, #536]	; (8003334 <moduleTRACKING+0x17a4>)
 800311c:	902b      	str	r0, [sp, #172]	; 0xac
 800311e:	17cc      	asrs	r4, r1, #31
 8003120:	fb87 7002 	smull	r7, r0, r7, r2
 8003124:	ebc4 57a5 	rsb	r7, r4, r5, asr #22
 8003128:	9c2b      	ldr	r4, [sp, #172]	; 0xac
 800312a:	4d82      	ldr	r5, [pc, #520]	; (8003334 <moduleTRACKING+0x17a4>)
 800312c:	17d3      	asrs	r3, r2, #31
 800312e:	fb85 c504 	smull	ip, r5, r5, r4
 8003132:	ebc3 53a0 	rsb	r3, r3, r0, asr #22
 8003136:	17e0      	asrs	r0, r4, #31
 8003138:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 800313a:	fb0e 1717 	mls	r7, lr, r7, r1
 800313e:	46a4      	mov	ip, r4
 8003140:	9927      	ldr	r1, [sp, #156]	; 0x9c
 8003142:	4c7c      	ldr	r4, [pc, #496]	; (8003334 <moduleTRACKING+0x17a4>)
 8003144:	9709      	str	r7, [sp, #36]	; 0x24
 8003146:	fb0e 2313 	mls	r3, lr, r3, r2
 800314a:	9a32      	ldr	r2, [sp, #200]	; 0xc8
 800314c:	920d      	str	r2, [sp, #52]	; 0x34
 800314e:	fb84 c40c 	smull	ip, r4, r4, ip
 8003152:	920a      	str	r2, [sp, #40]	; 0x28
 8003154:	9207      	str	r2, [sp, #28]
 8003156:	9205      	str	r2, [sp, #20]
 8003158:	17c9      	asrs	r1, r1, #31
 800315a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 800315c:	9202      	str	r2, [sp, #8]
 800315e:	ebc1 51a4 	rsb	r1, r1, r4, asr #22
 8003162:	9a37      	ldr	r2, [sp, #220]	; 0xdc
 8003164:	9c34      	ldr	r4, [sp, #208]	; 0xd0
 8003166:	9406      	str	r4, [sp, #24]
 8003168:	ebc0 50a5 	rsb	r0, r0, r5, asr #22
 800316c:	9c38      	ldr	r4, [sp, #224]	; 0xe0
 800316e:	9d26      	ldr	r5, [sp, #152]	; 0x98
 8003170:	9201      	str	r2, [sp, #4]
 8003172:	9a36      	ldr	r2, [sp, #216]	; 0xd8
 8003174:	9503      	str	r5, [sp, #12]
 8003176:	9404      	str	r4, [sp, #16]
 8003178:	9200      	str	r2, [sp, #0]
 800317a:	9008      	str	r0, [sp, #32]
 800317c:	4a6e      	ldr	r2, [pc, #440]	; (8003338 <moduleTRACKING+0x17a8>)
 800317e:	910b      	str	r1, [sp, #44]	; 0x2c
 8003180:	930c      	str	r3, [sp, #48]	; 0x30
 8003182:	496e      	ldr	r1, [pc, #440]	; (800333c <moduleTRACKING+0x17ac>)
 8003184:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8003186:	4863      	ldr	r0, [pc, #396]	; (8003314 <moduleTRACKING+0x1784>)
 8003188:	f00f faaa 	bl	80126e0 <chprintf.constprop.35>
 800318c:	4968      	ldr	r1, [pc, #416]	; (8003330 <moduleTRACKING+0x17a0>)
 800318e:	4861      	ldr	r0, [pc, #388]	; (8003314 <moduleTRACKING+0x1784>)
 8003190:	f00f faa6 	bl	80126e0 <chprintf.constprop.35>
 8003194:	485d      	ldr	r0, [pc, #372]	; (800330c <moduleTRACKING+0x177c>)
 8003196:	f00b fe4b 	bl	800ee30 <chMtxUnlock>
void setTime(ptime_t date) {
	RTCDateTime timespec;
	timespec.year = date.year - 2000;
	timespec.month = date.month;
	timespec.day = date.day;
	timespec.millisecond = date.hour * 3600000 + date.minute * 60000 + date.second * 1000 + date.millisecond;
 800319a:	9928      	ldr	r1, [sp, #160]	; 0xa0
 800319c:	4b68      	ldr	r3, [pc, #416]	; (8003340 <moduleTRACKING+0x17b0>)
 800319e:	f8bd 7118 	ldrh.w	r7, [sp, #280]	; 0x118

	TRACE_INFO("GPS  > Calibrate RTC");
 80031a2:	485a      	ldr	r0, [pc, #360]	; (800330c <moduleTRACKING+0x177c>)
void setTime(ptime_t date) {
	RTCDateTime timespec;
	timespec.year = date.year - 2000;
	timespec.month = date.month;
	timespec.day = date.day;
	timespec.millisecond = date.hour * 3600000 + date.minute * 60000 + date.second * 1000 + date.millisecond;
 80031a4:	f64e 2260 	movw	r2, #60000	; 0xea60
 80031a8:	fb02 f205 	mul.w	r2, r2, r5
 80031ac:	fb03 2301 	mla	r3, r3, r1, r2
 80031b0:	fb0b 3304 	mla	r3, fp, r4, r3
 80031b4:	441f      	add	r7, r3

	TRACE_INFO("GPS  > Calibrate RTC");
 80031b6:	f00b fe9b 	bl	800eef0 <chMtxLock>
 80031ba:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80031bc:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80031be:	4954      	ldr	r1, [pc, #336]	; (8003310 <moduleTRACKING+0x1780>)
 80031c0:	4854      	ldr	r0, [pc, #336]	; (8003314 <moduleTRACKING+0x1784>)
 80031c2:	fb0b f303 	mul.w	r3, fp, r3
 80031c6:	fbaa 4303 	umull	r4, r3, sl, r3
 80031ca:	0b9b      	lsrs	r3, r3, #14
 80031cc:	fba9 5403 	umull	r5, r4, r9, r3
 80031d0:	fbaa 5202 	umull	r5, r2, sl, r2
 80031d4:	09a4      	lsrs	r4, r4, #6
 80031d6:	fb0b 3314 	mls	r3, fp, r4, r3
 80031da:	0b92      	lsrs	r2, r2, #14
 80031dc:	f00f fa80 	bl	80126e0 <chprintf.constprop.35>
 80031e0:	4a4d      	ldr	r2, [pc, #308]	; (8003318 <moduleTRACKING+0x1788>)
 80031e2:	494e      	ldr	r1, [pc, #312]	; (800331c <moduleTRACKING+0x178c>)
 80031e4:	484b      	ldr	r0, [pc, #300]	; (8003314 <moduleTRACKING+0x1784>)
 80031e6:	f00f fa7b 	bl	80126e0 <chprintf.constprop.35>
 80031ea:	2363      	movs	r3, #99	; 0x63
 80031ec:	4a55      	ldr	r2, [pc, #340]	; (8003344 <moduleTRACKING+0x17b4>)
 80031ee:	494d      	ldr	r1, [pc, #308]	; (8003324 <moduleTRACKING+0x1794>)
 80031f0:	4848      	ldr	r0, [pc, #288]	; (8003314 <moduleTRACKING+0x1784>)
 80031f2:	f00f fa75 	bl	80126e0 <chprintf.constprop.35>
 80031f6:	494c      	ldr	r1, [pc, #304]	; (8003328 <moduleTRACKING+0x1798>)
 80031f8:	4846      	ldr	r0, [pc, #280]	; (8003314 <moduleTRACKING+0x1784>)
 80031fa:	f00f fa71 	bl	80126e0 <chprintf.constprop.35>
 80031fe:	4952      	ldr	r1, [pc, #328]	; (8003348 <moduleTRACKING+0x17b8>)
 8003200:	4844      	ldr	r0, [pc, #272]	; (8003314 <moduleTRACKING+0x1784>)
 8003202:	f00f fa6d 	bl	80126e0 <chprintf.constprop.35>
 8003206:	494a      	ldr	r1, [pc, #296]	; (8003330 <moduleTRACKING+0x17a0>)
 8003208:	4842      	ldr	r0, [pc, #264]	; (8003314 <moduleTRACKING+0x1784>)
 800320a:	f00f fa69 	bl	80126e0 <chprintf.constprop.35>
 800320e:	483f      	ldr	r0, [pc, #252]	; (800330c <moduleTRACKING+0x177c>)
 8003210:	f00b fe0e 	bl	800ee30 <chMtxUnlock>
	PRINT_TIME("RTC");
 8003214:	a86b      	add	r0, sp, #428	; 0x1ac
 8003216:	f007 f80b 	bl	800a230 <getTime>
 800321a:	483c      	ldr	r0, [pc, #240]	; (800330c <moduleTRACKING+0x177c>)
 800321c:	f00b fe68 	bl	800eef0 <chMtxLock>
 8003220:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8003222:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8003224:	493a      	ldr	r1, [pc, #232]	; (8003310 <moduleTRACKING+0x1780>)
 8003226:	483b      	ldr	r0, [pc, #236]	; (8003314 <moduleTRACKING+0x1784>)
 8003228:	fb0b f303 	mul.w	r3, fp, r3
 800322c:	fbaa 4303 	umull	r4, r3, sl, r3
 8003230:	0b9b      	lsrs	r3, r3, #14
 8003232:	fba9 5403 	umull	r5, r4, r9, r3
 8003236:	fbaa 5202 	umull	r5, r2, sl, r2
 800323a:	09a4      	lsrs	r4, r4, #6
 800323c:	fb0b 3314 	mls	r3, fp, r4, r3
 8003240:	0b92      	lsrs	r2, r2, #14
 8003242:	f00f fa4d 	bl	80126e0 <chprintf.constprop.35>
 8003246:	4a34      	ldr	r2, [pc, #208]	; (8003318 <moduleTRACKING+0x1788>)
 8003248:	4934      	ldr	r1, [pc, #208]	; (800331c <moduleTRACKING+0x178c>)
 800324a:	4832      	ldr	r0, [pc, #200]	; (8003314 <moduleTRACKING+0x1784>)
 800324c:	f00f fa48 	bl	80126e0 <chprintf.constprop.35>
 8003250:	2364      	movs	r3, #100	; 0x64
 8003252:	4a3c      	ldr	r2, [pc, #240]	; (8003344 <moduleTRACKING+0x17b4>)
 8003254:	4933      	ldr	r1, [pc, #204]	; (8003324 <moduleTRACKING+0x1794>)
 8003256:	482f      	ldr	r0, [pc, #188]	; (8003314 <moduleTRACKING+0x1784>)
 8003258:	f00f fa42 	bl	80126e0 <chprintf.constprop.35>
 800325c:	4932      	ldr	r1, [pc, #200]	; (8003328 <moduleTRACKING+0x1798>)
 800325e:	482d      	ldr	r0, [pc, #180]	; (8003314 <moduleTRACKING+0x1784>)
 8003260:	f00f fa3e 	bl	80126e0 <chprintf.constprop.35>
 8003264:	f8bd 61b4 	ldrh.w	r6, [sp, #436]	; 0x1b4
 8003268:	f89d 51b2 	ldrb.w	r5, [sp, #434]	; 0x1b2
 800326c:	f89d 41b1 	ldrb.w	r4, [sp, #433]	; 0x1b1
 8003270:	f89d 01b0 	ldrb.w	r0, [sp, #432]	; 0x1b0
 8003274:	f89d 11af 	ldrb.w	r1, [sp, #431]	; 0x1af
 8003278:	f89d 21ae 	ldrb.w	r2, [sp, #430]	; 0x1ae
 800327c:	f8bd 31ac 	ldrh.w	r3, [sp, #428]	; 0x1ac
 8003280:	9605      	str	r6, [sp, #20]
 8003282:	9504      	str	r5, [sp, #16]
 8003284:	9403      	str	r4, [sp, #12]
 8003286:	9002      	str	r0, [sp, #8]
 8003288:	9101      	str	r1, [sp, #4]
 800328a:	9200      	str	r2, [sp, #0]
 800328c:	492f      	ldr	r1, [pc, #188]	; (800334c <moduleTRACKING+0x17bc>)
 800328e:	4a30      	ldr	r2, [pc, #192]	; (8003350 <moduleTRACKING+0x17c0>)
 8003290:	4820      	ldr	r0, [pc, #128]	; (8003314 <moduleTRACKING+0x1784>)
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8003292:	4c30      	ldr	r4, [pc, #192]	; (8003354 <moduleTRACKING+0x17c4>)
 8003294:	4e30      	ldr	r6, [pc, #192]	; (8003358 <moduleTRACKING+0x17c8>)
 8003296:	4d31      	ldr	r5, [pc, #196]	; (800335c <moduleTRACKING+0x17cc>)
 8003298:	f00f fa22 	bl	80126e0 <chprintf.constprop.35>
 800329c:	4924      	ldr	r1, [pc, #144]	; (8003330 <moduleTRACKING+0x17a0>)
 800329e:	481d      	ldr	r0, [pc, #116]	; (8003314 <moduleTRACKING+0x1784>)
 80032a0:	f00f fa1e 	bl	80126e0 <chprintf.constprop.35>
 80032a4:	4819      	ldr	r0, [pc, #100]	; (800330c <moduleTRACKING+0x177c>)
 80032a6:	f00b fdc3 	bl	800ee30 <chMtxUnlock>
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
 80032aa:	9937      	ldr	r1, [sp, #220]	; 0xdc
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80032ac:	f8df c0bc 	ldr.w	ip, [pc, #188]	; 800336c <moduleTRACKING+0x17dc>
 80032b0:	4b2b      	ldr	r3, [pc, #172]	; (8003360 <moduleTRACKING+0x17d0>)
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 80032b2:	f89d e1ad 	ldrb.w	lr, [sp, #429]	; 0x1ad
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
  uint32_t n, tr = 0;

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 80032b6:	f027 4278 	bic.w	r2, r7, #4160749568	; 0xf8000000
 80032ba:	fb89 0202 	smull	r0, r2, r9, r2
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80032be:	4f29      	ldr	r7, [pc, #164]	; (8003364 <moduleTRACKING+0x17d4>)
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
 80032c0:	f001 011f 	and.w	r1, r1, #31
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
  uint32_t n, tr = 0;

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 80032c4:	0992      	lsrs	r2, r2, #6
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
 80032c6:	912e      	str	r1, [sp, #184]	; 0xb8
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
 80032c8:	9936      	ldr	r1, [sp, #216]	; 0xd8
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80032ca:	fba7 b002 	umull	fp, r0, r7, r2
 80032ce:	fba4 b402 	umull	fp, r4, r4, r2
 80032d2:	08c0      	lsrs	r0, r0, #3
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
 80032d4:	f001 010f 	and.w	r1, r1, #15
 80032d8:	912d      	str	r1, [sp, #180]	; 0xb4
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80032da:	fbac b100 	umull	fp, r1, ip, r0
 80032de:	ea4f 1b54 	mov.w	fp, r4, lsr #5
 80032e2:	fba3 4302 	umull	r4, r3, r3, r2
 80032e6:	099b      	lsrs	r3, r3, #6
 80032e8:	0889      	lsrs	r1, r1, #2
 80032ea:	9335      	str	r3, [sp, #212]	; 0xd4
 80032ec:	fba5 4502 	umull	r4, r5, r5, r2
 80032f0:	fba6 4302 	umull	r4, r3, r6, r2
 80032f4:	eb01 0141 	add.w	r1, r1, r1, lsl #1
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 80032f8:	ea4f 145e 	mov.w	r4, lr, lsr #5
 80032fc:	9439      	str	r4, [sp, #228]	; 0xe4
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80032fe:	eba0 0141 	sub.w	r1, r0, r1, lsl #1
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8003302:	9c2e      	ldr	r4, [sp, #184]	; 0xb8
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8003304:	9e35      	ldr	r6, [sp, #212]	; 0xd4
 8003306:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800330a:	e031      	b.n	8003370 <moduleTRACKING+0x17e0>
 800330c:	20027b2c 	.word	0x20027b2c
 8003310:	08013c50 	.word	0x08013c50
 8003314:	20027e60 	.word	0x20027e60
 8003318:	08013cfc 	.word	0x08013cfc
 800331c:	08013c5c 	.word	0x08013c5c
 8003320:	08013c6c 	.word	0x08013c6c
 8003324:	08013c78 	.word	0x08013c78
 8003328:	08013d00 	.word	0x08013d00
 800332c:	08014028 	.word	0x08014028
 8003330:	08013cac 	.word	0x08013cac
 8003334:	6b5fca6b 	.word	0x6b5fca6b
 8003338:	08013cd4 	.word	0x08013cd4
 800333c:	08014050 	.word	0x08014050
 8003340:	0036ee80 	.word	0x0036ee80
 8003344:	0801410c 	.word	0x0801410c
 8003348:	08014114 	.word	0x08014114
 800334c:	08014130 	.word	0x08014130
 8003350:	0801412c 	.word	0x0801412c
 8003354:	88888889 	.word	0x88888889
 8003358:	91a2b3c5 	.word	0x91a2b3c5
 800335c:	e90452d5 	.word	0xe90452d5
 8003360:	1b4e81b5 	.word	0x1b4e81b5
 8003364:	cccccccd 	.word	0xcccccccd
 8003368:	00989680 	.word	0x00989680
 800336c:	aaaaaaab 	.word	0xaaaaaaab
 8003370:	eba2 0040 	sub.w	r0, r2, r0, lsl #1
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8003374:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8003376:	fba7 e404 	umull	lr, r4, r7, r4
 800337a:	ea4f 0ed4 	mov.w	lr, r4, lsr #3
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 800337e:	0bed      	lsrs	r5, r5, #15
 8003380:	fbac c406 	umull	ip, r4, ip, r6
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8003384:	3230      	adds	r2, #48	; 0x30
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8003386:	9e2d      	ldr	r6, [sp, #180]	; 0xb4
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8003388:	b2d2      	uxtb	r2, r2
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 800338a:	ea40 5505 	orr.w	r5, r0, r5, lsl #20
 800338e:	08a0      	lsrs	r0, r4, #2
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8003390:	9c2e      	ldr	r4, [sp, #184]	; 0xb8
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8003392:	922c      	str	r2, [sp, #176]	; 0xb0
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8003394:	ea4f 2cd3 	mov.w	ip, r3, lsr #11
 8003398:	ea45 1501 	orr.w	r5, r5, r1, lsl #4
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 800339c:	fba7 6306 	umull	r6, r3, r7, r6
 80033a0:	9939      	ldr	r1, [sp, #228]	; 0xe4
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80033a2:	fba7 260b 	umull	r2, r6, r7, fp
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 80033a6:	eb0e 028e 	add.w	r2, lr, lr, lsl #2
 80033aa:	08db      	lsrs	r3, r3, #3
 80033ac:	eba4 0242 	sub.w	r2, r4, r2, lsl #1
 80033b0:	ea42 3241 	orr.w	r2, r2, r1, lsl #13
 80033b4:	9c2d      	ldr	r4, [sp, #180]	; 0xb4
 80033b6:	0099      	lsls	r1, r3, #2
 80033b8:	4419      	add	r1, r3
 80033ba:	eba4 0141 	sub.w	r1, r4, r1, lsl #1
 80033be:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80033c2:	08f6      	lsrs	r6, r6, #3
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 80033c4:	992c      	ldr	r1, [sp, #176]	; 0xb0
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80033c6:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 80033ca:	ebab 0646 	sub.w	r6, fp, r6, lsl #1
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 80033ce:	fba7 b401 	umull	fp, r4, r7, r1
 80033d2:	08e4      	lsrs	r4, r4, #3
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80033d4:	ea45 2606 	orr.w	r6, r5, r6, lsl #8
 80033d8:	9d35      	ldr	r5, [sp, #212]	; 0xd4
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 80033da:	fba7 b104 	umull	fp, r1, r7, r4
 80033de:	ea42 3303 	orr.w	r3, r2, r3, lsl #12
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80033e2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80033e6:	fba7 b20c 	umull	fp, r2, r7, ip
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 80033ea:	9f2c      	ldr	r7, [sp, #176]	; 0xb0
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 80033ec:	eba5 0040 	sub.w	r0, r5, r0, lsl #1
 80033f0:	08d2      	lsrs	r2, r2, #3
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 80033f2:	eb04 0584 	add.w	r5, r4, r4, lsl #2
 80033f6:	08c9      	lsrs	r1, r1, #3
 80033f8:	eba7 0545 	sub.w	r5, r7, r5, lsl #1
 80033fc:	ea43 130e 	orr.w	r3, r3, lr, lsl #4
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8003400:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8003404:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8003408:	ea46 3000 	orr.w	r0, r6, r0, lsl #12
 800340c:	ebac 0242 	sub.w	r2, ip, r2, lsl #1
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8003410:	eba4 0141 	sub.w	r1, r4, r1, lsl #1
 8003414:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8003418:	ea40 4602 	orr.w	r6, r0, r2, lsl #16
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 800341c:	ea43 5401 	orr.w	r4, r3, r1, lsl #20
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003420:	f3ef 8511 	mrs	r5, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8003424:	b90d      	cbnz	r5, 800342a <moduleTRACKING+0x189a>
 8003426:	f00b fe8b 	bl	800f140 <chSysGetStatusAndLockX.part.1.lto_priv.109>
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 800342a:	4b5d      	ldr	r3, [pc, #372]	; (80035a0 <moduleTRACKING+0x1a10>)
 800342c:	681a      	ldr	r2, [r3, #0]
 800342e:	68d3      	ldr	r3, [r2, #12]
 8003430:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003434:	60d3      	str	r3, [r2, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 8003436:	68d3      	ldr	r3, [r2, #12]
 8003438:	0659      	lsls	r1, r3, #25
 800343a:	d5fc      	bpl.n	8003436 <moduleTRACKING+0x18a6>
  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();

  /* Writing the registers.*/
  rtc_enter_init();
  rtcp->rtc->TR = tr;
 800343c:	6016      	str	r6, [r2, #0]
  rtcp->rtc->DR = dr;
 800343e:	6054      	str	r4, [r2, #4]
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 8003440:	68d3      	ldr	r3, [r2, #12]
 8003442:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8003446:	60d3      	str	r3, [r2, #12]
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 8003448:	b90d      	cbnz	r5, 800344e <moduleTRACKING+0x18be>
 800344a:	f00b fe91 	bl	800f170 <chSysRestoreStatusX.part.2.lto_priv.110>

			// Calibrate RTC
			setTime(gpsFix.time);

			// Take time from GPS
			tp->time.year = gpsFix.time.year;
 800344e:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8003450:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8003452:	f8bd 10a8 	ldrh.w	r1, [sp, #168]	; 0xa8
 8003456:	1a9b      	subs	r3, r3, r2
 8003458:	4a52      	ldr	r2, [pc, #328]	; (80035a4 <moduleTRACKING+0x1a14>)
 800345a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
			// Set new GPS fix
			tp->gps_lat = gpsFix.lat;
			tp->gps_lon = gpsFix.lon;
			tp->gps_alt = gpsFix.alt;

			tp->gps_lock = isGPSLocked(&gpsFix);
 800345e:	2201      	movs	r2, #1

			// Calibrate RTC
			setTime(gpsFix.time);

			// Take time from GPS
			tp->time.year = gpsFix.time.year;
 8003460:	8099      	strh	r1, [r3, #4]
			tp->time.month = gpsFix.time.month;
 8003462:	f89d 10d8 	ldrb.w	r1, [sp, #216]	; 0xd8
 8003466:	7199      	strb	r1, [r3, #6]
			tp->time.day = gpsFix.time.day;
 8003468:	f89d 10dc 	ldrb.w	r1, [sp, #220]	; 0xdc
 800346c:	71d9      	strb	r1, [r3, #7]
			tp->time.hour = gpsFix.time.hour;
 800346e:	f89d 10a0 	ldrb.w	r1, [sp, #160]	; 0xa0
 8003472:	7219      	strb	r1, [r3, #8]
			tp->time.minute = gpsFix.time.minute;
 8003474:	f89d 1098 	ldrb.w	r1, [sp, #152]	; 0x98
 8003478:	7259      	strb	r1, [r3, #9]
			tp->time.second = gpsFix.time.second;
 800347a:	f89d 10e0 	ldrb.w	r1, [sp, #224]	; 0xe0
 800347e:	7299      	strb	r1, [r3, #10]

			// Set new GPS fix
			tp->gps_lat = gpsFix.lat;
 8003480:	992b      	ldr	r1, [sp, #172]	; 0xac
 8003482:	6119      	str	r1, [r3, #16]
			tp->gps_lon = gpsFix.lon;
 8003484:	9927      	ldr	r1, [sp, #156]	; 0x9c
 8003486:	6159      	str	r1, [r3, #20]
			tp->gps_alt = gpsFix.alt;
 8003488:	9929      	ldr	r1, [sp, #164]	; 0xa4
 800348a:	6199      	str	r1, [r3, #24]

			tp->gps_lock = isGPSLocked(&gpsFix);
			tp->gps_sats = gpsFix.num_svs;
 800348c:	f89d 10d0 	ldrb.w	r1, [sp, #208]	; 0xd0
 8003490:	7719      	strb	r1, [r3, #28]
			// Set new GPS fix
			tp->gps_lat = gpsFix.lat;
			tp->gps_lon = gpsFix.lon;
			tp->gps_alt = gpsFix.alt;

			tp->gps_lock = isGPSLocked(&gpsFix);
 8003492:	739a      	strb	r2, [r3, #14]
			tp->gps_sats = gpsFix.num_svs;
 8003494:	f04f 0b03 	mov.w	fp, #3
 8003498:	f7ff ba32 	b.w	8002900 <moduleTRACKING+0xd70>
 800349c:	9637      	str	r6, [sp, #220]	; 0xdc
 800349e:	9534      	str	r5, [sp, #208]	; 0xd0
 80034a0:	463e      	mov	r6, r7
 80034a2:	9036      	str	r0, [sp, #216]	; 0xd8
 80034a4:	9f26      	ldr	r7, [sp, #152]	; 0x98
 80034a6:	f8cd c0e0 	str.w	ip, [sp, #224]	; 0xe0
 80034aa:	f8cd e098 	str.w	lr, [sp, #152]	; 0x98
 80034ae:	9d27      	ldr	r5, [sp, #156]	; 0x9c
 80034b0:	e5a2      	b.n	8002ff8 <moduleTRACKING+0x1468>
	} else {
		TRACE_ERROR("GPS  > Configure power save FAILED");
		status = 0;
	}
	if(gps_power_save(0)) {
		TRACE_INFO("GPS  > Disable power save OK");
 80034b2:	483d      	ldr	r0, [pc, #244]	; (80035a8 <moduleTRACKING+0x1a18>)
 80034b4:	f00b fd1c 	bl	800eef0 <chMtxLock>
 80034b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80034bc:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 80034c0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80034c2:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80034c4:	4939      	ldr	r1, [pc, #228]	; (80035ac <moduleTRACKING+0x1a1c>)
 80034c6:	fb04 f000 	mul.w	r0, r4, r0
 80034ca:	fbaa 3000 	umull	r3, r0, sl, r0
 80034ce:	0b80      	lsrs	r0, r0, #14
 80034d0:	fba9 5300 	umull	r5, r3, r9, r0
 80034d4:	fbaa 5202 	umull	r5, r2, sl, r2
 80034d8:	099b      	lsrs	r3, r3, #6
 80034da:	fb04 0313 	mls	r3, r4, r3, r0
 80034de:	0b92      	lsrs	r2, r2, #14
 80034e0:	4833      	ldr	r0, [pc, #204]	; (80035b0 <moduleTRACKING+0x1a20>)
 80034e2:	f00f f8fd 	bl	80126e0 <chprintf.constprop.35>
 80034e6:	4a33      	ldr	r2, [pc, #204]	; (80035b4 <moduleTRACKING+0x1a24>)
 80034e8:	4933      	ldr	r1, [pc, #204]	; (80035b8 <moduleTRACKING+0x1a28>)
 80034ea:	4831      	ldr	r0, [pc, #196]	; (80035b0 <moduleTRACKING+0x1a20>)
 80034ec:	f00f f8f8 	bl	80126e0 <chprintf.constprop.35>
 80034f0:	f240 13fb 	movw	r3, #507	; 0x1fb
 80034f4:	4a31      	ldr	r2, [pc, #196]	; (80035bc <moduleTRACKING+0x1a2c>)
 80034f6:	4932      	ldr	r1, [pc, #200]	; (80035c0 <moduleTRACKING+0x1a30>)
 80034f8:	482d      	ldr	r0, [pc, #180]	; (80035b0 <moduleTRACKING+0x1a20>)
 80034fa:	f00f f8f1 	bl	80126e0 <chprintf.constprop.35>
 80034fe:	4931      	ldr	r1, [pc, #196]	; (80035c4 <moduleTRACKING+0x1a34>)
 8003500:	482b      	ldr	r0, [pc, #172]	; (80035b0 <moduleTRACKING+0x1a20>)
 8003502:	f00f f8ed 	bl	80126e0 <chprintf.constprop.35>
 8003506:	4930      	ldr	r1, [pc, #192]	; (80035c8 <moduleTRACKING+0x1a38>)
 8003508:	4829      	ldr	r0, [pc, #164]	; (80035b0 <moduleTRACKING+0x1a20>)
 800350a:	f00f f8e9 	bl	80126e0 <chprintf.constprop.35>
 800350e:	492f      	ldr	r1, [pc, #188]	; (80035cc <moduleTRACKING+0x1a3c>)
 8003510:	4827      	ldr	r0, [pc, #156]	; (80035b0 <moduleTRACKING+0x1a20>)
 8003512:	f00f f8e5 	bl	80126e0 <chprintf.constprop.35>
 8003516:	4824      	ldr	r0, [pc, #144]	; (80035a8 <moduleTRACKING+0x1a18>)
 8003518:	f00b fc8a 	bl	800ee30 <chMtxUnlock>
 800351c:	f7ff b89b 	b.w	8002656 <moduleTRACKING+0xac6>
					TRACE_TAB, tp->int_press/10, tp->int_press%10, tp->int_temp/100, tp->int_temp%100, tp->int_hum/10, tp->int_hum%10,
					TRACE_TAB, tp->ext_press/10, tp->ext_press%10, tp->ext_temp/100, tp->ext_temp%100, tp->ext_hum/10, tp->ext_hum%10
		);

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
 8003520:	9a34      	ldr	r2, [sp, #208]	; 0xd0
 8003522:	2a04      	cmp	r2, #4
 8003524:	f67f abc1 	bls.w	8002caa <moduleTRACKING+0x111a>
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
 8003528:	7a20      	ldrb	r0, [r4, #8]
 800352a:	7a65      	ldrb	r5, [r4, #9]
 800352c:	88a2      	ldrh	r2, [r4, #4]
	timeC += (time.day-1) * 86400;
 800352e:	79e4      	ldrb	r4, [r4, #7]
 8003530:	f8b3 e008 	ldrh.w	lr, [r3, #8]
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
 8003534:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8003538:	fb01 f000 	mul.w	r0, r1, r0
  * @return UNIX timestamp in milliseconds
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
	timeC += time.minute * 60;
 800353c:	263c      	movs	r6, #60	; 0x3c
	timeC += time.hour * 3600;
 800353e:	17c1      	asrs	r1, r0, #31
 8003540:	fbc6 0185 	smlalbb	r0, r1, r6, r5
  * @param time Date to be converted
  * @return UNIX timestamp in milliseconds
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
 8003544:	799e      	ldrb	r6, [r3, #6]
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
 8003546:	eb16 0b00 	adds.w	fp, r6, r0
	timeC += (time.day-1) * 86400;
 800354a:	4821      	ldr	r0, [pc, #132]	; (80035d0 <moduleTRACKING+0x1a40>)
 800354c:	f104 34ff 	add.w	r4, r4, #4294967295
  * @param time Date to be converted
  * @return UNIX timestamp in milliseconds
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
 8003550:	f04f 0700 	mov.w	r7, #0
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
	timeC += (time.day-1) * 86400;
 8003554:	fb00 f404 	mul.w	r4, r0, r4
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
 8003558:	eb47 0c01 	adc.w	ip, r7, r1
 800355c:	7899      	ldrb	r1, [r3, #2]
	timeC += (time.day-1) * 86400;
 800355e:	eb1b 0604 	adds.w	r6, fp, r4
 8003562:	eb4c 77e4 	adc.w	r7, ip, r4, asr #31

	if(time.year % 4 == 0) { // is leapyear?
 8003566:	0793      	lsls	r3, r2, #30
		timeC += leapYear[time.month-1] * 86400;
 8003568:	f101 31ff 	add.w	r1, r1, #4294967295
	timeC  = time.second;
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
	timeC += (time.day-1) * 86400;

	if(time.year % 4 == 0) { // is leapyear?
 800356c:	f040 8167 	bne.w	800383e <moduleTRACKING+0x1cae>
		timeC += leapYear[time.month-1] * 86400;
 8003570:	4b18      	ldr	r3, [pc, #96]	; (80035d4 <moduleTRACKING+0x1a44>)
 8003572:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8003576:	fb00 f303 	mul.w	r3, r0, r3
 800357a:	18f0      	adds	r0, r6, r3
 800357c:	eb47 71e3 	adc.w	r1, r7, r3, asr #31
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 8003580:	f240 73b2 	movw	r3, #1970	; 0x7b2
 8003584:	429a      	cmp	r2, r3
 8003586:	d938      	bls.n	80035fa <moduleTRACKING+0x1a6a>
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
		} else {
			timeC += 31536000;
 8003588:	a503      	add	r5, pc, #12	; (adr r5, 8003598 <moduleTRACKING+0x1a08>)
 800358a:	e9d5 4500 	ldrd	r4, r5, [r5]
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
 800358e:	4e12      	ldr	r6, [pc, #72]	; (80035d8 <moduleTRACKING+0x1a48>)
 8003590:	2700      	movs	r7, #0
 8003592:	e029      	b.n	80035e8 <moduleTRACKING+0x1a58>
 8003594:	f3af 8000 	nop.w
 8003598:	01e13380 	.word	0x01e13380
 800359c:	00000000 	.word	0x00000000
 80035a0:	20028798 	.word	0x20028798
 80035a4:	20000c64 	.word	0x20000c64
 80035a8:	20027b2c 	.word	0x20027b2c
 80035ac:	08013c50 	.word	0x08013c50
 80035b0:	20027e60 	.word	0x20027e60
 80035b4:	08013cfc 	.word	0x08013cfc
 80035b8:	08013c5c 	.word	0x08013c5c
 80035bc:	08013e24 	.word	0x08013e24
 80035c0:	08013c78 	.word	0x08013c78
 80035c4:	08013d00 	.word	0x08013d00
 80035c8:	08013f38 	.word	0x08013f38
 80035cc:	08013cac 	.word	0x08013cac
 80035d0:	00015180 	.word	0x00015180
 80035d4:	08013c34 	.word	0x08013c34
 80035d8:	01e28500 	.word	0x01e28500
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 80035dc:	3301      	adds	r3, #1
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
 80035de:	1980      	adds	r0, r0, r6
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 80035e0:	b29b      	uxth	r3, r3
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
 80035e2:	4179      	adcs	r1, r7
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 80035e4:	4293      	cmp	r3, r2
 80035e6:	d008      	beq.n	80035fa <moduleTRACKING+0x1a6a>
		if(i % 4 == 0) { // is leapyear?
 80035e8:	f013 0f03 	tst.w	r3, #3
 80035ec:	d0f6      	beq.n	80035dc <moduleTRACKING+0x1a4c>
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 80035ee:	3301      	adds	r3, #1
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
		} else {
			timeC += 31536000;
 80035f0:	1900      	adds	r0, r0, r4
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 80035f2:	b29b      	uxth	r3, r3
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
		} else {
			timeC += 31536000;
 80035f4:	4169      	adcs	r1, r5
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 80035f6:	4293      	cmp	r3, r2
 80035f8:	d1f6      	bne.n	80035e8 <moduleTRACKING+0x1a58>

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 80035fa:	008c      	lsls	r4, r1, #2
 80035fc:	ea44 7390 	orr.w	r3, r4, r0, lsr #30
 8003600:	0082      	lsls	r2, r0, #2
 8003602:	015c      	lsls	r4, r3, #5
 8003604:	ea44 64d2 	orr.w	r4, r4, r2, lsr #27
 8003608:	943b      	str	r4, [sp, #236]	; 0xec
 800360a:	0154      	lsls	r4, r2, #5
 800360c:	943a      	str	r4, [sp, #232]	; 0xe8
 800360e:	e9dd 453a 	ldrd	r4, r5, [sp, #232]	; 0xe8
 8003612:	1aa4      	subs	r4, r4, r2
 8003614:	4622      	mov	r2, r4
	ltp.gps_lat = tp->gps_lat;
 8003616:	9d30      	ldr	r5, [sp, #192]	; 0xc0
 8003618:	9c2f      	ldr	r4, [sp, #188]	; 0xbc
 800361a:	4b8f      	ldr	r3, [pc, #572]	; (8003858 <moduleTRACKING+0x1cc8>)
 800361c:	1b64      	subs	r4, r4, r5
 800361e:	eb03 04c4 	add.w	r4, r3, r4, lsl #3

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 8003622:	1815      	adds	r5, r2, r0
 8003624:	00e8      	lsls	r0, r5, #3
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
 8003626:	4b8d      	ldr	r3, [pc, #564]	; (800385c <moduleTRACKING+0x1ccc>)
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;
 8003628:	69a1      	ldr	r1, [r4, #24]

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 800362a:	4605      	mov	r5, r0
	ltp.gps_lat = tp->gps_lat;
 800362c:	6920      	ldr	r0, [r4, #16]
	ltp.gps_lon = tp->gps_lon;
 800362e:	6964      	ldr	r4, [r4, #20]
 8003630:	9442      	str	r4, [sp, #264]	; 0x108
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
 8003632:	681c      	ldr	r4, [r3, #0]
static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
	ltp.gps_lat = tp->gps_lat;
 8003634:	9041      	str	r0, [sp, #260]	; 0x104
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
 8003636:	f504 0400 	add.w	r4, r4, #8388608	; 0x800000
 800363a:	f504 4440 	add.w	r4, r4, #49152	; 0xc000

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 800363e:	eb15 020e 	adds.w	r2, r5, lr
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
 8003642:	0124      	lsls	r4, r4, #4
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;
 8003644:	2900      	cmp	r1, #0
 8003646:	bfac      	ite	ge
 8003648:	b289      	uxthge	r1, r1
 800364a:	2100      	movlt	r1, #0

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
	if(address % LOG_FLASH_PAGE_SIZE == 0) // Found start of flash sector
 800364c:	f3c4 0310 	ubfx	r3, r4, #0, #17

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 8003650:	9240      	str	r2, [sp, #256]	; 0x100
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;
 8003652:	9143      	str	r1, [sp, #268]	; 0x10c

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
	if(address % LOG_FLASH_PAGE_SIZE == 0) // Found start of flash sector
 8003654:	2b00      	cmp	r3, #0
 8003656:	f000 80fb 	beq.w	8003850 <moduleTRACKING+0x1cc0>
			flashErase(address, LOG_FLASH_PAGE_SIZE);
		}
	}

	// Write data into flash
	TRACE_INFO("TRAC > Flash write (ADDR=%08x)", address);
 800365a:	4881      	ldr	r0, [pc, #516]	; (8003860 <moduleTRACKING+0x1cd0>)
 800365c:	f00b fc48 	bl	800eef0 <chMtxLock>
 8003660:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8003664:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003668:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 800366a:	6a48      	ldr	r0, [r1, #36]	; 0x24
 800366c:	497d      	ldr	r1, [pc, #500]	; (8003864 <moduleTRACKING+0x1cd4>)
 800366e:	fb03 f000 	mul.w	r0, r3, r0
 8003672:	fbaa 5000 	umull	r5, r0, sl, r0
 8003676:	0b80      	lsrs	r0, r0, #14
 8003678:	fba9 6500 	umull	r6, r5, r9, r0
 800367c:	fbaa 6202 	umull	r6, r2, sl, r2
 8003680:	09ad      	lsrs	r5, r5, #6
 8003682:	fb03 0315 	mls	r3, r3, r5, r0
 8003686:	0b92      	lsrs	r2, r2, #14
 8003688:	4877      	ldr	r0, [pc, #476]	; (8003868 <moduleTRACKING+0x1cd8>)
 800368a:	f00f f829 	bl	80126e0 <chprintf.constprop.35>
 800368e:	4a77      	ldr	r2, [pc, #476]	; (800386c <moduleTRACKING+0x1cdc>)
 8003690:	4977      	ldr	r1, [pc, #476]	; (8003870 <moduleTRACKING+0x1ce0>)
 8003692:	4875      	ldr	r0, [pc, #468]	; (8003868 <moduleTRACKING+0x1cd8>)
 8003694:	f00f f824 	bl	80126e0 <chprintf.constprop.35>
 8003698:	2336      	movs	r3, #54	; 0x36
 800369a:	4a76      	ldr	r2, [pc, #472]	; (8003874 <moduleTRACKING+0x1ce4>)
 800369c:	4976      	ldr	r1, [pc, #472]	; (8003878 <moduleTRACKING+0x1ce8>)
 800369e:	4872      	ldr	r0, [pc, #456]	; (8003868 <moduleTRACKING+0x1cd8>)
 80036a0:	f00f f81e 	bl	80126e0 <chprintf.constprop.35>
 80036a4:	4975      	ldr	r1, [pc, #468]	; (800387c <moduleTRACKING+0x1cec>)
 80036a6:	4870      	ldr	r0, [pc, #448]	; (8003868 <moduleTRACKING+0x1cd8>)
 80036a8:	f00f f81a 	bl	80126e0 <chprintf.constprop.35>
 80036ac:	4622      	mov	r2, r4
 80036ae:	4974      	ldr	r1, [pc, #464]	; (8003880 <moduleTRACKING+0x1cf0>)
 80036b0:	486d      	ldr	r0, [pc, #436]	; (8003868 <moduleTRACKING+0x1cd8>)
 80036b2:	f00f f815 	bl	80126e0 <chprintf.constprop.35>
 80036b6:	4973      	ldr	r1, [pc, #460]	; (8003884 <moduleTRACKING+0x1cf4>)
 80036b8:	486b      	ldr	r0, [pc, #428]	; (8003868 <moduleTRACKING+0x1cd8>)
 80036ba:	f00f f811 	bl	80126e0 <chprintf.constprop.35>
 80036be:	4868      	ldr	r0, [pc, #416]	; (8003860 <moduleTRACKING+0x1cd0>)
 80036c0:	f00b fbb6 	bl	800ee30 <chMtxUnlock>
	flashSectorBegin(flashSectorAt(address));
 80036c4:	4620      	mov	r0, r4
 80036c6:	f00d ff2b 	bl	8011520 <flashSectorAt>
 80036ca:	4603      	mov	r3, r0
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 80036cc:	b118      	cbz	r0, 80036d6 <moduleTRACKING+0x1b46>
    {
        --sector;
 80036ce:	3b01      	subs	r3, #1
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 80036d0:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 80036d4:	d1fb      	bne.n	80036ce <moduleTRACKING+0x1b3e>
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 80036d6:	4b6c      	ldr	r3, [pc, #432]	; (8003888 <moduleTRACKING+0x1cf8>)
 80036d8:	691a      	ldr	r2, [r3, #16]
 80036da:	2a00      	cmp	r2, #0
 80036dc:	f2c0 81ca 	blt.w	8003a74 <moduleTRACKING+0x1ee4>
    /* Unlock flash for write access */
    if(flashUnlock() == FALSE)
        return FLASH_RETURN_NO_PERMISSION;

    /* Wait for any busy flags */
    flashWaitWhileBusy();
 80036e0:	4969      	ldr	r1, [pc, #420]	; (8003888 <moduleTRACKING+0x1cf8>)
 80036e2:	68cb      	ldr	r3, [r1, #12]
 80036e4:	4a68      	ldr	r2, [pc, #416]	; (8003888 <moduleTRACKING+0x1cf8>)
 80036e6:	03d8      	lsls	r0, r3, #15
 80036e8:	d4fb      	bmi.n	80036e2 <moduleTRACKING+0x1b52>

    /* Setup parallelism before any program/erase */
    FLASH->CR &= ~FLASH_CR_PSIZE_MASK;
 80036ea:	6913      	ldr	r3, [r2, #16]
 80036ec:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80036f0:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_PSIZE_VALUE;
 80036f2:	6913      	ldr	r3, [r2, #16]
 80036f4:	6113      	str	r3, [r2, #16]

    /* Write the data */
    *(flashdata_t*)address = data;

    /* Wait for completion */
    flashWaitWhileBusy();
 80036f6:	4616      	mov	r6, r2
 80036f8:	f10d 00ff 	add.w	r0, sp, #255	; 0xff
 80036fc:	1e65      	subs	r5, r4, #1
}

static void flashWriteData(flashaddr_t address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 80036fe:	6913      	ldr	r3, [r2, #16]
    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
    {
        flashWriteData(address, *(const flashdata_t*)buffer);
 8003700:	f810 1f01 	ldrb.w	r1, [r0, #1]!
}

static void flashWriteData(flashaddr_t address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8003704:	f043 0301 	orr.w	r3, r3, #1
 8003708:	6113      	str	r3, [r2, #16]

    /* Write the data */
    *(flashdata_t*)address = data;
 800370a:	f805 1f01 	strb.w	r1, [r5, #1]!

    /* Wait for completion */
    flashWaitWhileBusy();
 800370e:	68d3      	ldr	r3, [r2, #12]
 8003710:	495d      	ldr	r1, [pc, #372]	; (8003888 <moduleTRACKING+0x1cf8>)
 8003712:	03db      	lsls	r3, r3, #15
 8003714:	d4fb      	bmi.n	800370e <moduleTRACKING+0x1b7e>

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8003716:	6933      	ldr	r3, [r6, #16]
 8003718:	f023 0301 	bic.w	r3, r3, #1
 800371c:	6133      	str	r3, [r6, #16]
    }

    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 800371e:	f20d 130f 	addw	r3, sp, #271	; 0x10f
 8003722:	4283      	cmp	r3, r0
 8003724:	d1eb      	bne.n	80036fe <moduleTRACKING+0x1b6e>
        memcpy(&tmp, buffer, size);
        flashWriteData(address, tmp);
    }

    /* Lock flash again */
    flashLock();
 8003726:	690b      	ldr	r3, [r1, #16]
 8003728:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800372c:	610b      	str	r3, [r1, #16]
 800372e:	ab40      	add	r3, sp, #256	; 0x100
 8003730:	f104 0010 	add.w	r0, r4, #16
{
    /* For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
    {
        if (*(volatile flashdata_t*)address != *(flashdata_t*)buffer)
 8003734:	7821      	ldrb	r1, [r4, #0]
 8003736:	f813 2b01 	ldrb.w	r2, [r3], #1
 800373a:	4291      	cmp	r1, r2
            return FALSE;
        address += sizeof(flashdata_t);
 800373c:	f104 0401 	add.w	r4, r4, #1
{
    /* For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
    {
        if (*(volatile flashdata_t*)address != *(flashdata_t*)buffer)
 8003740:	d144      	bne.n	80037cc <moduleTRACKING+0x1c3c>

bool flashCompare(flashaddr_t address, const char* buffer, size_t size)
{
    /* For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
 8003742:	4284      	cmp	r4, r0
 8003744:	d1f6      	bne.n	8003734 <moduleTRACKING+0x1ba4>
	flashWrite(address, (char*)&ltp, sizeof(logTrackPoint_t));
	flashSectorEnd(flashSectorAt(address));

	// Verify
	if(flashCompare(address, (char*)&ltp, sizeof(logTrackPoint_t)))
		TRACE_INFO("TRAC > Flash write OK")
 8003746:	4846      	ldr	r0, [pc, #280]	; (8003860 <moduleTRACKING+0x1cd0>)
 8003748:	f00b fbd2 	bl	800eef0 <chMtxLock>
 800374c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8003750:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003754:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8003756:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8003758:	4942      	ldr	r1, [pc, #264]	; (8003864 <moduleTRACKING+0x1cd4>)
 800375a:	fb03 f000 	mul.w	r0, r3, r0
 800375e:	fbaa 4000 	umull	r4, r0, sl, r0
 8003762:	0b80      	lsrs	r0, r0, #14
 8003764:	fba9 5400 	umull	r5, r4, r9, r0
 8003768:	fbaa 5202 	umull	r5, r2, sl, r2
 800376c:	09a4      	lsrs	r4, r4, #6
 800376e:	fb03 0314 	mls	r3, r3, r4, r0
 8003772:	0b92      	lsrs	r2, r2, #14
 8003774:	483c      	ldr	r0, [pc, #240]	; (8003868 <moduleTRACKING+0x1cd8>)
 8003776:	f00e ffb3 	bl	80126e0 <chprintf.constprop.35>
 800377a:	4a3c      	ldr	r2, [pc, #240]	; (800386c <moduleTRACKING+0x1cdc>)
 800377c:	493c      	ldr	r1, [pc, #240]	; (8003870 <moduleTRACKING+0x1ce0>)
 800377e:	483a      	ldr	r0, [pc, #232]	; (8003868 <moduleTRACKING+0x1cd8>)
 8003780:	f00e ffae 	bl	80126e0 <chprintf.constprop.35>
 8003784:	233d      	movs	r3, #61	; 0x3d
 8003786:	4a3b      	ldr	r2, [pc, #236]	; (8003874 <moduleTRACKING+0x1ce4>)
 8003788:	493b      	ldr	r1, [pc, #236]	; (8003878 <moduleTRACKING+0x1ce8>)
 800378a:	4837      	ldr	r0, [pc, #220]	; (8003868 <moduleTRACKING+0x1cd8>)
 800378c:	f00e ffa8 	bl	80126e0 <chprintf.constprop.35>
 8003790:	493a      	ldr	r1, [pc, #232]	; (800387c <moduleTRACKING+0x1cec>)
 8003792:	4835      	ldr	r0, [pc, #212]	; (8003868 <moduleTRACKING+0x1cd8>)
 8003794:	f00e ffa4 	bl	80126e0 <chprintf.constprop.35>
 8003798:	493c      	ldr	r1, [pc, #240]	; (800388c <moduleTRACKING+0x1cfc>)
 800379a:	4833      	ldr	r0, [pc, #204]	; (8003868 <moduleTRACKING+0x1cd8>)
 800379c:	f00e ffa0 	bl	80126e0 <chprintf.constprop.35>
 80037a0:	4938      	ldr	r1, [pc, #224]	; (8003884 <moduleTRACKING+0x1cf4>)
 80037a2:	4831      	ldr	r0, [pc, #196]	; (8003868 <moduleTRACKING+0x1cd8>)
 80037a4:	f00e ff9c 	bl	80126e0 <chprintf.constprop.35>
 80037a8:	482d      	ldr	r0, [pc, #180]	; (8003860 <moduleTRACKING+0x1cd0>)
 80037aa:	f00b fb41 	bl	800ee30 <chMtxUnlock>
	else
		TRACE_ERROR("TRAC > Flash write failed");

	// Increment log counter
	logEntryCounter = (logEntryCounter+1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t));
 80037ae:	4b2b      	ldr	r3, [pc, #172]	; (800385c <moduleTRACKING+0x1ccc>)

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
		{
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
 80037b0:	4a37      	ldr	r2, [pc, #220]	; (8003890 <moduleTRACKING+0x1d00>)
		TRACE_INFO("TRAC > Flash write OK")
	else
		TRACE_ERROR("TRAC > Flash write failed");

	// Increment log counter
	logEntryCounter = (logEntryCounter+1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t));
 80037b2:	681b      	ldr	r3, [r3, #0]

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
		{
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
 80037b4:	6812      	ldr	r2, [r2, #0]
 80037b6:	4937      	ldr	r1, [pc, #220]	; (8003894 <moduleTRACKING+0x1d04>)
		TRACE_INFO("TRAC > Flash write OK")
	else
		TRACE_ERROR("TRAC > Flash write failed");

	// Increment log counter
	logEntryCounter = (logEntryCounter+1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t));
 80037b8:	3301      	adds	r3, #1

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
		{
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
 80037ba:	4411      	add	r1, r2
		TRACE_INFO("TRAC > Flash write OK")
	else
		TRACE_ERROR("TRAC > Flash write failed");

	// Increment log counter
	logEntryCounter = (logEntryCounter+1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t));
 80037bc:	4a27      	ldr	r2, [pc, #156]	; (800385c <moduleTRACKING+0x1ccc>)
 80037be:	f3c3 030d 	ubfx	r3, r3, #0, #14
 80037c2:	6013      	str	r3, [r2, #0]

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
		{
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
 80037c4:	4b32      	ldr	r3, [pc, #200]	; (8003890 <moduleTRACKING+0x1d00>)
 80037c6:	6019      	str	r1, [r3, #0]
 80037c8:	f7ff ba6f 	b.w	8002caa <moduleTRACKING+0x111a>

	// Verify
	if(flashCompare(address, (char*)&ltp, sizeof(logTrackPoint_t)))
		TRACE_INFO("TRAC > Flash write OK")
	else
		TRACE_ERROR("TRAC > Flash write failed");
 80037cc:	4824      	ldr	r0, [pc, #144]	; (8003860 <moduleTRACKING+0x1cd0>)
 80037ce:	f00b fb8f 	bl	800eef0 <chMtxLock>
 80037d2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80037d6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80037da:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 80037dc:	6a48      	ldr	r0, [r1, #36]	; 0x24
 80037de:	4921      	ldr	r1, [pc, #132]	; (8003864 <moduleTRACKING+0x1cd4>)
 80037e0:	fb03 f000 	mul.w	r0, r3, r0
 80037e4:	fbaa 4000 	umull	r4, r0, sl, r0
 80037e8:	0b80      	lsrs	r0, r0, #14
 80037ea:	fba9 5400 	umull	r5, r4, r9, r0
 80037ee:	fbaa 5202 	umull	r5, r2, sl, r2
 80037f2:	09a4      	lsrs	r4, r4, #6
 80037f4:	fb03 0314 	mls	r3, r3, r4, r0
 80037f8:	0b92      	lsrs	r2, r2, #14
 80037fa:	481b      	ldr	r0, [pc, #108]	; (8003868 <moduleTRACKING+0x1cd8>)
 80037fc:	f00e ff70 	bl	80126e0 <chprintf.constprop.35>
 8003800:	4a25      	ldr	r2, [pc, #148]	; (8003898 <moduleTRACKING+0x1d08>)
 8003802:	491b      	ldr	r1, [pc, #108]	; (8003870 <moduleTRACKING+0x1ce0>)
 8003804:	4818      	ldr	r0, [pc, #96]	; (8003868 <moduleTRACKING+0x1cd8>)
 8003806:	f00e ff6b 	bl	80126e0 <chprintf.constprop.35>
 800380a:	233f      	movs	r3, #63	; 0x3f
 800380c:	4a19      	ldr	r2, [pc, #100]	; (8003874 <moduleTRACKING+0x1ce4>)
 800380e:	491a      	ldr	r1, [pc, #104]	; (8003878 <moduleTRACKING+0x1ce8>)
 8003810:	4815      	ldr	r0, [pc, #84]	; (8003868 <moduleTRACKING+0x1cd8>)
 8003812:	f00e ff65 	bl	80126e0 <chprintf.constprop.35>
 8003816:	4919      	ldr	r1, [pc, #100]	; (800387c <moduleTRACKING+0x1cec>)
 8003818:	4813      	ldr	r0, [pc, #76]	; (8003868 <moduleTRACKING+0x1cd8>)
 800381a:	f00e ff61 	bl	80126e0 <chprintf.constprop.35>
 800381e:	491f      	ldr	r1, [pc, #124]	; (800389c <moduleTRACKING+0x1d0c>)
 8003820:	4811      	ldr	r0, [pc, #68]	; (8003868 <moduleTRACKING+0x1cd8>)
 8003822:	f00e ff5d 	bl	80126e0 <chprintf.constprop.35>
 8003826:	4917      	ldr	r1, [pc, #92]	; (8003884 <moduleTRACKING+0x1cf4>)
 8003828:	480f      	ldr	r0, [pc, #60]	; (8003868 <moduleTRACKING+0x1cd8>)
 800382a:	f00e ff59 	bl	80126e0 <chprintf.constprop.35>
 800382e:	480c      	ldr	r0, [pc, #48]	; (8003860 <moduleTRACKING+0x1cd0>)
 8003830:	f00b fafe 	bl	800ee30 <chMtxUnlock>
 8003834:	213f      	movs	r1, #63	; 0x3f
 8003836:	480f      	ldr	r0, [pc, #60]	; (8003874 <moduleTRACKING+0x1ce4>)
 8003838:	f00c fb92 	bl	800ff60 <log_error>
 800383c:	e7b7      	b.n	80037ae <moduleTRACKING+0x1c1e>
	timeC += (time.day-1) * 86400;

	if(time.year % 4 == 0) { // is leapyear?
		timeC += leapYear[time.month-1] * 86400;
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
 800383e:	4b18      	ldr	r3, [pc, #96]	; (80038a0 <moduleTRACKING+0x1d10>)
 8003840:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8003844:	fb00 f303 	mul.w	r3, r0, r3
 8003848:	18f0      	adds	r0, r6, r3
 800384a:	eb47 71e3 	adc.w	r1, r7, r3, asr #31
 800384e:	e697      	b.n	8003580 <moduleTRACKING+0x19f0>
 8003850:	f504 3100 	add.w	r1, r4, #131072	; 0x20000
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
	if(address % LOG_FLASH_PAGE_SIZE == 0) // Found start of flash sector
 8003854:	4623      	mov	r3, r4
 8003856:	e028      	b.n	80038aa <moduleTRACKING+0x1d1a>
 8003858:	20000c64 	.word	0x20000c64
 800385c:	20000c60 	.word	0x20000c60
 8003860:	20027b2c 	.word	0x20027b2c
 8003864:	08013c50 	.word	0x08013c50
 8003868:	20027e60 	.word	0x20027e60
 800386c:	08013cfc 	.word	0x08013cfc
 8003870:	08013c5c 	.word	0x08013c5c
 8003874:	08013c6c 	.word	0x08013c6c
 8003878:	08013c78 	.word	0x08013c78
 800387c:	08013d00 	.word	0x08013d00
 8003880:	08014308 	.word	0x08014308
 8003884:	08013cac 	.word	0x08013cac
 8003888:	40023c00 	.word	0x40023c00
 800388c:	080142d4 	.word	0x080142d4
 8003890:	20000cd4 	.word	0x20000cd4
 8003894:	02255100 	.word	0x02255100
 8003898:	08013d9c 	.word	0x08013d9c
 800389c:	080142ec 	.word	0x080142ec
 80038a0:	08013c18 	.word	0x08013c18
bool flashIsErased(flashaddr_t address, size_t size)
{
    /* Check for default set bits in the flash memory
     * For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
 80038a4:	428b      	cmp	r3, r1
 80038a6:	f43f aed8 	beq.w	800365a <moduleTRACKING+0x1aca>
    {
        if (*(volatile flashdata_t*)address != (flashdata_t)(-1)) // flashdata_t being unsigned, -1 is 0xFF..FF
 80038aa:	781a      	ldrb	r2, [r3, #0]
 80038ac:	2aff      	cmp	r2, #255	; 0xff
            return FALSE;
        address += sizeof(flashdata_t);
 80038ae:	f103 0301 	add.w	r3, r3, #1
    /* Check for default set bits in the flash memory
     * For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
    {
        if (*(volatile flashdata_t*)address != (flashdata_t)(-1)) // flashdata_t being unsigned, -1 is 0xFF..FF
 80038b2:	d0f7      	beq.n	80038a4 <moduleTRACKING+0x1d14>
	{
		if(!flashIsErased(address, LOG_FLASH_PAGE_SIZE))
		{
			TRACE_INFO("TRAC > Erase flash %08x", address);
 80038b4:	4895      	ldr	r0, [pc, #596]	; (8003b0c <moduleTRACKING+0x1f7c>)
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 80038b6:	4d96      	ldr	r5, [pc, #600]	; (8003b10 <moduleTRACKING+0x1f80>)
 80038b8:	f00b fb1a 	bl	800eef0 <chMtxLock>
 80038bc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80038c0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80038c4:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 80038c6:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80038c8:	fb03 f101 	mul.w	r1, r3, r1
 80038cc:	fbaa 0101 	umull	r0, r1, sl, r1
 80038d0:	0b89      	lsrs	r1, r1, #14
 80038d2:	fba9 6001 	umull	r6, r0, r9, r1
 80038d6:	0980      	lsrs	r0, r0, #6
 80038d8:	fbaa 6202 	umull	r6, r2, sl, r2
 80038dc:	fb03 1310 	mls	r3, r3, r0, r1
 80038e0:	0b92      	lsrs	r2, r2, #14
 80038e2:	498c      	ldr	r1, [pc, #560]	; (8003b14 <moduleTRACKING+0x1f84>)
 80038e4:	488c      	ldr	r0, [pc, #560]	; (8003b18 <moduleTRACKING+0x1f88>)
 80038e6:	f00e fefb 	bl	80126e0 <chprintf.constprop.35>
 80038ea:	4a8c      	ldr	r2, [pc, #560]	; (8003b1c <moduleTRACKING+0x1f8c>)
 80038ec:	498c      	ldr	r1, [pc, #560]	; (8003b20 <moduleTRACKING+0x1f90>)
 80038ee:	488a      	ldr	r0, [pc, #552]	; (8003b18 <moduleTRACKING+0x1f88>)
 80038f0:	f00e fef6 	bl	80126e0 <chprintf.constprop.35>
 80038f4:	2330      	movs	r3, #48	; 0x30
 80038f6:	4a8b      	ldr	r2, [pc, #556]	; (8003b24 <moduleTRACKING+0x1f94>)
 80038f8:	498b      	ldr	r1, [pc, #556]	; (8003b28 <moduleTRACKING+0x1f98>)
 80038fa:	4887      	ldr	r0, [pc, #540]	; (8003b18 <moduleTRACKING+0x1f88>)
 80038fc:	f00e fef0 	bl	80126e0 <chprintf.constprop.35>
 8003900:	498a      	ldr	r1, [pc, #552]	; (8003b2c <moduleTRACKING+0x1f9c>)
 8003902:	4885      	ldr	r0, [pc, #532]	; (8003b18 <moduleTRACKING+0x1f88>)
 8003904:	f00e feec 	bl	80126e0 <chprintf.constprop.35>
 8003908:	4622      	mov	r2, r4
 800390a:	4989      	ldr	r1, [pc, #548]	; (8003b30 <moduleTRACKING+0x1fa0>)
 800390c:	4882      	ldr	r0, [pc, #520]	; (8003b18 <moduleTRACKING+0x1f88>)
 800390e:	f00e fee7 	bl	80126e0 <chprintf.constprop.35>
 8003912:	4988      	ldr	r1, [pc, #544]	; (8003b34 <moduleTRACKING+0x1fa4>)
 8003914:	4880      	ldr	r0, [pc, #512]	; (8003b18 <moduleTRACKING+0x1f88>)
 8003916:	f00e fee3 	bl	80126e0 <chprintf.constprop.35>
 800391a:	46a3      	mov	fp, r4
 800391c:	487b      	ldr	r0, [pc, #492]	; (8003b0c <moduleTRACKING+0x1f7c>)
 800391e:	f00b fa87 	bl	800ee30 <chMtxUnlock>
 8003922:	f44f 3300 	mov.w	r3, #131072	; 0x20000

int flashErase(flashaddr_t address, size_t size)
{
    while (size > 0)
    {
        flashsector_t sector = flashSectorAt(address);
 8003926:	4658      	mov	r0, fp
 8003928:	9426      	str	r4, [sp, #152]	; 0x98
 800392a:	461c      	mov	r4, r3
 800392c:	f00d fdf8 	bl	8011520 <flashSectorAt>
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 8003930:	692b      	ldr	r3, [r5, #16]
 8003932:	2b00      	cmp	r3, #0

int flashErase(flashaddr_t address, size_t size)
{
    while (size > 0)
    {
        flashsector_t sector = flashSectorAt(address);
 8003934:	4607      	mov	r7, r0
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 8003936:	f2c0 808c 	blt.w	8003a52 <moduleTRACKING+0x1ec2>
    /* Unlock flash for write access */
    if(flashUnlock() == FALSE)
        return FLASH_RETURN_NO_PERMISSION;

    /* Wait for any busy flags. */
    flashWaitWhileBusy();
 800393a:	68eb      	ldr	r3, [r5, #12]
 800393c:	4a74      	ldr	r2, [pc, #464]	; (8003b10 <moduleTRACKING+0x1f80>)
 800393e:	03de      	lsls	r6, r3, #15
 8003940:	d4fb      	bmi.n	800393a <moduleTRACKING+0x1daa>

    /* Setup parallelism before any program/erase */
    FLASH->CR &= ~FLASH_CR_PSIZE_MASK;
 8003942:	6913      	ldr	r3, [r2, #16]
 8003944:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003948:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_PSIZE_VALUE;
 800394a:	6913      	ldr	r3, [r2, #16]
 800394c:	6113      	str	r3, [r2, #16]
     * 0000 sector 0
     * 0001 sector 1
     * ...
     * 1011 sector 11
     * others not allowed */
    FLASH->CR &= ~(FLASH_CR_SNB_0 | FLASH_CR_SNB_1 | FLASH_CR_SNB_2 | FLASH_CR_SNB_3);
 800394e:	6913      	ldr	r3, [r2, #16]
    if (sector & 0x1) FLASH->CR |= FLASH_CR_SNB_0;
 8003950:	07f8      	lsls	r0, r7, #31
     * 0000 sector 0
     * 0001 sector 1
     * ...
     * 1011 sector 11
     * others not allowed */
    FLASH->CR &= ~(FLASH_CR_SNB_0 | FLASH_CR_SNB_1 | FLASH_CR_SNB_2 | FLASH_CR_SNB_3);
 8003952:	f023 0378 	bic.w	r3, r3, #120	; 0x78
 8003956:	6113      	str	r3, [r2, #16]
    if (sector & 0x1) FLASH->CR |= FLASH_CR_SNB_0;
 8003958:	d503      	bpl.n	8003962 <moduleTRACKING+0x1dd2>
 800395a:	6913      	ldr	r3, [r2, #16]
 800395c:	f043 0308 	orr.w	r3, r3, #8
 8003960:	6113      	str	r3, [r2, #16]
    if (sector & 0x2) FLASH->CR |= FLASH_CR_SNB_1;
 8003962:	07b9      	lsls	r1, r7, #30
 8003964:	d503      	bpl.n	800396e <moduleTRACKING+0x1dde>
 8003966:	692b      	ldr	r3, [r5, #16]
 8003968:	f043 0310 	orr.w	r3, r3, #16
 800396c:	612b      	str	r3, [r5, #16]
    if (sector & 0x4) FLASH->CR |= FLASH_CR_SNB_2;
 800396e:	077a      	lsls	r2, r7, #29
 8003970:	d503      	bpl.n	800397a <moduleTRACKING+0x1dea>
 8003972:	692b      	ldr	r3, [r5, #16]
 8003974:	f043 0320 	orr.w	r3, r3, #32
 8003978:	612b      	str	r3, [r5, #16]
    if (sector & 0x8) FLASH->CR |= FLASH_CR_SNB_3;
 800397a:	073b      	lsls	r3, r7, #28
 800397c:	d503      	bpl.n	8003986 <moduleTRACKING+0x1df6>
 800397e:	692b      	ldr	r3, [r5, #16]
 8003980:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003984:	612b      	str	r3, [r5, #16]
    FLASH->CR |= FLASH_CR_SER;
 8003986:	692b      	ldr	r3, [r5, #16]
 8003988:	f043 0302 	orr.w	r3, r3, #2
 800398c:	612b      	str	r3, [r5, #16]
    FLASH->CR |= FLASH_CR_STRT;
 800398e:	692b      	ldr	r3, [r5, #16]
 8003990:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003994:	612b      	str	r3, [r5, #16]

    /* Wait until it's finished. */
    flashWaitWhileBusy();
 8003996:	68eb      	ldr	r3, [r5, #12]
 8003998:	4a5d      	ldr	r2, [pc, #372]	; (8003b10 <moduleTRACKING+0x1f80>)
 800399a:	03de      	lsls	r6, r3, #15
 800399c:	d4fb      	bmi.n	8003996 <moduleTRACKING+0x1e06>

    /* Sector erase flag does not clear automatically. */
    FLASH->CR &= ~FLASH_CR_SER;
 800399e:	6913      	ldr	r3, [r2, #16]
 80039a0:	f023 0302 	bic.w	r3, r3, #2
 80039a4:	6113      	str	r3, [r2, #16]

    /* Lock flash again */
    flashLock();
 80039a6:	6913      	ldr	r3, [r2, #16]
 80039a8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80039ac:	6113      	str	r3, [r2, #16]
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 80039ae:	2f00      	cmp	r7, #0
 80039b0:	d069      	beq.n	8003a86 <moduleTRACKING+0x1ef6>
 80039b2:	463e      	mov	r6, r7
 80039b4:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
    {
        --sector;
 80039b8:	3e01      	subs	r6, #1
 80039ba:	b2f6      	uxtb	r6, r6
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 80039bc:	2e03      	cmp	r6, #3
 80039be:	4630      	mov	r0, r6
 80039c0:	d907      	bls.n	80039d2 <moduleTRACKING+0x1e42>
 80039c2:	f00d fd9d 	bl	8011500 <flashSectorSize.part.1.lto_priv.168>
flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
 80039c6:	3e01      	subs	r6, #1
 80039c8:	b2f6      	uxtb	r6, r6
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 80039ca:	2e03      	cmp	r6, #3
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 80039cc:	4483      	add	fp, r0
 80039ce:	4630      	mov	r0, r6
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 80039d0:	d8f7      	bhi.n	80039c2 <moduleTRACKING+0x1e32>
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 80039d2:	f50b 4b80 	add.w	fp, fp, #16384	; 0x4000
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 80039d6:	2e00      	cmp	r6, #0
 80039d8:	d1ee      	bne.n	80039b8 <moduleTRACKING+0x1e28>
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 80039da:	2f03      	cmp	r7, #3
 80039dc:	d947      	bls.n	8003a6e <moduleTRACKING+0x1ede>
 80039de:	4638      	mov	r0, r7
 80039e0:	f00d fd8e 	bl	8011500 <flashSectorSize.part.1.lto_priv.168>
bool flashIsErased(flashaddr_t address, size_t size)
{
    /* Check for default set bits in the flash memory
     * For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
 80039e4:	b170      	cbz	r0, 8003a04 <moduleTRACKING+0x1e74>
    {
        if (*(volatile flashdata_t*)address != (flashdata_t)(-1)) // flashdata_t being unsigned, -1 is 0xFF..FF
 80039e6:	f89b 2000 	ldrb.w	r2, [fp]
 80039ea:	2aff      	cmp	r2, #255	; 0xff
 80039ec:	d13a      	bne.n	8003a64 <moduleTRACKING+0x1ed4>
 80039ee:	eb00 010b 	add.w	r1, r0, fp
 80039f2:	f10b 0301 	add.w	r3, fp, #1
 80039f6:	e003      	b.n	8003a00 <moduleTRACKING+0x1e70>
 80039f8:	f813 2b01 	ldrb.w	r2, [r3], #1
 80039fc:	2aff      	cmp	r2, #255	; 0xff
 80039fe:	d131      	bne.n	8003a64 <moduleTRACKING+0x1ed4>
bool flashIsErased(flashaddr_t address, size_t size)
{
    /* Check for default set bits in the flash memory
     * For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
 8003a00:	4299      	cmp	r1, r3
 8003a02:	d1f9      	bne.n	80039f8 <moduleTRACKING+0x1e68>
    return address;
}

flashaddr_t flashSectorEnd(flashsector_t sector)
{
    return flashSectorBegin(sector + 1);
 8003a04:	1c7e      	adds	r6, r7, #1
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8003a06:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 8003a0a:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
 8003a0e:	d010      	beq.n	8003a32 <moduleTRACKING+0x1ea2>
    {
        --sector;
 8003a10:	3e01      	subs	r6, #1
 8003a12:	b2f6      	uxtb	r6, r6
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8003a14:	2e03      	cmp	r6, #3
 8003a16:	4630      	mov	r0, r6
 8003a18:	d907      	bls.n	8003a2a <moduleTRACKING+0x1e9a>
 8003a1a:	f00d fd71 	bl	8011500 <flashSectorSize.part.1.lto_priv.168>
flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
 8003a1e:	3e01      	subs	r6, #1
 8003a20:	b2f6      	uxtb	r6, r6
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8003a22:	2e03      	cmp	r6, #3
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 8003a24:	4483      	add	fp, r0
 8003a26:	4630      	mov	r0, r6
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8003a28:	d8f7      	bhi.n	8003a1a <moduleTRACKING+0x1e8a>
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 8003a2a:	f50b 4b80 	add.w	fp, fp, #16384	; 0x4000
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8003a2e:	2e00      	cmp	r6, #0
 8003a30:	d1ee      	bne.n	8003a10 <moduleTRACKING+0x1e80>
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8003a32:	2f03      	cmp	r7, #3
 8003a34:	d918      	bls.n	8003a68 <moduleTRACKING+0x1ed8>
 8003a36:	4638      	mov	r0, r7
 8003a38:	f00d fd62 	bl	8011500 <flashSectorSize.part.1.lto_priv.168>
        int err = flashSectorErase(sector);
        if (err != FLASH_RETURN_SUCCESS)
            return err;
        address = flashSectorEnd(sector);
        size_t sector_size = flashSectorSize(sector);
        if (sector_size >= size)
 8003a3c:	4284      	cmp	r4, r0
 8003a3e:	d911      	bls.n	8003a64 <moduleTRACKING+0x1ed4>
            break;
        else
            size -= sector_size;
 8003a40:	1a24      	subs	r4, r4, r0

int flashErase(flashaddr_t address, size_t size)
{
    while (size > 0)
    {
        flashsector_t sector = flashSectorAt(address);
 8003a42:	4658      	mov	r0, fp
 8003a44:	f00d fd6c 	bl	8011520 <flashSectorAt>
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 8003a48:	692b      	ldr	r3, [r5, #16]
 8003a4a:	2b00      	cmp	r3, #0

int flashErase(flashaddr_t address, size_t size)
{
    while (size > 0)
    {
        flashsector_t sector = flashSectorAt(address);
 8003a4c:	4607      	mov	r7, r0
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 8003a4e:	f6bf af74 	bge.w	800393a <moduleTRACKING+0x1daa>
        return TRUE;

    /* Write magic unlock sequence */
    FLASH->KEYR = 0x45670123;
 8003a52:	4b39      	ldr	r3, [pc, #228]	; (8003b38 <moduleTRACKING+0x1fa8>)
 8003a54:	606b      	str	r3, [r5, #4]
    FLASH->KEYR = 0xCDEF89AB;
 8003a56:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 8003a5a:	606b      	str	r3, [r5, #4]

    /* Check if unlock was successful */
    if (FLASH->CR & FLASH_CR_LOCK)
 8003a5c:	692b      	ldr	r3, [r5, #16]
 8003a5e:	2b00      	cmp	r3, #0
 8003a60:	f6bf af6b 	bge.w	800393a <moduleTRACKING+0x1daa>
 8003a64:	9c26      	ldr	r4, [sp, #152]	; 0x98
 8003a66:	e5f8      	b.n	800365a <moduleTRACKING+0x1aca>
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
        return 16 * 1024;
 8003a68:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8003a6c:	e7e6      	b.n	8003a3c <moduleTRACKING+0x1eac>
 8003a6e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8003a72:	e7b8      	b.n	80039e6 <moduleTRACKING+0x1e56>
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
        return TRUE;

    /* Write magic unlock sequence */
    FLASH->KEYR = 0x45670123;
 8003a74:	4930      	ldr	r1, [pc, #192]	; (8003b38 <moduleTRACKING+0x1fa8>)
    FLASH->KEYR = 0xCDEF89AB;
 8003a76:	4a31      	ldr	r2, [pc, #196]	; (8003b3c <moduleTRACKING+0x1fac>)
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
        return TRUE;

    /* Write magic unlock sequence */
    FLASH->KEYR = 0x45670123;
 8003a78:	6059      	str	r1, [r3, #4]
    FLASH->KEYR = 0xCDEF89AB;
 8003a7a:	605a      	str	r2, [r3, #4]

    /* Check if unlock was successful */
    if (FLASH->CR & FLASH_CR_LOCK)
 8003a7c:	691b      	ldr	r3, [r3, #16]
 8003a7e:	2b00      	cmp	r3, #0
 8003a80:	f6bf ae2e 	bge.w	80036e0 <moduleTRACKING+0x1b50>
 8003a84:	e653      	b.n	800372e <moduleTRACKING+0x1b9e>
    return 0;
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
 8003a86:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
        return 16 * 1024;
 8003a8a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8003a8e:	e7aa      	b.n	80039e6 <moduleTRACKING+0x1e56>
		BME280_Init(&bmeExt, BME280_ADDRESS_EXT);
		lastTrackPoint->ext_press = BME280_getPressure(&bmeExt, 256);
		lastTrackPoint->ext_hum = BME280_getHumidity(&bmeExt);
		lastTrackPoint->ext_temp = BME280_getTemperature(&bmeExt);
	} else { // No external BME280 found
		TRACE_WARN("TRAC > External BME280 not available");
 8003a90:	481e      	ldr	r0, [pc, #120]	; (8003b0c <moduleTRACKING+0x1f7c>)
 8003a92:	4d2b      	ldr	r5, [pc, #172]	; (8003b40 <moduleTRACKING+0x1fb0>)
 8003a94:	f00b fa2c 	bl	800eef0 <chMtxLock>
 8003a98:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003a9c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003aa0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003aa2:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8003aa4:	4b27      	ldr	r3, [pc, #156]	; (8003b44 <moduleTRACKING+0x1fb4>)
 8003aa6:	fb00 f101 	mul.w	r1, r0, r1
 8003aaa:	fba5 6101 	umull	r6, r1, r5, r1
 8003aae:	0b89      	lsrs	r1, r1, #14
 8003ab0:	fba3 6301 	umull	r6, r3, r3, r1
 8003ab4:	fba5 5202 	umull	r5, r2, r5, r2
 8003ab8:	099b      	lsrs	r3, r3, #6
 8003aba:	fb00 1313 	mls	r3, r0, r3, r1
 8003abe:	0b92      	lsrs	r2, r2, #14
 8003ac0:	4914      	ldr	r1, [pc, #80]	; (8003b14 <moduleTRACKING+0x1f84>)
 8003ac2:	4815      	ldr	r0, [pc, #84]	; (8003b18 <moduleTRACKING+0x1f88>)
 8003ac4:	f00e fe0c 	bl	80126e0 <chprintf.constprop.35>
 8003ac8:	4a1f      	ldr	r2, [pc, #124]	; (8003b48 <moduleTRACKING+0x1fb8>)
 8003aca:	4915      	ldr	r1, [pc, #84]	; (8003b20 <moduleTRACKING+0x1f90>)
 8003acc:	4812      	ldr	r0, [pc, #72]	; (8003b18 <moduleTRACKING+0x1f88>)
 8003ace:	f00e fe07 	bl	80126e0 <chprintf.constprop.35>
 8003ad2:	23a2      	movs	r3, #162	; 0xa2
 8003ad4:	4a13      	ldr	r2, [pc, #76]	; (8003b24 <moduleTRACKING+0x1f94>)
 8003ad6:	4914      	ldr	r1, [pc, #80]	; (8003b28 <moduleTRACKING+0x1f98>)
 8003ad8:	480f      	ldr	r0, [pc, #60]	; (8003b18 <moduleTRACKING+0x1f88>)
 8003ada:	f00e fe01 	bl	80126e0 <chprintf.constprop.35>
 8003ade:	4913      	ldr	r1, [pc, #76]	; (8003b2c <moduleTRACKING+0x1f9c>)
 8003ae0:	480d      	ldr	r0, [pc, #52]	; (8003b18 <moduleTRACKING+0x1f88>)
 8003ae2:	f00e fdfd 	bl	80126e0 <chprintf.constprop.35>
 8003ae6:	4919      	ldr	r1, [pc, #100]	; (8003b4c <moduleTRACKING+0x1fbc>)
 8003ae8:	480b      	ldr	r0, [pc, #44]	; (8003b18 <moduleTRACKING+0x1f88>)
 8003aea:	f00e fdf9 	bl	80126e0 <chprintf.constprop.35>
 8003aee:	4911      	ldr	r1, [pc, #68]	; (8003b34 <moduleTRACKING+0x1fa4>)
 8003af0:	4809      	ldr	r0, [pc, #36]	; (8003b18 <moduleTRACKING+0x1f88>)
 8003af2:	f00e fdf5 	bl	80126e0 <chprintf.constprop.35>
 8003af6:	4805      	ldr	r0, [pc, #20]	; (8003b0c <moduleTRACKING+0x1f7c>)
 8003af8:	f00b f99a 	bl	800ee30 <chMtxUnlock>
		lastTrackPoint->ext_press = 0;
 8003afc:	4b14      	ldr	r3, [pc, #80]	; (8003b50 <moduleTRACKING+0x1fc0>)
 8003afe:	681b      	ldr	r3, [r3, #0]
 8003b00:	631c      	str	r4, [r3, #48]	; 0x30
		lastTrackPoint->ext_hum = 0;
 8003b02:	869c      	strh	r4, [r3, #52]	; 0x34
		lastTrackPoint->ext_temp = 0;
 8003b04:	86dc      	strh	r4, [r3, #54]	; 0x36
 8003b06:	f7fe b9c9 	b.w	8001e9c <moduleTRACKING+0x30c>
 8003b0a:	bf00      	nop
 8003b0c:	20027b2c 	.word	0x20027b2c
 8003b10:	40023c00 	.word	0x40023c00
 8003b14:	08013c50 	.word	0x08013c50
 8003b18:	20027e60 	.word	0x20027e60
 8003b1c:	08013cfc 	.word	0x08013cfc
 8003b20:	08013c5c 	.word	0x08013c5c
 8003b24:	08013c6c 	.word	0x08013c6c
 8003b28:	08013c78 	.word	0x08013c78
 8003b2c:	08013d00 	.word	0x08013d00
 8003b30:	080142bc 	.word	0x080142bc
 8003b34:	08013cac 	.word	0x08013cac
 8003b38:	45670123 	.word	0x45670123
 8003b3c:	cdef89ab 	.word	0xcdef89ab
 8003b40:	d1b71759 	.word	0xd1b71759
 8003b44:	10624dd3 	.word	0x10624dd3
 8003b48:	08013cb0 	.word	0x08013cb0
 8003b4c:	08013dcc 	.word	0x08013dcc
 8003b50:	20027e3c 	.word	0x20027e3c
		BME280_Init(&bmeInt, BME280_ADDRESS_INT);
		lastTrackPoint->int_press = BME280_getPressure(&bmeInt, 256);
		lastTrackPoint->int_hum = BME280_getHumidity(&bmeInt);
		lastTrackPoint->int_temp = BME280_getTemperature(&bmeInt);
	} else { // No internal BME280 found
		TRACE_ERROR("TRAC > Internal BME280 not available");
 8003b54:	4834      	ldr	r0, [pc, #208]	; (8003c28 <moduleTRACKING+0x2098>)
 8003b56:	4e35      	ldr	r6, [pc, #212]	; (8003c2c <moduleTRACKING+0x209c>)
 8003b58:	f00b f9ca 	bl	800eef0 <chMtxLock>
 8003b5c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003b60:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003b64:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003b66:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8003b68:	4b31      	ldr	r3, [pc, #196]	; (8003c30 <moduleTRACKING+0x20a0>)
 8003b6a:	fb00 f101 	mul.w	r1, r0, r1
 8003b6e:	fba6 7101 	umull	r7, r1, r6, r1
 8003b72:	0b89      	lsrs	r1, r1, #14
 8003b74:	fba3 7301 	umull	r7, r3, r3, r1
 8003b78:	fba6 6202 	umull	r6, r2, r6, r2
 8003b7c:	099b      	lsrs	r3, r3, #6
 8003b7e:	fb00 1313 	mls	r3, r0, r3, r1
 8003b82:	0b92      	lsrs	r2, r2, #14
 8003b84:	492b      	ldr	r1, [pc, #172]	; (8003c34 <moduleTRACKING+0x20a4>)
 8003b86:	482c      	ldr	r0, [pc, #176]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003b88:	f00e fdaa 	bl	80126e0 <chprintf.constprop.35>
 8003b8c:	4a2b      	ldr	r2, [pc, #172]	; (8003c3c <moduleTRACKING+0x20ac>)
 8003b8e:	492c      	ldr	r1, [pc, #176]	; (8003c40 <moduleTRACKING+0x20b0>)
 8003b90:	4829      	ldr	r0, [pc, #164]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003b92:	f00e fda5 	bl	80126e0 <chprintf.constprop.35>
 8003b96:	2395      	movs	r3, #149	; 0x95
 8003b98:	4a2a      	ldr	r2, [pc, #168]	; (8003c44 <moduleTRACKING+0x20b4>)
 8003b9a:	492b      	ldr	r1, [pc, #172]	; (8003c48 <moduleTRACKING+0x20b8>)
 8003b9c:	4826      	ldr	r0, [pc, #152]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003b9e:	f00e fd9f 	bl	80126e0 <chprintf.constprop.35>
 8003ba2:	492a      	ldr	r1, [pc, #168]	; (8003c4c <moduleTRACKING+0x20bc>)
 8003ba4:	4824      	ldr	r0, [pc, #144]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003ba6:	f00e fd9b 	bl	80126e0 <chprintf.constprop.35>
 8003baa:	4929      	ldr	r1, [pc, #164]	; (8003c50 <moduleTRACKING+0x20c0>)
 8003bac:	4822      	ldr	r0, [pc, #136]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003bae:	f00e fd97 	bl	80126e0 <chprintf.constprop.35>
 8003bb2:	4928      	ldr	r1, [pc, #160]	; (8003c54 <moduleTRACKING+0x20c4>)
 8003bb4:	4820      	ldr	r0, [pc, #128]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003bb6:	f00e fd93 	bl	80126e0 <chprintf.constprop.35>
 8003bba:	481b      	ldr	r0, [pc, #108]	; (8003c28 <moduleTRACKING+0x2098>)
 8003bbc:	f00b f938 	bl	800ee30 <chMtxUnlock>
 8003bc0:	2195      	movs	r1, #149	; 0x95
 8003bc2:	4820      	ldr	r0, [pc, #128]	; (8003c44 <moduleTRACKING+0x20b4>)
 8003bc4:	f00c f9cc 	bl	800ff60 <log_error>
		lastTrackPoint->int_press = 0;
 8003bc8:	682b      	ldr	r3, [r5, #0]
 8003bca:	629c      	str	r4, [r3, #40]	; 0x28
		lastTrackPoint->int_hum = 0;
 8003bcc:	859c      	strh	r4, [r3, #44]	; 0x2c
		lastTrackPoint->int_temp = 0;
 8003bce:	85dc      	strh	r4, [r3, #46]	; 0x2e
 8003bd0:	f7fe b947 	b.w	8001e62 <moduleTRACKING+0x2d2>
			TRACE_TAB, lastTrackPoint->gps_lat/10000000, (lastTrackPoint->gps_lat > 0 ? 1:-1)*lastTrackPoint->gps_lat%10000000,
			TRACE_TAB, lastTrackPoint->gps_lon/10000000, (lastTrackPoint->gps_lon > 0 ? 1:-1)*lastTrackPoint->gps_lon%10000000,
			TRACE_TAB, lastTrackPoint->gps_alt
		);
	} else {
		TRACE_INFO("TRAC > No GPS position in memory");
 8003bd4:	f00b f98c 	bl	800eef0 <chMtxLock>
 8003bd8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003bda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003bdc:	fb05 f303 	mul.w	r3, r5, r3
 8003be0:	fba6 1303 	umull	r1, r3, r6, r3
 8003be4:	0b9b      	lsrs	r3, r3, #14
 8003be6:	fba4 0103 	umull	r0, r1, r4, r3
 8003bea:	fba6 0202 	umull	r0, r2, r6, r2
 8003bee:	0989      	lsrs	r1, r1, #6
 8003bf0:	fb05 3311 	mls	r3, r5, r1, r3
 8003bf4:	0b92      	lsrs	r2, r2, #14
 8003bf6:	490f      	ldr	r1, [pc, #60]	; (8003c34 <moduleTRACKING+0x20a4>)
 8003bf8:	480f      	ldr	r0, [pc, #60]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003bfa:	f00e fd71 	bl	80126e0 <chprintf.constprop.35>
 8003bfe:	4a16      	ldr	r2, [pc, #88]	; (8003c58 <moduleTRACKING+0x20c8>)
 8003c00:	490f      	ldr	r1, [pc, #60]	; (8003c40 <moduleTRACKING+0x20b0>)
 8003c02:	480d      	ldr	r0, [pc, #52]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003c04:	f00e fd6c 	bl	80126e0 <chprintf.constprop.35>
 8003c08:	2382      	movs	r3, #130	; 0x82
 8003c0a:	4a0e      	ldr	r2, [pc, #56]	; (8003c44 <moduleTRACKING+0x20b4>)
 8003c0c:	490e      	ldr	r1, [pc, #56]	; (8003c48 <moduleTRACKING+0x20b8>)
 8003c0e:	480a      	ldr	r0, [pc, #40]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003c10:	f00e fd66 	bl	80126e0 <chprintf.constprop.35>
 8003c14:	490d      	ldr	r1, [pc, #52]	; (8003c4c <moduleTRACKING+0x20bc>)
 8003c16:	4808      	ldr	r0, [pc, #32]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003c18:	f00e fd62 	bl	80126e0 <chprintf.constprop.35>
 8003c1c:	490f      	ldr	r1, [pc, #60]	; (8003c5c <moduleTRACKING+0x20cc>)
 8003c1e:	4806      	ldr	r0, [pc, #24]	; (8003c38 <moduleTRACKING+0x20a8>)
 8003c20:	f00e fd5e 	bl	80126e0 <chprintf.constprop.35>
 8003c24:	f7fe b8ea 	b.w	8001dfc <moduleTRACKING+0x26c>
 8003c28:	20027b2c 	.word	0x20027b2c
 8003c2c:	d1b71759 	.word	0xd1b71759
 8003c30:	10624dd3 	.word	0x10624dd3
 8003c34:	08013c50 	.word	0x08013c50
 8003c38:	20027e60 	.word	0x20027e60
 8003c3c:	08013d9c 	.word	0x08013d9c
 8003c40:	08013c5c 	.word	0x08013c5c
 8003c44:	08013c6c 	.word	0x08013c6c
 8003c48:	08013c78 	.word	0x08013c78
 8003c4c:	08013d00 	.word	0x08013d00
 8003c50:	08013da4 	.word	0x08013da4
 8003c54:	08013cac 	.word	0x08013cac
 8003c58:	08013cfc 	.word	0x08013cfc
 8003c5c:	08013d78 	.word	0x08013d78

08003c60 <moduleIMG>:
	}

	TRACE_INFO("SSDV > %i packets", i);
}

THD_FUNCTION(moduleIMG, arg) {
 8003c60:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 8003c64:	6b42      	ldr	r2, [r0, #52]	; 0x34
	}

	TRACE_INFO("SSDV > %i packets", i);
}

THD_FUNCTION(moduleIMG, arg) {
 8003c66:	b09b      	sub	sp, #108	; 0x6c
 8003c68:	4683      	mov	fp, r0
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 8003c6a:	b15a      	cbz	r2, 8003c84 <moduleIMG+0x24>
		chThdSleepMilliseconds(config->init_delay);
 8003c6c:	f644 6320 	movw	r3, #20000	; 0x4e20
 8003c70:	fb03 f302 	mul.w	r3, r3, r2
 8003c74:	48bd      	ldr	r0, [pc, #756]	; (8003f6c <moduleIMG+0x30c>)
 8003c76:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8003c7a:	fba0 3003 	umull	r3, r0, r0, r3
 8003c7e:	0980      	lsrs	r0, r0, #6
 8003c80:	f00b fa06 	bl	800f090 <chThdSleep>
 8003c84:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000

	// Print initialization message
	TRACE_INFO("IMG  > Startup module %s", config->name);
 8003c88:	48b9      	ldr	r0, [pc, #740]	; (8003f70 <moduleIMG+0x310>)
 8003c8a:	4dba      	ldr	r5, [pc, #744]	; (8003f74 <moduleIMG+0x314>)
}

void OV2640_DeinitDMA(void)
{
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamDisable(stream);
 8003c8c:	f8df a334 	ldr.w	sl, [pc, #820]	; 8003fc4 <moduleIMG+0x364>
 8003c90:	f00b f92e 	bl	800eef0 <chMtxLock>
 8003c94:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003c96:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8003c98:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003c9c:	fb00 f101 	mul.w	r1, r0, r1
 8003ca0:	fba5 3101 	umull	r3, r1, r5, r1
 8003ca4:	4bb1      	ldr	r3, [pc, #708]	; (8003f6c <moduleIMG+0x30c>)
 8003ca6:	0b89      	lsrs	r1, r1, #14
 8003ca8:	fba3 6301 	umull	r6, r3, r3, r1
 8003cac:	fba5 5202 	umull	r5, r2, r5, r2
 8003cb0:	099b      	lsrs	r3, r3, #6
 8003cb2:	fb00 1313 	mls	r3, r0, r3, r1
 8003cb6:	0b92      	lsrs	r2, r2, #14
 8003cb8:	49af      	ldr	r1, [pc, #700]	; (8003f78 <moduleIMG+0x318>)
 8003cba:	48b0      	ldr	r0, [pc, #704]	; (8003f7c <moduleIMG+0x31c>)
 8003cbc:	f00e fd10 	bl	80126e0 <chprintf.constprop.35>
 8003cc0:	4aaf      	ldr	r2, [pc, #700]	; (8003f80 <moduleIMG+0x320>)
 8003cc2:	49b0      	ldr	r1, [pc, #704]	; (8003f84 <moduleIMG+0x324>)
 8003cc4:	48ad      	ldr	r0, [pc, #692]	; (8003f7c <moduleIMG+0x31c>)
 8003cc6:	f00e fd0b 	bl	80126e0 <chprintf.constprop.35>
 8003cca:	2373      	movs	r3, #115	; 0x73
 8003ccc:	4aae      	ldr	r2, [pc, #696]	; (8003f88 <moduleIMG+0x328>)
 8003cce:	49af      	ldr	r1, [pc, #700]	; (8003f8c <moduleIMG+0x32c>)
 8003cd0:	48aa      	ldr	r0, [pc, #680]	; (8003f7c <moduleIMG+0x31c>)
 8003cd2:	f00e fd05 	bl	80126e0 <chprintf.constprop.35>
 8003cd6:	49ae      	ldr	r1, [pc, #696]	; (8003f90 <moduleIMG+0x330>)
 8003cd8:	48a8      	ldr	r0, [pc, #672]	; (8003f7c <moduleIMG+0x31c>)
 8003cda:	f00e fd01 	bl	80126e0 <chprintf.constprop.35>
 8003cde:	465a      	mov	r2, fp
 8003ce0:	49ac      	ldr	r1, [pc, #688]	; (8003f94 <moduleIMG+0x334>)
 8003ce2:	48a6      	ldr	r0, [pc, #664]	; (8003f7c <moduleIMG+0x31c>)
 8003ce4:	f00e fcfc 	bl	80126e0 <chprintf.constprop.35>
 8003ce8:	49ab      	ldr	r1, [pc, #684]	; (8003f98 <moduleIMG+0x338>)
 8003cea:	48a4      	ldr	r0, [pc, #656]	; (8003f7c <moduleIMG+0x31c>)
 8003cec:	f00e fcf8 	bl	80126e0 <chprintf.constprop.35>
 8003cf0:	489f      	ldr	r0, [pc, #636]	; (8003f70 <moduleIMG+0x310>)
 8003cf2:	f00b f89d 	bl	800ee30 <chMtxUnlock>
 8003cf6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003cf8:	9300      	str	r3, [sp, #0]
 8003cfa:	f10b 033c 	add.w	r3, fp, #60	; 0x3c
 8003cfe:	9301      	str	r3, [sp, #4]
 8003d00:	f50b 7386 	add.w	r3, fp, #268	; 0x10c
 8003d04:	9303      	str	r3, [sp, #12]
 8003d06:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("IMG  > Do module IMAGE cycle");
 8003d0a:	4899      	ldr	r0, [pc, #612]	; (8003f70 <moduleIMG+0x310>)
 8003d0c:	4e99      	ldr	r6, [pc, #612]	; (8003f74 <moduleIMG+0x314>)
 8003d0e:	4f97      	ldr	r7, [pc, #604]	; (8003f6c <moduleIMG+0x30c>)
 8003d10:	f00b f8ee 	bl	800eef0 <chMtxLock>
 8003d14:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003d16:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003d18:	4997      	ldr	r1, [pc, #604]	; (8003f78 <moduleIMG+0x318>)
 8003d1a:	4898      	ldr	r0, [pc, #608]	; (8003f7c <moduleIMG+0x31c>)
 8003d1c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8003d20:	fb05 fe03 	mul.w	lr, r5, r3
 8003d24:	fba6 3e0e 	umull	r3, lr, r6, lr
 8003d28:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 8003d2c:	fba7 c30e 	umull	ip, r3, r7, lr
 8003d30:	fba6 c202 	umull	ip, r2, r6, r2
 8003d34:	099b      	lsrs	r3, r3, #6
 8003d36:	fb05 e313 	mls	r3, r5, r3, lr
 8003d3a:	0b92      	lsrs	r2, r2, #14
 8003d3c:	f00e fcd0 	bl	80126e0 <chprintf.constprop.35>
 8003d40:	4a8f      	ldr	r2, [pc, #572]	; (8003f80 <moduleIMG+0x320>)
 8003d42:	4990      	ldr	r1, [pc, #576]	; (8003f84 <moduleIMG+0x324>)
 8003d44:	488d      	ldr	r0, [pc, #564]	; (8003f7c <moduleIMG+0x31c>)
 8003d46:	f00e fccb 	bl	80126e0 <chprintf.constprop.35>
 8003d4a:	2378      	movs	r3, #120	; 0x78
 8003d4c:	4a8e      	ldr	r2, [pc, #568]	; (8003f88 <moduleIMG+0x328>)
 8003d4e:	498f      	ldr	r1, [pc, #572]	; (8003f8c <moduleIMG+0x32c>)
 8003d50:	488a      	ldr	r0, [pc, #552]	; (8003f7c <moduleIMG+0x31c>)
 8003d52:	f00e fcc5 	bl	80126e0 <chprintf.constprop.35>
 8003d56:	498e      	ldr	r1, [pc, #568]	; (8003f90 <moduleIMG+0x330>)
 8003d58:	4888      	ldr	r0, [pc, #544]	; (8003f7c <moduleIMG+0x31c>)
 8003d5a:	f00e fcc1 	bl	80126e0 <chprintf.constprop.35>
 8003d5e:	498f      	ldr	r1, [pc, #572]	; (8003f9c <moduleIMG+0x33c>)
 8003d60:	4886      	ldr	r0, [pc, #536]	; (8003f7c <moduleIMG+0x31c>)
 8003d62:	f00e fcbd 	bl	80126e0 <chprintf.constprop.35>
 8003d66:	498c      	ldr	r1, [pc, #560]	; (8003f98 <moduleIMG+0x338>)
 8003d68:	4884      	ldr	r0, [pc, #528]	; (8003f7c <moduleIMG+0x31c>)
 8003d6a:	f00e fcb9 	bl	80126e0 <chprintf.constprop.35>
 8003d6e:	4880      	ldr	r0, [pc, #512]	; (8003f70 <moduleIMG+0x310>)
 8003d70:	f00b f85e 	bl	800ee30 <chMtxUnlock>
 8003d74:	6a63      	ldr	r3, [r4, #36]	; 0x24
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer
 8003d76:	f8cb 31b0 	str.w	r3, [fp, #432]	; 0x1b0

		if(!p_sleep(&config->sleep_config))
 8003d7a:	9801      	ldr	r0, [sp, #4]
 8003d7c:	f00e faf8 	bl	8012370 <p_sleep>
 8003d80:	2800      	cmp	r0, #0
 8003d82:	f040 8225 	bne.w	80041d0 <moduleIMG+0x570>
		{
			uint32_t image_len = 0;
			uint8_t *image;

			// Take photo if camera activated (if camera disabled, camera buffer is probably shared in config file)
			if(!config->ssdv_config.no_camera)
 8003d86:	f89b 8120 	ldrb.w	r8, [fp, #288]	; 0x120
 8003d8a:	f1b8 0f00 	cmp.w	r8, #0
 8003d8e:	f040 817f 	bne.w	8004090 <moduleIMG+0x430>
			{
				// Lock camera
				TRACE_INFO("IMG  > Lock camera");
 8003d92:	4877      	ldr	r0, [pc, #476]	; (8003f70 <moduleIMG+0x310>)
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 8003d94:	f8df 9230 	ldr.w	r9, [pc, #560]	; 8003fc8 <moduleIMG+0x368>
 8003d98:	f00b f8aa 	bl	800eef0 <chMtxLock>
 8003d9c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003d9e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003da0:	4975      	ldr	r1, [pc, #468]	; (8003f78 <moduleIMG+0x318>)
 8003da2:	fb05 f303 	mul.w	r3, r5, r3
 8003da6:	fba6 0303 	umull	r0, r3, r6, r3
 8003daa:	0b9b      	lsrs	r3, r3, #14
 8003dac:	fba7 e003 	umull	lr, r0, r7, r3
 8003db0:	fba6 e202 	umull	lr, r2, r6, r2
 8003db4:	0980      	lsrs	r0, r0, #6
 8003db6:	fb05 3310 	mls	r3, r5, r0, r3
 8003dba:	0b92      	lsrs	r2, r2, #14
 8003dbc:	486f      	ldr	r0, [pc, #444]	; (8003f7c <moduleIMG+0x31c>)
 8003dbe:	f00e fc8f 	bl	80126e0 <chprintf.constprop.35>
 8003dc2:	4a6f      	ldr	r2, [pc, #444]	; (8003f80 <moduleIMG+0x320>)
 8003dc4:	496f      	ldr	r1, [pc, #444]	; (8003f84 <moduleIMG+0x324>)
 8003dc6:	486d      	ldr	r0, [pc, #436]	; (8003f7c <moduleIMG+0x31c>)
 8003dc8:	f00e fc8a 	bl	80126e0 <chprintf.constprop.35>
 8003dcc:	2384      	movs	r3, #132	; 0x84
 8003dce:	4a6e      	ldr	r2, [pc, #440]	; (8003f88 <moduleIMG+0x328>)
 8003dd0:	496e      	ldr	r1, [pc, #440]	; (8003f8c <moduleIMG+0x32c>)
 8003dd2:	486a      	ldr	r0, [pc, #424]	; (8003f7c <moduleIMG+0x31c>)
 8003dd4:	f00e fc84 	bl	80126e0 <chprintf.constprop.35>
 8003dd8:	496d      	ldr	r1, [pc, #436]	; (8003f90 <moduleIMG+0x330>)
 8003dda:	4868      	ldr	r0, [pc, #416]	; (8003f7c <moduleIMG+0x31c>)
 8003ddc:	f00e fc80 	bl	80126e0 <chprintf.constprop.35>
 8003de0:	496f      	ldr	r1, [pc, #444]	; (8003fa0 <moduleIMG+0x340>)
 8003de2:	4866      	ldr	r0, [pc, #408]	; (8003f7c <moduleIMG+0x31c>)
 8003de4:	f00e fc7c 	bl	80126e0 <chprintf.constprop.35>
 8003de8:	496b      	ldr	r1, [pc, #428]	; (8003f98 <moduleIMG+0x338>)
 8003dea:	4864      	ldr	r0, [pc, #400]	; (8003f7c <moduleIMG+0x31c>)
 8003dec:	f00e fc78 	bl	80126e0 <chprintf.constprop.35>
 8003df0:	485f      	ldr	r0, [pc, #380]	; (8003f70 <moduleIMG+0x310>)
 8003df2:	f00b f81d 	bl	800ee30 <chMtxUnlock>
				chMtxLock(&camera_mtx);
 8003df6:	486b      	ldr	r0, [pc, #428]	; (8003fa4 <moduleIMG+0x344>)
 8003df8:	f00b f87a 	bl	800eef0 <chMtxLock>
				TRACE_INFO("IMG  > Locked camera");
 8003dfc:	485c      	ldr	r0, [pc, #368]	; (8003f70 <moduleIMG+0x310>)
 8003dfe:	f00b f877 	bl	800eef0 <chMtxLock>
 8003e02:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003e04:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003e06:	495c      	ldr	r1, [pc, #368]	; (8003f78 <moduleIMG+0x318>)
 8003e08:	fb05 f303 	mul.w	r3, r5, r3
 8003e0c:	fba6 0303 	umull	r0, r3, r6, r3
 8003e10:	0b9b      	lsrs	r3, r3, #14
 8003e12:	fba7 e003 	umull	lr, r0, r7, r3
 8003e16:	fba6 e202 	umull	lr, r2, r6, r2
 8003e1a:	0980      	lsrs	r0, r0, #6
 8003e1c:	fb05 3310 	mls	r3, r5, r0, r3
 8003e20:	0b92      	lsrs	r2, r2, #14
 8003e22:	4856      	ldr	r0, [pc, #344]	; (8003f7c <moduleIMG+0x31c>)
 8003e24:	f00e fc5c 	bl	80126e0 <chprintf.constprop.35>
 8003e28:	4a55      	ldr	r2, [pc, #340]	; (8003f80 <moduleIMG+0x320>)
 8003e2a:	4956      	ldr	r1, [pc, #344]	; (8003f84 <moduleIMG+0x324>)
 8003e2c:	4853      	ldr	r0, [pc, #332]	; (8003f7c <moduleIMG+0x31c>)
 8003e2e:	f00e fc57 	bl	80126e0 <chprintf.constprop.35>
 8003e32:	2386      	movs	r3, #134	; 0x86
 8003e34:	4a54      	ldr	r2, [pc, #336]	; (8003f88 <moduleIMG+0x328>)
 8003e36:	4955      	ldr	r1, [pc, #340]	; (8003f8c <moduleIMG+0x32c>)
 8003e38:	4850      	ldr	r0, [pc, #320]	; (8003f7c <moduleIMG+0x31c>)
 8003e3a:	f00e fc51 	bl	80126e0 <chprintf.constprop.35>
 8003e3e:	4954      	ldr	r1, [pc, #336]	; (8003f90 <moduleIMG+0x330>)
 8003e40:	484e      	ldr	r0, [pc, #312]	; (8003f7c <moduleIMG+0x31c>)
 8003e42:	f00e fc4d 	bl	80126e0 <chprintf.constprop.35>
 8003e46:	4958      	ldr	r1, [pc, #352]	; (8003fa8 <moduleIMG+0x348>)
 8003e48:	484c      	ldr	r0, [pc, #304]	; (8003f7c <moduleIMG+0x31c>)
 8003e4a:	f00e fc49 	bl	80126e0 <chprintf.constprop.35>
 8003e4e:	4952      	ldr	r1, [pc, #328]	; (8003f98 <moduleIMG+0x338>)
 8003e50:	484a      	ldr	r0, [pc, #296]	; (8003f7c <moduleIMG+0x31c>)
 8003e52:	f00e fc45 	bl	80126e0 <chprintf.constprop.35>
 8003e56:	4846      	ldr	r0, [pc, #280]	; (8003f70 <moduleIMG+0x310>)
 8003e58:	f00a ffea 	bl	800ee30 <chMtxUnlock>

				// Lock RADIO from producing interferences
				TRACE_INFO("IMG  > Lock radio");
 8003e5c:	4844      	ldr	r0, [pc, #272]	; (8003f70 <moduleIMG+0x310>)
 8003e5e:	f00b f847 	bl	800eef0 <chMtxLock>
 8003e62:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003e64:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003e66:	4944      	ldr	r1, [pc, #272]	; (8003f78 <moduleIMG+0x318>)
 8003e68:	fb05 f303 	mul.w	r3, r5, r3
 8003e6c:	fba6 0303 	umull	r0, r3, r6, r3
 8003e70:	0b9b      	lsrs	r3, r3, #14
 8003e72:	fba7 e003 	umull	lr, r0, r7, r3
 8003e76:	fba6 e202 	umull	lr, r2, r6, r2
 8003e7a:	0980      	lsrs	r0, r0, #6
 8003e7c:	fb05 3310 	mls	r3, r5, r0, r3
 8003e80:	0b92      	lsrs	r2, r2, #14
 8003e82:	483e      	ldr	r0, [pc, #248]	; (8003f7c <moduleIMG+0x31c>)
 8003e84:	f00e fc2c 	bl	80126e0 <chprintf.constprop.35>
 8003e88:	4a3d      	ldr	r2, [pc, #244]	; (8003f80 <moduleIMG+0x320>)
 8003e8a:	493e      	ldr	r1, [pc, #248]	; (8003f84 <moduleIMG+0x324>)
 8003e8c:	483b      	ldr	r0, [pc, #236]	; (8003f7c <moduleIMG+0x31c>)
 8003e8e:	f00e fc27 	bl	80126e0 <chprintf.constprop.35>
 8003e92:	2389      	movs	r3, #137	; 0x89
 8003e94:	4a3c      	ldr	r2, [pc, #240]	; (8003f88 <moduleIMG+0x328>)
 8003e96:	493d      	ldr	r1, [pc, #244]	; (8003f8c <moduleIMG+0x32c>)
 8003e98:	4838      	ldr	r0, [pc, #224]	; (8003f7c <moduleIMG+0x31c>)
 8003e9a:	f00e fc21 	bl	80126e0 <chprintf.constprop.35>
 8003e9e:	493c      	ldr	r1, [pc, #240]	; (8003f90 <moduleIMG+0x330>)
 8003ea0:	4836      	ldr	r0, [pc, #216]	; (8003f7c <moduleIMG+0x31c>)
 8003ea2:	f00e fc1d 	bl	80126e0 <chprintf.constprop.35>
 8003ea6:	4941      	ldr	r1, [pc, #260]	; (8003fac <moduleIMG+0x34c>)
 8003ea8:	4834      	ldr	r0, [pc, #208]	; (8003f7c <moduleIMG+0x31c>)
 8003eaa:	f00e fc19 	bl	80126e0 <chprintf.constprop.35>
 8003eae:	493a      	ldr	r1, [pc, #232]	; (8003f98 <moduleIMG+0x338>)
 8003eb0:	4832      	ldr	r0, [pc, #200]	; (8003f7c <moduleIMG+0x31c>)
 8003eb2:	f00e fc15 	bl	80126e0 <chprintf.constprop.35>
 8003eb6:	482e      	ldr	r0, [pc, #184]	; (8003f70 <moduleIMG+0x310>)
 8003eb8:	f00a ffba 	bl	800ee30 <chMtxUnlock>
				chMtxLock(&interference_mtx);
 8003ebc:	483c      	ldr	r0, [pc, #240]	; (8003fb0 <moduleIMG+0x350>)
 8003ebe:	f00b f817 	bl	800eef0 <chMtxLock>
				TRACE_INFO("IMG  > Locked radio");
 8003ec2:	482b      	ldr	r0, [pc, #172]	; (8003f70 <moduleIMG+0x310>)
 8003ec4:	f00b f814 	bl	800eef0 <chMtxLock>
 8003ec8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003eca:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003ecc:	492a      	ldr	r1, [pc, #168]	; (8003f78 <moduleIMG+0x318>)
 8003ece:	fb05 f303 	mul.w	r3, r5, r3
 8003ed2:	fba6 0303 	umull	r0, r3, r6, r3
 8003ed6:	0b9b      	lsrs	r3, r3, #14
 8003ed8:	fba7 e003 	umull	lr, r0, r7, r3
 8003edc:	fba6 e202 	umull	lr, r2, r6, r2
 8003ee0:	0980      	lsrs	r0, r0, #6
 8003ee2:	fb05 3310 	mls	r3, r5, r0, r3
 8003ee6:	0b92      	lsrs	r2, r2, #14
 8003ee8:	4824      	ldr	r0, [pc, #144]	; (8003f7c <moduleIMG+0x31c>)
 8003eea:	f00e fbf9 	bl	80126e0 <chprintf.constprop.35>
 8003eee:	4a24      	ldr	r2, [pc, #144]	; (8003f80 <moduleIMG+0x320>)
 8003ef0:	4924      	ldr	r1, [pc, #144]	; (8003f84 <moduleIMG+0x324>)
 8003ef2:	4822      	ldr	r0, [pc, #136]	; (8003f7c <moduleIMG+0x31c>)
 8003ef4:	f00e fbf4 	bl	80126e0 <chprintf.constprop.35>
 8003ef8:	238b      	movs	r3, #139	; 0x8b
 8003efa:	4a23      	ldr	r2, [pc, #140]	; (8003f88 <moduleIMG+0x328>)
 8003efc:	4923      	ldr	r1, [pc, #140]	; (8003f8c <moduleIMG+0x32c>)
 8003efe:	481f      	ldr	r0, [pc, #124]	; (8003f7c <moduleIMG+0x31c>)
 8003f00:	f00e fbee 	bl	80126e0 <chprintf.constprop.35>
 8003f04:	4922      	ldr	r1, [pc, #136]	; (8003f90 <moduleIMG+0x330>)
 8003f06:	481d      	ldr	r0, [pc, #116]	; (8003f7c <moduleIMG+0x31c>)
 8003f08:	f00e fbea 	bl	80126e0 <chprintf.constprop.35>
 8003f0c:	4929      	ldr	r1, [pc, #164]	; (8003fb4 <moduleIMG+0x354>)
 8003f0e:	481b      	ldr	r0, [pc, #108]	; (8003f7c <moduleIMG+0x31c>)
 8003f10:	f00e fbe6 	bl	80126e0 <chprintf.constprop.35>
 8003f14:	4920      	ldr	r1, [pc, #128]	; (8003f98 <moduleIMG+0x338>)
 8003f16:	4819      	ldr	r0, [pc, #100]	; (8003f7c <moduleIMG+0x31c>)
 8003f18:	f00e fbe2 	bl	80126e0 <chprintf.constprop.35>
 8003f1c:	4814      	ldr	r0, [pc, #80]	; (8003f70 <moduleIMG+0x310>)
 8003f1e:	f00a ff87 	bl	800ee30 <chMtxUnlock>
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 8003f22:	4b25      	ldr	r3, [pc, #148]	; (8003fb8 <moduleIMG+0x358>)
	initialized[radio] = false;
 8003f24:	4a25      	ldr	r2, [pc, #148]	; (8003fbc <moduleIMG+0x35c>)
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 8003f26:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 8003fcc <moduleIMG+0x36c>
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 8003f2a:	4825      	ldr	r0, [pc, #148]	; (8003fc0 <moduleIMG+0x360>)
 8003f2c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8003f30:	f8c9 1018 	str.w	r1, [r9, #24]
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 8003f34:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 8003f38:	6199      	str	r1, [r3, #24]
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 8003f3a:	2140      	movs	r1, #64	; 0x40
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
	initialized[radio] = false;
 8003f3c:	f882 8001 	strb.w	r8, [r2, #1]
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 8003f40:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 8003f44:	f8ce 1018 	str.w	r1, [lr, #24]
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 8003f48:	619a      	str	r2, [r3, #24]
	initialized[radio] = false;
 8003f4a:	4b1c      	ldr	r3, [pc, #112]	; (8003fbc <moduleIMG+0x35c>)
 8003f4c:	f883 8002 	strb.w	r8, [r3, #2]
 8003f50:	f00a ffce 	bl	800eef0 <chMtxLock>
}

bool OV2640_isAvailable(void)
{
	I2C_lock();
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch on camera
 8003f54:	f04f 0308 	mov.w	r3, #8

	chThdSleepMilliseconds(100);
 8003f58:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
}

bool OV2640_isAvailable(void)
{
	I2C_lock();
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch on camera
 8003f5c:	f8a9 3018 	strh.w	r3, [r9, #24]

	chThdSleepMilliseconds(100);
 8003f60:	f00b f896 	bl	800f090 <chThdSleep>

	uint16_t val;
	bool ret;
	if(I2C_read16_locked(OV2640_I2C_ADR, 0x0A, &val))
 8003f64:	aa13      	add	r2, sp, #76	; 0x4c
 8003f66:	210a      	movs	r1, #10
 8003f68:	2030      	movs	r0, #48	; 0x30
 8003f6a:	e031      	b.n	8003fd0 <moduleIMG+0x370>
 8003f6c:	10624dd3 	.word	0x10624dd3
 8003f70:	20027b2c 	.word	0x20027b2c
 8003f74:	d1b71759 	.word	0xd1b71759
 8003f78:	08013c50 	.word	0x08013c50
 8003f7c:	20027e60 	.word	0x20027e60
 8003f80:	08013cfc 	.word	0x08013cfc
 8003f84:	08013c5c 	.word	0x08013c5c
 8003f88:	08014340 	.word	0x08014340
 8003f8c:	08013c78 	.word	0x08013c78
 8003f90:	08013d00 	.word	0x08013d00
 8003f94:	08014348 	.word	0x08014348
 8003f98:	08013cac 	.word	0x08013cac
 8003f9c:	08014364 	.word	0x08014364
 8003fa0:	08014384 	.word	0x08014384
 8003fa4:	2002772c 	.word	0x2002772c
 8003fa8:	08014398 	.word	0x08014398
 8003fac:	080143b0 	.word	0x080143b0
 8003fb0:	20027770 	.word	0x20027770
 8003fb4:	080143c4 	.word	0x080143c4
 8003fb8:	40020c00 	.word	0x40020c00
 8003fbc:	20027e18 	.word	0x20027e18
 8003fc0:	200278f8 	.word	0x200278f8
 8003fc4:	40026428 	.word	0x40026428
 8003fc8:	40021000 	.word	0x40021000
 8003fcc:	40021800 	.word	0x40021800
 8003fd0:	f006 f9b6 	bl	800a340 <I2C_read16_locked>
 8003fd4:	2800      	cmp	r0, #0
 8003fd6:	f000 8123 	beq.w	8004220 <moduleIMG+0x5c0>
		ret = val == PID_OV2640;
	else
		ret = false;

	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 8003fda:	f04f 0308 	mov.w	r3, #8
	chThdSleepMilliseconds(100);

	uint16_t val;
	bool ret;
	if(I2C_read16_locked(OV2640_I2C_ADR, 0x0A, &val))
		ret = val == PID_OV2640;
 8003fde:	f8bd 804c 	ldrh.w	r8, [sp, #76]	; 0x4c
/**
  * Unlocks all other I2C threads to access I2C
  */
void I2C_unlock(void)
{
	chMtxUnlock(&pi2c_mtx);
 8003fe2:	487f      	ldr	r0, [pc, #508]	; (80041e0 <moduleIMG+0x580>)
	else
		ret = false;

	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 8003fe4:	f8a9 301a 	strh.w	r3, [r9, #26]
 8003fe8:	f00a ff22 	bl	800ee30 <chMtxUnlock>

				uint8_t tries;
				bool status = false;

				// Detect camera
				if(OV2640_isAvailable()) // OV2640 available
 8003fec:	f242 6326 	movw	r3, #9766	; 0x2626
 8003ff0:	4598      	cmp	r8, r3
 8003ff2:	f040 811c 	bne.w	800422e <moduleIMG+0x5ce>
				{
					TRACE_INFO("IMG  > OV2640 found");
 8003ff6:	487b      	ldr	r0, [pc, #492]	; (80041e4 <moduleIMG+0x584>)
 8003ff8:	f00a ff7a 	bl	800eef0 <chMtxLock>
 8003ffc:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003ffe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004000:	4979      	ldr	r1, [pc, #484]	; (80041e8 <moduleIMG+0x588>)
 8004002:	fb05 f303 	mul.w	r3, r5, r3
 8004006:	fba6 0303 	umull	r0, r3, r6, r3
 800400a:	0b9b      	lsrs	r3, r3, #14
 800400c:	fba7 4003 	umull	r4, r0, r7, r3
 8004010:	0980      	lsrs	r0, r0, #6
 8004012:	fba6 4202 	umull	r4, r2, r6, r2
 8004016:	fb05 3310 	mls	r3, r5, r0, r3
 800401a:	0b92      	lsrs	r2, r2, #14
 800401c:	4873      	ldr	r0, [pc, #460]	; (80041ec <moduleIMG+0x58c>)
 800401e:	f00e fb5f 	bl	80126e0 <chprintf.constprop.35>
 8004022:	4a73      	ldr	r2, [pc, #460]	; (80041f0 <moduleIMG+0x590>)
 8004024:	4973      	ldr	r1, [pc, #460]	; (80041f4 <moduleIMG+0x594>)
 8004026:	4871      	ldr	r0, [pc, #452]	; (80041ec <moduleIMG+0x58c>)
 8004028:	f00e fb5a 	bl	80126e0 <chprintf.constprop.35>
 800402c:	2397      	movs	r3, #151	; 0x97
 800402e:	4a72      	ldr	r2, [pc, #456]	; (80041f8 <moduleIMG+0x598>)
 8004030:	4972      	ldr	r1, [pc, #456]	; (80041fc <moduleIMG+0x59c>)
 8004032:	486e      	ldr	r0, [pc, #440]	; (80041ec <moduleIMG+0x58c>)
 8004034:	f00e fb54 	bl	80126e0 <chprintf.constprop.35>
 8004038:	4971      	ldr	r1, [pc, #452]	; (8004200 <moduleIMG+0x5a0>)
 800403a:	486c      	ldr	r0, [pc, #432]	; (80041ec <moduleIMG+0x58c>)
 800403c:	f00e fb50 	bl	80126e0 <chprintf.constprop.35>
 8004040:	4970      	ldr	r1, [pc, #448]	; (8004204 <moduleIMG+0x5a4>)
 8004042:	486a      	ldr	r0, [pc, #424]	; (80041ec <moduleIMG+0x58c>)
 8004044:	f00e fb4c 	bl	80126e0 <chprintf.constprop.35>
 8004048:	496f      	ldr	r1, [pc, #444]	; (8004208 <moduleIMG+0x5a8>)
 800404a:	4868      	ldr	r0, [pc, #416]	; (80041ec <moduleIMG+0x58c>)
 800404c:	f00e fb48 	bl	80126e0 <chprintf.constprop.35>
 8004050:	4864      	ldr	r0, [pc, #400]	; (80041e4 <moduleIMG+0x584>)
 8004052:	f00a feed 	bl	800ee30 <chMtxUnlock>

					if(config->ssdv_config.res == RES_MAX) // Attempt maximum resolution (limited by memory)
 8004056:	f89b 4114 	ldrb.w	r4, [fp, #276]	; 0x114
 800405a:	2c05      	cmp	r4, #5
 800405c:	f040 826a 	bne.w	8004534 <moduleIMG+0x8d4>
					{
						config->ssdv_config.res = RES_UXGA; // Try maximum resolution
 8004060:	2304      	movs	r3, #4

						do {

							// Init camera
							OV2640_init(&config->ssdv_config);
 8004062:	9803      	ldr	r0, [sp, #12]
				{
					TRACE_INFO("IMG  > OV2640 found");

					if(config->ssdv_config.res == RES_MAX) // Attempt maximum resolution (limited by memory)
					{
						config->ssdv_config.res = RES_UXGA; // Try maximum resolution
 8004064:	f88b 3114 	strb.w	r3, [fp, #276]	; 0x114

						do {

							// Init camera
							OV2640_init(&config->ssdv_config);
 8004068:	f00b f96a 	bl	800f340 <OV2640_init>

							// Sample data from DCMI through DMA into RAM
							tries = 5; // Try 5 times at maximum
							do { // Try capturing image until capture successful
								status = OV2640_Snapshot2RAM();
 800406c:	f00b fc60 	bl	800f930 <OV2640_Snapshot2RAM>
							} while(!status && --tries);
 8004070:	b918      	cbnz	r0, 800407a <moduleIMG+0x41a>
 8004072:	1e63      	subs	r3, r4, #1
 8004074:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 8004078:	d1f8      	bne.n	800406c <moduleIMG+0x40c>
{
	return OV2640_getBuffer(NULL) > ov2640_config->ram_size-3;
}

uint32_t OV2640_getBuffer(uint8_t** buffer) {
	*buffer = ov2640_config->ram_buffer;
 800407a:	4a64      	ldr	r2, [pc, #400]	; (800420c <moduleIMG+0x5ac>)

							config->ssdv_config.res--; // Decrement resolution in next attempt (if status==false)
 800407c:	f89b 3114 	ldrb.w	r3, [fp, #276]	; 0x114
 8004080:	6811      	ldr	r1, [r2, #0]
 8004082:	2200      	movs	r2, #0
 8004084:	68c9      	ldr	r1, [r1, #12]
 8004086:	3b01      	subs	r3, #1
 8004088:	f88b 3114 	strb.w	r3, [fp, #276]	; 0x114
 800408c:	6011      	str	r1, [r2, #0]
 800408e:	deff      	udf	#255	; 0xff
					encode_ssdv(image, image_len, config, gimage_id);
				}

			} else {

				image_len = OV2640_getBuffer(&image);
 8004090:	a809      	add	r0, sp, #36	; 0x24
 8004092:	f00b fc35 	bl	800f900 <OV2640_getBuffer>
 8004096:	4680      	mov	r8, r0
				TRACE_INFO("IMG  > Image size: %d bytes", image_len);
 8004098:	4852      	ldr	r0, [pc, #328]	; (80041e4 <moduleIMG+0x584>)

				TRACE_INFO("IMG  > Camera disabled");
				TRACE_INFO("IMG  > Encode/Transmit SSDV ID=%d", gimage_id);
 800409a:	f8df 9180 	ldr.w	r9, [pc, #384]	; 800421c <moduleIMG+0x5bc>
				}

			} else {

				image_len = OV2640_getBuffer(&image);
				TRACE_INFO("IMG  > Image size: %d bytes", image_len);
 800409e:	f00a ff27 	bl	800eef0 <chMtxLock>
 80040a2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80040a4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80040a6:	4950      	ldr	r1, [pc, #320]	; (80041e8 <moduleIMG+0x588>)
 80040a8:	fb05 f303 	mul.w	r3, r5, r3
 80040ac:	fba6 0303 	umull	r0, r3, r6, r3
 80040b0:	0b9b      	lsrs	r3, r3, #14
 80040b2:	fba7 e003 	umull	lr, r0, r7, r3
 80040b6:	fba6 e202 	umull	lr, r2, r6, r2
 80040ba:	0980      	lsrs	r0, r0, #6
 80040bc:	fb05 3310 	mls	r3, r5, r0, r3
 80040c0:	0b92      	lsrs	r2, r2, #14
 80040c2:	484a      	ldr	r0, [pc, #296]	; (80041ec <moduleIMG+0x58c>)
 80040c4:	f00e fb0c 	bl	80126e0 <chprintf.constprop.35>
 80040c8:	4a49      	ldr	r2, [pc, #292]	; (80041f0 <moduleIMG+0x590>)
 80040ca:	494a      	ldr	r1, [pc, #296]	; (80041f4 <moduleIMG+0x594>)
 80040cc:	4847      	ldr	r0, [pc, #284]	; (80041ec <moduleIMG+0x58c>)
 80040ce:	f00e fb07 	bl	80126e0 <chprintf.constprop.35>
 80040d2:	23e2      	movs	r3, #226	; 0xe2
 80040d4:	4a48      	ldr	r2, [pc, #288]	; (80041f8 <moduleIMG+0x598>)
 80040d6:	4949      	ldr	r1, [pc, #292]	; (80041fc <moduleIMG+0x59c>)
 80040d8:	4844      	ldr	r0, [pc, #272]	; (80041ec <moduleIMG+0x58c>)
 80040da:	f00e fb01 	bl	80126e0 <chprintf.constprop.35>
 80040de:	4948      	ldr	r1, [pc, #288]	; (8004200 <moduleIMG+0x5a0>)
 80040e0:	4842      	ldr	r0, [pc, #264]	; (80041ec <moduleIMG+0x58c>)
 80040e2:	f00e fafd 	bl	80126e0 <chprintf.constprop.35>
 80040e6:	4642      	mov	r2, r8
 80040e8:	4949      	ldr	r1, [pc, #292]	; (8004210 <moduleIMG+0x5b0>)
 80040ea:	4840      	ldr	r0, [pc, #256]	; (80041ec <moduleIMG+0x58c>)
 80040ec:	f00e faf8 	bl	80126e0 <chprintf.constprop.35>
 80040f0:	4945      	ldr	r1, [pc, #276]	; (8004208 <moduleIMG+0x5a8>)
 80040f2:	483e      	ldr	r0, [pc, #248]	; (80041ec <moduleIMG+0x58c>)
 80040f4:	f00e faf4 	bl	80126e0 <chprintf.constprop.35>
 80040f8:	483a      	ldr	r0, [pc, #232]	; (80041e4 <moduleIMG+0x584>)
 80040fa:	f00a fe99 	bl	800ee30 <chMtxUnlock>

				TRACE_INFO("IMG  > Camera disabled");
 80040fe:	4839      	ldr	r0, [pc, #228]	; (80041e4 <moduleIMG+0x584>)
 8004100:	f00a fef6 	bl	800eef0 <chMtxLock>
 8004104:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004106:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004108:	4937      	ldr	r1, [pc, #220]	; (80041e8 <moduleIMG+0x588>)
 800410a:	fb05 f303 	mul.w	r3, r5, r3
 800410e:	fba6 0303 	umull	r0, r3, r6, r3
 8004112:	0b9b      	lsrs	r3, r3, #14
 8004114:	fba7 e003 	umull	lr, r0, r7, r3
 8004118:	fba6 e202 	umull	lr, r2, r6, r2
 800411c:	0980      	lsrs	r0, r0, #6
 800411e:	fb05 3310 	mls	r3, r5, r0, r3
 8004122:	0b92      	lsrs	r2, r2, #14
 8004124:	4831      	ldr	r0, [pc, #196]	; (80041ec <moduleIMG+0x58c>)
 8004126:	f00e fadb 	bl	80126e0 <chprintf.constprop.35>
 800412a:	4a31      	ldr	r2, [pc, #196]	; (80041f0 <moduleIMG+0x590>)
 800412c:	4931      	ldr	r1, [pc, #196]	; (80041f4 <moduleIMG+0x594>)
 800412e:	482f      	ldr	r0, [pc, #188]	; (80041ec <moduleIMG+0x58c>)
 8004130:	f00e fad6 	bl	80126e0 <chprintf.constprop.35>
 8004134:	23e4      	movs	r3, #228	; 0xe4
 8004136:	4a30      	ldr	r2, [pc, #192]	; (80041f8 <moduleIMG+0x598>)
 8004138:	4930      	ldr	r1, [pc, #192]	; (80041fc <moduleIMG+0x59c>)
 800413a:	482c      	ldr	r0, [pc, #176]	; (80041ec <moduleIMG+0x58c>)
 800413c:	f00e fad0 	bl	80126e0 <chprintf.constprop.35>
 8004140:	492f      	ldr	r1, [pc, #188]	; (8004200 <moduleIMG+0x5a0>)
 8004142:	482a      	ldr	r0, [pc, #168]	; (80041ec <moduleIMG+0x58c>)
 8004144:	f00e facc 	bl	80126e0 <chprintf.constprop.35>
 8004148:	4932      	ldr	r1, [pc, #200]	; (8004214 <moduleIMG+0x5b4>)
 800414a:	4828      	ldr	r0, [pc, #160]	; (80041ec <moduleIMG+0x58c>)
 800414c:	f00e fac8 	bl	80126e0 <chprintf.constprop.35>
 8004150:	492d      	ldr	r1, [pc, #180]	; (8004208 <moduleIMG+0x5a8>)
 8004152:	4826      	ldr	r0, [pc, #152]	; (80041ec <moduleIMG+0x58c>)
 8004154:	f00e fac4 	bl	80126e0 <chprintf.constprop.35>
 8004158:	4822      	ldr	r0, [pc, #136]	; (80041e4 <moduleIMG+0x584>)
 800415a:	f00a fe69 	bl	800ee30 <chMtxUnlock>
				TRACE_INFO("IMG  > Encode/Transmit SSDV ID=%d", gimage_id);
 800415e:	4821      	ldr	r0, [pc, #132]	; (80041e4 <moduleIMG+0x584>)
 8004160:	f00a fec6 	bl	800eef0 <chMtxLock>
 8004164:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004166:	6a64      	ldr	r4, [r4, #36]	; 0x24
 8004168:	491f      	ldr	r1, [pc, #124]	; (80041e8 <moduleIMG+0x588>)
 800416a:	4820      	ldr	r0, [pc, #128]	; (80041ec <moduleIMG+0x58c>)
 800416c:	fb05 f404 	mul.w	r4, r5, r4
 8004170:	fba6 3404 	umull	r3, r4, r6, r4
 8004174:	0ba4      	lsrs	r4, r4, #14
 8004176:	fba7 3704 	umull	r3, r7, r7, r4
 800417a:	09bb      	lsrs	r3, r7, #6
 800417c:	fba6 6202 	umull	r6, r2, r6, r2
 8004180:	fb05 4313 	mls	r3, r5, r3, r4
 8004184:	0b92      	lsrs	r2, r2, #14
 8004186:	f00e faab 	bl	80126e0 <chprintf.constprop.35>
 800418a:	4a19      	ldr	r2, [pc, #100]	; (80041f0 <moduleIMG+0x590>)
 800418c:	4919      	ldr	r1, [pc, #100]	; (80041f4 <moduleIMG+0x594>)
 800418e:	4817      	ldr	r0, [pc, #92]	; (80041ec <moduleIMG+0x58c>)
 8004190:	f00e faa6 	bl	80126e0 <chprintf.constprop.35>
 8004194:	23e5      	movs	r3, #229	; 0xe5
 8004196:	4a18      	ldr	r2, [pc, #96]	; (80041f8 <moduleIMG+0x598>)
 8004198:	4918      	ldr	r1, [pc, #96]	; (80041fc <moduleIMG+0x59c>)
 800419a:	4814      	ldr	r0, [pc, #80]	; (80041ec <moduleIMG+0x58c>)
 800419c:	f00e faa0 	bl	80126e0 <chprintf.constprop.35>
 80041a0:	4917      	ldr	r1, [pc, #92]	; (8004200 <moduleIMG+0x5a0>)
 80041a2:	4812      	ldr	r0, [pc, #72]	; (80041ec <moduleIMG+0x58c>)
 80041a4:	f00e fa9c 	bl	80126e0 <chprintf.constprop.35>
 80041a8:	f8d9 2000 	ldr.w	r2, [r9]
 80041ac:	491a      	ldr	r1, [pc, #104]	; (8004218 <moduleIMG+0x5b8>)
 80041ae:	480f      	ldr	r0, [pc, #60]	; (80041ec <moduleIMG+0x58c>)
 80041b0:	f00e fa96 	bl	80126e0 <chprintf.constprop.35>
 80041b4:	4914      	ldr	r1, [pc, #80]	; (8004208 <moduleIMG+0x5a8>)
 80041b6:	480d      	ldr	r0, [pc, #52]	; (80041ec <moduleIMG+0x58c>)
 80041b8:	f00e fa92 	bl	80126e0 <chprintf.constprop.35>
 80041bc:	4809      	ldr	r0, [pc, #36]	; (80041e4 <moduleIMG+0x584>)
 80041be:	f00a fe37 	bl	800ee30 <chMtxUnlock>
				encode_ssdv(image, image_len, config, gimage_id);
 80041c2:	f899 3000 	ldrb.w	r3, [r9]
 80041c6:	9809      	ldr	r0, [sp, #36]	; 0x24
 80041c8:	4641      	mov	r1, r8
 80041ca:	465a      	mov	r2, fp
 80041cc:	f001 fa90 	bl	80056f0 <encode_ssdv>

			}
		}

		time = waitForTrigger(time, &config->trigger);
 80041d0:	9800      	ldr	r0, [sp, #0]
 80041d2:	f10b 0144 	add.w	r1, fp, #68	; 0x44
 80041d6:	f00e f8a3 	bl	8012320 <waitForTrigger>
 80041da:	9000      	str	r0, [sp, #0]
 80041dc:	e593      	b.n	8003d06 <moduleIMG+0xa6>
 80041de:	bf00      	nop
 80041e0:	200278f8 	.word	0x200278f8
 80041e4:	20027b2c 	.word	0x20027b2c
 80041e8:	08013c50 	.word	0x08013c50
 80041ec:	20027e60 	.word	0x20027e60
 80041f0:	08013cfc 	.word	0x08013cfc
 80041f4:	08013c5c 	.word	0x08013c5c
 80041f8:	08014340 	.word	0x08014340
 80041fc:	08013c78 	.word	0x08013c78
 8004200:	08013d00 	.word	0x08013d00
 8004204:	080143d8 	.word	0x080143d8
 8004208:	08013cac 	.word	0x08013cac
 800420c:	20027b40 	.word	0x20027b40
 8004210:	0801443c 	.word	0x0801443c
 8004214:	080145fc 	.word	0x080145fc
 8004218:	080145d8 	.word	0x080145d8
 800421c:	20000cd8 	.word	0x20000cd8
	if(I2C_read16_locked(OV2640_I2C_ADR, 0x0A, &val))
		ret = val == PID_OV2640;
	else
		ret = false;

	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 8004220:	f04f 0308 	mov.w	r3, #8
 8004224:	f8a9 301a 	strh.w	r3, [r9, #26]
 8004228:	48ac      	ldr	r0, [pc, #688]	; (80044dc <moduleIMG+0x87c>)
 800422a:	f00a fe01 	bl	800ee30 <chMtxUnlock>
					chsnprintf(filename, sizeof(filename), "image%d.jpg", gimage_id);
					writeBufferToFile(filename, image, image_len);

				} else { // Camera error

					TRACE_ERROR("IMG  > No camera found");
 800422e:	48ac      	ldr	r0, [pc, #688]	; (80044e0 <moduleIMG+0x880>)
 8004230:	4cac      	ldr	r4, [pc, #688]	; (80044e4 <moduleIMG+0x884>)
 8004232:	f00a fe5d 	bl	800eef0 <chMtxLock>
 8004236:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800423a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800423e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004240:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8004242:	4ba9      	ldr	r3, [pc, #676]	; (80044e8 <moduleIMG+0x888>)
 8004244:	fb00 f101 	mul.w	r1, r0, r1
 8004248:	fba4 5101 	umull	r5, r1, r4, r1
 800424c:	0b89      	lsrs	r1, r1, #14
 800424e:	fba3 5301 	umull	r5, r3, r3, r1
 8004252:	fba4 4202 	umull	r4, r2, r4, r2
 8004256:	099b      	lsrs	r3, r3, #6
 8004258:	fb00 1313 	mls	r3, r0, r3, r1
 800425c:	0b92      	lsrs	r2, r2, #14
 800425e:	49a3      	ldr	r1, [pc, #652]	; (80044ec <moduleIMG+0x88c>)
 8004260:	48a3      	ldr	r0, [pc, #652]	; (80044f0 <moduleIMG+0x890>)
 8004262:	f00e fa3d 	bl	80126e0 <chprintf.constprop.35>
 8004266:	4aa3      	ldr	r2, [pc, #652]	; (80044f4 <moduleIMG+0x894>)
 8004268:	49a3      	ldr	r1, [pc, #652]	; (80044f8 <moduleIMG+0x898>)
 800426a:	48a1      	ldr	r0, [pc, #644]	; (80044f0 <moduleIMG+0x890>)
 800426c:	f00e fa38 	bl	80126e0 <chprintf.constprop.35>
 8004270:	23ca      	movs	r3, #202	; 0xca
 8004272:	4aa2      	ldr	r2, [pc, #648]	; (80044fc <moduleIMG+0x89c>)
 8004274:	49a2      	ldr	r1, [pc, #648]	; (8004500 <moduleIMG+0x8a0>)
 8004276:	489e      	ldr	r0, [pc, #632]	; (80044f0 <moduleIMG+0x890>)
 8004278:	f00e fa32 	bl	80126e0 <chprintf.constprop.35>
 800427c:	49a1      	ldr	r1, [pc, #644]	; (8004504 <moduleIMG+0x8a4>)
 800427e:	489c      	ldr	r0, [pc, #624]	; (80044f0 <moduleIMG+0x890>)
 8004280:	f00e fa2e 	bl	80126e0 <chprintf.constprop.35>
 8004284:	49a0      	ldr	r1, [pc, #640]	; (8004508 <moduleIMG+0x8a8>)
 8004286:	489a      	ldr	r0, [pc, #616]	; (80044f0 <moduleIMG+0x890>)
 8004288:	f00e fa2a 	bl	80126e0 <chprintf.constprop.35>
 800428c:	499f      	ldr	r1, [pc, #636]	; (800450c <moduleIMG+0x8ac>)
 800428e:	4898      	ldr	r0, [pc, #608]	; (80044f0 <moduleIMG+0x890>)
 8004290:	f00e fa26 	bl	80126e0 <chprintf.constprop.35>
 8004294:	4892      	ldr	r0, [pc, #584]	; (80044e0 <moduleIMG+0x880>)
 8004296:	f00a fdcb 	bl	800ee30 <chMtxUnlock>
				// Shutdown radios (to avoid interference)
				radioShutdown(RADIO_2M);
				radioShutdown(RADIO_70CM);

				uint8_t tries;
				bool status = false;
 800429a:	f04f 0900 	mov.w	r9, #0
					chsnprintf(filename, sizeof(filename), "image%d.jpg", gimage_id);
					writeBufferToFile(filename, image, image_len);

				} else { // Camera error

					TRACE_ERROR("IMG  > No camera found");
 800429e:	21ca      	movs	r1, #202	; 0xca
 80042a0:	4896      	ldr	r0, [pc, #600]	; (80044fc <moduleIMG+0x89c>)
 80042a2:	f00b fe5d 	bl	800ff60 <log_error>
		TRACE_INFO("IMG  > Do module IMAGE cycle");
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		if(!p_sleep(&config->sleep_config))
		{
			uint32_t image_len = 0;
 80042a6:	f8cd 9008 	str.w	r9, [sp, #8]
 80042aa:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
					TRACE_ERROR("IMG  > No camera found");

				}

				// Unlock radio
				TRACE_INFO("IMG  > Unlock radio");
 80042ae:	488c      	ldr	r0, [pc, #560]	; (80044e0 <moduleIMG+0x880>)
 80042b0:	4d8c      	ldr	r5, [pc, #560]	; (80044e4 <moduleIMG+0x884>)
 80042b2:	4f8d      	ldr	r7, [pc, #564]	; (80044e8 <moduleIMG+0x888>)
 80042b4:	f00a fe1c 	bl	800eef0 <chMtxLock>
 80042b8:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80042ba:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80042bc:	498b      	ldr	r1, [pc, #556]	; (80044ec <moduleIMG+0x88c>)
 80042be:	488c      	ldr	r0, [pc, #560]	; (80044f0 <moduleIMG+0x890>)
 80042c0:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 80042c4:	fb04 f303 	mul.w	r3, r4, r3
 80042c8:	fba5 e303 	umull	lr, r3, r5, r3
 80042cc:	0b9b      	lsrs	r3, r3, #14
 80042ce:	fba7 ce03 	umull	ip, lr, r7, r3
 80042d2:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 80042d6:	fba5 c202 	umull	ip, r2, r5, r2
 80042da:	fb04 331e 	mls	r3, r4, lr, r3
 80042de:	0b92      	lsrs	r2, r2, #14
 80042e0:	f00e f9fe 	bl	80126e0 <chprintf.constprop.35>
 80042e4:	4a8a      	ldr	r2, [pc, #552]	; (8004510 <moduleIMG+0x8b0>)
 80042e6:	4984      	ldr	r1, [pc, #528]	; (80044f8 <moduleIMG+0x898>)
 80042e8:	4881      	ldr	r0, [pc, #516]	; (80044f0 <moduleIMG+0x890>)
 80042ea:	f00e f9f9 	bl	80126e0 <chprintf.constprop.35>
 80042ee:	23cf      	movs	r3, #207	; 0xcf
 80042f0:	4a82      	ldr	r2, [pc, #520]	; (80044fc <moduleIMG+0x89c>)
 80042f2:	4983      	ldr	r1, [pc, #524]	; (8004500 <moduleIMG+0x8a0>)
 80042f4:	487e      	ldr	r0, [pc, #504]	; (80044f0 <moduleIMG+0x890>)
 80042f6:	f00e f9f3 	bl	80126e0 <chprintf.constprop.35>
 80042fa:	4982      	ldr	r1, [pc, #520]	; (8004504 <moduleIMG+0x8a4>)
 80042fc:	487c      	ldr	r0, [pc, #496]	; (80044f0 <moduleIMG+0x890>)
 80042fe:	f00e f9ef 	bl	80126e0 <chprintf.constprop.35>
 8004302:	4984      	ldr	r1, [pc, #528]	; (8004514 <moduleIMG+0x8b4>)
 8004304:	487a      	ldr	r0, [pc, #488]	; (80044f0 <moduleIMG+0x890>)
 8004306:	f00e f9eb 	bl	80126e0 <chprintf.constprop.35>
 800430a:	4980      	ldr	r1, [pc, #512]	; (800450c <moduleIMG+0x8ac>)
 800430c:	4878      	ldr	r0, [pc, #480]	; (80044f0 <moduleIMG+0x890>)
 800430e:	f00e f9e7 	bl	80126e0 <chprintf.constprop.35>
 8004312:	4873      	ldr	r0, [pc, #460]	; (80044e0 <moduleIMG+0x880>)
 8004314:	f00a fd8c 	bl	800ee30 <chMtxUnlock>
				chMtxUnlock(&interference_mtx);
 8004318:	487f      	ldr	r0, [pc, #508]	; (8004518 <moduleIMG+0x8b8>)
 800431a:	f00a fd89 	bl	800ee30 <chMtxUnlock>
				TRACE_INFO("IMG  > Unlocked radio");
 800431e:	4870      	ldr	r0, [pc, #448]	; (80044e0 <moduleIMG+0x880>)
 8004320:	f00a fde6 	bl	800eef0 <chMtxLock>
 8004324:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8004326:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8004328:	4970      	ldr	r1, [pc, #448]	; (80044ec <moduleIMG+0x88c>)
 800432a:	4871      	ldr	r0, [pc, #452]	; (80044f0 <moduleIMG+0x890>)
 800432c:	fb04 f303 	mul.w	r3, r4, r3
 8004330:	fba5 e303 	umull	lr, r3, r5, r3
 8004334:	0b9b      	lsrs	r3, r3, #14
 8004336:	fba7 ce03 	umull	ip, lr, r7, r3
 800433a:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800433e:	fba5 c202 	umull	ip, r2, r5, r2
 8004342:	fb04 331e 	mls	r3, r4, lr, r3
 8004346:	0b92      	lsrs	r2, r2, #14
 8004348:	f00e f9ca 	bl	80126e0 <chprintf.constprop.35>
 800434c:	4a70      	ldr	r2, [pc, #448]	; (8004510 <moduleIMG+0x8b0>)
 800434e:	496a      	ldr	r1, [pc, #424]	; (80044f8 <moduleIMG+0x898>)
 8004350:	4867      	ldr	r0, [pc, #412]	; (80044f0 <moduleIMG+0x890>)
 8004352:	f00e f9c5 	bl	80126e0 <chprintf.constprop.35>
 8004356:	23d1      	movs	r3, #209	; 0xd1
 8004358:	4a68      	ldr	r2, [pc, #416]	; (80044fc <moduleIMG+0x89c>)
 800435a:	4969      	ldr	r1, [pc, #420]	; (8004500 <moduleIMG+0x8a0>)
 800435c:	4864      	ldr	r0, [pc, #400]	; (80044f0 <moduleIMG+0x890>)
 800435e:	f00e f9bf 	bl	80126e0 <chprintf.constprop.35>
 8004362:	4968      	ldr	r1, [pc, #416]	; (8004504 <moduleIMG+0x8a4>)
 8004364:	4862      	ldr	r0, [pc, #392]	; (80044f0 <moduleIMG+0x890>)
 8004366:	f00e f9bb 	bl	80126e0 <chprintf.constprop.35>
 800436a:	496c      	ldr	r1, [pc, #432]	; (800451c <moduleIMG+0x8bc>)
 800436c:	4860      	ldr	r0, [pc, #384]	; (80044f0 <moduleIMG+0x890>)
 800436e:	f00e f9b7 	bl	80126e0 <chprintf.constprop.35>
 8004372:	4966      	ldr	r1, [pc, #408]	; (800450c <moduleIMG+0x8ac>)
 8004374:	485e      	ldr	r0, [pc, #376]	; (80044f0 <moduleIMG+0x890>)
 8004376:	f00e f9b3 	bl	80126e0 <chprintf.constprop.35>
 800437a:	4859      	ldr	r0, [pc, #356]	; (80044e0 <moduleIMG+0x880>)
 800437c:	f00a fd58 	bl	800ee30 <chMtxUnlock>

				// Unlock camera
				TRACE_INFO("IMG  > Unlock camera");
 8004380:	4857      	ldr	r0, [pc, #348]	; (80044e0 <moduleIMG+0x880>)
 8004382:	f00a fdb5 	bl	800eef0 <chMtxLock>
 8004386:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8004388:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800438a:	4958      	ldr	r1, [pc, #352]	; (80044ec <moduleIMG+0x88c>)
 800438c:	4858      	ldr	r0, [pc, #352]	; (80044f0 <moduleIMG+0x890>)
 800438e:	fb04 f303 	mul.w	r3, r4, r3
 8004392:	fba5 e303 	umull	lr, r3, r5, r3
 8004396:	0b9b      	lsrs	r3, r3, #14
 8004398:	fba7 ce03 	umull	ip, lr, r7, r3
 800439c:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 80043a0:	fba5 c202 	umull	ip, r2, r5, r2
 80043a4:	fb04 331e 	mls	r3, r4, lr, r3
 80043a8:	0b92      	lsrs	r2, r2, #14
 80043aa:	f00e f999 	bl	80126e0 <chprintf.constprop.35>
 80043ae:	4a58      	ldr	r2, [pc, #352]	; (8004510 <moduleIMG+0x8b0>)
 80043b0:	4951      	ldr	r1, [pc, #324]	; (80044f8 <moduleIMG+0x898>)
 80043b2:	484f      	ldr	r0, [pc, #316]	; (80044f0 <moduleIMG+0x890>)
 80043b4:	f00e f994 	bl	80126e0 <chprintf.constprop.35>
 80043b8:	23d4      	movs	r3, #212	; 0xd4
 80043ba:	4a50      	ldr	r2, [pc, #320]	; (80044fc <moduleIMG+0x89c>)
 80043bc:	4950      	ldr	r1, [pc, #320]	; (8004500 <moduleIMG+0x8a0>)
 80043be:	484c      	ldr	r0, [pc, #304]	; (80044f0 <moduleIMG+0x890>)
 80043c0:	f00e f98e 	bl	80126e0 <chprintf.constprop.35>
 80043c4:	494f      	ldr	r1, [pc, #316]	; (8004504 <moduleIMG+0x8a4>)
 80043c6:	484a      	ldr	r0, [pc, #296]	; (80044f0 <moduleIMG+0x890>)
 80043c8:	f00e f98a 	bl	80126e0 <chprintf.constprop.35>
 80043cc:	4954      	ldr	r1, [pc, #336]	; (8004520 <moduleIMG+0x8c0>)
 80043ce:	4848      	ldr	r0, [pc, #288]	; (80044f0 <moduleIMG+0x890>)
 80043d0:	f00e f986 	bl	80126e0 <chprintf.constprop.35>
 80043d4:	494d      	ldr	r1, [pc, #308]	; (800450c <moduleIMG+0x8ac>)
 80043d6:	4846      	ldr	r0, [pc, #280]	; (80044f0 <moduleIMG+0x890>)
 80043d8:	f00e f982 	bl	80126e0 <chprintf.constprop.35>
 80043dc:	4840      	ldr	r0, [pc, #256]	; (80044e0 <moduleIMG+0x880>)
 80043de:	f00a fd27 	bl	800ee30 <chMtxUnlock>
				chMtxUnlock(&camera_mtx);
 80043e2:	4850      	ldr	r0, [pc, #320]	; (8004524 <moduleIMG+0x8c4>)
 80043e4:	f00a fd24 	bl	800ee30 <chMtxUnlock>
				TRACE_INFO("IMG  > Unlocked camera");
 80043e8:	483d      	ldr	r0, [pc, #244]	; (80044e0 <moduleIMG+0x880>)
 80043ea:	f00a fd81 	bl	800eef0 <chMtxLock>
 80043ee:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80043f0:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80043f2:	493e      	ldr	r1, [pc, #248]	; (80044ec <moduleIMG+0x88c>)
 80043f4:	483e      	ldr	r0, [pc, #248]	; (80044f0 <moduleIMG+0x890>)
 80043f6:	fb04 f303 	mul.w	r3, r4, r3
 80043fa:	fba5 e303 	umull	lr, r3, r5, r3
 80043fe:	0b9b      	lsrs	r3, r3, #14
 8004400:	fba7 ce03 	umull	ip, lr, r7, r3
 8004404:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8004408:	fba5 c202 	umull	ip, r2, r5, r2
 800440c:	fb04 331e 	mls	r3, r4, lr, r3
 8004410:	0b92      	lsrs	r2, r2, #14
 8004412:	f00e f965 	bl	80126e0 <chprintf.constprop.35>
 8004416:	4a3e      	ldr	r2, [pc, #248]	; (8004510 <moduleIMG+0x8b0>)
 8004418:	4937      	ldr	r1, [pc, #220]	; (80044f8 <moduleIMG+0x898>)
 800441a:	4835      	ldr	r0, [pc, #212]	; (80044f0 <moduleIMG+0x890>)
 800441c:	f00e f960 	bl	80126e0 <chprintf.constprop.35>
 8004420:	23d6      	movs	r3, #214	; 0xd6
 8004422:	4a36      	ldr	r2, [pc, #216]	; (80044fc <moduleIMG+0x89c>)
 8004424:	4936      	ldr	r1, [pc, #216]	; (8004500 <moduleIMG+0x8a0>)
 8004426:	4832      	ldr	r0, [pc, #200]	; (80044f0 <moduleIMG+0x890>)
 8004428:	f00e f95a 	bl	80126e0 <chprintf.constprop.35>
 800442c:	4935      	ldr	r1, [pc, #212]	; (8004504 <moduleIMG+0x8a4>)
 800442e:	4830      	ldr	r0, [pc, #192]	; (80044f0 <moduleIMG+0x890>)
 8004430:	f00e f956 	bl	80126e0 <chprintf.constprop.35>
 8004434:	493c      	ldr	r1, [pc, #240]	; (8004528 <moduleIMG+0x8c8>)
 8004436:	482e      	ldr	r0, [pc, #184]	; (80044f0 <moduleIMG+0x890>)
 8004438:	f00e f952 	bl	80126e0 <chprintf.constprop.35>
 800443c:	4933      	ldr	r1, [pc, #204]	; (800450c <moduleIMG+0x8ac>)
 800443e:	482c      	ldr	r0, [pc, #176]	; (80044f0 <moduleIMG+0x890>)
 8004440:	f00e f94e 	bl	80126e0 <chprintf.constprop.35>
 8004444:	4826      	ldr	r0, [pc, #152]	; (80044e0 <moduleIMG+0x880>)
 8004446:	f00a fcf3 	bl	800ee30 <chMtxUnlock>

				// Encode/Transmit SSDV if image sampled successfully
				if(status)
 800444a:	f1b9 0f00 	cmp.w	r9, #0
 800444e:	f43f aebf 	beq.w	80041d0 <moduleIMG+0x570>
				{
					TRACE_INFO("IMG  > Encode/Transmit SSDV ID=%d", gimage_id++);
 8004452:	4823      	ldr	r0, [pc, #140]	; (80044e0 <moduleIMG+0x880>)
 8004454:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 8004530 <moduleIMG+0x8d0>
 8004458:	f00a fd4a 	bl	800eef0 <chMtxLock>
 800445c:	6a72      	ldr	r2, [r6, #36]	; 0x24
 800445e:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8004460:	fb04 f101 	mul.w	r1, r4, r1
 8004464:	fba5 3101 	umull	r3, r1, r5, r1
 8004468:	0b89      	lsrs	r1, r1, #14
 800446a:	fba7 3701 	umull	r3, r7, r7, r1
 800446e:	fba5 0202 	umull	r0, r2, r5, r2
 8004472:	09bb      	lsrs	r3, r7, #6
 8004474:	fb04 1313 	mls	r3, r4, r3, r1
 8004478:	0b92      	lsrs	r2, r2, #14
 800447a:	491c      	ldr	r1, [pc, #112]	; (80044ec <moduleIMG+0x88c>)
 800447c:	481c      	ldr	r0, [pc, #112]	; (80044f0 <moduleIMG+0x890>)
 800447e:	f00e f92f 	bl	80126e0 <chprintf.constprop.35>
 8004482:	4a23      	ldr	r2, [pc, #140]	; (8004510 <moduleIMG+0x8b0>)
 8004484:	491c      	ldr	r1, [pc, #112]	; (80044f8 <moduleIMG+0x898>)
 8004486:	481a      	ldr	r0, [pc, #104]	; (80044f0 <moduleIMG+0x890>)
 8004488:	f00e f92a 	bl	80126e0 <chprintf.constprop.35>
 800448c:	23db      	movs	r3, #219	; 0xdb
 800448e:	4a1b      	ldr	r2, [pc, #108]	; (80044fc <moduleIMG+0x89c>)
 8004490:	491b      	ldr	r1, [pc, #108]	; (8004500 <moduleIMG+0x8a0>)
 8004492:	4817      	ldr	r0, [pc, #92]	; (80044f0 <moduleIMG+0x890>)
 8004494:	f00e f924 	bl	80126e0 <chprintf.constprop.35>
 8004498:	491a      	ldr	r1, [pc, #104]	; (8004504 <moduleIMG+0x8a4>)
 800449a:	4815      	ldr	r0, [pc, #84]	; (80044f0 <moduleIMG+0x890>)
 800449c:	f00e f920 	bl	80126e0 <chprintf.constprop.35>
 80044a0:	f8d8 2000 	ldr.w	r2, [r8]
 80044a4:	4921      	ldr	r1, [pc, #132]	; (800452c <moduleIMG+0x8cc>)
 80044a6:	4812      	ldr	r0, [pc, #72]	; (80044f0 <moduleIMG+0x890>)
 80044a8:	1c53      	adds	r3, r2, #1
 80044aa:	f8c8 3000 	str.w	r3, [r8]
 80044ae:	f00e f917 	bl	80126e0 <chprintf.constprop.35>
 80044b2:	4916      	ldr	r1, [pc, #88]	; (800450c <moduleIMG+0x8ac>)
 80044b4:	480e      	ldr	r0, [pc, #56]	; (80044f0 <moduleIMG+0x890>)
 80044b6:	f00e f913 	bl	80126e0 <chprintf.constprop.35>
 80044ba:	4809      	ldr	r0, [pc, #36]	; (80044e0 <moduleIMG+0x880>)
 80044bc:	f00a fcb8 	bl	800ee30 <chMtxUnlock>
					encode_ssdv(image, image_len, config, gimage_id);
 80044c0:	f898 3000 	ldrb.w	r3, [r8]
 80044c4:	9809      	ldr	r0, [sp, #36]	; 0x24
 80044c6:	9902      	ldr	r1, [sp, #8]
 80044c8:	465a      	mov	r2, fp
 80044ca:	f001 f911 	bl	80056f0 <encode_ssdv>
				encode_ssdv(image, image_len, config, gimage_id);

			}
		}

		time = waitForTrigger(time, &config->trigger);
 80044ce:	9800      	ldr	r0, [sp, #0]
 80044d0:	f10b 0144 	add.w	r1, fp, #68	; 0x44
 80044d4:	f00d ff24 	bl	8012320 <waitForTrigger>
 80044d8:	9000      	str	r0, [sp, #0]
 80044da:	e414      	b.n	8003d06 <moduleIMG+0xa6>
 80044dc:	200278f8 	.word	0x200278f8
 80044e0:	20027b2c 	.word	0x20027b2c
 80044e4:	d1b71759 	.word	0xd1b71759
 80044e8:	10624dd3 	.word	0x10624dd3
 80044ec:	08013c50 	.word	0x08013c50
 80044f0:	20027e60 	.word	0x20027e60
 80044f4:	08013d9c 	.word	0x08013d9c
 80044f8:	08013c5c 	.word	0x08013c5c
 80044fc:	08014340 	.word	0x08014340
 8004500:	08013c78 	.word	0x08013c78
 8004504:	08013d00 	.word	0x08013d00
 8004508:	08014564 	.word	0x08014564
 800450c:	08013cac 	.word	0x08013cac
 8004510:	08013cfc 	.word	0x08013cfc
 8004514:	0801457c 	.word	0x0801457c
 8004518:	20027770 	.word	0x20027770
 800451c:	08014590 	.word	0x08014590
 8004520:	080145a8 	.word	0x080145a8
 8004524:	2002772c 	.word	0x2002772c
 8004528:	080145c0 	.word	0x080145c0
 800452c:	080145d8 	.word	0x080145d8
 8004530:	20000cd8 	.word	0x20000cd8
						config->ssdv_config.res = RES_MAX; // Revert register

					} else { // Static resolution

						// Init camera
						OV2640_init(&config->ssdv_config);
 8004534:	9803      	ldr	r0, [sp, #12]
 8004536:	f00a ff03 	bl	800f340 <OV2640_init>
 800453a:	2405      	movs	r4, #5

						// Sample data from DCMI through DMA into RAM
						tries = 5; // Try 5 times at maximum
						do { // Try capturing image until capture successful
							status = OV2640_Snapshot2RAM();
 800453c:	f00b f9f8 	bl	800f930 <OV2640_Snapshot2RAM>
						} while(!status && --tries);
 8004540:	b918      	cbnz	r0, 800454a <moduleIMG+0x8ea>
 8004542:	1e63      	subs	r3, r4, #1
 8004544:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 8004548:	d1f8      	bne.n	800453c <moduleIMG+0x8dc>
 800454a:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 800454e:	4681      	mov	r9, r0
	chThdSleepMilliseconds(3000);
}

void OV2640_deinit(void) {
	// DCMI Init
	TRACE_INFO("CAM  > Deinit DCMI");
 8004550:	48b7      	ldr	r0, [pc, #732]	; (8004830 <moduleIMG+0xbd0>)
 8004552:	4eb8      	ldr	r6, [pc, #736]	; (8004834 <moduleIMG+0xbd4>)
 8004554:	4cb8      	ldr	r4, [pc, #736]	; (8004838 <moduleIMG+0xbd8>)
 8004556:	f00a fccb 	bl	800eef0 <chMtxLock>
 800455a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800455c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800455e:	49b7      	ldr	r1, [pc, #732]	; (800483c <moduleIMG+0xbdc>)
 8004560:	48b7      	ldr	r0, [pc, #732]	; (8004840 <moduleIMG+0xbe0>)
 8004562:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8004566:	fb05 f303 	mul.w	r3, r5, r3
 800456a:	fba6 e303 	umull	lr, r3, r6, r3
 800456e:	0b9b      	lsrs	r3, r3, #14
 8004570:	fba4 ce03 	umull	ip, lr, r4, r3
 8004574:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8004578:	fba6 c202 	umull	ip, r2, r6, r2
 800457c:	fb05 331e 	mls	r3, r5, lr, r3
 8004580:	0b92      	lsrs	r2, r2, #14
 8004582:	f00e f8ad 	bl	80126e0 <chprintf.constprop.35>
 8004586:	4aaf      	ldr	r2, [pc, #700]	; (8004844 <moduleIMG+0xbe4>)
 8004588:	49af      	ldr	r1, [pc, #700]	; (8004848 <moduleIMG+0xbe8>)
 800458a:	48ad      	ldr	r0, [pc, #692]	; (8004840 <moduleIMG+0xbe0>)
 800458c:	f00e f8a8 	bl	80126e0 <chprintf.constprop.35>
 8004590:	f240 3352 	movw	r3, #850	; 0x352
 8004594:	4aad      	ldr	r2, [pc, #692]	; (800484c <moduleIMG+0xbec>)
 8004596:	49ae      	ldr	r1, [pc, #696]	; (8004850 <moduleIMG+0xbf0>)
 8004598:	48a9      	ldr	r0, [pc, #676]	; (8004840 <moduleIMG+0xbe0>)
 800459a:	f00e f8a1 	bl	80126e0 <chprintf.constprop.35>
 800459e:	49ad      	ldr	r1, [pc, #692]	; (8004854 <moduleIMG+0xbf4>)
 80045a0:	48a7      	ldr	r0, [pc, #668]	; (8004840 <moduleIMG+0xbe0>)
 80045a2:	f00e f89d 	bl	80126e0 <chprintf.constprop.35>
 80045a6:	49ac      	ldr	r1, [pc, #688]	; (8004858 <moduleIMG+0xbf8>)
 80045a8:	48a5      	ldr	r0, [pc, #660]	; (8004840 <moduleIMG+0xbe0>)
 80045aa:	f00e f899 	bl	80126e0 <chprintf.constprop.35>
 80045ae:	49ab      	ldr	r1, [pc, #684]	; (800485c <moduleIMG+0xbfc>)
 80045b0:	48a3      	ldr	r0, [pc, #652]	; (8004840 <moduleIMG+0xbe0>)
 80045b2:	f00e f895 	bl	80126e0 <chprintf.constprop.35>
 80045b6:	489e      	ldr	r0, [pc, #632]	; (8004830 <moduleIMG+0xbd0>)
 80045b8:	f00a fc3a 	bl	800ee30 <chMtxUnlock>
}

void OV2640_DeinitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR &= ~RCC_AHB2Periph_DCMI;
 80045bc:	49a8      	ldr	r1, [pc, #672]	; (8004860 <moduleIMG+0xc00>)
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 80045be:	4aa9      	ldr	r2, [pc, #676]	; (8004864 <moduleIMG+0xc04>)
}

void OV2640_DeinitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR &= ~RCC_AHB2Periph_DCMI;
 80045c0:	6b4b      	ldr	r3, [r1, #52]	; 0x34
	// DCMI Init
	TRACE_INFO("CAM  > Deinit DCMI");
	OV2640_DeinitDCMI();

	// DCMI DMA
	TRACE_INFO("CAM  > Deinit DMA");
 80045c2:	489b      	ldr	r0, [pc, #620]	; (8004830 <moduleIMG+0xbd0>)
}

void OV2640_DeinitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR &= ~RCC_AHB2Periph_DCMI;
 80045c4:	f023 0301 	bic.w	r3, r3, #1
 80045c8:	634b      	str	r3, [r1, #52]	; 0x34
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 80045ca:	6813      	ldr	r3, [r2, #0]
 80045cc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80045d0:	f023 0301 	bic.w	r3, r3, #1
 80045d4:	6013      	str	r3, [r2, #0]
	// DCMI Init
	TRACE_INFO("CAM  > Deinit DCMI");
	OV2640_DeinitDCMI();

	// DCMI DMA
	TRACE_INFO("CAM  > Deinit DMA");
 80045d6:	f00a fc8b 	bl	800eef0 <chMtxLock>
 80045da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80045dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045de:	4997      	ldr	r1, [pc, #604]	; (800483c <moduleIMG+0xbdc>)
 80045e0:	4897      	ldr	r0, [pc, #604]	; (8004840 <moduleIMG+0xbe0>)
 80045e2:	fb05 f303 	mul.w	r3, r5, r3
 80045e6:	fba6 7303 	umull	r7, r3, r6, r3
 80045ea:	0b9b      	lsrs	r3, r3, #14
 80045ec:	fba4 7403 	umull	r7, r4, r4, r3
 80045f0:	09a4      	lsrs	r4, r4, #6
 80045f2:	fba6 6202 	umull	r6, r2, r6, r2
 80045f6:	fb05 3314 	mls	r3, r5, r4, r3
 80045fa:	0b92      	lsrs	r2, r2, #14
 80045fc:	f00e f870 	bl	80126e0 <chprintf.constprop.35>
 8004600:	4a90      	ldr	r2, [pc, #576]	; (8004844 <moduleIMG+0xbe4>)
 8004602:	4991      	ldr	r1, [pc, #580]	; (8004848 <moduleIMG+0xbe8>)
 8004604:	488e      	ldr	r0, [pc, #568]	; (8004840 <moduleIMG+0xbe0>)
 8004606:	f00e f86b 	bl	80126e0 <chprintf.constprop.35>
 800460a:	f240 3356 	movw	r3, #854	; 0x356
 800460e:	4a8f      	ldr	r2, [pc, #572]	; (800484c <moduleIMG+0xbec>)
 8004610:	498f      	ldr	r1, [pc, #572]	; (8004850 <moduleIMG+0xbf0>)
 8004612:	488b      	ldr	r0, [pc, #556]	; (8004840 <moduleIMG+0xbe0>)
 8004614:	f00e f864 	bl	80126e0 <chprintf.constprop.35>
 8004618:	498e      	ldr	r1, [pc, #568]	; (8004854 <moduleIMG+0xbf4>)
 800461a:	4889      	ldr	r0, [pc, #548]	; (8004840 <moduleIMG+0xbe0>)
 800461c:	f00e f860 	bl	80126e0 <chprintf.constprop.35>
 8004620:	4991      	ldr	r1, [pc, #580]	; (8004868 <moduleIMG+0xc08>)
 8004622:	4887      	ldr	r0, [pc, #540]	; (8004840 <moduleIMG+0xbe0>)
 8004624:	f00e f85c 	bl	80126e0 <chprintf.constprop.35>
 8004628:	498c      	ldr	r1, [pc, #560]	; (800485c <moduleIMG+0xbfc>)
 800462a:	4885      	ldr	r0, [pc, #532]	; (8004840 <moduleIMG+0xbe0>)
 800462c:	f00e f858 	bl	80126e0 <chprintf.constprop.35>
 8004630:	487f      	ldr	r0, [pc, #508]	; (8004830 <moduleIMG+0xbd0>)
 8004632:	f00a fbfd 	bl	800ee30 <chMtxUnlock>
}

void OV2640_DeinitDMA(void)
{
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamDisable(stream);
 8004636:	f8da 3000 	ldr.w	r3, [sl]
 800463a:	f023 031f 	bic.w	r3, r3, #31
 800463e:	f8ca 3000 	str.w	r3, [sl]
 8004642:	f8da 3000 	ldr.w	r3, [sl]
 8004646:	07db      	lsls	r3, r3, #31
 8004648:	d4fb      	bmi.n	8004642 <moduleIMG+0x9e2>
 800464a:	4b88      	ldr	r3, [pc, #544]	; (800486c <moduleIMG+0xc0c>)
	// DCMI DMA
	TRACE_INFO("CAM  > Deinit DMA");
	OV2640_DeinitDMA();

	// Power off OV2640
	TRACE_INFO("CAM  > Switch off");
 800464c:	4878      	ldr	r0, [pc, #480]	; (8004830 <moduleIMG+0xbd0>)
 800464e:	4d79      	ldr	r5, [pc, #484]	; (8004834 <moduleIMG+0xbd4>)
 8004650:	4f79      	ldr	r7, [pc, #484]	; (8004838 <moduleIMG+0xbd8>)
 8004652:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
}

void OV2640_DeinitDMA(void)
{
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamDisable(stream);
 8004656:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 800465a:	601a      	str	r2, [r3, #0]
	// DCMI DMA
	TRACE_INFO("CAM  > Deinit DMA");
	OV2640_DeinitDMA();

	// Power off OV2640
	TRACE_INFO("CAM  > Switch off");
 800465c:	f00a fc48 	bl	800eef0 <chMtxLock>
 8004660:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8004662:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8004664:	4975      	ldr	r1, [pc, #468]	; (800483c <moduleIMG+0xbdc>)
 8004666:	4876      	ldr	r0, [pc, #472]	; (8004840 <moduleIMG+0xbe0>)
 8004668:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 800466c:	fb04 f303 	mul.w	r3, r4, r3
 8004670:	fba5 e303 	umull	lr, r3, r5, r3
 8004674:	0b9b      	lsrs	r3, r3, #14
 8004676:	fba7 ce03 	umull	ip, lr, r7, r3
 800467a:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800467e:	fba5 c202 	umull	ip, r2, r5, r2
 8004682:	fb04 331e 	mls	r3, r4, lr, r3
 8004686:	0b92      	lsrs	r2, r2, #14
 8004688:	f00e f82a 	bl	80126e0 <chprintf.constprop.35>
 800468c:	4a6d      	ldr	r2, [pc, #436]	; (8004844 <moduleIMG+0xbe4>)
 800468e:	496e      	ldr	r1, [pc, #440]	; (8004848 <moduleIMG+0xbe8>)
 8004690:	486b      	ldr	r0, [pc, #428]	; (8004840 <moduleIMG+0xbe0>)
 8004692:	f00e f825 	bl	80126e0 <chprintf.constprop.35>
 8004696:	f240 335a 	movw	r3, #858	; 0x35a
 800469a:	4a6c      	ldr	r2, [pc, #432]	; (800484c <moduleIMG+0xbec>)
 800469c:	496c      	ldr	r1, [pc, #432]	; (8004850 <moduleIMG+0xbf0>)
 800469e:	4868      	ldr	r0, [pc, #416]	; (8004840 <moduleIMG+0xbe0>)
 80046a0:	f00e f81e 	bl	80126e0 <chprintf.constprop.35>
 80046a4:	496b      	ldr	r1, [pc, #428]	; (8004854 <moduleIMG+0xbf4>)
 80046a6:	4866      	ldr	r0, [pc, #408]	; (8004840 <moduleIMG+0xbe0>)
 80046a8:	f00e f81a 	bl	80126e0 <chprintf.constprop.35>
 80046ac:	4970      	ldr	r1, [pc, #448]	; (8004870 <moduleIMG+0xc10>)
 80046ae:	4864      	ldr	r0, [pc, #400]	; (8004840 <moduleIMG+0xbe0>)
 80046b0:	f00e f816 	bl	80126e0 <chprintf.constprop.35>
 80046b4:	4969      	ldr	r1, [pc, #420]	; (800485c <moduleIMG+0xbfc>)
 80046b6:	4862      	ldr	r0, [pc, #392]	; (8004840 <moduleIMG+0xbe0>)
 80046b8:	f00e f812 	bl	80126e0 <chprintf.constprop.35>
 80046bc:	485c      	ldr	r0, [pc, #368]	; (8004830 <moduleIMG+0xbd0>)
 80046be:	f00a fbb7 	bl	800ee30 <chMtxUnlock>
	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 80046c2:	4b6c      	ldr	r3, [pc, #432]	; (8004874 <moduleIMG+0xc14>)
 80046c4:	486c      	ldr	r0, [pc, #432]	; (8004878 <moduleIMG+0xc18>)
 80046c6:	2208      	movs	r2, #8
 80046c8:	835a      	strh	r2, [r3, #26]
 80046ca:	f00a fbb1 	bl	800ee30 <chMtxUnlock>

					// Switch off camera
					OV2640_deinit();

					// Get image
					image_len = OV2640_getBuffer(&image);
 80046ce:	a809      	add	r0, sp, #36	; 0x24
 80046d0:	f00b f916 	bl	800f900 <OV2640_getBuffer>
 80046d4:	4680      	mov	r8, r0
 80046d6:	9002      	str	r0, [sp, #8]
					TRACE_INFO("IMG  > Image size: %d bytes", image_len);
 80046d8:	4855      	ldr	r0, [pc, #340]	; (8004830 <moduleIMG+0xbd0>)
 80046da:	f00a fc09 	bl	800eef0 <chMtxLock>
 80046de:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80046e0:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80046e2:	4956      	ldr	r1, [pc, #344]	; (800483c <moduleIMG+0xbdc>)
 80046e4:	4856      	ldr	r0, [pc, #344]	; (8004840 <moduleIMG+0xbe0>)
 80046e6:	fb04 f303 	mul.w	r3, r4, r3
 80046ea:	fba5 e303 	umull	lr, r3, r5, r3
 80046ee:	0b9b      	lsrs	r3, r3, #14
 80046f0:	fba7 ce03 	umull	ip, lr, r7, r3
 80046f4:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 80046f8:	fba5 c202 	umull	ip, r2, r5, r2
 80046fc:	fb04 331e 	mls	r3, r4, lr, r3
 8004700:	0b92      	lsrs	r2, r2, #14
 8004702:	f00d ffed 	bl	80126e0 <chprintf.constprop.35>
 8004706:	4a4f      	ldr	r2, [pc, #316]	; (8004844 <moduleIMG+0xbe4>)
 8004708:	494f      	ldr	r1, [pc, #316]	; (8004848 <moduleIMG+0xbe8>)
 800470a:	484d      	ldr	r0, [pc, #308]	; (8004840 <moduleIMG+0xbe0>)
 800470c:	f00d ffe8 	bl	80126e0 <chprintf.constprop.35>
 8004710:	23c0      	movs	r3, #192	; 0xc0
 8004712:	4a5a      	ldr	r2, [pc, #360]	; (800487c <moduleIMG+0xc1c>)
 8004714:	494e      	ldr	r1, [pc, #312]	; (8004850 <moduleIMG+0xbf0>)
 8004716:	484a      	ldr	r0, [pc, #296]	; (8004840 <moduleIMG+0xbe0>)
 8004718:	f00d ffe2 	bl	80126e0 <chprintf.constprop.35>
 800471c:	494d      	ldr	r1, [pc, #308]	; (8004854 <moduleIMG+0xbf4>)
 800471e:	4848      	ldr	r0, [pc, #288]	; (8004840 <moduleIMG+0xbe0>)
 8004720:	f00d ffde 	bl	80126e0 <chprintf.constprop.35>
 8004724:	4642      	mov	r2, r8
 8004726:	4956      	ldr	r1, [pc, #344]	; (8004880 <moduleIMG+0xc20>)
 8004728:	4845      	ldr	r0, [pc, #276]	; (8004840 <moduleIMG+0xbe0>)
 800472a:	f00d ffd9 	bl	80126e0 <chprintf.constprop.35>
 800472e:	494b      	ldr	r1, [pc, #300]	; (800485c <moduleIMG+0xbfc>)
 8004730:	4843      	ldr	r0, [pc, #268]	; (8004840 <moduleIMG+0xbe0>)
 8004732:	f00d ffd5 	bl	80126e0 <chprintf.constprop.35>
 8004736:	483e      	ldr	r0, [pc, #248]	; (8004830 <moduleIMG+0xbd0>)
 8004738:	f00a fb7a 	bl	800ee30 <chMtxUnlock>

					// Write image to SD card
					TRACE_INFO("IMG  > Write to SD card");
 800473c:	483c      	ldr	r0, [pc, #240]	; (8004830 <moduleIMG+0xbd0>)
 800473e:	f00a fbd7 	bl	800eef0 <chMtxLock>
 8004742:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8004744:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8004746:	493d      	ldr	r1, [pc, #244]	; (800483c <moduleIMG+0xbdc>)
 8004748:	483d      	ldr	r0, [pc, #244]	; (8004840 <moduleIMG+0xbe0>)
 800474a:	fb04 f303 	mul.w	r3, r4, r3
 800474e:	fba5 e303 	umull	lr, r3, r5, r3
 8004752:	0b9b      	lsrs	r3, r3, #14
 8004754:	fba7 ce03 	umull	ip, lr, r7, r3
 8004758:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800475c:	fba5 c202 	umull	ip, r2, r5, r2
 8004760:	fb04 331e 	mls	r3, r4, lr, r3
 8004764:	0b92      	lsrs	r2, r2, #14
 8004766:	f00d ffbb 	bl	80126e0 <chprintf.constprop.35>
 800476a:	4a36      	ldr	r2, [pc, #216]	; (8004844 <moduleIMG+0xbe4>)
 800476c:	4936      	ldr	r1, [pc, #216]	; (8004848 <moduleIMG+0xbe8>)
 800476e:	4834      	ldr	r0, [pc, #208]	; (8004840 <moduleIMG+0xbe0>)
 8004770:	f00d ffb6 	bl	80126e0 <chprintf.constprop.35>
 8004774:	23c3      	movs	r3, #195	; 0xc3
 8004776:	4a41      	ldr	r2, [pc, #260]	; (800487c <moduleIMG+0xc1c>)
 8004778:	4935      	ldr	r1, [pc, #212]	; (8004850 <moduleIMG+0xbf0>)
 800477a:	4831      	ldr	r0, [pc, #196]	; (8004840 <moduleIMG+0xbe0>)
 800477c:	f00d ffb0 	bl	80126e0 <chprintf.constprop.35>
 8004780:	4934      	ldr	r1, [pc, #208]	; (8004854 <moduleIMG+0xbf4>)
 8004782:	482f      	ldr	r0, [pc, #188]	; (8004840 <moduleIMG+0xbe0>)
 8004784:	f00d ffac 	bl	80126e0 <chprintf.constprop.35>
 8004788:	493e      	ldr	r1, [pc, #248]	; (8004884 <moduleIMG+0xc24>)
 800478a:	482d      	ldr	r0, [pc, #180]	; (8004840 <moduleIMG+0xbe0>)
 800478c:	f00d ffa8 	bl	80126e0 <chprintf.constprop.35>
 8004790:	4932      	ldr	r1, [pc, #200]	; (800485c <moduleIMG+0xbfc>)
 8004792:	482b      	ldr	r0, [pc, #172]	; (8004840 <moduleIMG+0xbe0>)
 8004794:	f00d ffa4 	bl	80126e0 <chprintf.constprop.35>
 8004798:	4825      	ldr	r0, [pc, #148]	; (8004830 <moduleIMG+0xbd0>)
 800479a:	f00a fb49 	bl	800ee30 <chMtxUnlock>
					char filename[16];
					chsnprintf(filename, sizeof(filename), "image%d.jpg", gimage_id);
 800479e:	4b3a      	ldr	r3, [pc, #232]	; (8004888 <moduleIMG+0xc28>)
 80047a0:	4a3a      	ldr	r2, [pc, #232]	; (800488c <moduleIMG+0xc2c>)
 80047a2:	681b      	ldr	r3, [r3, #0]
 80047a4:	a80b      	add	r0, sp, #44	; 0x2c
 80047a6:	2110      	movs	r1, #16
 80047a8:	f007 fd42 	bl	800c230 <chsnprintf>
	return sdInitialized;
}

bool writeBufferToFile(const char *filename, const uint8_t *buffer, uint32_t len)
{
	if(!sdInitialized)
 80047ac:	4b38      	ldr	r3, [pc, #224]	; (8004890 <moduleIMG+0xc30>)
 80047ae:	781b      	ldrb	r3, [r3, #0]
 80047b0:	2b00      	cmp	r3, #0
 80047b2:	f43f ad7a 	beq.w	80042aa <moduleIMG+0x64a>
					writeBufferToFile(filename, image, image_len);
 80047b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80047b8:	4836      	ldr	r0, [pc, #216]	; (8004894 <moduleIMG+0xc34>)
 80047ba:	9306      	str	r3, [sp, #24]
 80047bc:	f00a fb98 	bl	800eef0 <chMtxLock>
	static FIL fdst;
	FRESULT res;
	bool gres = true; // Optimist

	// Mount SD card
	TRACE_INFO("SD   > Mount");
 80047c0:	481b      	ldr	r0, [pc, #108]	; (8004830 <moduleIMG+0xbd0>)
 80047c2:	f00a fb95 	bl	800eef0 <chMtxLock>
 80047c6:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80047c8:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80047ca:	491c      	ldr	r1, [pc, #112]	; (800483c <moduleIMG+0xbdc>)
 80047cc:	481c      	ldr	r0, [pc, #112]	; (8004840 <moduleIMG+0xbe0>)
 80047ce:	fb04 f303 	mul.w	r3, r4, r3
 80047d2:	fba5 e303 	umull	lr, r3, r5, r3
 80047d6:	0b9b      	lsrs	r3, r3, #14
 80047d8:	fba7 ce03 	umull	ip, lr, r7, r3
 80047dc:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 80047e0:	fba5 c202 	umull	ip, r2, r5, r2
 80047e4:	fb04 331e 	mls	r3, r4, lr, r3
 80047e8:	0b92      	lsrs	r2, r2, #14
 80047ea:	f00d ff79 	bl	80126e0 <chprintf.constprop.35>
 80047ee:	4a15      	ldr	r2, [pc, #84]	; (8004844 <moduleIMG+0xbe4>)
 80047f0:	4915      	ldr	r1, [pc, #84]	; (8004848 <moduleIMG+0xbe8>)
 80047f2:	4813      	ldr	r0, [pc, #76]	; (8004840 <moduleIMG+0xbe0>)
 80047f4:	f00d ff74 	bl	80126e0 <chprintf.constprop.35>
 80047f8:	233c      	movs	r3, #60	; 0x3c
 80047fa:	4a27      	ldr	r2, [pc, #156]	; (8004898 <moduleIMG+0xc38>)
 80047fc:	4914      	ldr	r1, [pc, #80]	; (8004850 <moduleIMG+0xbf0>)
 80047fe:	4810      	ldr	r0, [pc, #64]	; (8004840 <moduleIMG+0xbe0>)
 8004800:	f00d ff6e 	bl	80126e0 <chprintf.constprop.35>
 8004804:	4913      	ldr	r1, [pc, #76]	; (8004854 <moduleIMG+0xbf4>)
 8004806:	480e      	ldr	r0, [pc, #56]	; (8004840 <moduleIMG+0xbe0>)
 8004808:	f00d ff6a 	bl	80126e0 <chprintf.constprop.35>
 800480c:	4923      	ldr	r1, [pc, #140]	; (800489c <moduleIMG+0xc3c>)
 800480e:	480c      	ldr	r0, [pc, #48]	; (8004840 <moduleIMG+0xbe0>)
 8004810:	f00d ff66 	bl	80126e0 <chprintf.constprop.35>
 8004814:	4911      	ldr	r1, [pc, #68]	; (800485c <moduleIMG+0xbfc>)
 8004816:	480a      	ldr	r0, [pc, #40]	; (8004840 <moduleIMG+0xbe0>)
 8004818:	f00d ff62 	bl	80126e0 <chprintf.constprop.35>
 800481c:	4804      	ldr	r0, [pc, #16]	; (8004830 <moduleIMG+0xbd0>)
 800481e:	f00a fb07 	bl	800ee30 <chMtxUnlock>
	res = f_mount(&fs, "/", 0);
 8004822:	491f      	ldr	r1, [pc, #124]	; (80048a0 <moduleIMG+0xc40>)
 8004824:	481f      	ldr	r0, [pc, #124]	; (80048a4 <moduleIMG+0xc44>)
 8004826:	f009 fc63 	bl	800e0f0 <f_mount.constprop.12>
	if(res != FR_OK)
 800482a:	4603      	mov	r3, r0
 800482c:	9004      	str	r0, [sp, #16]
 800482e:	e03b      	b.n	80048a8 <moduleIMG+0xc48>
 8004830:	20027b2c 	.word	0x20027b2c
 8004834:	d1b71759 	.word	0xd1b71759
 8004838:	10624dd3 	.word	0x10624dd3
 800483c:	08013c50 	.word	0x08013c50
 8004840:	20027e60 	.word	0x20027e60
 8004844:	08013cfc 	.word	0x08013cfc
 8004848:	08013c5c 	.word	0x08013c5c
 800484c:	080143f4 	.word	0x080143f4
 8004850:	08013c78 	.word	0x08013c78
 8004854:	08013d00 	.word	0x08013d00
 8004858:	08014400 	.word	0x08014400
 800485c:	08013cac 	.word	0x08013cac
 8004860:	40023800 	.word	0x40023800
 8004864:	50050000 	.word	0x50050000
 8004868:	08014414 	.word	0x08014414
 800486c:	40026408 	.word	0x40026408
 8004870:	08014428 	.word	0x08014428
 8004874:	40021000 	.word	0x40021000
 8004878:	200278f8 	.word	0x200278f8
 800487c:	08014340 	.word	0x08014340
 8004880:	0801443c 	.word	0x0801443c
 8004884:	08014458 	.word	0x08014458
 8004888:	20000cd8 	.word	0x20000cd8
 800488c:	08014470 	.word	0x08014470
 8004890:	20027798 	.word	0x20027798
 8004894:	200287a8 	.word	0x200287a8
 8004898:	08014484 	.word	0x08014484
 800489c:	0801448c 	.word	0x0801448c
 80048a0:	0801449c 	.word	0x0801449c
 80048a4:	20000ce0 	.word	0x20000ce0
	{

		TRACE_ERROR("SD   > Mounting failed (err=%d)", res);
 80048a8:	48a0      	ldr	r0, [pc, #640]	; (8004b2c <moduleIMG+0xecc>)
	bool gres = true; // Optimist

	// Mount SD card
	TRACE_INFO("SD   > Mount");
	res = f_mount(&fs, "/", 0);
	if(res != FR_OK)
 80048aa:	2b00      	cmp	r3, #0
 80048ac:	d037      	beq.n	800491e <moduleIMG+0xcbe>
	{

		TRACE_ERROR("SD   > Mounting failed (err=%d)", res);
 80048ae:	f00a fb1f 	bl	800eef0 <chMtxLock>
 80048b2:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80048b4:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80048b6:	499e      	ldr	r1, [pc, #632]	; (8004b30 <moduleIMG+0xed0>)
 80048b8:	fb04 f303 	mul.w	r3, r4, r3
 80048bc:	fba5 6303 	umull	r6, r3, r5, r3
 80048c0:	0b9b      	lsrs	r3, r3, #14
 80048c2:	fba7 6003 	umull	r6, r0, r7, r3
 80048c6:	0980      	lsrs	r0, r0, #6
 80048c8:	fba5 5202 	umull	r5, r2, r5, r2
 80048cc:	fb04 3310 	mls	r3, r4, r0, r3
 80048d0:	0b92      	lsrs	r2, r2, #14
 80048d2:	4898      	ldr	r0, [pc, #608]	; (8004b34 <moduleIMG+0xed4>)
 80048d4:	f00d ff04 	bl	80126e0 <chprintf.constprop.35>
 80048d8:	4a97      	ldr	r2, [pc, #604]	; (8004b38 <moduleIMG+0xed8>)
 80048da:	4998      	ldr	r1, [pc, #608]	; (8004b3c <moduleIMG+0xedc>)
 80048dc:	4895      	ldr	r0, [pc, #596]	; (8004b34 <moduleIMG+0xed4>)
 80048de:	f00d feff 	bl	80126e0 <chprintf.constprop.35>
 80048e2:	2341      	movs	r3, #65	; 0x41
 80048e4:	4a96      	ldr	r2, [pc, #600]	; (8004b40 <moduleIMG+0xee0>)
 80048e6:	4997      	ldr	r1, [pc, #604]	; (8004b44 <moduleIMG+0xee4>)
 80048e8:	4892      	ldr	r0, [pc, #584]	; (8004b34 <moduleIMG+0xed4>)
 80048ea:	f00d fef9 	bl	80126e0 <chprintf.constprop.35>
 80048ee:	4996      	ldr	r1, [pc, #600]	; (8004b48 <moduleIMG+0xee8>)
 80048f0:	4890      	ldr	r0, [pc, #576]	; (8004b34 <moduleIMG+0xed4>)
 80048f2:	f00d fef5 	bl	80126e0 <chprintf.constprop.35>
 80048f6:	9a04      	ldr	r2, [sp, #16]
 80048f8:	4994      	ldr	r1, [pc, #592]	; (8004b4c <moduleIMG+0xeec>)
 80048fa:	488e      	ldr	r0, [pc, #568]	; (8004b34 <moduleIMG+0xed4>)
 80048fc:	f00d fef0 	bl	80126e0 <chprintf.constprop.35>
 8004900:	4993      	ldr	r1, [pc, #588]	; (8004b50 <moduleIMG+0xef0>)
 8004902:	488c      	ldr	r0, [pc, #560]	; (8004b34 <moduleIMG+0xed4>)
 8004904:	f00d feec 	bl	80126e0 <chprintf.constprop.35>
 8004908:	4888      	ldr	r0, [pc, #544]	; (8004b2c <moduleIMG+0xecc>)
 800490a:	f00a fa91 	bl	800ee30 <chMtxUnlock>
 800490e:	2141      	movs	r1, #65	; 0x41
 8004910:	488b      	ldr	r0, [pc, #556]	; (8004b40 <moduleIMG+0xee0>)
 8004912:	f00b fb25 	bl	800ff60 <log_error>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8004916:	488f      	ldr	r0, [pc, #572]	; (8004b54 <moduleIMG+0xef4>)
 8004918:	f00a fa8a 	bl	800ee30 <chMtxUnlock>
 800491c:	e4c5      	b.n	80042aa <moduleIMG+0x64a>
		gres = false;

	} else {

		// Open file
		TRACE_INFO("SD   > Open file %s", filename);
 800491e:	f00a fae7 	bl	800eef0 <chMtxLock>
 8004922:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8004924:	6a71      	ldr	r1, [r6, #36]	; 0x24
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */
 8004926:	f8df 8254 	ldr.w	r8, [pc, #596]	; 8004b7c <moduleIMG+0xf1c>
 800492a:	fb04 f101 	mul.w	r1, r4, r1
 800492e:	fba5 3101 	umull	r3, r1, r5, r1
 8004932:	0b89      	lsrs	r1, r1, #14
 8004934:	fba7 3701 	umull	r3, r7, r7, r1
 8004938:	fba5 0202 	umull	r0, r2, r5, r2
 800493c:	09bb      	lsrs	r3, r7, #6
 800493e:	fb04 1313 	mls	r3, r4, r3, r1
 8004942:	0b92      	lsrs	r2, r2, #14
 8004944:	497a      	ldr	r1, [pc, #488]	; (8004b30 <moduleIMG+0xed0>)
 8004946:	487b      	ldr	r0, [pc, #492]	; (8004b34 <moduleIMG+0xed4>)
 8004948:	f00d feca 	bl	80126e0 <chprintf.constprop.35>
 800494c:	4a82      	ldr	r2, [pc, #520]	; (8004b58 <moduleIMG+0xef8>)
 800494e:	497b      	ldr	r1, [pc, #492]	; (8004b3c <moduleIMG+0xedc>)
 8004950:	4878      	ldr	r0, [pc, #480]	; (8004b34 <moduleIMG+0xed4>)
 8004952:	f00d fec5 	bl	80126e0 <chprintf.constprop.35>
 8004956:	2347      	movs	r3, #71	; 0x47
 8004958:	4a79      	ldr	r2, [pc, #484]	; (8004b40 <moduleIMG+0xee0>)
 800495a:	497a      	ldr	r1, [pc, #488]	; (8004b44 <moduleIMG+0xee4>)
 800495c:	4875      	ldr	r0, [pc, #468]	; (8004b34 <moduleIMG+0xed4>)
 800495e:	f00d febf 	bl	80126e0 <chprintf.constprop.35>
 8004962:	4979      	ldr	r1, [pc, #484]	; (8004b48 <moduleIMG+0xee8>)
 8004964:	4873      	ldr	r0, [pc, #460]	; (8004b34 <moduleIMG+0xed4>)
 8004966:	f00d febb 	bl	80126e0 <chprintf.constprop.35>
 800496a:	aa0b      	add	r2, sp, #44	; 0x2c
 800496c:	497b      	ldr	r1, [pc, #492]	; (8004b5c <moduleIMG+0xefc>)
 800496e:	4871      	ldr	r0, [pc, #452]	; (8004b34 <moduleIMG+0xed4>)
 8004970:	f00d feb6 	bl	80126e0 <chprintf.constprop.35>
 8004974:	4976      	ldr	r1, [pc, #472]	; (8004b50 <moduleIMG+0xef0>)
 8004976:	486f      	ldr	r0, [pc, #444]	; (8004b34 <moduleIMG+0xed4>)
 8004978:	f00d feb2 	bl	80126e0 <chprintf.constprop.35>
 800497c:	486b      	ldr	r0, [pc, #428]	; (8004b2c <moduleIMG+0xecc>)
 800497e:	f00a fa57 	bl	800ee30 <chMtxUnlock>
 8004982:	ab0b      	add	r3, sp, #44	; 0x2c
 8004984:	930a      	str	r3, [sp, #40]	; 0x28
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8004986:	a80a      	add	r0, sp, #40	; 0x28
	WORD nrsv;
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
 8004988:	9b04      	ldr	r3, [sp, #16]
 800498a:	9313      	str	r3, [sp, #76]	; 0x4c
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */
 800498c:	f8c8 3000 	str.w	r3, [r8]
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 8004990:	f00d f976 	bl	8011c80 <get_ldnumber.lto_priv.113>
	if (vol < 0) return FR_INVALID_DRIVE;
 8004994:	1e05      	subs	r5, r0, #0
 8004996:	f2c0 80c6 	blt.w	8004b26 <moduleIMG+0xec6>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 800499a:	4b71      	ldr	r3, [pc, #452]	; (8004b60 <moduleIMG+0xf00>)
 800499c:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80049a0:	2c00      	cmp	r4, #0
 80049a2:	f000 845c 	beq.w	800525e <moduleIMG+0x15fe>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 80049a6:	9413      	str	r4, [sp, #76]	; 0x4c

	if (fs->fs_type) {					/* If the volume has been mounted */
 80049a8:	7823      	ldrb	r3, [r4, #0]
 80049aa:	2b00      	cmp	r3, #0
 80049ac:	f000 81e6 	beq.w	8004d7c <moduleIMG+0x111c>
		stat = disk_status(fs->drv);
 80049b0:	7860      	ldrb	r0, [r4, #1]
 80049b2:	f007 faa5 	bl	800bf00 <disk_initialize>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 80049b6:	07c7      	lsls	r7, r0, #31
 80049b8:	f100 81e0 	bmi.w	8004d7c <moduleIMG+0x111c>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 80049bc:	0746      	lsls	r6, r0, #29
 80049be:	f140 8170 	bpl.w	8004ca2 <moduleIMG+0x1042>
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80049c2:	240a      	movs	r4, #10
		res = f_open(&fdst, (TCHAR*)filename, FA_CREATE_ALWAYS | FA_WRITE);
		if(res != FR_OK)
		{

			TRACE_ERROR("SD   > Opening file failed (err=%d)", res);
 80049c4:	4859      	ldr	r0, [pc, #356]	; (8004b2c <moduleIMG+0xecc>)
 80049c6:	4d67      	ldr	r5, [pc, #412]	; (8004b64 <moduleIMG+0xf04>)
 80049c8:	f00a fa92 	bl	800eef0 <chMtxLock>
 80049cc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80049d0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80049d4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80049d6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80049d8:	4b63      	ldr	r3, [pc, #396]	; (8004b68 <moduleIMG+0xf08>)
 80049da:	fb00 f101 	mul.w	r1, r0, r1
 80049de:	fba5 6101 	umull	r6, r1, r5, r1
 80049e2:	0b89      	lsrs	r1, r1, #14
 80049e4:	fba3 6301 	umull	r6, r3, r3, r1
 80049e8:	fba5 5202 	umull	r5, r2, r5, r2
 80049ec:	099b      	lsrs	r3, r3, #6
 80049ee:	fb00 1313 	mls	r3, r0, r3, r1
 80049f2:	0b92      	lsrs	r2, r2, #14
 80049f4:	494e      	ldr	r1, [pc, #312]	; (8004b30 <moduleIMG+0xed0>)
 80049f6:	484f      	ldr	r0, [pc, #316]	; (8004b34 <moduleIMG+0xed4>)
 80049f8:	f00d fe72 	bl	80126e0 <chprintf.constprop.35>
 80049fc:	4a4e      	ldr	r2, [pc, #312]	; (8004b38 <moduleIMG+0xed8>)
 80049fe:	494f      	ldr	r1, [pc, #316]	; (8004b3c <moduleIMG+0xedc>)
 8004a00:	484c      	ldr	r0, [pc, #304]	; (8004b34 <moduleIMG+0xed4>)
 8004a02:	f00d fe6d 	bl	80126e0 <chprintf.constprop.35>
 8004a06:	234c      	movs	r3, #76	; 0x4c
 8004a08:	4a4d      	ldr	r2, [pc, #308]	; (8004b40 <moduleIMG+0xee0>)
 8004a0a:	494e      	ldr	r1, [pc, #312]	; (8004b44 <moduleIMG+0xee4>)
 8004a0c:	4849      	ldr	r0, [pc, #292]	; (8004b34 <moduleIMG+0xed4>)
 8004a0e:	f00d fe67 	bl	80126e0 <chprintf.constprop.35>
 8004a12:	494d      	ldr	r1, [pc, #308]	; (8004b48 <moduleIMG+0xee8>)
 8004a14:	4847      	ldr	r0, [pc, #284]	; (8004b34 <moduleIMG+0xed4>)
 8004a16:	f00d fe63 	bl	80126e0 <chprintf.constprop.35>
 8004a1a:	4622      	mov	r2, r4
 8004a1c:	4953      	ldr	r1, [pc, #332]	; (8004b6c <moduleIMG+0xf0c>)
 8004a1e:	4845      	ldr	r0, [pc, #276]	; (8004b34 <moduleIMG+0xed4>)
 8004a20:	f00d fe5e 	bl	80126e0 <chprintf.constprop.35>
 8004a24:	494a      	ldr	r1, [pc, #296]	; (8004b50 <moduleIMG+0xef0>)
 8004a26:	4843      	ldr	r0, [pc, #268]	; (8004b34 <moduleIMG+0xed4>)
 8004a28:	f00d fe5a 	bl	80126e0 <chprintf.constprop.35>
 8004a2c:	483f      	ldr	r0, [pc, #252]	; (8004b2c <moduleIMG+0xecc>)
 8004a2e:	f00a f9ff 	bl	800ee30 <chMtxUnlock>
 8004a32:	214c      	movs	r1, #76	; 0x4c
 8004a34:	4842      	ldr	r0, [pc, #264]	; (8004b40 <moduleIMG+0xee0>)
 8004a36:	f00b fa93 	bl	800ff60 <log_error>
 8004a3a:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
			}

		}

		// Unmount
		TRACE_INFO("SD   > Unmount");
 8004a3e:	483b      	ldr	r0, [pc, #236]	; (8004b2c <moduleIMG+0xecc>)
 8004a40:	4f48      	ldr	r7, [pc, #288]	; (8004b64 <moduleIMG+0xf04>)
 8004a42:	f8df 8124 	ldr.w	r8, [pc, #292]	; 8004b68 <moduleIMG+0xf08>
 8004a46:	f00a fa53 	bl	800eef0 <chMtxLock>
 8004a4a:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8004a4c:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8004a4e:	4938      	ldr	r1, [pc, #224]	; (8004b30 <moduleIMG+0xed0>)
 8004a50:	4838      	ldr	r0, [pc, #224]	; (8004b34 <moduleIMG+0xed4>)
 8004a52:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8004a56:	fb04 f303 	mul.w	r3, r4, r3
 8004a5a:	fba7 5303 	umull	r5, r3, r7, r3
 8004a5e:	0b9b      	lsrs	r3, r3, #14
 8004a60:	fba8 e503 	umull	lr, r5, r8, r3
 8004a64:	09ad      	lsrs	r5, r5, #6
 8004a66:	fba7 e202 	umull	lr, r2, r7, r2
 8004a6a:	fb04 3315 	mls	r3, r4, r5, r3
 8004a6e:	0b92      	lsrs	r2, r2, #14
 8004a70:	f00d fe36 	bl	80126e0 <chprintf.constprop.35>
 8004a74:	4a38      	ldr	r2, [pc, #224]	; (8004b58 <moduleIMG+0xef8>)
 8004a76:	4931      	ldr	r1, [pc, #196]	; (8004b3c <moduleIMG+0xedc>)
 8004a78:	482e      	ldr	r0, [pc, #184]	; (8004b34 <moduleIMG+0xed4>)
 8004a7a:	f00d fe31 	bl	80126e0 <chprintf.constprop.35>
 8004a7e:	2367      	movs	r3, #103	; 0x67
 8004a80:	4a2f      	ldr	r2, [pc, #188]	; (8004b40 <moduleIMG+0xee0>)
 8004a82:	4930      	ldr	r1, [pc, #192]	; (8004b44 <moduleIMG+0xee4>)
 8004a84:	482b      	ldr	r0, [pc, #172]	; (8004b34 <moduleIMG+0xed4>)
 8004a86:	f00d fe2b 	bl	80126e0 <chprintf.constprop.35>
 8004a8a:	492f      	ldr	r1, [pc, #188]	; (8004b48 <moduleIMG+0xee8>)
 8004a8c:	4829      	ldr	r0, [pc, #164]	; (8004b34 <moduleIMG+0xed4>)
 8004a8e:	f00d fe27 	bl	80126e0 <chprintf.constprop.35>
 8004a92:	4937      	ldr	r1, [pc, #220]	; (8004b70 <moduleIMG+0xf10>)
 8004a94:	4827      	ldr	r0, [pc, #156]	; (8004b34 <moduleIMG+0xed4>)
 8004a96:	f00d fe23 	bl	80126e0 <chprintf.constprop.35>
 8004a9a:	492d      	ldr	r1, [pc, #180]	; (8004b50 <moduleIMG+0xef0>)
 8004a9c:	4825      	ldr	r0, [pc, #148]	; (8004b34 <moduleIMG+0xed4>)
 8004a9e:	f00d fe1f 	bl	80126e0 <chprintf.constprop.35>
 8004aa2:	4822      	ldr	r0, [pc, #136]	; (8004b2c <moduleIMG+0xecc>)
 8004aa4:	f00a f9c4 	bl	800ee30 <chMtxUnlock>
		res = f_mount(0, "", 0);
 8004aa8:	4932      	ldr	r1, [pc, #200]	; (8004b74 <moduleIMG+0xf14>)
 8004aaa:	2000      	movs	r0, #0
 8004aac:	f009 fb20 	bl	800e0f0 <f_mount.constprop.12>
		if(res != FR_OK)
 8004ab0:	4605      	mov	r5, r0
 8004ab2:	2800      	cmp	r0, #0
 8004ab4:	f43f af2f 	beq.w	8004916 <moduleIMG+0xcb6>
		{
			TRACE_ERROR("SD   > Unmounting failed (err=%d)", res);
 8004ab8:	481c      	ldr	r0, [pc, #112]	; (8004b2c <moduleIMG+0xecc>)
 8004aba:	f00a fa19 	bl	800eef0 <chMtxLock>
 8004abe:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8004ac0:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8004ac2:	491b      	ldr	r1, [pc, #108]	; (8004b30 <moduleIMG+0xed0>)
 8004ac4:	fb04 f000 	mul.w	r0, r4, r0
 8004ac8:	fba7 3000 	umull	r3, r0, r7, r0
 8004acc:	0b80      	lsrs	r0, r0, #14
 8004ace:	fba8 3800 	umull	r3, r8, r8, r0
 8004ad2:	ea4f 1398 	mov.w	r3, r8, lsr #6
 8004ad6:	fba7 6202 	umull	r6, r2, r7, r2
 8004ada:	fb04 0313 	mls	r3, r4, r3, r0
 8004ade:	0b92      	lsrs	r2, r2, #14
 8004ae0:	4814      	ldr	r0, [pc, #80]	; (8004b34 <moduleIMG+0xed4>)
 8004ae2:	f00d fdfd 	bl	80126e0 <chprintf.constprop.35>
 8004ae6:	4a14      	ldr	r2, [pc, #80]	; (8004b38 <moduleIMG+0xed8>)
 8004ae8:	4914      	ldr	r1, [pc, #80]	; (8004b3c <moduleIMG+0xedc>)
 8004aea:	4812      	ldr	r0, [pc, #72]	; (8004b34 <moduleIMG+0xed4>)
 8004aec:	f00d fdf8 	bl	80126e0 <chprintf.constprop.35>
 8004af0:	236b      	movs	r3, #107	; 0x6b
 8004af2:	4a13      	ldr	r2, [pc, #76]	; (8004b40 <moduleIMG+0xee0>)
 8004af4:	4913      	ldr	r1, [pc, #76]	; (8004b44 <moduleIMG+0xee4>)
 8004af6:	480f      	ldr	r0, [pc, #60]	; (8004b34 <moduleIMG+0xed4>)
 8004af8:	f00d fdf2 	bl	80126e0 <chprintf.constprop.35>
 8004afc:	4912      	ldr	r1, [pc, #72]	; (8004b48 <moduleIMG+0xee8>)
 8004afe:	480d      	ldr	r0, [pc, #52]	; (8004b34 <moduleIMG+0xed4>)
 8004b00:	f00d fdee 	bl	80126e0 <chprintf.constprop.35>
 8004b04:	462a      	mov	r2, r5
 8004b06:	491c      	ldr	r1, [pc, #112]	; (8004b78 <moduleIMG+0xf18>)
 8004b08:	480a      	ldr	r0, [pc, #40]	; (8004b34 <moduleIMG+0xed4>)
 8004b0a:	f00d fde9 	bl	80126e0 <chprintf.constprop.35>
 8004b0e:	4910      	ldr	r1, [pc, #64]	; (8004b50 <moduleIMG+0xef0>)
 8004b10:	4808      	ldr	r0, [pc, #32]	; (8004b34 <moduleIMG+0xed4>)
 8004b12:	f00d fde5 	bl	80126e0 <chprintf.constprop.35>
 8004b16:	4805      	ldr	r0, [pc, #20]	; (8004b2c <moduleIMG+0xecc>)
 8004b18:	f00a f98a 	bl	800ee30 <chMtxUnlock>
 8004b1c:	216b      	movs	r1, #107	; 0x6b
 8004b1e:	4808      	ldr	r0, [pc, #32]	; (8004b40 <moduleIMG+0xee0>)
 8004b20:	f00b fa1e 	bl	800ff60 <log_error>
 8004b24:	e6f7      	b.n	8004916 <moduleIMG+0xcb6>


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 8004b26:	240b      	movs	r4, #11
 8004b28:	e74c      	b.n	80049c4 <moduleIMG+0xd64>
 8004b2a:	bf00      	nop
 8004b2c:	20027b2c 	.word	0x20027b2c
 8004b30:	08013c50 	.word	0x08013c50
 8004b34:	20027e60 	.word	0x20027e60
 8004b38:	08013d9c 	.word	0x08013d9c
 8004b3c:	08013c5c 	.word	0x08013c5c
 8004b40:	08014484 	.word	0x08014484
 8004b44:	08013c78 	.word	0x08013c78
 8004b48:	08013d00 	.word	0x08013d00
 8004b4c:	080144a0 	.word	0x080144a0
 8004b50:	08013cac 	.word	0x08013cac
 8004b54:	200287a8 	.word	0x200287a8
 8004b58:	08013cfc 	.word	0x08013cfc
 8004b5c:	080144c0 	.word	0x080144c0
 8004b60:	20027b3c 	.word	0x20027b3c
 8004b64:	d1b71759 	.word	0xd1b71759
 8004b68:	10624dd3 	.word	0x10624dd3
 8004b6c:	08014614 	.word	0x08014614
 8004b70:	08014530 	.word	0x08014530
 8004b74:	080144f8 	.word	0x080144f8
 8004b78:	08014540 	.word	0x08014540
 8004b7c:	20027908 	.word	0x20027908
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8004b80:	2002      	movs	r0, #2
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8004b82:	ab13      	add	r3, sp, #76	; 0x4c
 8004b84:	429e      	cmp	r6, r3
 8004b86:	f000 839d 	beq.w	80052c4 <moduleIMG+0x1664>
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
 8004b8a:	f856 5b04 	ldr.w	r5, [r6], #4
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 8004b8e:	2d00      	cmp	r5, #0
 8004b90:	d0f6      	beq.n	8004b80 <moduleIMG+0xf20>
 8004b92:	4629      	mov	r1, r5
 8004b94:	4620      	mov	r0, r4
 8004b96:	f00d fabb 	bl	8012110 <check_fs.lto_priv.152>
		} while (!LD2PT(vol) && fmt && ++i < 4);
 8004b9a:	2800      	cmp	r0, #0
 8004b9c:	d1f1      	bne.n	8004b82 <moduleIMG+0xf22>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8004b9e:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
 8004ba2:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
 8004ba6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8004baa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004bae:	f040 838f 	bne.w	80052d0 <moduleIMG+0x1670>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8004bb2:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 8004bb6:	f894 e040 	ldrb.w	lr, [r4, #64]	; 0x40
	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8004bba:	f894 7047 	ldrb.w	r7, [r4, #71]	; 0x47
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 8004bbe:	f884 e003 	strb.w	lr, [r4, #3]

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8004bc2:	ea53 2707 	orrs.w	r7, r3, r7, lsl #8
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8004bc6:	f10e 33ff 	add.w	r3, lr, #4294967295

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 8004bca:	bf08      	it	eq
 8004bcc:	6d67      	ldreq	r7, [r4, #84]	; 0x54
	fs->fsize = fasize;
 8004bce:	61a7      	str	r7, [r4, #24]

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8004bd0:	2b01      	cmp	r3, #1
 8004bd2:	f200 837d 	bhi.w	80052d0 <moduleIMG+0x1670>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 8004bd6:	f894 003d 	ldrb.w	r0, [r4, #61]	; 0x3d
 8004bda:	70a0      	strb	r0, [r4, #2]
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
 8004bdc:	fb07 fe0e 	mul.w	lr, r7, lr

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 8004be0:	2800      	cmp	r0, #0
 8004be2:	f000 8375 	beq.w	80052d0 <moduleIMG+0x1670>
 8004be6:	1e43      	subs	r3, r0, #1
 8004be8:	4203      	tst	r3, r0
 8004bea:	f040 8371 	bne.w	80052d0 <moduleIMG+0x1670>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8004bee:	f894 6042 	ldrb.w	r6, [r4, #66]	; 0x42
 8004bf2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8004bf6:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
 8004bfa:	0731      	lsls	r1, r6, #28

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 8004bfc:	8126      	strh	r6, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
 8004bfe:	f040 8367 	bne.w	80052d0 <moduleIMG+0x1670>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8004c02:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8004c06:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8004c0a:	f894 103f 	ldrb.w	r1, [r4, #63]	; 0x3f
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8004c0e:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 8004c12:	f894 203e 	ldrb.w	r2, [r4, #62]	; 0x3e
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 8004c16:	bf08      	it	eq
 8004c18:	6d23      	ldreq	r3, [r4, #80]	; 0x50

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 8004c1a:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8004c1e:	f000 8357 	beq.w	80052d0 <moduleIMG+0x1670>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 8004c22:	eb02 1116 	add.w	r1, r2, r6, lsr #4
 8004c26:	4471      	add	r1, lr
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8004c28:	4299      	cmp	r1, r3
 8004c2a:	f200 8351 	bhi.w	80052d0 <moduleIMG+0x1670>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 8004c2e:	1a5b      	subs	r3, r3, r1
 8004c30:	fbb3 f3f0 	udiv	r3, r3, r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 8004c34:	2b00      	cmp	r3, #0
 8004c36:	f000 834b 	beq.w	80052d0 <moduleIMG+0x1670>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 8004c3a:	f640 70f5 	movw	r0, #4085	; 0xff5
 8004c3e:	4283      	cmp	r3, r0
 8004c40:	f240 84e4 	bls.w	800560c <moduleIMG+0x19ac>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 8004c44:	f64f 70f5 	movw	r0, #65525	; 0xfff5
 8004c48:	4283      	cmp	r3, r0
 8004c4a:	f240 8505 	bls.w	8005658 <moduleIMG+0x19f8>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004c4e:	3302      	adds	r3, #2
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8004c50:	442a      	add	r2, r5
	fs->database = bsect + sysect;						/* Data start sector */
 8004c52:	4429      	add	r1, r5
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8004c54:	6163      	str	r3, [r4, #20]
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8004c56:	6222      	str	r2, [r4, #32]
	fs->database = bsect + sysect;						/* Data start sector */
 8004c58:	62a1      	str	r1, [r4, #40]	; 0x28
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->volbase = bsect;								/* Volume start sector */
 8004c5a:	61e5      	str	r5, [r4, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	fs->database = bsect + sysect;						/* Data start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 8004c5c:	2e00      	cmp	r6, #0
 8004c5e:	f040 8337 	bne.w	80052d0 <moduleIMG+0x1670>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8004c62:	009b      	lsls	r3, r3, #2
 8004c64:	f203 12ff 	addw	r2, r3, #511	; 0x1ff
 8004c68:	ebb7 2f52 	cmp.w	r7, r2, lsr #9
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	fs->database = bsect + sysect;						/* Data start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 8004c6c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8004c6e:	6263      	str	r3, [r4, #36]	; 0x24
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8004c70:	f0c0 832e 	bcc.w	80052d0 <moduleIMG+0x1670>

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
 8004c74:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
 8004c78:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
 8004c7c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8004c80:	2180      	movs	r1, #128	; 0x80
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8004c82:	f04f 32ff 	mov.w	r2, #4294967295

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
 8004c86:	2b01      	cmp	r3, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8004c88:	6122      	str	r2, [r4, #16]
 8004c8a:	60e2      	str	r2, [r4, #12]

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8004c8c:	7161      	strb	r1, [r4, #5]
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
 8004c8e:	f000 84ff 	beq.w	8005690 <moduleIMG+0x1a30>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 8004c92:	2303      	movs	r3, #3
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
 8004c94:	4a96      	ldr	r2, [pc, #600]	; (8004ef0 <moduleIMG+0x1290>)
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
 8004c96:	7023      	strb	r3, [r4, #0]
	fs->id = ++Fsid;	/* File system mount ID */
 8004c98:	8813      	ldrh	r3, [r2, #0]
 8004c9a:	3301      	adds	r3, #1
 8004c9c:	b29b      	uxth	r3, r3
 8004c9e:	8013      	strh	r3, [r2, #0]
 8004ca0:	80e3      	strh	r3, [r4, #6]
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004ca2:	ab0f      	add	r3, sp, #60	; 0x3c
		res = follow_path(&dj, path);	/* Follow the file path */
 8004ca4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004ca6:	9319      	str	r3, [sp, #100]	; 0x64
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
 8004ca8:	7822      	ldrb	r2, [r4, #0]
 8004caa:	2a2f      	cmp	r2, #47	; 0x2f
 8004cac:	f000 80d6 	beq.w	8004e5c <moduleIMG+0x11fc>
 8004cb0:	2a5c      	cmp	r2, #92	; 0x5c
 8004cb2:	f000 80d3 	beq.w	8004e5c <moduleIMG+0x11fc>
		path++;
	dp->sclust = 0;							/* Always start from the root directory */
 8004cb6:	2500      	movs	r5, #0
 8004cb8:	9515      	str	r5, [sp, #84]	; 0x54
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8004cba:	7822      	ldrb	r2, [r4, #0]
 8004cbc:	2a1f      	cmp	r2, #31
 8004cbe:	d802      	bhi.n	8004cc6 <moduleIMG+0x1066>
 8004cc0:	e0d3      	b.n	8004e6a <moduleIMG+0x120a>
 8004cc2:	f814 2f01 	ldrb.w	r2, [r4, #1]!
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 8004cc6:	2a2f      	cmp	r2, #47	; 0x2f
 8004cc8:	d0fb      	beq.n	8004cc2 <moduleIMG+0x1062>
 8004cca:	2a5c      	cmp	r2, #92	; 0x5c
 8004ccc:	d0f9      	beq.n	8004cc2 <moduleIMG+0x1062>
 8004cce:	f103 000b 	add.w	r0, r3, #11
 8004cd2:	461a      	mov	r2, r3
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 8004cd4:	2120      	movs	r1, #32
 8004cd6:	f802 1b01 	strb.w	r1, [r2], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8004cda:	4282      	cmp	r2, r0
 8004cdc:	d1fb      	bne.n	8004cd6 <moduleIMG+0x1076>
 8004cde:	2500      	movs	r5, #0
 8004ce0:	462e      	mov	r6, r5
 8004ce2:	46ae      	mov	lr, r5
 8004ce4:	1e67      	subs	r7, r4, #1
 8004ce6:	f04f 0c08 	mov.w	ip, #8
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 8004cea:	f817 1f01 	ldrb.w	r1, [r7, #1]!
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 8004cee:	2920      	cmp	r1, #32
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 8004cf0:	f106 0601 	add.w	r6, r6, #1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 8004cf4:	d922      	bls.n	8004d3c <moduleIMG+0x10dc>
 8004cf6:	292f      	cmp	r1, #47	; 0x2f
 8004cf8:	d04b      	beq.n	8004d92 <moduleIMG+0x1132>
 8004cfa:	295c      	cmp	r1, #92	; 0x5c
 8004cfc:	d049      	beq.n	8004d92 <moduleIMG+0x1132>
		if (c == '.' || i >= ni) {
 8004cfe:	292e      	cmp	r1, #46	; 0x2e
 8004d00:	d022      	beq.n	8004d48 <moduleIMG+0x10e8>
 8004d02:	45ac      	cmp	ip, r5
 8004d04:	d91d      	bls.n	8004d42 <moduleIMG+0x10e2>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended character? */
 8004d06:	060a      	lsls	r2, r1, #24
 8004d08:	d432      	bmi.n	8004d70 <moduleIMG+0x1110>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8004d0a:	2922      	cmp	r1, #34	; 0x22
 8004d0c:	d019      	beq.n	8004d42 <moduleIMG+0x10e2>
 8004d0e:	4879      	ldr	r0, [pc, #484]	; (8004ef4 <moduleIMG+0x1294>)
 8004d10:	e001      	b.n	8004d16 <moduleIMG+0x10b6>
 8004d12:	428a      	cmp	r2, r1
 8004d14:	d015      	beq.n	8004d42 <moduleIMG+0x10e2>
 8004d16:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 8004d1a:	2a00      	cmp	r2, #0
 8004d1c:	d1f9      	bne.n	8004d12 <moduleIMG+0x10b2>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
 8004d1e:	f1a1 0241 	sub.w	r2, r1, #65	; 0x41
 8004d22:	2a19      	cmp	r2, #25
 8004d24:	d81b      	bhi.n	8004d5e <moduleIMG+0x10fe>
				b |= 2;
 8004d26:	f04e 0e02 	orr.w	lr, lr, #2
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
					b |= 1; c -= 0x20;
				}
			}
			sfn[i++] = c;
 8004d2a:	5559      	strb	r1, [r3, r5]
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 8004d2c:	f817 1f01 	ldrb.w	r1, [r7, #1]!
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 8004d30:	2920      	cmp	r1, #32
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
					b |= 1; c -= 0x20;
				}
			}
			sfn[i++] = c;
 8004d32:	f105 0501 	add.w	r5, r5, #1
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 8004d36:	f106 0601 	add.w	r6, r6, #1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 8004d3a:	d8dc      	bhi.n	8004cf6 <moduleIMG+0x1096>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
 8004d3c:	4434      	add	r4, r6
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8004d3e:	2204      	movs	r2, #4

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 8004d40:	bb5d      	cbnz	r5, 8004d9a <moduleIMG+0x113a>
 8004d42:	2006      	movs	r0, #6
 8004d44:	4604      	mov	r4, r0
 8004d46:	e63d      	b.n	80049c4 <moduleIMG+0xd64>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 8004d48:	f1bc 0f08 	cmp.w	ip, #8
 8004d4c:	d1f9      	bne.n	8004d42 <moduleIMG+0x10e2>
			i = 8; ni = 11;
			b <<= 2; continue;
 8004d4e:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
 8004d52:	4665      	mov	r5, ip
			b <<= 2; continue;
 8004d54:	fa5f fe8e 	uxtb.w	lr, lr
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
 8004d58:	f04f 0c0b 	mov.w	ip, #11
 8004d5c:	e7c5      	b.n	8004cea <moduleIMG+0x108a>
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
				b |= 2;
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
 8004d5e:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 8004d62:	2a19      	cmp	r2, #25
 8004d64:	d8e1      	bhi.n	8004d2a <moduleIMG+0x10ca>
					b |= 1; c -= 0x20;
 8004d66:	3920      	subs	r1, #32
 8004d68:	b2c9      	uxtb	r1, r1
 8004d6a:	f04e 0e01 	orr.w	lr, lr, #1
 8004d6e:	e7dc      	b.n	8004d2a <moduleIMG+0x10ca>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended character? */
			b |= 3;						/* Eliminate NT flag */
#ifdef _EXCVT
			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
 8004d70:	3980      	subs	r1, #128	; 0x80
 8004d72:	4a61      	ldr	r2, [pc, #388]	; (8004ef8 <moduleIMG+0x1298>)
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended character? */
			b |= 3;						/* Eliminate NT flag */
 8004d74:	f04e 0e03 	orr.w	lr, lr, #3
#ifdef _EXCVT
			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
 8004d78:	5c51      	ldrb	r1, [r2, r1]
 8004d7a:	e7c6      	b.n	8004d0a <moduleIMG+0x10aa>

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8004d7c:	b2e8      	uxtb	r0, r5
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8004d7e:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8004d80:	7060      	strb	r0, [r4, #1]
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 8004d82:	7023      	strb	r3, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8004d84:	f007 f8bc 	bl	800bf00 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8004d88:	07c5      	lsls	r5, r0, #31
 8004d8a:	f140 828d 	bpl.w	80052a8 <moduleIMG+0x1648>
 8004d8e:	2403      	movs	r4, #3
 8004d90:	e618      	b.n	80049c4 <moduleIMG+0xd64>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
 8004d92:	4434      	add	r4, r6
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8004d94:	2200      	movs	r2, #0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 8004d96:	2d00      	cmp	r5, #0
 8004d98:	d0d3      	beq.n	8004d42 <moduleIMG+0x10e2>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first character collides with DDE, replace it with 0x05 */
 8004d9a:	7819      	ldrb	r1, [r3, #0]
 8004d9c:	29e5      	cmp	r1, #229	; 0xe5
 8004d9e:	bf04      	itt	eq
 8004da0:	2105      	moveq	r1, #5
 8004da2:	7019      	strbeq	r1, [r3, #0]

	if (ni == 8) b <<= 2;
 8004da4:	f1bc 0f08 	cmp.w	ip, #8
 8004da8:	bf04      	itt	eq
 8004daa:	ea4f 0e8e 	moveq.w	lr, lr, lsl #2
 8004dae:	fa5f fe8e 	uxtbeq.w	lr, lr
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 8004db2:	f00e 0103 	and.w	r1, lr, #3
 8004db6:	2901      	cmp	r1, #1
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 8004db8:	f00e 0e0c 	and.w	lr, lr, #12

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first character collides with DDE, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 8004dbc:	bf08      	it	eq
 8004dbe:	f042 0210 	orreq.w	r2, r2, #16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 8004dc2:	f1be 0f04 	cmp.w	lr, #4
 8004dc6:	bf08      	it	eq
 8004dc8:	f042 0208 	orreq.w	r2, r2, #8

	sfn[NS] = c;		/* Store NT flag, File name is created */
 8004dcc:	72da      	strb	r2, [r3, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8004dce:	a813      	add	r0, sp, #76	; 0x4c
 8004dd0:	f009 f9ae 	bl	800e130 <dir_sdi.constprop.11>
	if (res != FR_OK) return res;
 8004dd4:	2800      	cmp	r0, #0
 8004dd6:	d131      	bne.n	8004e3c <moduleIMG+0x11dc>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
 8004dd8:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8004dda:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8004ddc:	f00c ff78 	bl	8011cd0 <move_window.lto_priv.151>
		if (res != FR_OK) break;
 8004de0:	bb60      	cbnz	r0, 8004e3c <moduleIMG+0x11dc>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 8004de2:	9d18      	ldr	r5, [sp, #96]	; 0x60
		c = dir[DIR_Name];
 8004de4:	7829      	ldrb	r1, [r5, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8004de6:	b359      	cbz	r1, 8004e40 <moduleIMG+0x11e0>
				if (!(dp->fn[NS] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
 8004de8:	f895 e00b 	ldrb.w	lr, [r5, #11]
 8004dec:	f01e 0f08 	tst.w	lr, #8
 8004df0:	d11e      	bne.n	8004e30 <moduleIMG+0x11d0>
 8004df2:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8004df4:	462e      	mov	r6, r5
 8004df6:	f103 070b 	add.w	r7, r3, #11
 8004dfa:	461a      	mov	r2, r3
 8004dfc:	e001      	b.n	8004e02 <moduleIMG+0x11a2>
 8004dfe:	f816 1f01 	ldrb.w	r1, [r6, #1]!
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8004e02:	f812 0b01 	ldrb.w	r0, [r2], #1
 8004e06:	4288      	cmp	r0, r1
 8004e08:	d112      	bne.n	8004e30 <moduleIMG+0x11d0>
 8004e0a:	4297      	cmp	r7, r2
 8004e0c:	d1f7      	bne.n	8004dfe <moduleIMG+0x119e>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8004e0e:	7ada      	ldrb	r2, [r3, #11]
 8004e10:	0750      	lsls	r0, r2, #29
 8004e12:	d43f      	bmi.n	8004e94 <moduleIMG+0x1234>
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 8004e14:	f01e 0f10 	tst.w	lr, #16
 8004e18:	d016      	beq.n	8004e48 <moduleIMG+0x11e8>
 8004e1a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8004e1c:	7ee8      	ldrb	r0, [r5, #27]
	if (fs->fs_type == FS_FAT32)
 8004e1e:	7811      	ldrb	r1, [r2, #0]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8004e20:	7eaa      	ldrb	r2, [r5, #26]
	if (fs->fs_type == FS_FAT32)
 8004e22:	2903      	cmp	r1, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8004e24:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32)
 8004e28:	d011      	beq.n	8004e4e <moduleIMG+0x11ee>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
 8004e2a:	9215      	str	r2, [sp, #84]	; 0x54
 8004e2c:	7822      	ldrb	r2, [r4, #0]
 8004e2e:	e74a      	b.n	8004cc6 <moduleIMG+0x1066>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
 8004e30:	2100      	movs	r1, #0
 8004e32:	a813      	add	r0, sp, #76	; 0x4c
 8004e34:	f00d f8cc 	bl	8011fd0 <dir_next.lto_priv.153>
	} while (res == FR_OK);
 8004e38:	2800      	cmp	r0, #0
 8004e3a:	d0cd      	beq.n	8004dd8 <moduleIMG+0x1178>
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NS];
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
 8004e3c:	2804      	cmp	r0, #4
 8004e3e:	d181      	bne.n	8004d44 <moduleIMG+0x10e4>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NS];
 8004e40:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8004e42:	7adb      	ldrb	r3, [r3, #11]
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8004e44:	0759      	lsls	r1, r3, #29
 8004e46:	d41a      	bmi.n	8004e7e <moduleIMG+0x121e>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
 8004e48:	2005      	movs	r0, #5
 8004e4a:	4604      	mov	r4, r0
 8004e4c:	e5ba      	b.n	80049c4 <moduleIMG+0xd64>
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 8004e4e:	7d68      	ldrb	r0, [r5, #21]
 8004e50:	7d29      	ldrb	r1, [r5, #20]
 8004e52:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8004e56:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8004e5a:	e7e6      	b.n	8004e2a <moduleIMG+0x11ca>
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
		path++;
 8004e5c:	3401      	adds	r4, #1
	dp->sclust = 0;							/* Always start from the root directory */
 8004e5e:	2500      	movs	r5, #0
 8004e60:	9515      	str	r5, [sp, #84]	; 0x54
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8004e62:	7822      	ldrb	r2, [r4, #0]
 8004e64:	2a1f      	cmp	r2, #31
 8004e66:	f63f af2e 	bhi.w	8004cc6 <moduleIMG+0x1066>
		res = dir_sdi(dp, 0);
 8004e6a:	a813      	add	r0, sp, #76	; 0x4c
 8004e6c:	f009 f960 	bl	800e130 <dir_sdi.constprop.11>
		dp->dir = 0;
 8004e70:	9518      	str	r5, [sp, #96]	; 0x60
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 8004e72:	2800      	cmp	r0, #0
 8004e74:	f43f af65 	beq.w	8004d42 <moduleIMG+0x10e2>
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 8004e78:	2804      	cmp	r0, #4
 8004e7a:	f47f af63 	bne.w	8004d44 <moduleIMG+0x10e4>
{
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
 8004e7e:	a813      	add	r0, sp, #76	; 0x4c
 8004e80:	f009 f956 	bl	800e130 <dir_sdi.constprop.11>
	if (res == FR_OK) {
 8004e84:	2800      	cmp	r0, #0
 8004e86:	f000 8391 	beq.w	80055ac <moduleIMG+0x194c>
 8004e8a:	2804      	cmp	r0, #4
 8004e8c:	bf14      	ite	ne
 8004e8e:	4604      	movne	r4, r0
 8004e90:	2407      	moveq	r4, #7
 8004e92:	e597      	b.n	80049c4 <moduleIMG+0xd64>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8004e94:	f01e 0f11 	tst.w	lr, #17
 8004e98:	f040 821f 	bne.w	80052da <moduleIMG+0x167a>
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
				dw = get_fattime();				/* Created time */
 8004e9c:	f006 ff90 	bl	800bdc0 <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;				/* Reset attribute */
 8004ea0:	2300      	movs	r3, #0
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
				dw = get_fattime();				/* Created time */
				ST_DWORD(dir+DIR_CrtTime, dw);
 8004ea2:	1204      	asrs	r4, r0, #8
 8004ea4:	0e02      	lsrs	r2, r0, #24
 8004ea6:	0c01      	lsrs	r1, r0, #16
 8004ea8:	746a      	strb	r2, [r5, #17]
 8004eaa:	73a8      	strb	r0, [r5, #14]
 8004eac:	73ec      	strb	r4, [r5, #15]
 8004eae:	7429      	strb	r1, [r5, #16]
				dir[DIR_Attr] = 0;				/* Reset attribute */
 8004eb0:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 8004eb2:	772b      	strb	r3, [r5, #28]
 8004eb4:	776b      	strb	r3, [r5, #29]
 8004eb6:	77ab      	strb	r3, [r5, #30]
 8004eb8:	77eb      	strb	r3, [r5, #31]
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
 8004eba:	9c13      	ldr	r4, [sp, #76]	; 0x4c
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8004ebc:	7eef      	ldrb	r7, [r5, #27]
	if (fs->fs_type == FS_FAT32)
 8004ebe:	7823      	ldrb	r3, [r4, #0]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8004ec0:	7eaa      	ldrb	r2, [r5, #26]
	if (fs->fs_type == FS_FAT32)
 8004ec2:	2b03      	cmp	r3, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8004ec4:	ea42 2707 	orr.w	r7, r2, r7, lsl #8
	if (fs->fs_type == FS_FAT32)
 8004ec8:	f000 8399 	beq.w	80055fe <moduleIMG+0x199e>
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8004ecc:	2300      	movs	r3, #0
				ST_DWORD(dir+DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
 8004ece:	2201      	movs	r2, #1
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8004ed0:	76ab      	strb	r3, [r5, #26]
 8004ed2:	76eb      	strb	r3, [r5, #27]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8004ed4:	752b      	strb	r3, [r5, #20]
 8004ed6:	756b      	strb	r3, [r5, #21]
				ST_DWORD(dir+DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
 8004ed8:	7122      	strb	r2, [r4, #4]
				if (cl) {						/* Remove the cluster chain if exist */
 8004eda:	2f00      	cmp	r7, #0
 8004edc:	d03f      	beq.n	8004f5e <moduleIMG+0x12fe>
					dw = dj.fs->winsect;
 8004ede:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004ee0:	9304      	str	r3, [sp, #16]
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004ee2:	4297      	cmp	r7, r2
 8004ee4:	d902      	bls.n	8004eec <moduleIMG+0x128c>
 8004ee6:	6963      	ldr	r3, [r4, #20]
 8004ee8:	429f      	cmp	r7, r3
 8004eea:	d307      	bcc.n	8004efc <moduleIMG+0x129c>
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8004eec:	2402      	movs	r4, #2
 8004eee:	e569      	b.n	80049c4 <moduleIMG+0xd64>
 8004ef0:	20000cdc 	.word	0x20000cdc
 8004ef4:	08014328 	.word	0x08014328
 8004ef8:	0801465c 	.word	0x0801465c
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004efc:	463e      	mov	r6, r7
 8004efe:	4631      	mov	r1, r6
 8004f00:	4620      	mov	r0, r4
 8004f02:	f00c ff9d 	bl	8011e40 <get_fat.part.6.lto_priv.114>

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
 8004f06:	b300      	cbz	r0, 8004f4a <moduleIMG+0x12ea>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8004f08:	2801      	cmp	r0, #1
 8004f0a:	d0ef      	beq.n	8004eec <moduleIMG+0x128c>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8004f0c:	1c42      	adds	r2, r0, #1
 8004f0e:	f000 8331 	beq.w	8005574 <moduleIMG+0x1914>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8004f12:	2e01      	cmp	r6, #1
 8004f14:	d9ea      	bls.n	8004eec <moduleIMG+0x128c>
 8004f16:	6962      	ldr	r2, [r4, #20]
 8004f18:	42b2      	cmp	r2, r6
 8004f1a:	d9e7      	bls.n	8004eec <moduleIMG+0x128c>
 8004f1c:	9005      	str	r0, [sp, #20]
 8004f1e:	4631      	mov	r1, r6
 8004f20:	2200      	movs	r2, #0
 8004f22:	4620      	mov	r0, r4
 8004f24:	f00c fef4 	bl	8011d10 <put_fat.part.8.lto_priv.154>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
 8004f28:	9b05      	ldr	r3, [sp, #20]
 8004f2a:	2800      	cmp	r0, #0
 8004f2c:	f47f af0a 	bne.w	8004d44 <moduleIMG+0x10e4>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
 8004f30:	6922      	ldr	r2, [r4, #16]
 8004f32:	1c56      	adds	r6, r2, #1
 8004f34:	d005      	beq.n	8004f42 <moduleIMG+0x12e2>
				fs->free_clust++;
				fs->fsi_flag |= 1;
 8004f36:	7961      	ldrb	r1, [r4, #5]
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
				fs->free_clust++;
 8004f38:	3201      	adds	r2, #1
				fs->fsi_flag |= 1;
 8004f3a:	f041 0101 	orr.w	r1, r1, #1
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
				fs->free_clust++;
 8004f3e:	6122      	str	r2, [r4, #16]
				fs->fsi_flag |= 1;
 8004f40:	7161      	strb	r1, [r4, #5]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
 8004f42:	6962      	ldr	r2, [r4, #20]
 8004f44:	4293      	cmp	r3, r2
 8004f46:	461e      	mov	r6, r3
 8004f48:	d3d9      	bcc.n	8004efe <moduleIMG+0x129e>
				dj.fs->wflag = 1;
				if (cl) {						/* Remove the cluster chain if exist */
					dw = dj.fs->winsect;
					res = remove_chain(dj.fs, cl);
					if (res == FR_OK) {
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8004f4a:	9813      	ldr	r0, [sp, #76]	; 0x4c
						res = move_window(dj.fs, dw);
 8004f4c:	9904      	ldr	r1, [sp, #16]
				dj.fs->wflag = 1;
				if (cl) {						/* Remove the cluster chain if exist */
					dw = dj.fs->winsect;
					res = remove_chain(dj.fs, cl);
					if (res == FR_OK) {
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 8004f4e:	3f01      	subs	r7, #1
 8004f50:	60c7      	str	r7, [r0, #12]
						res = move_window(dj.fs, dw);
 8004f52:	f00c febd 	bl	8011cd0 <move_window.lto_priv.151>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
 8004f56:	2800      	cmp	r0, #0
 8004f58:	f47f aef4 	bne.w	8004d44 <moduleIMG+0x10e4>
 8004f5c:	9c13      	ldr	r4, [sp, #76]	; 0x4c
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 8004f5e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
			fp->dir_ptr = dir;
 8004f60:	f8c8 5020 	str.w	r5, [r8, #32]
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
 8004f64:	232a      	movs	r3, #42	; 0x2a
 8004f66:	f888 3006 	strb.w	r3, [r8, #6]
			fp->err = 0;						/* Clear error flag */
 8004f6a:	2300      	movs	r3, #0
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 8004f6c:	f8c8 201c 	str.w	r2, [r8, #28]
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
 8004f70:	f888 3007 	strb.w	r3, [r8, #7]
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
 8004f74:	7822      	ldrb	r2, [r4, #0]
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8004f76:	7ee9      	ldrb	r1, [r5, #27]
 8004f78:	7eab      	ldrb	r3, [r5, #26]
	if (fs->fs_type == FS_FAT32)
 8004f7a:	2a03      	cmp	r2, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8004f7c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (fs->fs_type == FS_FAT32)
 8004f80:	f000 81ae 	beq.w	80052e0 <moduleIMG+0x1680>
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
 8004f84:	88e2      	ldrh	r2, [r4, #6]

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 8004f86:	69e9      	ldr	r1, [r5, #28]
			gres = false;

		} else {

			// Write buffer into file
			TRACE_INFO("SD   > Write buffer to file (len=%d)", len);
 8004f88:	48b6      	ldr	r0, [pc, #728]	; (8005264 <moduleIMG+0x1604>)
 8004f8a:	f8c8 100c 	str.w	r1, [r8, #12]
			fp->fptr = 0;						/* File pointer */
 8004f8e:	2500      	movs	r5, #0
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8004f90:	f8c8 3010 	str.w	r3, [r8, #16]
			fp->fptr = 0;						/* File pointer */
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
 8004f94:	f8c8 4000 	str.w	r4, [r8]
			fp->id = fp->fs->id;
 8004f98:	f8a8 2004 	strh.w	r2, [r8, #4]
		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
			fp->fptr = 0;						/* File pointer */
 8004f9c:	f8c8 5008 	str.w	r5, [r8, #8]
			fp->dsect = 0;
 8004fa0:	f8c8 5018 	str.w	r5, [r8, #24]
 8004fa4:	f009 ffa4 	bl	800eef0 <chMtxLock>
 8004fa8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004fac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004fb0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004fb2:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8004fb4:	4cac      	ldr	r4, [pc, #688]	; (8005268 <moduleIMG+0x1608>)
 8004fb6:	4bad      	ldr	r3, [pc, #692]	; (800526c <moduleIMG+0x160c>)
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8004fb8:	4fad      	ldr	r7, [pc, #692]	; (8005270 <moduleIMG+0x1610>)
 8004fba:	fb00 f101 	mul.w	r1, r0, r1
 8004fbe:	fba4 6101 	umull	r6, r1, r4, r1
 8004fc2:	0b89      	lsrs	r1, r1, #14
 8004fc4:	fba3 6301 	umull	r6, r3, r3, r1
 8004fc8:	fba4 4202 	umull	r4, r2, r4, r2
 8004fcc:	099b      	lsrs	r3, r3, #6
 8004fce:	fb00 1313 	mls	r3, r0, r3, r1
 8004fd2:	0b92      	lsrs	r2, r2, #14
 8004fd4:	49a7      	ldr	r1, [pc, #668]	; (8005274 <moduleIMG+0x1614>)
 8004fd6:	48a8      	ldr	r0, [pc, #672]	; (8005278 <moduleIMG+0x1618>)
 8004fd8:	f00d fb82 	bl	80126e0 <chprintf.constprop.35>
 8004fdc:	4aa7      	ldr	r2, [pc, #668]	; (800527c <moduleIMG+0x161c>)
 8004fde:	49a8      	ldr	r1, [pc, #672]	; (8005280 <moduleIMG+0x1620>)
 8004fe0:	48a5      	ldr	r0, [pc, #660]	; (8005278 <moduleIMG+0x1618>)
 8004fe2:	f00d fb7d 	bl	80126e0 <chprintf.constprop.35>
 8004fe6:	2352      	movs	r3, #82	; 0x52
 8004fe8:	4aa6      	ldr	r2, [pc, #664]	; (8005284 <moduleIMG+0x1624>)
 8004fea:	49a7      	ldr	r1, [pc, #668]	; (8005288 <moduleIMG+0x1628>)
 8004fec:	48a2      	ldr	r0, [pc, #648]	; (8005278 <moduleIMG+0x1618>)
 8004fee:	f00d fb77 	bl	80126e0 <chprintf.constprop.35>
 8004ff2:	49a6      	ldr	r1, [pc, #664]	; (800528c <moduleIMG+0x162c>)
 8004ff4:	48a0      	ldr	r0, [pc, #640]	; (8005278 <moduleIMG+0x1618>)
 8004ff6:	f00d fb73 	bl	80126e0 <chprintf.constprop.35>
 8004ffa:	9a02      	ldr	r2, [sp, #8]
 8004ffc:	49a4      	ldr	r1, [pc, #656]	; (8005290 <moduleIMG+0x1630>)
 8004ffe:	489e      	ldr	r0, [pc, #632]	; (8005278 <moduleIMG+0x1618>)
 8005000:	f00d fb6e 	bl	80126e0 <chprintf.constprop.35>
 8005004:	49a3      	ldr	r1, [pc, #652]	; (8005294 <moduleIMG+0x1634>)
 8005006:	489c      	ldr	r0, [pc, #624]	; (8005278 <moduleIMG+0x1618>)
 8005008:	f00d fb6a 	bl	80126e0 <chprintf.constprop.35>
 800500c:	4895      	ldr	r0, [pc, #596]	; (8005264 <moduleIMG+0x1604>)
 800500e:	f009 ff0f 	bl	800ee30 <chMtxUnlock>
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
 8005012:	f009 fad5 	bl	800e5c0 <validate.constprop.7>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8005016:	2800      	cmp	r0, #0
 8005018:	f040 811a 	bne.w	8005250 <moduleIMG+0x15f0>
	if (fp->err)							/* Check error */
 800501c:	79f9      	ldrb	r1, [r7, #7]
 800501e:	b939      	cbnz	r1, 8005030 <moduleIMG+0x13d0>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8005020:	79bb      	ldrb	r3, [r7, #6]
 8005022:	f003 0202 	and.w	r2, r3, #2
 8005026:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800502a:	2a00      	cmp	r2, #0
 800502c:	f040 815f 	bne.w	80052ee <moduleIMG+0x168e>
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
 8005030:	9004      	str	r0, [sp, #16]
			uint32_t len_written;
			f_write(&fdst, buffer, len, (UINT*)&len_written);
			if(len_written != len)
 8005032:	9b02      	ldr	r3, [sp, #8]
 8005034:	9a04      	ldr	r2, [sp, #16]
 8005036:	4293      	cmp	r3, r2
 8005038:	d03a      	beq.n	80050b0 <moduleIMG+0x1450>
			{
				TRACE_ERROR("SD   > Writing failed (err=%d)", res);
 800503a:	488a      	ldr	r0, [pc, #552]	; (8005264 <moduleIMG+0x1604>)
 800503c:	4c8a      	ldr	r4, [pc, #552]	; (8005268 <moduleIMG+0x1608>)
 800503e:	f009 ff57 	bl	800eef0 <chMtxLock>
 8005042:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005046:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800504a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800504c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800504e:	4b87      	ldr	r3, [pc, #540]	; (800526c <moduleIMG+0x160c>)
 8005050:	fb00 f101 	mul.w	r1, r0, r1
 8005054:	fba4 5101 	umull	r5, r1, r4, r1
 8005058:	0b89      	lsrs	r1, r1, #14
 800505a:	fba3 5301 	umull	r5, r3, r3, r1
 800505e:	fba4 4202 	umull	r4, r2, r4, r2
 8005062:	099b      	lsrs	r3, r3, #6
 8005064:	fb00 1313 	mls	r3, r0, r3, r1
 8005068:	0b92      	lsrs	r2, r2, #14
 800506a:	4982      	ldr	r1, [pc, #520]	; (8005274 <moduleIMG+0x1614>)
 800506c:	4882      	ldr	r0, [pc, #520]	; (8005278 <moduleIMG+0x1618>)
 800506e:	f00d fb37 	bl	80126e0 <chprintf.constprop.35>
 8005072:	4a89      	ldr	r2, [pc, #548]	; (8005298 <moduleIMG+0x1638>)
 8005074:	4982      	ldr	r1, [pc, #520]	; (8005280 <moduleIMG+0x1620>)
 8005076:	4880      	ldr	r0, [pc, #512]	; (8005278 <moduleIMG+0x1618>)
 8005078:	f00d fb32 	bl	80126e0 <chprintf.constprop.35>
 800507c:	2357      	movs	r3, #87	; 0x57
 800507e:	4a81      	ldr	r2, [pc, #516]	; (8005284 <moduleIMG+0x1624>)
 8005080:	4981      	ldr	r1, [pc, #516]	; (8005288 <moduleIMG+0x1628>)
 8005082:	487d      	ldr	r0, [pc, #500]	; (8005278 <moduleIMG+0x1618>)
 8005084:	f00d fb2c 	bl	80126e0 <chprintf.constprop.35>
 8005088:	4980      	ldr	r1, [pc, #512]	; (800528c <moduleIMG+0x162c>)
 800508a:	487b      	ldr	r0, [pc, #492]	; (8005278 <moduleIMG+0x1618>)
 800508c:	f00d fb28 	bl	80126e0 <chprintf.constprop.35>
 8005090:	2200      	movs	r2, #0
 8005092:	4982      	ldr	r1, [pc, #520]	; (800529c <moduleIMG+0x163c>)
 8005094:	4878      	ldr	r0, [pc, #480]	; (8005278 <moduleIMG+0x1618>)
 8005096:	f00d fb23 	bl	80126e0 <chprintf.constprop.35>
 800509a:	497e      	ldr	r1, [pc, #504]	; (8005294 <moduleIMG+0x1634>)
 800509c:	4876      	ldr	r0, [pc, #472]	; (8005278 <moduleIMG+0x1618>)
 800509e:	f00d fb1f 	bl	80126e0 <chprintf.constprop.35>
 80050a2:	4870      	ldr	r0, [pc, #448]	; (8005264 <moduleIMG+0x1604>)
 80050a4:	f009 fec4 	bl	800ee30 <chMtxUnlock>
 80050a8:	2157      	movs	r1, #87	; 0x57
 80050aa:	4876      	ldr	r0, [pc, #472]	; (8005284 <moduleIMG+0x1624>)
 80050ac:	f00a ff58 	bl	800ff60 <log_error>
				gres = false;
			}

			// Close file
			TRACE_INFO("SD   > Close file");
 80050b0:	486c      	ldr	r0, [pc, #432]	; (8005264 <moduleIMG+0x1604>)
 80050b2:	4c6d      	ldr	r4, [pc, #436]	; (8005268 <moduleIMG+0x1608>)
 80050b4:	f009 ff1c 	bl	800eef0 <chMtxLock>
 80050b8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80050bc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80050c0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80050c2:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80050c4:	4b69      	ldr	r3, [pc, #420]	; (800526c <moduleIMG+0x160c>)
 80050c6:	fb00 f101 	mul.w	r1, r0, r1
 80050ca:	fba4 5101 	umull	r5, r1, r4, r1
 80050ce:	0b89      	lsrs	r1, r1, #14
 80050d0:	fba3 5301 	umull	r5, r3, r3, r1
 80050d4:	fba4 4202 	umull	r4, r2, r4, r2
 80050d8:	099b      	lsrs	r3, r3, #6
 80050da:	fb00 1313 	mls	r3, r0, r3, r1
 80050de:	0b92      	lsrs	r2, r2, #14
 80050e0:	4964      	ldr	r1, [pc, #400]	; (8005274 <moduleIMG+0x1614>)
 80050e2:	4865      	ldr	r0, [pc, #404]	; (8005278 <moduleIMG+0x1618>)
 80050e4:	f00d fafc 	bl	80126e0 <chprintf.constprop.35>
 80050e8:	4a64      	ldr	r2, [pc, #400]	; (800527c <moduleIMG+0x161c>)
 80050ea:	4965      	ldr	r1, [pc, #404]	; (8005280 <moduleIMG+0x1620>)
 80050ec:	4862      	ldr	r0, [pc, #392]	; (8005278 <moduleIMG+0x1618>)
 80050ee:	f00d faf7 	bl	80126e0 <chprintf.constprop.35>
 80050f2:	235c      	movs	r3, #92	; 0x5c
 80050f4:	4a63      	ldr	r2, [pc, #396]	; (8005284 <moduleIMG+0x1624>)
 80050f6:	4964      	ldr	r1, [pc, #400]	; (8005288 <moduleIMG+0x1628>)
 80050f8:	485f      	ldr	r0, [pc, #380]	; (8005278 <moduleIMG+0x1618>)
 80050fa:	f00d faf1 	bl	80126e0 <chprintf.constprop.35>
 80050fe:	4963      	ldr	r1, [pc, #396]	; (800528c <moduleIMG+0x162c>)
 8005100:	485d      	ldr	r0, [pc, #372]	; (8005278 <moduleIMG+0x1618>)
 8005102:	f00d faed 	bl	80126e0 <chprintf.constprop.35>
 8005106:	4966      	ldr	r1, [pc, #408]	; (80052a0 <moduleIMG+0x1640>)
 8005108:	485b      	ldr	r0, [pc, #364]	; (8005278 <moduleIMG+0x1618>)
 800510a:	f00d fae9 	bl	80126e0 <chprintf.constprop.35>
 800510e:	4961      	ldr	r1, [pc, #388]	; (8005294 <moduleIMG+0x1634>)
 8005110:	4859      	ldr	r0, [pc, #356]	; (8005278 <moduleIMG+0x1618>)
 8005112:	f00d fae5 	bl	80126e0 <chprintf.constprop.35>
 8005116:	4853      	ldr	r0, [pc, #332]	; (8005264 <moduleIMG+0x1604>)
 8005118:	f009 fe8a 	bl	800ee30 <chMtxUnlock>
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
 800511c:	f009 fa50 	bl	800e5c0 <validate.constprop.7>
	if (res == FR_OK) {
 8005120:	2800      	cmp	r0, #0
 8005122:	f040 8093 	bne.w	800524c <moduleIMG+0x15ec>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 8005126:	f898 3006 	ldrb.w	r3, [r8, #6]
 800512a:	4c51      	ldr	r4, [pc, #324]	; (8005270 <moduleIMG+0x1610>)
 800512c:	069a      	lsls	r2, r3, #26
 800512e:	f140 8091 	bpl.w	8005254 <moduleIMG+0x15f4>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
 8005132:	065b      	lsls	r3, r3, #25
 8005134:	d50e      	bpl.n	8005154 <moduleIMG+0x14f4>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
 8005136:	4621      	mov	r1, r4
 8005138:	2301      	movs	r3, #1
 800513a:	f851 0b24 	ldr.w	r0, [r1], #36
 800513e:	69a2      	ldr	r2, [r4, #24]
 8005140:	7840      	ldrb	r0, [r0, #1]
 8005142:	f006 fe8d 	bl	800be60 <disk_write>
 8005146:	2800      	cmp	r0, #0
 8005148:	f040 80c5 	bne.w	80052d6 <moduleIMG+0x1676>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 800514c:	79a3      	ldrb	r3, [r4, #6]
 800514e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005152:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 8005154:	f8d8 101c 	ldr.w	r1, [r8, #28]
 8005158:	f8d8 0000 	ldr.w	r0, [r8]
 800515c:	4e44      	ldr	r6, [pc, #272]	; (8005270 <moduleIMG+0x1610>)
 800515e:	f00c fdb7 	bl	8011cd0 <move_window.lto_priv.151>
			if (res == FR_OK) {
 8005162:	4605      	mov	r5, r0
 8005164:	2800      	cmp	r0, #0
 8005166:	d03c      	beq.n	80051e2 <moduleIMG+0x1582>
 8005168:	4604      	mov	r4, r0
			res = f_close(&fdst);
			if(res != FR_OK)
			{
				TRACE_ERROR("SD   > Closing file failed (err=%d)", res);
 800516a:	483e      	ldr	r0, [pc, #248]	; (8005264 <moduleIMG+0x1604>)
 800516c:	4d3e      	ldr	r5, [pc, #248]	; (8005268 <moduleIMG+0x1608>)
 800516e:	f009 febf 	bl	800eef0 <chMtxLock>
 8005172:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005176:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800517a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800517c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800517e:	4b3b      	ldr	r3, [pc, #236]	; (800526c <moduleIMG+0x160c>)
 8005180:	fb00 f101 	mul.w	r1, r0, r1
 8005184:	fba5 6101 	umull	r6, r1, r5, r1
 8005188:	0b89      	lsrs	r1, r1, #14
 800518a:	fba3 6301 	umull	r6, r3, r3, r1
 800518e:	fba5 5202 	umull	r5, r2, r5, r2
 8005192:	099b      	lsrs	r3, r3, #6
 8005194:	fb00 1313 	mls	r3, r0, r3, r1
 8005198:	0b92      	lsrs	r2, r2, #14
 800519a:	4936      	ldr	r1, [pc, #216]	; (8005274 <moduleIMG+0x1614>)
 800519c:	4836      	ldr	r0, [pc, #216]	; (8005278 <moduleIMG+0x1618>)
 800519e:	f00d fa9f 	bl	80126e0 <chprintf.constprop.35>
 80051a2:	4a3d      	ldr	r2, [pc, #244]	; (8005298 <moduleIMG+0x1638>)
 80051a4:	4936      	ldr	r1, [pc, #216]	; (8005280 <moduleIMG+0x1620>)
 80051a6:	4834      	ldr	r0, [pc, #208]	; (8005278 <moduleIMG+0x1618>)
 80051a8:	f00d fa9a 	bl	80126e0 <chprintf.constprop.35>
 80051ac:	2360      	movs	r3, #96	; 0x60
 80051ae:	4a35      	ldr	r2, [pc, #212]	; (8005284 <moduleIMG+0x1624>)
 80051b0:	4935      	ldr	r1, [pc, #212]	; (8005288 <moduleIMG+0x1628>)
 80051b2:	4831      	ldr	r0, [pc, #196]	; (8005278 <moduleIMG+0x1618>)
 80051b4:	f00d fa94 	bl	80126e0 <chprintf.constprop.35>
 80051b8:	4934      	ldr	r1, [pc, #208]	; (800528c <moduleIMG+0x162c>)
 80051ba:	482f      	ldr	r0, [pc, #188]	; (8005278 <moduleIMG+0x1618>)
 80051bc:	f00d fa90 	bl	80126e0 <chprintf.constprop.35>
 80051c0:	4622      	mov	r2, r4
 80051c2:	4938      	ldr	r1, [pc, #224]	; (80052a4 <moduleIMG+0x1644>)
 80051c4:	482c      	ldr	r0, [pc, #176]	; (8005278 <moduleIMG+0x1618>)
 80051c6:	f00d fa8b 	bl	80126e0 <chprintf.constprop.35>
 80051ca:	4932      	ldr	r1, [pc, #200]	; (8005294 <moduleIMG+0x1634>)
 80051cc:	482a      	ldr	r0, [pc, #168]	; (8005278 <moduleIMG+0x1618>)
 80051ce:	f00d fa87 	bl	80126e0 <chprintf.constprop.35>
 80051d2:	4824      	ldr	r0, [pc, #144]	; (8005264 <moduleIMG+0x1604>)
 80051d4:	f009 fe2c 	bl	800ee30 <chMtxUnlock>
 80051d8:	2160      	movs	r1, #96	; 0x60
 80051da:	482a      	ldr	r0, [pc, #168]	; (8005284 <moduleIMG+0x1624>)
 80051dc:	f00a fec0 	bl	800ff60 <log_error>
 80051e0:	e42b      	b.n	8004a3a <moduleIMG+0xdda>
				dir = fp->dir_ptr;
 80051e2:	6a37      	ldr	r7, [r6, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 80051e4:	7afb      	ldrb	r3, [r7, #11]
 80051e6:	f043 0320 	orr.w	r3, r3, #32
 80051ea:	72fb      	strb	r3, [r7, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 80051ec:	68f3      	ldr	r3, [r6, #12]
				st_clust(dir, fp->sclust);					/* Update start cluster */
 80051ee:	6932      	ldr	r2, [r6, #16]
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 80051f0:	773b      	strb	r3, [r7, #28]
 80051f2:	1219      	asrs	r1, r3, #8
 80051f4:	7779      	strb	r1, [r7, #29]
 80051f6:	0c19      	lsrs	r1, r3, #16
 80051f8:	77b9      	strb	r1, [r7, #30]
 80051fa:	0e1b      	lsrs	r3, r3, #24
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 80051fc:	0c11      	lsrs	r1, r2, #16
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 80051fe:	1210      	asrs	r0, r2, #8
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 8005200:	77fb      	strb	r3, [r7, #31]
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8005202:	120b      	asrs	r3, r1, #8
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8005204:	76ba      	strb	r2, [r7, #26]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8005206:	757b      	strb	r3, [r7, #21]
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8005208:	76f8      	strb	r0, [r7, #27]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800520a:	7539      	strb	r1, [r7, #20]
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
 800520c:	f006 fdd8 	bl	800bdc0 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tm);
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
 8005210:	79b3      	ldrb	r3, [r6, #6]
				fp->fs->wflag = 1;
 8005212:	6834      	ldr	r4, [r6, #0]
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
 8005214:	75b8      	strb	r0, [r7, #22]
 8005216:	1202      	asrs	r2, r0, #8
 8005218:	75fa      	strb	r2, [r7, #23]
 800521a:	0c02      	lsrs	r2, r0, #16
 800521c:	763a      	strb	r2, [r7, #24]
 800521e:	0e00      	lsrs	r0, r0, #24
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
 8005220:	f023 0320 	bic.w	r3, r3, #32
				fp->fs->wflag = 1;
 8005224:	2201      	movs	r2, #1
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
 8005226:	7678      	strb	r0, [r7, #25]
				ST_WORD(dir+DIR_LstAccDate, 0);
 8005228:	74bd      	strb	r5, [r7, #18]
 800522a:	74fd      	strb	r5, [r7, #19]
				fp->flag &= ~FA__WRITTEN;
 800522c:	71b3      	strb	r3, [r6, #6]
 800522e:	4620      	mov	r0, r4
				fp->fs->wflag = 1;
 8005230:	7122      	strb	r2, [r4, #4]
 8005232:	f00c fcf5 	bl	8011c20 <sync_window.part.3.lto_priv.156>
{
	FRESULT res;


	res = sync_window(fs);
	if (res == FR_OK) {
 8005236:	b948      	cbnz	r0, 800524c <moduleIMG+0x15ec>
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 8005238:	7823      	ldrb	r3, [r4, #0]
 800523a:	2b03      	cmp	r3, #3
 800523c:	f000 812d 	beq.w	800549a <moduleIMG+0x183a>
    BYTE pdrv,        /* Physical drive nmuber (0..) */
    BYTE cmd,        /* Control code */
    void *buff        /* Buffer to send/receive control data */
)
{
  switch (pdrv) {
 8005240:	7863      	ldrb	r3, [r4, #1]
 8005242:	2b00      	cmp	r3, #0
 8005244:	d147      	bne.n	80052d6 <moduleIMG+0x1676>
#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
	if (res == FR_OK)
#endif
	{
		res = validate(fp);				/* Lock volume */
 8005246:	f009 f9bb 	bl	800e5c0 <validate.constprop.7>
		if (res == FR_OK) {
 800524a:	b118      	cbz	r0, 8005254 <moduleIMG+0x15f4>
 800524c:	4604      	mov	r4, r0
 800524e:	e78c      	b.n	800516a <moduleIMG+0x150a>
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
 8005250:	9504      	str	r5, [sp, #16]
 8005252:	e6ee      	b.n	8005032 <moduleIMG+0x13d2>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
 8005254:	2300      	movs	r3, #0
 8005256:	f8c8 3000 	str.w	r3, [r8]
 800525a:	f7ff bbee 	b.w	8004a3a <moduleIMG+0xdda>
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800525e:	240c      	movs	r4, #12
 8005260:	f7ff bbb0 	b.w	80049c4 <moduleIMG+0xd64>
 8005264:	20027b2c 	.word	0x20027b2c
 8005268:	d1b71759 	.word	0xd1b71759
 800526c:	10624dd3 	.word	0x10624dd3
 8005270:	20027908 	.word	0x20027908
 8005274:	08013c50 	.word	0x08013c50
 8005278:	20027e60 	.word	0x20027e60
 800527c:	08013cfc 	.word	0x08013cfc
 8005280:	08013c5c 	.word	0x08013c5c
 8005284:	08014484 	.word	0x08014484
 8005288:	08013c78 	.word	0x08013c78
 800528c:	08013d00 	.word	0x08013d00
 8005290:	080144d4 	.word	0x080144d4
 8005294:	08013cac 	.word	0x08013cac
 8005298:	08013d9c 	.word	0x08013d9c
 800529c:	080144fc 	.word	0x080144fc
 80052a0:	0801451c 	.word	0x0801451c
 80052a4:	08014638 	.word	0x08014638
	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 80052a8:	f000 0304 	and.w	r3, r0, #4
 80052ac:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80052b0:	2b00      	cmp	r3, #0
 80052b2:	f47f ab86 	bne.w	80049c2 <moduleIMG+0xd62>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
 80052b6:	4629      	mov	r1, r5
 80052b8:	4620      	mov	r0, r4
 80052ba:	f00c ff29 	bl	8012110 <check_fs.lto_priv.152>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 80052be:	2801      	cmp	r0, #1
 80052c0:	f000 815b 	beq.w	800557a <moduleIMG+0x191a>
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80052c4:	2803      	cmp	r0, #3
 80052c6:	f000 8155 	beq.w	8005574 <moduleIMG+0x1914>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 80052ca:	2800      	cmp	r0, #0
 80052cc:	f43f ac67 	beq.w	8004b9e <moduleIMG+0xf3e>
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80052d0:	240d      	movs	r4, #13
 80052d2:	f7ff bb77 	b.w	80049c4 <moduleIMG+0xd64>
 80052d6:	2401      	movs	r4, #1
 80052d8:	e747      	b.n	800516a <moduleIMG+0x150a>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 80052da:	2407      	movs	r4, #7
 80052dc:	f7ff bb72 	b.w	80049c4 <moduleIMG+0xd64>
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 80052e0:	7d69      	ldrb	r1, [r5, #21]
 80052e2:	7d2a      	ldrb	r2, [r5, #20]
 80052e4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80052e8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80052ec:	e64a      	b.n	8004f84 <moduleIMG+0x1324>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->err)							/* Check error */
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
 80052ee:	68ba      	ldr	r2, [r7, #8]
 80052f0:	9802      	ldr	r0, [sp, #8]
 80052f2:	42d0      	cmn	r0, r2
 80052f4:	f080 80b6 	bcs.w	8005464 <moduleIMG+0x1804>

	for ( ;  btw;							/* Repeat until all data written */
 80052f8:	2800      	cmp	r0, #0
 80052fa:	f000 80b2 	beq.w	8005462 <moduleIMG+0x1802>
 80052fe:	f8cd 9014 	str.w	r9, [sp, #20]
 8005302:	f8dd 9018 	ldr.w	r9, [sp, #24]
 8005306:	9104      	str	r1, [sp, #16]
 8005308:	9007      	str	r0, [sp, #28]
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 800530a:	f3c2 0308 	ubfx	r3, r2, #0, #9
 800530e:	2b00      	cmp	r3, #0
 8005310:	d179      	bne.n	8005406 <moduleIMG+0x17a6>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 8005312:	f8d8 1000 	ldr.w	r1, [r8]
 8005316:	788d      	ldrb	r5, [r1, #2]
 8005318:	3d01      	subs	r5, #1
 800531a:	ea05 2552 	and.w	r5, r5, r2, lsr #9
			if (!csect) {					/* On the cluster boundary? */
 800531e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 8005322:	d112      	bne.n	800534a <moduleIMG+0x16ea>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8005324:	2a00      	cmp	r2, #0
 8005326:	f040 808e 	bne.w	8005446 <moduleIMG+0x17e6>
					clst = fp->sclust;		/* Follow from the origin */
 800532a:	6938      	ldr	r0, [r7, #16]
					if (clst == 0)			/* When no cluster is allocated, */
 800532c:	2800      	cmp	r0, #0
 800532e:	f000 8109 	beq.w	8005544 <moduleIMG+0x18e4>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 8005332:	2801      	cmp	r0, #1
 8005334:	f000 80fb 	beq.w	800552e <moduleIMG+0x18ce>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8005338:	1c44      	adds	r4, r0, #1
 800533a:	d07e      	beq.n	800543a <moduleIMG+0x17da>
				fp->clust = clst;			/* Update current cluster */
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
 800533c:	f8d8 3010 	ldr.w	r3, [r8, #16]
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;			/* Update current cluster */
 8005340:	f8c8 0014 	str.w	r0, [r8, #20]
 8005344:	6839      	ldr	r1, [r7, #0]
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
 8005346:	b903      	cbnz	r3, 800534a <moduleIMG+0x16ea>
 8005348:	6138      	str	r0, [r7, #16]
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
 800534a:	f898 3006 	ldrb.w	r3, [r8, #6]
 800534e:	4cc0      	ldr	r4, [pc, #768]	; (8005650 <moduleIMG+0x19f0>)
 8005350:	0658      	lsls	r0, r3, #25
 8005352:	f100 8093 	bmi.w	800547c <moduleIMG+0x181c>
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 8005356:	f8d8 2014 	ldr.w	r2, [r8, #20]
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800535a:	6948      	ldr	r0, [r1, #20]
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 800535c:	4bbc      	ldr	r3, [pc, #752]	; (8005650 <moduleIMG+0x19f0>)
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 800535e:	3a02      	subs	r2, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8005360:	3802      	subs	r0, #2
 8005362:	4282      	cmp	r2, r0
 8005364:	f080 80e3 	bcs.w	800552e <moduleIMG+0x18ce>
	return clst * fs->csize + fs->database;
 8005368:	7888      	ldrb	r0, [r1, #2]
 800536a:	6a8e      	ldr	r6, [r1, #40]	; 0x28
 800536c:	fb00 6602 	mla	r6, r0, r2, r6
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8005370:	2e00      	cmp	r6, #0
 8005372:	f000 80dc 	beq.w	800552e <moduleIMG+0x18ce>
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 8005376:	9a07      	ldr	r2, [sp, #28]
 8005378:	0a54      	lsrs	r4, r2, #9
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
 800537a:	442e      	add	r6, r5
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 800537c:	d037      	beq.n	80053ee <moduleIMG+0x178e>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 800537e:	192b      	adds	r3, r5, r4
 8005380:	4298      	cmp	r0, r3
					cc = fp->fs->csize - csect;
 8005382:	bf38      	it	cc
 8005384:	1b44      	subcc	r4, r0, r5
				if (disk_write(fp->fs->drv, wbuff, sect, cc))
 8005386:	4623      	mov	r3, r4
 8005388:	7848      	ldrb	r0, [r1, #1]
 800538a:	4632      	mov	r2, r6
 800538c:	4649      	mov	r1, r9
 800538e:	f006 fd67 	bl	800be60 <disk_write>
 8005392:	2800      	cmp	r0, #0
 8005394:	d151      	bne.n	800543a <moduleIMG+0x17da>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8005396:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800539a:	1b9e      	subs	r6, r3, r6
 800539c:	42b4      	cmp	r4, r6
 800539e:	d911      	bls.n	80053c4 <moduleIMG+0x1764>
 80053a0:	4bac      	ldr	r3, [pc, #688]	; (8005654 <moduleIMG+0x19f4>)
 80053a2:	eb09 2646 	add.w	r6, r9, r6, lsl #9
 80053a6:	1e72      	subs	r2, r6, #1
 80053a8:	f503 7000 	add.w	r0, r3, #512	; 0x200
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
 80053ac:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 80053b0:	f803 1f01 	strb.w	r1, [r3, #1]!
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 80053b4:	4283      	cmp	r3, r0
 80053b6:	d1f9      	bne.n	80053ac <moduleIMG+0x174c>
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->flag &= ~FA__DIRTY;
 80053b8:	f898 3006 	ldrb.w	r3, [r8, #6]
 80053bc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80053c0:	f888 3006 	strb.w	r3, [r8, #6]
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 80053c4:	0264      	lsls	r4, r4, #9
 80053c6:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80053ca:	eb09 0004 	add.w	r0, r9, r4
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 80053ce:	9b04      	ldr	r3, [sp, #16]
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
 80053d0:	9907      	ldr	r1, [sp, #28]
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 80053d2:	4423      	add	r3, r4
 80053d4:	4422      	add	r2, r4
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
 80053d6:	1b09      	subs	r1, r1, r4
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 80053d8:	9304      	str	r3, [sp, #16]
 80053da:	f8c8 2008 	str.w	r2, [r8, #8]
 80053de:	4681      	mov	r9, r0
 80053e0:	4b9b      	ldr	r3, [pc, #620]	; (8005650 <moduleIMG+0x19f0>)
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
 80053e2:	9107      	str	r1, [sp, #28]
 80053e4:	d191      	bne.n	800530a <moduleIMG+0x16aa>
 80053e6:	f8dd 9014 	ldr.w	r9, [sp, #20]
 80053ea:	799b      	ldrb	r3, [r3, #6]
 80053ec:	e03b      	b.n	8005466 <moduleIMG+0x1806>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 80053ee:	69ba      	ldr	r2, [r7, #24]
 80053f0:	4296      	cmp	r6, r2
				if (fp->fptr < fp->fsize &&
 80053f2:	68ba      	ldr	r2, [r7, #8]
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 80053f4:	d003      	beq.n	80053fe <moduleIMG+0x179e>
				if (fp->fptr < fp->fsize &&
 80053f6:	68f8      	ldr	r0, [r7, #12]
 80053f8:	4282      	cmp	r2, r0
 80053fa:	f0c0 80ab 	bcc.w	8005554 <moduleIMG+0x18f4>
					disk_read(fp->fs->drv, fp->buf, sect, 1))
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
 80053fe:	f8c8 6018 	str.w	r6, [r8, #24]
 8005402:	f3c2 0308 	ubfx	r3, r2, #0, #9
 8005406:	9a07      	ldr	r2, [sp, #28]
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 8005408:	f5c3 7400 	rsb	r4, r3, #512	; 0x200
 800540c:	4294      	cmp	r4, r2
 800540e:	bf28      	it	cs
 8005410:	4614      	movcs	r4, r2
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8005412:	4443      	add	r3, r8
 8005414:	3323      	adds	r3, #35	; 0x23
 8005416:	eb09 0004 	add.w	r0, r9, r4
 800541a:	464a      	mov	r2, r9
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
 800541c:	f812 1b01 	ldrb.w	r1, [r2], #1
 8005420:	f803 1f01 	strb.w	r1, [r3, #1]!
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 8005424:	4290      	cmp	r0, r2
 8005426:	d1f9      	bne.n	800541c <moduleIMG+0x17bc>
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
 8005428:	f898 3006 	ldrb.w	r3, [r8, #6]
 800542c:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8005430:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005434:	f888 3006 	strb.w	r3, [r8, #6]
 8005438:	e7c9      	b.n	80053ce <moduleIMG+0x176e>
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
					cc = fp->fs->csize - csect;
				if (disk_write(fp->fs->drv, wbuff, sect, cc))
					ABORT(fp->fs, FR_DISK_ERR);
 800543a:	2301      	movs	r3, #1
 800543c:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8005440:	f888 3007 	strb.w	r3, [r8, #7]
 8005444:	e5f5      	b.n	8005032 <moduleIMG+0x13d2>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8005446:	4608      	mov	r0, r1
 8005448:	6979      	ldr	r1, [r7, #20]
 800544a:	f00c fd59 	bl	8011f00 <create_chain.lto_priv.155>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800544e:	2800      	cmp	r0, #0
 8005450:	f47f af6f 	bne.w	8005332 <moduleIMG+0x16d2>
 8005454:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8005458:	f8d8 2008 	ldr.w	r2, [r8, #8]
 800545c:	f898 3006 	ldrb.w	r3, [r8, #6]
 8005460:	e001      	b.n	8005466 <moduleIMG+0x1806>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
 8005462:	9902      	ldr	r1, [sp, #8]
 8005464:	9104      	str	r1, [sp, #16]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 8005466:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800546a:	4979      	ldr	r1, [pc, #484]	; (8005650 <moduleIMG+0x19f0>)
 800546c:	4282      	cmp	r2, r0
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 800546e:	f043 0320 	orr.w	r3, r3, #32
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 8005472:	bf88      	it	hi
 8005474:	60ca      	strhi	r2, [r1, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 8005476:	f888 3006 	strb.w	r3, [r8, #6]
 800547a:	e5da      	b.n	8005032 <moduleIMG+0x13d2>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
 800547c:	7848      	ldrb	r0, [r1, #1]
 800547e:	69ba      	ldr	r2, [r7, #24]
 8005480:	2301      	movs	r3, #1
 8005482:	f104 0124 	add.w	r1, r4, #36	; 0x24
 8005486:	f006 fceb 	bl	800be60 <disk_write>
 800548a:	2800      	cmp	r0, #0
 800548c:	d155      	bne.n	800553a <moduleIMG+0x18da>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 800548e:	79bb      	ldrb	r3, [r7, #6]
 8005490:	6839      	ldr	r1, [r7, #0]
 8005492:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005496:	71bb      	strb	r3, [r7, #6]
 8005498:	e75d      	b.n	8005356 <moduleIMG+0x16f6>


	res = sync_window(fs);
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 800549a:	7963      	ldrb	r3, [r4, #5]
 800549c:	2b01      	cmp	r3, #1
 800549e:	f47f aecf 	bne.w	8005240 <moduleIMG+0x15e0>
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
 80054a2:	f104 0130 	add.w	r1, r4, #48	; 0x30
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
 80054a6:	460b      	mov	r3, r1
 80054a8:	f504 720c 	add.w	r2, r4, #560	; 0x230

	while (cnt--)
		*d++ = (BYTE)val;
 80054ac:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80054b0:	429a      	cmp	r2, r3
		*d++ = (BYTE)val;
 80054b2:	f04f 0500 	mov.w	r5, #0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80054b6:	d1f9      	bne.n	80054ac <moduleIMG+0x184c>
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 80054b8:	6920      	ldr	r0, [r4, #16]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 80054ba:	68e3      	ldr	r3, [r4, #12]
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 80054bc:	69e2      	ldr	r2, [r4, #28]
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 80054be:	f884 0218 	strb.w	r0, [r4, #536]	; 0x218
 80054c2:	1206      	asrs	r6, r0, #8
 80054c4:	f884 6219 	strb.w	r6, [r4, #537]	; 0x219
 80054c8:	0c06      	lsrs	r6, r0, #16
 80054ca:	f884 621a 	strb.w	r6, [r4, #538]	; 0x21a
 80054ce:	0e00      	lsrs	r0, r0, #24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 80054d0:	0c1e      	lsrs	r6, r3, #16
 80054d2:	121f      	asrs	r7, r3, #8
 80054d4:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
 80054d8:	0e1b      	lsrs	r3, r3, #24
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 80054da:	f884 021b 	strb.w	r0, [r4, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 80054de:	f884 621e 	strb.w	r6, [r4, #542]	; 0x21e
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 80054e2:	2055      	movs	r0, #85	; 0x55
 80054e4:	26aa      	movs	r6, #170	; 0xaa
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 80054e6:	f884 321f 	strb.w	r3, [r4, #543]	; 0x21f
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 80054ea:	2352      	movs	r3, #82	; 0x52
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 80054ec:	3201      	adds	r2, #1
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 80054ee:	f884 022e 	strb.w	r0, [r4, #558]	; 0x22e
 80054f2:	f884 622f 	strb.w	r6, [r4, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 80054f6:	2061      	movs	r0, #97	; 0x61
 80054f8:	2641      	movs	r6, #65	; 0x41
 80054fa:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
 80054fe:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8005502:	2372      	movs	r3, #114	; 0x72
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 8005504:	f884 0032 	strb.w	r0, [r4, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8005508:	f884 0217 	strb.w	r0, [r4, #535]	; 0x217
 800550c:	f884 3214 	strb.w	r3, [r4, #532]	; 0x214
 8005510:	f884 3215 	strb.w	r3, [r4, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8005514:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 8005518:	62e2      	str	r2, [r4, #44]	; 0x2c
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 800551a:	f884 6033 	strb.w	r6, [r4, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 800551e:	f884 6216 	strb.w	r6, [r4, #534]	; 0x216
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8005522:	2301      	movs	r3, #1
 8005524:	7860      	ldrb	r0, [r4, #1]
 8005526:	f006 fc9b 	bl	800be60 <disk_write>
			fs->fsi_flag = 0;
 800552a:	7165      	strb	r5, [r4, #5]
 800552c:	e688      	b.n	8005240 <moduleIMG+0x15e0>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 800552e:	2302      	movs	r3, #2
 8005530:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8005534:	f888 3007 	strb.w	r3, [r8, #7]
 8005538:	e57b      	b.n	8005032 <moduleIMG+0x13d2>
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
					ABORT(fp->fs, FR_DISK_ERR);
 800553a:	2301      	movs	r3, #1
 800553c:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8005540:	71e3      	strb	r3, [r4, #7]
 8005542:	e576      	b.n	8005032 <moduleIMG+0x13d2>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 8005544:	4608      	mov	r0, r1
 8005546:	4629      	mov	r1, r5
 8005548:	f00c fcda 	bl	8011f00 <create_chain.lto_priv.155>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800554c:	2800      	cmp	r0, #0
 800554e:	f47f aef0 	bne.w	8005332 <moduleIMG+0x16d2>
 8005552:	e77f      	b.n	8005454 <moduleIMG+0x17f4>
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1))
 8005554:	7848      	ldrb	r0, [r1, #1]
 8005556:	9306      	str	r3, [sp, #24]
 8005558:	f103 0124 	add.w	r1, r3, #36	; 0x24
 800555c:	4632      	mov	r2, r6
 800555e:	f00d f8d7 	bl	8012710 <disk_read.constprop.33>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
 8005562:	9b06      	ldr	r3, [sp, #24]
 8005564:	b908      	cbnz	r0, 800556a <moduleIMG+0x190a>
 8005566:	68ba      	ldr	r2, [r7, #8]
 8005568:	e749      	b.n	80053fe <moduleIMG+0x179e>
					disk_read(fp->fs->drv, fp->buf, sect, 1))
						ABORT(fp->fs, FR_DISK_ERR);
 800556a:	2201      	movs	r2, #1
 800556c:	f8dd 9014 	ldr.w	r9, [sp, #20]
 8005570:	71da      	strb	r2, [r3, #7]
 8005572:	e55e      	b.n	8005032 <moduleIMG+0x13d2>
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8005574:	2401      	movs	r4, #1
 8005576:	f7ff ba25 	b.w	80049c4 <moduleIMG+0xd64>
 800557a:	ae0f      	add	r6, sp, #60	; 0x3c
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 800557c:	4631      	mov	r1, r6
 800557e:	f504 73fb 	add.w	r3, r4, #502	; 0x1f6
 8005582:	f204 2036 	addw	r0, r4, #566	; 0x236
		UINT i;
		DWORD br[4];

		for (i = 0; i < 4; i++) {			/* Get partition offset */
			BYTE *pt = fs->win+MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 8005586:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 800558a:	b102      	cbz	r2, 800558e <moduleIMG+0x192e>
 800558c:	681a      	ldr	r2, [r3, #0]
 800558e:	f841 2b04 	str.w	r2, [r1], #4
 8005592:	3310      	adds	r3, #16
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		UINT i;
		DWORD br[4];

		for (i = 0; i < 4; i++) {			/* Get partition offset */
 8005594:	4298      	cmp	r0, r3
 8005596:	d1f6      	bne.n	8005586 <moduleIMG+0x1926>
 8005598:	f7ff baf7 	b.w	8004b8a <moduleIMG+0xf2a>
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
 800559c:	b18b      	cbz	r3, 80055c2 <moduleIMG+0x1962>
				if (++n == nent) break;	/* A block of contiguous entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 800559e:	2101      	movs	r1, #1
 80055a0:	a813      	add	r0, sp, #76	; 0x4c
 80055a2:	f00c fd15 	bl	8011fd0 <dir_next.lto_priv.153>
		} while (res == FR_OK);
 80055a6:	2800      	cmp	r0, #0
 80055a8:	f47f ac6f 	bne.w	8004e8a <moduleIMG+0x122a>

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
 80055ac:	9917      	ldr	r1, [sp, #92]	; 0x5c
 80055ae:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80055b0:	f00c fb8e 	bl	8011cd0 <move_window.lto_priv.151>
			if (res != FR_OK) break;
 80055b4:	2800      	cmp	r0, #0
 80055b6:	f47f ac68 	bne.w	8004e8a <moduleIMG+0x122a>
			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
 80055ba:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80055bc:	781b      	ldrb	r3, [r3, #0]
 80055be:	2be5      	cmp	r3, #229	; 0xe5
 80055c0:	d1ec      	bne.n	800559c <moduleIMG+0x193c>
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
#endif

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
 80055c2:	9917      	ldr	r1, [sp, #92]	; 0x5c
 80055c4:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80055c6:	f00c fb83 	bl	8011cd0 <move_window.lto_priv.151>
		if (res == FR_OK) {
 80055ca:	2800      	cmp	r0, #0
 80055cc:	f47f abba 	bne.w	8004d44 <moduleIMG+0x10e4>
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
 80055d0:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80055d2:	f103 0220 	add.w	r2, r3, #32
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 80055d6:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80055da:	4293      	cmp	r3, r2
 80055dc:	d1fb      	bne.n	80055d6 <moduleIMG+0x1976>

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
		if (res == FR_OK) {
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
 80055de:	9a19      	ldr	r2, [sp, #100]	; 0x64
 80055e0:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80055e2:	f102 010b 	add.w	r1, r2, #11
 80055e6:	3b01      	subs	r3, #1
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
 80055e8:	f812 0b01 	ldrb.w	r0, [r2], #1
 80055ec:	f803 0f01 	strb.w	r0, [r3, #1]!
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 80055f0:	428a      	cmp	r2, r1
 80055f2:	d1f9      	bne.n	80055e8 <moduleIMG+0x1988>
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NS] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
 80055f4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80055f6:	2201      	movs	r2, #1
 80055f8:	711a      	strb	r2, [r3, #4]
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
 80055fa:	9d18      	ldr	r5, [sp, #96]	; 0x60
 80055fc:	e44e      	b.n	8004e9c <moduleIMG+0x123c>
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32)
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 80055fe:	7d6a      	ldrb	r2, [r5, #21]
 8005600:	7d2b      	ldrb	r3, [r5, #20]
 8005602:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8005606:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 800560a:	e45f      	b.n	8004ecc <moduleIMG+0x126c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 800560c:	3302      	adds	r3, #2
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800560e:	442a      	add	r2, r5
	fs->database = bsect + sysect;						/* Data start sector */
 8005610:	4429      	add	r1, r5
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005612:	6163      	str	r3, [r4, #20]
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005614:	6222      	str	r2, [r4, #32]
	fs->database = bsect + sysect;						/* Data start sector */
 8005616:	62a1      	str	r1, [r4, #40]	; 0x28
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->volbase = bsect;								/* Volume start sector */
 8005618:	61e5      	str	r5, [r4, #28]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 800561a:	2e00      	cmp	r6, #0
 800561c:	f43f ae58 	beq.w	80052d0 <moduleIMG+0x1670>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8005620:	f003 0101 	and.w	r1, r3, #1
 8005624:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
 8005628:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800562c:	eb01 0353 	add.w	r3, r1, r3, lsr #1
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005630:	4472      	add	r2, lr
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8005632:	ebb7 2f53 	cmp.w	r7, r3, lsr #9
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005636:	6262      	str	r2, [r4, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8005638:	f4ff ae4a 	bcc.w	80052d0 <moduleIMG+0x1670>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 800563c:	f04f 33ff 	mov.w	r3, #4294967295

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8005640:	2280      	movs	r2, #128	; 0x80
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8005642:	6123      	str	r3, [r4, #16]
 8005644:	60e3      	str	r3, [r4, #12]

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8005646:	7162      	strb	r2, [r4, #5]
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
 8005648:	2301      	movs	r3, #1
 800564a:	f7ff bb23 	b.w	8004c94 <moduleIMG+0x1034>
 800564e:	bf00      	nop
 8005650:	20027908 	.word	0x20027908
 8005654:	2002792b 	.word	0x2002792b
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 8005658:	3302      	adds	r3, #2
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800565a:	442a      	add	r2, r5
	fs->database = bsect + sysect;						/* Data start sector */
 800565c:	4429      	add	r1, r5
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 800565e:	6163      	str	r3, [r4, #20]
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 8005660:	6222      	str	r2, [r4, #32]
	fs->database = bsect + sysect;						/* Data start sector */
 8005662:	62a1      	str	r1, [r4, #40]	; 0x28
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->volbase = bsect;								/* Volume start sector */
 8005664:	61e5      	str	r5, [r4, #28]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8005666:	2e00      	cmp	r6, #0
 8005668:	f43f ae32 	beq.w	80052d0 <moduleIMG+0x1670>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 800566c:	005b      	lsls	r3, r3, #1
 800566e:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005672:	4472      	add	r2, lr
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 8005674:	ebb7 2f53 	cmp.w	r7, r3, lsr #9
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8005678:	6262      	str	r2, [r4, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
 800567a:	f4ff ae29 	bcc.w	80052d0 <moduleIMG+0x1670>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 800567e:	f04f 33ff 	mov.w	r3, #4294967295

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8005682:	2280      	movs	r2, #128	; 0x80
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8005684:	6123      	str	r3, [r4, #16]
 8005686:	60e3      	str	r3, [r4, #12]

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8005688:	7162      	strb	r2, [r4, #5]
 800568a:	2302      	movs	r3, #2
 800568c:	f7ff bb02 	b.w	8004c94 <moduleIMG+0x1034>
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
 8005690:	1c69      	adds	r1, r5, #1
 8005692:	4620      	mov	r0, r4
 8005694:	f00c fb1c 	bl	8011cd0 <move_window.lto_priv.151>
 8005698:	2800      	cmp	r0, #0
 800569a:	f47f aafa 	bne.w	8004c92 <moduleIMG+0x1032>
	{
		fs->fsi_flag = 0;
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 800569e:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 80056a2:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
 80056a6:	7166      	strb	r6, [r4, #5]
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 80056a8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80056ac:	f64a 2255 	movw	r2, #43605	; 0xaa55
 80056b0:	4293      	cmp	r3, r2
 80056b2:	f47f aaee 	bne.w	8004c92 <moduleIMG+0x1032>
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
 80056b6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80056b8:	4a0a      	ldr	r2, [pc, #40]	; (80056e4 <moduleIMG+0x1a84>)
 80056ba:	4293      	cmp	r3, r2
 80056bc:	f47f aae9 	bne.w	8004c92 <moduleIMG+0x1032>
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
 80056c0:	f102 52ff 	add.w	r2, r2, #534773760	; 0x1fe00000
 80056c4:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80056c8:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
 80056cc:	3220      	adds	r2, #32
 80056ce:	4293      	cmp	r3, r2
 80056d0:	f47f aadf 	bne.w	8004c92 <moduleIMG+0x1032>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80056d4:	f8d4 2218 	ldr.w	r2, [r4, #536]	; 0x218
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80056d8:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80056dc:	6122      	str	r2, [r4, #16]
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80056de:	60e3      	str	r3, [r4, #12]
 80056e0:	f7ff bad7 	b.w	8004c92 <moduleIMG+0x1032>
 80056e4:	41615252 	.word	0x41615252
	...

080056f0 <encode_ssdv>:

static uint32_t gimage_id;
mutex_t camera_mtx;

void encode_ssdv(uint8_t *image, uint32_t image_len, module_conf_t* config, uint8_t image_id)
{
 80056f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80056f4:	f6ad 1d5c 	subw	sp, sp, #2396	; 0x95c
 80056f8:	4617      	mov	r7, r2
	return(SSDV_OK);
}

char ssdv_enc_init(ssdv_t *s, uint8_t type, char *callsign, uint8_t image_id)
{
	memset(s, 0, sizeof(ssdv_t));
 80056fa:	f20d 444c 	addw	r4, sp, #1100	; 0x44c
 80056fe:	461e      	mov	r6, r3
 8005700:	9207      	str	r2, [sp, #28]
 8005702:	9004      	str	r0, [sp, #16]
 8005704:	9105      	str	r1, [sp, #20]
 8005706:	4620      	mov	r0, r4
 8005708:	2100      	movs	r1, #0
 800570a:	f240 520c 	movw	r2, #1292	; 0x50c
	uint8_t *b;
	uint32_t bi = 0;
	uint8_t c = SSDV_OK;

	// Init SSDV (FEC at 2FSK, non FEC at APRS)
	ssdv_enc_init(&ssdv, SSDV_TYPE_NORMAL, config->ssdv_config.callsign, image_id);
 800570e:	f507 7586 	add.w	r5, r7, #268	; 0x10c
 8005712:	f00e f9a5 	bl	8013a60 <memset>
	s->image_id = image_id;
 8005716:	7426      	strb	r6, [r4, #16]
 8005718:	462b      	mov	r3, r5
 800571a:	f507 7189 	add.w	r1, r7, #274	; 0x112
 800571e:	461a      	mov	r2, r3
 8005720:	3301      	adds	r3, #1
{
	uint32_t x;
	char *c;
	
	/* Point c at the end of the callsign, maximum of 6 characters */
	for(x = 0, c = callsign; x < SSDV_MAX_CALLSIGN && *c; x++, c++);
 8005722:	7810      	ldrb	r0, [r2, #0]
 8005724:	b110      	cbz	r0, 800572c <encode_ssdv+0x3c>
 8005726:	428b      	cmp	r3, r1
 8005728:	461a      	mov	r2, r3
 800572a:	d1f8      	bne.n	800571e <encode_ssdv+0x2e>
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
 800572c:	1e53      	subs	r3, r2, #1
 800572e:	429d      	cmp	r5, r3
 8005730:	f04f 0300 	mov.w	r3, #0
 8005734:	d903      	bls.n	800573e <encode_ssdv+0x4e>
 8005736:	e01a      	b.n	800576e <encode_ssdv+0x7e>
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 8005738:	180b      	adds	r3, r1, r0
	/* Point c at the end of the callsign, maximum of 6 characters */
	for(x = 0, c = callsign; x < SSDV_MAX_CALLSIGN && *c; x++, c++);
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
 800573a:	42aa      	cmp	r2, r5
 800573c:	d017      	beq.n	800576e <encode_ssdv+0x7e>
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 800573e:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
	{
		x *= 40;
 8005742:	eb03 0383 	add.w	r3, r3, r3, lsl #2
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 8005746:	f1a1 0041 	sub.w	r0, r1, #65	; 0x41
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
	{
		x *= 40;
 800574a:	00db      	lsls	r3, r3, #3
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 800574c:	2819      	cmp	r0, #25
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
 800574e:	f1a1 0661 	sub.w	r6, r1, #97	; 0x61
 8005752:	f1a3 0033 	sub.w	r0, r3, #51	; 0x33
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 8005756:	d9ef      	bls.n	8005738 <encode_ssdv+0x48>
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
 8005758:	2e19      	cmp	r6, #25
		else if(*c >= '0' && *c <= '9') x += *c - '0' + 1;
 800575a:	f1a1 0030 	sub.w	r0, r1, #48	; 0x30
 800575e:	f1a3 0653 	sub.w	r6, r3, #83	; 0x53
	x = 0;
	for(c--; c >= callsign; c--)
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
 8005762:	f200 808a 	bhi.w	800587a <encode_ssdv+0x18a>
	/* Point c at the end of the callsign, maximum of 6 characters */
	for(x = 0, c = callsign; x < SSDV_MAX_CALLSIGN && *c; x++, c++);
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
 8005766:	42aa      	cmp	r2, r5
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
 8005768:	eb01 0306 	add.w	r3, r1, r6
	/* Point c at the end of the callsign, maximum of 6 characters */
	for(x = 0, c = callsign; x < SSDV_MAX_CALLSIGN && *c; x++, c++);
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
 800576c:	d1e7      	bne.n	800573e <encode_ssdv+0x4e>
 800576e:	f20d 751a 	addw	r5, sp, #1818	; 0x71a
	/* Configure the payload size and CRC position */
	switch(s->type)
	{
	case SSDV_TYPE_NORMAL:
		s->pkt_size_payload = SSDV_PKT_SIZE - SSDV_PKT_SIZE_HEADER - SSDV_PKT_SIZE_CRC - SSDV_PKT_SIZE_RSCODES;
		s->pkt_size_crcdata = SSDV_PKT_SIZE_HEADER + s->pkt_size_payload - 1;
 8005772:	f04f 0edb 	mov.w	lr, #219	; 0xdb
 8005776:	4628      	mov	r0, r5
{
	/* Configure the payload size and CRC position */
	switch(s->type)
	{
	case SSDV_TYPE_NORMAL:
		s->pkt_size_payload = SSDV_PKT_SIZE - SSDV_PKT_SIZE_HEADER - SSDV_PKT_SIZE_CRC - SSDV_PKT_SIZE_RSCODES;
 8005778:	26cd      	movs	r6, #205	; 0xcd
 800577a:	2241      	movs	r2, #65	; 0x41
 800577c:	4947      	ldr	r1, [pc, #284]	; (800589c <encode_ssdv+0x1ac>)

char ssdv_enc_init(ssdv_t *s, uint8_t type, char *callsign, uint8_t image_id)
{
	memset(s, 0, sizeof(ssdv_t));
	s->image_id = image_id;
	s->callsign = encode_callsign(callsign);
 800577e:	60e3      	str	r3, [r4, #12]
 8005780:	f20d 775b 	addw	r7, sp, #1883	; 0x75b
	/* Configure the payload size and CRC position */
	switch(s->type)
	{
	case SSDV_TYPE_NORMAL:
		s->pkt_size_payload = SSDV_PKT_SIZE - SSDV_PKT_SIZE_HEADER - SSDV_PKT_SIZE_CRC - SSDV_PKT_SIZE_RSCODES;
		s->pkt_size_crcdata = SSDV_PKT_SIZE_HEADER + s->pkt_size_payload - 1;
 8005784:	f8a4 e004 	strh.w	lr, [r4, #4]
{
	/* Configure the payload size and CRC position */
	switch(s->type)
	{
	case SSDV_TYPE_NORMAL:
		s->pkt_size_payload = SSDV_PKT_SIZE - SSDV_PKT_SIZE_HEADER - SSDV_PKT_SIZE_CRC - SSDV_PKT_SIZE_RSCODES;
 8005788:	8066      	strh	r6, [r4, #2]
 800578a:	f7fb ff81 	bl	8001690 <memcpy>
	s->mode = S_ENCODING;
	s->type = type;
	ssdv_set_packet_conf(s);
	
	/* Prepare the output JPEG tables */
	s->ddqt[0] = dtblcpy(s, std_dqt0, sizeof(std_dqt0));
 800578e:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
 8005792:	4d43      	ldr	r5, [pc, #268]	; (80058a0 <encode_ssdv+0x1b0>)
 8005794:	4943      	ldr	r1, [pc, #268]	; (80058a4 <encode_ssdv+0x1b4>)
 8005796:	4638      	mov	r0, r7
 8005798:	2241      	movs	r2, #65	; 0x41
 800579a:	f7fb ff79 	bl	8001690 <memcpy>
 800579e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
	s->ddqt[1] = dtblcpy(s, std_dqt1, sizeof(std_dqt1));
 80057a0:	f8c4 7504 	str.w	r7, [r4, #1284]	; 0x504
 80057a4:	f20d 779c 	addw	r7, sp, #1948	; 0x79c
 80057a8:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80057aa:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80057ae:	c707      	stmia	r7!, {r0, r1, r2}
 80057b0:	4d3d      	ldr	r5, [pc, #244]	; (80058a8 <encode_ssdv+0x1b8>)
 80057b2:	703b      	strb	r3, [r7, #0]
 80057b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80057b6:	f8cd 07b9 	str.w	r0, [sp, #1977]	; 0x7b9
 80057ba:	f8cd 17bd 	str.w	r1, [sp, #1981]	; 0x7bd
 80057be:	f8cd 27c1 	str.w	r2, [sp, #1985]	; 0x7c1
 80057c2:	cd07      	ldmia	r5!, {r0, r1, r2}
	s->ddht[0][0] = dtblcpy(s, std_dht00, sizeof(std_dht00));
 80057c4:	f20d 7e9c 	addw	lr, sp, #1948	; 0x79c
 80057c8:	f8c4 e4f0 	str.w	lr, [r4, #1264]	; 0x4f0
 80057cc:	f8cd 37c5 	str.w	r3, [sp, #1989]	; 0x7c5
 80057d0:	f8cd 07c9 	str.w	r0, [sp, #1993]	; 0x7c9
 80057d4:	f20d 73d6 	addw	r3, sp, #2006	; 0x7d6
 80057d8:	f8cd 17cd 	str.w	r1, [sp, #1997]	; 0x7cd
 80057dc:	f8cd 27d1 	str.w	r2, [sp, #2001]	; 0x7d1
 80057e0:	782a      	ldrb	r2, [r5, #0]
 80057e2:	4932      	ldr	r1, [pc, #200]	; (80058ac <encode_ssdv+0x1bc>)
 80057e4:	f88d 27d5 	strb.w	r2, [sp, #2005]	; 0x7d5
 80057e8:	f20d 77b9 	addw	r7, sp, #1977	; 0x7b9
 80057ec:	4618      	mov	r0, r3
 80057ee:	22b3      	movs	r2, #179	; 0xb3
	s->ddht[0][1] = dtblcpy(s, std_dht01, sizeof(std_dht01));
 80057f0:	f8c4 74f4 	str.w	r7, [r4, #1268]	; 0x4f4
 80057f4:	f7fb ff4c 	bl	8001690 <memcpy>
 80057f8:	f60d 0589 	addw	r5, sp, #2185	; 0x889
 80057fc:	4603      	mov	r3, r0
 80057fe:	22b3      	movs	r2, #179	; 0xb3
 8005800:	492b      	ldr	r1, [pc, #172]	; (80058b0 <encode_ssdv+0x1c0>)
	s->ddht[1][0] = dtblcpy(s, std_dht10, sizeof(std_dht10));
 8005802:	f8c4 34f8 	str.w	r3, [r4, #1272]	; 0x4f8
 8005806:	4628      	mov	r0, r5
 8005808:	f7fb ff42 	bl	8001690 <memcpy>
static void *dtblcpy(ssdv_t *s, const void *src, size_t n)
{
	void *r;
	if(s->dtbl_len + n > TBL_LEN) return(NULL);
	r = memcpy(&s->dtbls[s->dtbl_len], src, n);
	s->dtbl_len += n;
 800580c:	f240 2722 	movw	r7, #546	; 0x222
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
 8005810:	f10d 032f 	add.w	r3, sp, #47	; 0x2f
	s->out_len = s->pkt_size_payload;
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 8005814:	a808      	add	r0, sp, #32
 8005816:	f44f 7280 	mov.w	r2, #256	; 0x100
 800581a:	2100      	movs	r1, #0
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
 800581c:	63a3      	str	r3, [r4, #56]	; 0x38
	s->out_len = s->pkt_size_payload;
 800581e:	63e6      	str	r6, [r4, #60]	; 0x3c
	s->ddqt[0] = dtblcpy(s, std_dqt0, sizeof(std_dqt0));
	s->ddqt[1] = dtblcpy(s, std_dqt1, sizeof(std_dqt1));
	s->ddht[0][0] = dtblcpy(s, std_dht00, sizeof(std_dht00));
	s->ddht[0][1] = dtblcpy(s, std_dht01, sizeof(std_dht01));
	s->ddht[1][0] = dtblcpy(s, std_dht10, sizeof(std_dht10));
	s->ddht[1][1] = dtblcpy(s, std_dht11, sizeof(std_dht11));
 8005820:	f8c4 54fc 	str.w	r5, [r4, #1276]	; 0x4fc
	return(SSDV_OK);
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
 8005824:	6360      	str	r0, [r4, #52]	; 0x34
static void *dtblcpy(ssdv_t *s, const void *src, size_t n)
{
	void *r;
	if(s->dtbl_len + n > TBL_LEN) return(NULL);
	r = memcpy(&s->dtbls[s->dtbl_len], src, n);
	s->dtbl_len += n;
 8005826:	f8a4 7508 	strh.w	r7, [r4, #1288]	; 0x508
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
	s->out_len = s->pkt_size_payload;
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 800582a:	f00e f919 	bl	8013a60 <memset>
	
	/* Flush the output bits */
	ssdv_outbits(s, 0, 0);
 800582e:	2200      	movs	r2, #0
 8005830:	4611      	mov	r1, r2
 8005832:	4620      	mov	r0, r4
 8005834:	f00a fb34 	bl	800fea0 <ssdv_outbits.lto_priv.158>
 8005838:	2300      	movs	r3, #0
 800583a:	9306      	str	r3, [sp, #24]
	ssdv_t ssdv;
	uint8_t pkt[SSDV_PKT_SIZE];
	uint8_t pkt_base91[BASE91LEN(SSDV_PKT_SIZE-37)];
	uint16_t i = 0;
	uint8_t *b;
	uint32_t bi = 0;
 800583c:	9303      	str	r3, [sp, #12]
 800583e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
{
	int r;
	uint8_t b;
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
 8005842:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
	ssdv_enc_init(&ssdv, SSDV_TYPE_NORMAL, config->ssdv_config.callsign, image_id);
	ssdv_enc_set_buffer(&ssdv, pkt);

	while(true)
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer
 8005846:	9907      	ldr	r1, [sp, #28]
 8005848:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800584a:	f8c1 21b0 	str.w	r2, [r1, #432]	; 0x1b0
 800584e:	2b05      	cmp	r3, #5
 8005850:	f000 8216 	beq.w	8005c80 <encode_ssdv+0x590>
	
	/* If the output buffer is empty, re-initialise */
	if(s->out_len == 0) ssdv_enc_set_buffer(s, s->out);
 8005854:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8005856:	2d00      	cmp	r5, #0
 8005858:	f000 87bf 	beq.w	80067da <encode_ssdv+0x10ea>
 800585c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	
	while(s->in_len)
 800585e:	2b00      	cmp	r3, #0
 8005860:	f000 81f6 	beq.w	8005c50 <encode_ssdv+0x560>
	{
		b = *(s->inp++);
 8005864:	6a21      	ldr	r1, [r4, #32]
		s->in_len--;
		
		/* Skip bytes if necessary */
		if(s->in_skip) { s->in_skip--; continue; }
 8005866:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	/* If the output buffer is empty, re-initialise */
	if(s->out_len == 0) ssdv_enc_set_buffer(s, s->out);
	
	while(s->in_len)
	{
		b = *(s->inp++);
 8005868:	1c48      	adds	r0, r1, #1
		s->in_len--;
 800586a:	3b01      	subs	r3, #1
	/* If the output buffer is empty, re-initialise */
	if(s->out_len == 0) ssdv_enc_set_buffer(s, s->out);
	
	while(s->in_len)
	{
		b = *(s->inp++);
 800586c:	6220      	str	r0, [r4, #32]
 800586e:	7809      	ldrb	r1, [r1, #0]
		s->in_len--;
 8005870:	6263      	str	r3, [r4, #36]	; 0x24
		
		/* Skip bytes if necessary */
		if(s->in_skip) { s->in_skip--; continue; }
 8005872:	b13a      	cbz	r2, 8005884 <encode_ssdv+0x194>
 8005874:	3a01      	subs	r2, #1
 8005876:	62a2      	str	r2, [r4, #40]	; 0x28
 8005878:	e7f1      	b.n	800585e <encode_ssdv+0x16e>
	for(c--; c >= callsign; c--)
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
		else if(*c >= '0' && *c <= '9') x += *c - '0' + 1;
 800587a:	2809      	cmp	r0, #9
 800587c:	bf9c      	itt	ls
 800587e:	3b2f      	subls	r3, #47	; 0x2f
 8005880:	185b      	addls	r3, r3, r1
 8005882:	e75a      	b.n	800573a <encode_ssdv+0x4a>
		s->in_len--;
		
		/* Skip bytes if necessary */
		if(s->in_skip) { s->in_skip--; continue; }
		
		switch(s->state)
 8005884:	f894 2049 	ldrb.w	r2, [r4, #73]	; 0x49
 8005888:	2a04      	cmp	r2, #4
 800588a:	d8e8      	bhi.n	800585e <encode_ssdv+0x16e>
 800588c:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005890:	01c40187 	.word	0x01c40187
 8005894:	0012014f 	.word	0x0012014f
 8005898:	0012      	.short	0x0012
 800589a:	bf00      	nop
 800589c:	08014844 	.word	0x08014844
 80058a0:	08014ecc 	.word	0x08014ecc
 80058a4:	08014888 	.word	0x08014888
 80058a8:	08014eec 	.word	0x08014eec
 80058ac:	080146dc 	.word	0x080146dc
 80058b0:	08014790 	.word	0x08014790
		
		case S_HUFF:
		case S_INT:
			/* Is the next byte a stuffing byte? Skip it */
			/* TODO: Test the next byte is actually 0x00 */
			if(b == 0xFF) s->in_skip++;
 80058b4:	29ff      	cmp	r1, #255	; 0xff
 80058b6:	bf04      	itt	eq
 80058b8:	2301      	moveq	r3, #1
 80058ba:	62a3      	streq	r3, [r4, #40]	; 0x28
			
			/* Add the new byte to the work area */
			s->workbits = (s->workbits << 8) | b;
 80058bc:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
			s->worklen += 8;
 80058be:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
			/* Is the next byte a stuffing byte? Skip it */
			/* TODO: Test the next byte is actually 0x00 */
			if(b == 0xFF) s->in_skip++;
			
			/* Add the new byte to the work area */
			s->workbits = (s->workbits << 8) | b;
 80058c2:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			s->worklen += 8;
 80058c6:	3308      	adds	r3, #8
	return(SSDV_OK);
}

static char ssdv_process(ssdv_t *s)
{
	if(s->state == S_HUFF)
 80058c8:	2a03      	cmp	r2, #3
			/* Is the next byte a stuffing byte? Skip it */
			/* TODO: Test the next byte is actually 0x00 */
			if(b == 0xFF) s->in_skip++;
			
			/* Add the new byte to the work area */
			s->workbits = (s->workbits << 8) | b;
 80058ca:	62e1      	str	r1, [r4, #44]	; 0x2c
			s->worklen += 8;
 80058cc:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	return(SSDV_ERROR);
}

static inline int jpeg_int(int bits, int width)
{
	int b = (1 << width) - 1;
 80058d0:	f04f 0501 	mov.w	r5, #1
			s->acrle = 0;
			if(symbol == 0x00)
			{
				/* EOB -- all remaining AC parts are zero */
				ssdv_out_jpeg_int(s, 0, 0);
				s->acpart = 64;
 80058d4:	f04f 0640 	mov.w	r6, #64	; 0x40
	return(SSDV_OK);
}

static char ssdv_process(ssdv_t *s)
{
	if(s->state == S_HUFF)
 80058d8:	f000 84bb 	beq.w	8006252 <encode_ssdv+0xb62>
		
		/* Clear processed bits */
		s->worklen -= width;
		s->workbits &= (1 << s->worklen) - 1;
	}
	else if(s->state == S_INT)
 80058dc:	2a04      	cmp	r2, #4
 80058de:	f000 8557 	beq.w	8006390 <encode_ssdv+0xca0>
 80058e2:	f894 7059 	ldrb.w	r7, [r4, #89]	; 0x59
		/* Clear processed bits */
		s->worklen -= s->needbits;
		s->workbits &= (1 << s->worklen) - 1;
	}
	
	if(s->acpart >= 64)
 80058e6:	2f3f      	cmp	r7, #63	; 0x3f
 80058e8:	d917      	bls.n	800591a <encode_ssdv+0x22a>
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
 80058ea:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 80058ee:	f894 2057 	ldrb.w	r2, [r4, #87]	; 0x57
 80058f2:	3301      	adds	r3, #1
 80058f4:	b2db      	uxtb	r3, r3
 80058f6:	1c91      	adds	r1, r2, #2
 80058f8:	428b      	cmp	r3, r1
 80058fa:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
 80058fe:	f000 85c3 	beq.w	8006488 <encode_ssdv+0xd98>
				s->state = S_MARKER;
				return(SSDV_FEED_ME);
			}
		}
		
		if(s->mcupart < s->ycparts) s->component = 0;
 8005902:	4293      	cmp	r3, r2
		else s->component = s->mcupart - s->ycparts + 1;
 8005904:	bf2a      	itet	cs
 8005906:	3301      	addcs	r3, #1
				s->state = S_MARKER;
				return(SSDV_FEED_ME);
			}
		}
		
		if(s->mcupart < s->ycparts) s->component = 0;
 8005908:	2300      	movcc	r3, #0
		else s->component = s->mcupart - s->ycparts + 1;
 800590a:	1a9b      	subcs	r3, r3, r2
 800590c:	f884 3056 	strb.w	r3, [r4, #86]	; 0x56
		
		s->acpart = 0;
 8005910:	2300      	movs	r3, #0
 8005912:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59
		s->accrle = 0;
 8005916:	f884 3075 	strb.w	r3, [r4, #117]	; 0x75
	}
	
	if(s->out_len == 0) return(SSDV_BUFFER_FULL);
 800591a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800591c:	2b00      	cmp	r3, #0
 800591e:	f040 8493 	bne.w	8006248 <encode_ssdv+0xb58>
			while((r = ssdv_process(s)) == SSDV_OK);
			
			if(r == SSDV_BUFFER_FULL || r == SSDV_EOI)
			{
				uint16_t mcu_id     = s->packet_mcu_id;
				uint8_t i, mcu_offset = s->packet_mcu_offset;
 8005922:	7f23      	ldrb	r3, [r4, #28]
				uint32_t x;
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
 8005924:	2bff      	cmp	r3, #255	; 0xff
		
		s->acpart = 0;
		s->accrle = 0;
	}
	
	if(s->out_len == 0) return(SSDV_BUFFER_FULL);
 8005926:	f04f 0503 	mov.w	r5, #3
			{
				uint16_t mcu_id     = s->packet_mcu_id;
				uint8_t i, mcu_offset = s->packet_mcu_offset;
				uint32_t x;
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
 800592a:	f000 8668 	beq.w	80065fe <encode_ssdv+0xf0e>
 800592e:	8862      	ldrh	r2, [r4, #2]
 8005930:	4293      	cmp	r3, r2
 8005932:	f0c0 8664 	bcc.w	80065fe <encode_ssdv+0xf0e>
				{
					/* The first MCU begins in the next packet, not this one */
					mcu_id = 0xFFFF;
					mcu_offset = 0xFF;
					s->packet_mcu_offset -= s->pkt_size_payload;
 8005936:	1a9b      	subs	r3, r3, r2
 8005938:	21ff      	movs	r1, #255	; 0xff
 800593a:	7723      	strb	r3, [r4, #28]
 800593c:	460f      	mov	r7, r1
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
				{
					/* The first MCU begins in the next packet, not this one */
					mcu_id = 0xFFFF;
					mcu_offset = 0xFF;
 800593e:	460b      	mov	r3, r1
					s->packet_mcu_id = 0xFFFF;
					s->packet_mcu_offset = 0xFF;
				}
				
				/* A packet is ready, create the headers */
				s->out[0]   = 0x55;                /* Sync */
 8005940:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005942:	2055      	movs	r0, #85	; 0x55
 8005944:	7010      	strb	r0, [r2, #0]
				s->out[1]   = 0x66 + s->type;      /* Type */
 8005946:	7822      	ldrb	r2, [r4, #0]
 8005948:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800594a:	3266      	adds	r2, #102	; 0x66
 800594c:	7042      	strb	r2, [r0, #1]
				s->out[2]   = s->callsign >> 24;
 800594e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005950:	7be0      	ldrb	r0, [r4, #15]
 8005952:	7090      	strb	r0, [r2, #2]
				s->out[3]   = s->callsign >> 16;
 8005954:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005956:	89e0      	ldrh	r0, [r4, #14]
 8005958:	70d0      	strb	r0, [r2, #3]
				s->out[4]   = s->callsign >> 8;
 800595a:	68e2      	ldr	r2, [r4, #12]
 800595c:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800595e:	0a12      	lsrs	r2, r2, #8
 8005960:	7102      	strb	r2, [r0, #4]
				s->out[5]   = s->callsign;
 8005962:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005964:	68e0      	ldr	r0, [r4, #12]
 8005966:	7150      	strb	r0, [r2, #5]
				s->out[6]   = s->image_id;         /* Image ID */
 8005968:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800596a:	7c20      	ldrb	r0, [r4, #16]
 800596c:	7190      	strb	r0, [r2, #6]
				s->out[7]   = s->packet_id >> 8;   /* Packet ID MSB */
 800596e:	8a62      	ldrh	r2, [r4, #18]
 8005970:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8005972:	0a12      	lsrs	r2, r2, #8
 8005974:	71c2      	strb	r2, [r0, #7]
				s->out[8]   = s->packet_id & 0xFF; /* Packet ID LSB */
 8005976:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005978:	8a60      	ldrh	r0, [r4, #18]
 800597a:	7210      	strb	r0, [r2, #8]
				s->out[9]   = s->width >> 4;       /* Width / 16 */
 800597c:	88e2      	ldrh	r2, [r4, #6]
 800597e:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8005980:	0912      	lsrs	r2, r2, #4
 8005982:	7242      	strb	r2, [r0, #9]
				s->out[10]  = s->height >> 4;      /* Height / 16 */
 8005984:	8922      	ldrh	r2, [r4, #8]
 8005986:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8005988:	0912      	lsrs	r2, r2, #4
 800598a:	7282      	strb	r2, [r0, #10]
				s->out[11]  = 0x00;
 800598c:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800598e:	2200      	movs	r2, #0
 8005990:	72c2      	strb	r2, [r0, #11]
				s->out[11] |= (r == SSDV_EOI ? 1 : 0) << 2; /* EOI flag (1 bit) */
 8005992:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8005994:	2d04      	cmp	r5, #4
 8005996:	f996 e00b 	ldrsb.w	lr, [r6, #11]
 800599a:	bf14      	ite	ne
 800599c:	4610      	movne	r0, r2
 800599e:	2004      	moveq	r0, #4
 80059a0:	ea4e 0000 	orr.w	r0, lr, r0
 80059a4:	72f0      	strb	r0, [r6, #11]
				s->out[11] |= s->mcu_mode & 0x03;  /* MCU mode (2 bits) */
 80059a6:	f8d4 e034 	ldr.w	lr, [r4, #52]	; 0x34
 80059aa:	7d26      	ldrb	r6, [r4, #20]
 80059ac:	f89e 000b 	ldrb.w	r0, [lr, #11]
 80059b0:	f006 0603 	and.w	r6, r6, #3
 80059b4:	4330      	orrs	r0, r6
 80059b6:	f88e 000b 	strb.w	r0, [lr, #11]
				s->out[12]  = mcu_offset;          /* Next MCU offset */
 80059ba:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80059bc:	7303      	strb	r3, [r0, #12]
				s->out[13]  = mcu_id >> 8;         /* MCU ID MSB */
 80059be:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80059c0:	735f      	strb	r7, [r3, #13]
				s->out[14]  = mcu_id & 0xFF;       /* MCU ID LSB */
 80059c2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80059c4:	7399      	strb	r1, [r3, #14]
				
				/* Fill any remaining bytes with noise */
				if(s->out_len > 0) ssdv_memset_prng(s->outp, s->out_len);
 80059c6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80059c8:	b178      	cbz	r0, 80059ea <encode_ssdv+0x2fa>
 80059ca:	6ba1      	ldr	r1, [r4, #56]	; 0x38
/*****************************************************************************/

static void ssdv_memset_prng(uint8_t *s, size_t n)
{
	/* A very simple PRNG for noise whitening */
	uint8_t l = 0x00;
 80059cc:	4613      	mov	r3, r2
 80059ce:	180a      	adds	r2, r1, r0
	for(; n > 0; n--) *(s++) = (l = l * 245 + 45);
 80059d0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80059d4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80059d8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80059dc:	332d      	adds	r3, #45	; 0x2d
 80059de:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80059e2:	f801 3b01 	strb.w	r3, [r1], #1
 80059e6:	4291      	cmp	r1, r2
 80059e8:	d1f2      	bne.n	80059d0 <encode_ssdv+0x2e0>
				
				/* Fill any remaining bytes with noise */
				if(s->out_len > 0) ssdv_memset_prng(s->outp, s->out_len);
				
				/* Calculate the CRC codes */
				x = crc32(&s->out[1], s->pkt_size_crcdata);
 80059ea:	88a7      	ldrh	r7, [r4, #4]
 80059ec:	f8d4 e034 	ldr.w	lr, [r4, #52]	; 0x34
static uint32_t crc32(void *data, size_t length)
{
	uint32_t crc, x;
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
 80059f0:	2f00      	cmp	r7, #0
 80059f2:	f001 8130 	beq.w	8006c56 <encode_ssdv+0x1566>
 80059f6:	4676      	mov	r6, lr
 80059f8:	eb0e 0c07 	add.w	ip, lr, r7
 80059fc:	f04f 30ff 	mov.w	r0, #4294967295
	{
		x = (crc ^ *(d++)) & 0xFF;
 8005a00:	f816 3f01 	ldrb.w	r3, [r6, #1]!
 8005a04:	4043      	eors	r3, r0
 8005a06:	b2db      	uxtb	r3, r3
 8005a08:	2208      	movs	r2, #8
		for(i = 8; i > 0; i--)
		{
			if(x & 1) x = (x >> 1) ^ 0xEDB88320;
 8005a0a:	f013 0f01 	tst.w	r3, #1
 8005a0e:	ea4f 0153 	mov.w	r1, r3, lsr #1
 8005a12:	bf18      	it	ne
 8005a14:	4b73      	ldrne	r3, [pc, #460]	; (8005be4 <encode_ssdv+0x4f4>)
 8005a16:	f102 32ff 	add.w	r2, r2, #4294967295
 8005a1a:	bf14      	ite	ne
 8005a1c:	404b      	eorne	r3, r1
			else x >>= 1;
 8005a1e:	085b      	lsreq	r3, r3, #1
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
	{
		x = (crc ^ *(d++)) & 0xFF;
		for(i = 8; i > 0; i--)
 8005a20:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
 8005a24:	d1f1      	bne.n	8005a0a <encode_ssdv+0x31a>
static uint32_t crc32(void *data, size_t length)
{
	uint32_t crc, x;
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
 8005a26:	4566      	cmp	r6, ip
		for(i = 8; i > 0; i--)
		{
			if(x & 1) x = (x >> 1) ^ 0xEDB88320;
			else x >>= 1;
		}
		crc = (crc >> 8) ^ x;
 8005a28:	ea83 2010 	eor.w	r0, r3, r0, lsr #8
static uint32_t crc32(void *data, size_t length)
{
	uint32_t crc, x;
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
 8005a2c:	d1e8      	bne.n	8005a00 <encode_ssdv+0x310>
 8005a2e:	43c0      	mvns	r0, r0
 8005a30:	ea4f 6c10 	mov.w	ip, r0, lsr #24
 8005a34:	f3c0 4107 	ubfx	r1, r0, #16, #8
 8005a38:	f3c0 2607 	ubfx	r6, r0, #8, #8
 8005a3c:	b2c0      	uxtb	r0, r0
				if(s->out_len > 0) ssdv_memset_prng(s->outp, s->out_len);
				
				/* Calculate the CRC codes */
				x = crc32(&s->out[1], s->pkt_size_crcdata);
				
				i = 1 + s->pkt_size_crcdata;
 8005a3e:	fa5f f887 	uxtb.w	r8, r7
				s->out[i++] = (x >> 24) & 0xFF;
 8005a42:	f108 0201 	add.w	r2, r8, #1
 8005a46:	b2d2      	uxtb	r2, r2
				s->out[i++] = (x >> 16) & 0xFF;
 8005a48:	f108 0302 	add.w	r3, r8, #2
				
				/* Calculate the CRC codes */
				x = crc32(&s->out[1], s->pkt_size_crcdata);
				
				i = 1 + s->pkt_size_crcdata;
				s->out[i++] = (x >> 24) & 0xFF;
 8005a4c:	f80e c002 	strb.w	ip, [lr, r2]
				s->out[i++] = (x >> 16) & 0xFF;
 8005a50:	b2db      	uxtb	r3, r3
 8005a52:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005a54:	54d1      	strb	r1, [r2, r3]
				s->out[i++] = (x >> 8) & 0xFF;
 8005a56:	f108 0203 	add.w	r2, r8, #3
 8005a5a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8005a5c:	b2d2      	uxtb	r2, r2
				s->out[i++] = x & 0xFF;
 8005a5e:	f108 0304 	add.w	r3, r8, #4
				x = crc32(&s->out[1], s->pkt_size_crcdata);
				
				i = 1 + s->pkt_size_crcdata;
				s->out[i++] = (x >> 24) & 0xFF;
				s->out[i++] = (x >> 16) & 0xFF;
				s->out[i++] = (x >> 8) & 0xFF;
 8005a62:	548e      	strb	r6, [r1, r2]
				s->out[i++] = x & 0xFF;
 8005a64:	b2db      	uxtb	r3, r3
 8005a66:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005a68:	54d0      	strb	r0, [r2, r3]
				
				/* Generate the RS codes */
				if(s->type == SSDV_TYPE_NORMAL)
 8005a6a:	7821      	ldrb	r1, [r4, #0]
 8005a6c:	2900      	cmp	r1, #0
 8005a6e:	f001 80ad 	beq.w	8006bcc <encode_ssdv+0x14dc>
					encode_rs_8(&s->out[1], &s->out[i], 0);
				
				s->packet_id++;
 8005a72:	8a63      	ldrh	r3, [r4, #18]
				
				/* Have we reached the end of the image data? */
				if(r == SSDV_EOI) s->state = S_EOI;
 8005a74:	2d04      	cmp	r5, #4
				
				/* Generate the RS codes */
				if(s->type == SSDV_TYPE_NORMAL)
					encode_rs_8(&s->out[1], &s->out[i], 0);
				
				s->packet_id++;
 8005a76:	f103 0301 	add.w	r3, r3, #1
 8005a7a:	8263      	strh	r3, [r4, #18]
				
				/* Have we reached the end of the image data? */
				if(r == SSDV_EOI) s->state = S_EOI;
 8005a7c:	f001 807f 	beq.w	8006b7e <encode_ssdv+0x148e>
			return;
		}

		// Transmit packet
		radioMSG_t msg;
		msg.freq = getFrequency(&config->frequency);
 8005a80:	9d07      	ldr	r5, [sp, #28]
 8005a82:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8005a86:	f00c fcf3 	bl	8012470 <getFrequency>
		msg.power = config->power;

		switch(config->protocol) {
 8005a8a:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
		}

		// Transmit packet
		radioMSG_t msg;
		msg.freq = getFrequency(&config->frequency);
		msg.power = config->power;
 8005a8e:	f895 2020 	ldrb.w	r2, [r5, #32]
			return;
		}

		// Transmit packet
		radioMSG_t msg;
		msg.freq = getFrequency(&config->frequency);
 8005a92:	f8cd 0434 	str.w	r0, [sp, #1076]	; 0x434
		msg.power = config->power;
 8005a96:	f88d 2438 	strb.w	r2, [sp, #1080]	; 0x438

		switch(config->protocol) {
 8005a9a:	2b00      	cmp	r3, #0
 8005a9c:	f000 877e 	beq.w	800699c <encode_ssdv+0x12ac>
 8005aa0:	2b02      	cmp	r3, #2
 8005aa2:	f240 8738 	bls.w	8006916 <encode_ssdv+0x1226>

				transmitOnRadio(&msg);
				break;

			default:
				TRACE_ERROR("IMG  > Unsupported protocol selected for module IMAGE");
 8005aa6:	4850      	ldr	r0, [pc, #320]	; (8005be8 <encode_ssdv+0x4f8>)
 8005aa8:	f009 fa22 	bl	800eef0 <chMtxLock>
 8005aac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005ab0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8005ab4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005ab6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005ab8:	4b4c      	ldr	r3, [pc, #304]	; (8005bec <encode_ssdv+0x4fc>)
 8005aba:	494d      	ldr	r1, [pc, #308]	; (8005bf0 <encode_ssdv+0x500>)
 8005abc:	fb05 f000 	mul.w	r0, r5, r0
 8005ac0:	fba3 3000 	umull	r3, r0, r3, r0
 8005ac4:	4b4b      	ldr	r3, [pc, #300]	; (8005bf4 <encode_ssdv+0x504>)
 8005ac6:	0b80      	lsrs	r0, r0, #14
 8005ac8:	fba3 6300 	umull	r6, r3, r3, r0
 8005acc:	4e47      	ldr	r6, [pc, #284]	; (8005bec <encode_ssdv+0x4fc>)
 8005ace:	099b      	lsrs	r3, r3, #6
 8005ad0:	fba6 6202 	umull	r6, r2, r6, r2
 8005ad4:	fb05 0313 	mls	r3, r5, r3, r0
 8005ad8:	0b92      	lsrs	r2, r2, #14
 8005ada:	4847      	ldr	r0, [pc, #284]	; (8005bf8 <encode_ssdv+0x508>)
 8005adc:	f00c fe00 	bl	80126e0 <chprintf.constprop.35>
 8005ae0:	4a46      	ldr	r2, [pc, #280]	; (8005bfc <encode_ssdv+0x50c>)
 8005ae2:	4947      	ldr	r1, [pc, #284]	; (8005c00 <encode_ssdv+0x510>)
 8005ae4:	4844      	ldr	r0, [pc, #272]	; (8005bf8 <encode_ssdv+0x508>)
 8005ae6:	f00c fdfb 	bl	80126e0 <chprintf.constprop.35>
 8005aea:	235e      	movs	r3, #94	; 0x5e
 8005aec:	4a45      	ldr	r2, [pc, #276]	; (8005c04 <encode_ssdv+0x514>)
 8005aee:	4946      	ldr	r1, [pc, #280]	; (8005c08 <encode_ssdv+0x518>)
 8005af0:	4841      	ldr	r0, [pc, #260]	; (8005bf8 <encode_ssdv+0x508>)
 8005af2:	f00c fdf5 	bl	80126e0 <chprintf.constprop.35>
 8005af6:	4945      	ldr	r1, [pc, #276]	; (8005c0c <encode_ssdv+0x51c>)
 8005af8:	483f      	ldr	r0, [pc, #252]	; (8005bf8 <encode_ssdv+0x508>)
 8005afa:	f00c fdf1 	bl	80126e0 <chprintf.constprop.35>
 8005afe:	4944      	ldr	r1, [pc, #272]	; (8005c10 <encode_ssdv+0x520>)
 8005b00:	483d      	ldr	r0, [pc, #244]	; (8005bf8 <encode_ssdv+0x508>)
 8005b02:	f00c fded 	bl	80126e0 <chprintf.constprop.35>
 8005b06:	4943      	ldr	r1, [pc, #268]	; (8005c14 <encode_ssdv+0x524>)
 8005b08:	483b      	ldr	r0, [pc, #236]	; (8005bf8 <encode_ssdv+0x508>)
 8005b0a:	f00c fde9 	bl	80126e0 <chprintf.constprop.35>
 8005b0e:	4836      	ldr	r0, [pc, #216]	; (8005be8 <encode_ssdv+0x4f8>)
 8005b10:	f009 f98e 	bl	800ee30 <chMtxUnlock>
 8005b14:	215e      	movs	r1, #94	; 0x5e
 8005b16:	483b      	ldr	r0, [pc, #236]	; (8005c04 <encode_ssdv+0x514>)
 8005b18:	f00a fa22 	bl	800ff60 <log_error>
		}

		// Packet spacing (delay)
		if(config->packet_spacing)
 8005b1c:	9b07      	ldr	r3, [sp, #28]
 8005b1e:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8005b20:	2800      	cmp	r0, #0
 8005b22:	f040 872d 	bne.w	8006980 <encode_ssdv+0x1290>
 8005b26:	9b06      	ldr	r3, [sp, #24]
 8005b28:	3301      	adds	r3, #1
 8005b2a:	9306      	str	r3, [sp, #24]
 8005b2c:	e687      	b.n	800583e <encode_ssdv+0x14e>
				if(r != SSDV_OK) return(r);
			}
			break;
		
		case S_MARKER_DATA:
			s->marker_data[s->marker_data_len++] = b;
 8005b2e:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
 8005b32:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8005b34:	1c58      	adds	r0, r3, #1
 8005b36:	f8a4 0054 	strh.w	r0, [r4, #84]	; 0x54
 8005b3a:	54d1      	strb	r1, [r2, r3]
			if(s->marker_data_len == s->marker_len)
 8005b3c:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
 8005b40:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8005b44:	429a      	cmp	r2, r3
 8005b46:	f47f ae89 	bne.w	800585c <encode_ssdv+0x16c>
{
	uint8_t *d = s->marker_data;
	size_t l = s->marker_len;
	int i;
	
	switch(s->marker)
 8005b4a:	f8b4 204a 	ldrh.w	r2, [r4, #74]	; 0x4a
	return(SSDV_OK);
}

static char ssdv_have_marker_data(ssdv_t *s)
{
	uint8_t *d = s->marker_data;
 8005b4e:	6d25      	ldr	r5, [r4, #80]	; 0x50
	size_t l = s->marker_len;
	int i;
	
	switch(s->marker)
 8005b50:	f5a2 427f 	sub.w	r2, r2, #65280	; 0xff00
 8005b54:	3ac0      	subs	r2, #192	; 0xc0
}

static char ssdv_have_marker_data(ssdv_t *s)
{
	uint8_t *d = s->marker_data;
	size_t l = s->marker_len;
 8005b56:	461e      	mov	r6, r3
	int i;
	
	switch(s->marker)
 8005b58:	2a1d      	cmp	r2, #29
 8005b5a:	f200 8143 	bhi.w	8005de4 <encode_ssdv+0x6f4>
 8005b5e:	e8df f012 	tbh	[pc, r2, lsl #1]
 8005b62:	0283      	.short	0x0283
 8005b64:	01410141 	.word	0x01410141
 8005b68:	02340141 	.word	0x02340141
 8005b6c:	01410141 	.word	0x01410141
 8005b70:	01410141 	.word	0x01410141
 8005b74:	01410141 	.word	0x01410141
 8005b78:	01410141 	.word	0x01410141
 8005b7c:	01410141 	.word	0x01410141
 8005b80:	01410141 	.word	0x01410141
 8005b84:	01410141 	.word	0x01410141
 8005b88:	01410141 	.word	0x01410141
 8005b8c:	01410141 	.word	0x01410141
 8005b90:	01410141 	.word	0x01410141
 8005b94:	017b0141 	.word	0x017b0141
 8005b98:	01410145 	.word	0x01410145
 8005b9c:	00fc      	.short	0x00fc
		if(s->in_skip) { s->in_skip--; continue; }
		
		switch(s->state)
		{
		case S_MARKER:
			s->marker = (s->marker << 8) | b;
 8005b9e:	f8b4 204a 	ldrh.w	r2, [r4, #74]	; 0x4a
 8005ba2:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 8005ba6:	b289      	uxth	r1, r1
			
			if(s->marker == J_TEM ||
 8005ba8:	f64f 7201 	movw	r2, #65281	; 0xff01
 8005bac:	4291      	cmp	r1, r2
		if(s->in_skip) { s->in_skip--; continue; }
		
		switch(s->state)
		{
		case S_MARKER:
			s->marker = (s->marker << 8) | b;
 8005bae:	f8a4 104a 	strh.w	r1, [r4, #74]	; 0x4a
			
			if(s->marker == J_TEM ||
 8005bb2:	f000 852d 	beq.w	8006610 <encode_ssdv+0xf20>
 8005bb6:	f101 0230 	add.w	r2, r1, #48	; 0x30
 8005bba:	b292      	uxth	r2, r2
 8005bbc:	2a09      	cmp	r2, #9
 8005bbe:	f240 8527 	bls.w	8006610 <encode_ssdv+0xf20>
				/* Marker without data */
				s->marker_len = 0;
				r = ssdv_have_marker(s);
				if(r != SSDV_OK) return(r);
			}
			else if(s->marker >= J_SOF0 && s->marker <= J_COM)
 8005bc2:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8005bc6:	b292      	uxth	r2, r2
 8005bc8:	2a3e      	cmp	r2, #62	; 0x3e
 8005bca:	f63f ae48 	bhi.w	800585e <encode_ssdv+0x16e>
			{
				/* All other markers are followed by data */
				s->marker_len = 0;
 8005bce:	2000      	movs	r0, #0
				s->state = S_MARKER_LEN;
 8005bd0:	2101      	movs	r1, #1
				s->needbits = 16;
 8005bd2:	2210      	movs	r2, #16
				if(r != SSDV_OK) return(r);
			}
			else if(s->marker >= J_SOF0 && s->marker <= J_COM)
			{
				/* All other markers are followed by data */
				s->marker_len = 0;
 8005bd4:	f8a4 004c 	strh.w	r0, [r4, #76]	; 0x4c
				s->state = S_MARKER_LEN;
 8005bd8:	f884 1049 	strb.w	r1, [r4, #73]	; 0x49
				s->needbits = 16;
 8005bdc:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
 8005be0:	e63d      	b.n	800585e <encode_ssdv+0x16e>
 8005be2:	bf00      	nop
 8005be4:	edb88320 	.word	0xedb88320
 8005be8:	20027b2c 	.word	0x20027b2c
 8005bec:	d1b71759 	.word	0xd1b71759
 8005bf0:	08013c50 	.word	0x08013c50
 8005bf4:	10624dd3 	.word	0x10624dd3
 8005bf8:	20027e60 	.word	0x20027e60
 8005bfc:	08013d9c 	.word	0x08013d9c
 8005c00:	08013c5c 	.word	0x08013c5c
 8005c04:	08014340 	.word	0x08014340
 8005c08:	08013c78 	.word	0x08013c78
 8005c0c:	08013d00 	.word	0x08013d00
 8005c10:	08014c38 	.word	0x08014c38
 8005c14:	08013cac 	.word	0x08013cac
			}
			break;
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
 8005c18:	f8b4 004c 	ldrh.w	r0, [r4, #76]	; 0x4c
			if((s->needbits -= 8) == 0)
 8005c1c:	f894 2080 	ldrb.w	r2, [r4, #128]	; 0x80
				s->needbits = 16;
			}
			break;
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
 8005c20:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			if((s->needbits -= 8) == 0)
 8005c24:	3a08      	subs	r2, #8
				s->needbits = 16;
			}
			break;
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
 8005c26:	b289      	uxth	r1, r1
			if((s->needbits -= 8) == 0)
 8005c28:	b2d2      	uxtb	r2, r2
				s->needbits = 16;
			}
			break;
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
 8005c2a:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
			if((s->needbits -= 8) == 0)
 8005c2e:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
 8005c32:	2a00      	cmp	r2, #0
 8005c34:	f47f ae13 	bne.w	800585e <encode_ssdv+0x16e>
			{
				s->marker_len -= 2;
 8005c38:	3902      	subs	r1, #2
				r = ssdv_have_marker(s);
 8005c3a:	4620      	mov	r0, r4
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
			if((s->needbits -= 8) == 0)
			{
				s->marker_len -= 2;
 8005c3c:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
				r = ssdv_have_marker(s);
 8005c40:	f004 fd6e 	bl	800a720 <ssdv_have_marker.lto_priv.157>
				if(r != SSDV_OK) return(r);
 8005c44:	2800      	cmp	r0, #0
 8005c46:	f43f ae09 	beq.w	800585c <encode_ssdv+0x16c>

	while(true)
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
 8005c4a:	2801      	cmp	r0, #1
 8005c4c:	f040 84ec 	bne.w	8006628 <encode_ssdv+0xf38>
		{
			b = &image[bi];
			uint8_t r = bi < image_len-128 ? 128 : image_len - bi;
 8005c50:	9d05      	ldr	r5, [sp, #20]
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
		{
			b = &image[bi];
 8005c52:	9903      	ldr	r1, [sp, #12]
 8005c54:	9804      	ldr	r0, [sp, #16]
			uint8_t r = bi < image_len-128 ? 128 : image_len - bi;
 8005c56:	f1a5 0380 	sub.w	r3, r5, #128	; 0x80
 8005c5a:	428b      	cmp	r3, r1
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
		{
			b = &image[bi];
 8005c5c:	eb00 0201 	add.w	r2, r0, r1
			uint8_t r = bi < image_len-128 ? 128 : image_len - bi;
 8005c60:	f200 8571 	bhi.w	8006746 <encode_ssdv+0x1056>
 8005c64:	1a6b      	subs	r3, r5, r1
 8005c66:	b2db      	uxtb	r3, r3
			bi += r;
 8005c68:	4419      	add	r1, r3
 8005c6a:	9103      	str	r1, [sp, #12]

			if(r <= 0)
 8005c6c:	2b00      	cmp	r3, #0
 8005c6e:	f000 8615 	beq.w	800689c <encode_ssdv+0x11ac>
{
	int r;
	uint8_t b;
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
 8005c72:	f894 1049 	ldrb.w	r1, [r4, #73]	; 0x49
	return(SSDV_FEED_ME);
}

char ssdv_enc_feed(ssdv_t *s, uint8_t *buffer, size_t length)
{
	s->inp    = buffer;
 8005c76:	6222      	str	r2, [r4, #32]
{
	int r;
	uint8_t b;
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
 8005c78:	2905      	cmp	r1, #5
}

char ssdv_enc_feed(ssdv_t *s, uint8_t *buffer, size_t length)
{
	s->inp    = buffer;
	s->in_len = length;
 8005c7a:	6263      	str	r3, [r4, #36]	; 0x24
{
	int r;
	uint8_t b;
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
 8005c7c:	f47f adea 	bne.w	8005854 <encode_ssdv+0x164>
 8005c80:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
			ssdv_enc_feed(&ssdv, b, r);
		}

		if(c == SSDV_EOI)
		{
			TRACE_INFO("SSDV > ssdv_enc_get_packet said EOI");
 8005c84:	4864      	ldr	r0, [pc, #400]	; (8005e18 <encode_ssdv+0x728>)
 8005c86:	4e65      	ldr	r6, [pc, #404]	; (8005e1c <encode_ssdv+0x72c>)
 8005c88:	4c65      	ldr	r4, [pc, #404]	; (8005e20 <encode_ssdv+0x730>)
 8005c8a:	f009 f931 	bl	800eef0 <chMtxLock>
 8005c8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005c90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005c92:	4964      	ldr	r1, [pc, #400]	; (8005e24 <encode_ssdv+0x734>)
 8005c94:	4864      	ldr	r0, [pc, #400]	; (8005e28 <encode_ssdv+0x738>)
 8005c96:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8005c9a:	fb05 f303 	mul.w	r3, r5, r3
 8005c9e:	fba6 e303 	umull	lr, r3, r6, r3
 8005ca2:	0b9b      	lsrs	r3, r3, #14
 8005ca4:	fba4 ce03 	umull	ip, lr, r4, r3
 8005ca8:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8005cac:	fba6 c202 	umull	ip, r2, r6, r2
 8005cb0:	fb05 331e 	mls	r3, r5, lr, r3
 8005cb4:	0b92      	lsrs	r2, r2, #14
 8005cb6:	f00c fd13 	bl	80126e0 <chprintf.constprop.35>
 8005cba:	4a5c      	ldr	r2, [pc, #368]	; (8005e2c <encode_ssdv+0x73c>)
 8005cbc:	495c      	ldr	r1, [pc, #368]	; (8005e30 <encode_ssdv+0x740>)
 8005cbe:	485a      	ldr	r0, [pc, #360]	; (8005e28 <encode_ssdv+0x738>)
 8005cc0:	f00c fd0e 	bl	80126e0 <chprintf.constprop.35>
 8005cc4:	2336      	movs	r3, #54	; 0x36
 8005cc6:	4a5b      	ldr	r2, [pc, #364]	; (8005e34 <encode_ssdv+0x744>)
 8005cc8:	495b      	ldr	r1, [pc, #364]	; (8005e38 <encode_ssdv+0x748>)
 8005cca:	4857      	ldr	r0, [pc, #348]	; (8005e28 <encode_ssdv+0x738>)
 8005ccc:	f00c fd08 	bl	80126e0 <chprintf.constprop.35>
 8005cd0:	495a      	ldr	r1, [pc, #360]	; (8005e3c <encode_ssdv+0x74c>)
 8005cd2:	4855      	ldr	r0, [pc, #340]	; (8005e28 <encode_ssdv+0x738>)
 8005cd4:	f00c fd04 	bl	80126e0 <chprintf.constprop.35>
 8005cd8:	4959      	ldr	r1, [pc, #356]	; (8005e40 <encode_ssdv+0x750>)
 8005cda:	4853      	ldr	r0, [pc, #332]	; (8005e28 <encode_ssdv+0x738>)
 8005cdc:	f00c fd00 	bl	80126e0 <chprintf.constprop.35>
 8005ce0:	4958      	ldr	r1, [pc, #352]	; (8005e44 <encode_ssdv+0x754>)
 8005ce2:	4851      	ldr	r0, [pc, #324]	; (8005e28 <encode_ssdv+0x738>)
 8005ce4:	f00c fcfc 	bl	80126e0 <chprintf.constprop.35>
 8005ce8:	484b      	ldr	r0, [pc, #300]	; (8005e18 <encode_ssdv+0x728>)
 8005cea:	f009 f8a1 	bl	800ee30 <chMtxUnlock>
			chThdSleepMilliseconds(config->packet_spacing);

		i++;
	}

	TRACE_INFO("SSDV > %i packets", i);
 8005cee:	484a      	ldr	r0, [pc, #296]	; (8005e18 <encode_ssdv+0x728>)
 8005cf0:	f009 f8fe 	bl	800eef0 <chMtxLock>
 8005cf4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005cf6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005cf8:	494a      	ldr	r1, [pc, #296]	; (8005e24 <encode_ssdv+0x734>)
 8005cfa:	484b      	ldr	r0, [pc, #300]	; (8005e28 <encode_ssdv+0x738>)
 8005cfc:	fb05 f303 	mul.w	r3, r5, r3
 8005d00:	fba6 7303 	umull	r7, r3, r6, r3
 8005d04:	0b9b      	lsrs	r3, r3, #14
 8005d06:	fba4 7403 	umull	r7, r4, r4, r3
 8005d0a:	09a4      	lsrs	r4, r4, #6
 8005d0c:	fba6 6202 	umull	r6, r2, r6, r2
 8005d10:	fb05 3314 	mls	r3, r5, r4, r3
 8005d14:	0b92      	lsrs	r2, r2, #14
 8005d16:	f00c fce3 	bl	80126e0 <chprintf.constprop.35>
 8005d1a:	4a44      	ldr	r2, [pc, #272]	; (8005e2c <encode_ssdv+0x73c>)
 8005d1c:	4944      	ldr	r1, [pc, #272]	; (8005e30 <encode_ssdv+0x740>)
 8005d1e:	4842      	ldr	r0, [pc, #264]	; (8005e28 <encode_ssdv+0x738>)
 8005d20:	f00c fcde 	bl	80126e0 <chprintf.constprop.35>
 8005d24:	2368      	movs	r3, #104	; 0x68
 8005d26:	4a43      	ldr	r2, [pc, #268]	; (8005e34 <encode_ssdv+0x744>)
 8005d28:	4943      	ldr	r1, [pc, #268]	; (8005e38 <encode_ssdv+0x748>)
 8005d2a:	483f      	ldr	r0, [pc, #252]	; (8005e28 <encode_ssdv+0x738>)
 8005d2c:	f00c fcd8 	bl	80126e0 <chprintf.constprop.35>
 8005d30:	4942      	ldr	r1, [pc, #264]	; (8005e3c <encode_ssdv+0x74c>)
 8005d32:	483d      	ldr	r0, [pc, #244]	; (8005e28 <encode_ssdv+0x738>)
 8005d34:	f00c fcd4 	bl	80126e0 <chprintf.constprop.35>
 8005d38:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 8005d3c:	4942      	ldr	r1, [pc, #264]	; (8005e48 <encode_ssdv+0x758>)
 8005d3e:	483a      	ldr	r0, [pc, #232]	; (8005e28 <encode_ssdv+0x738>)
 8005d40:	f00c fcce 	bl	80126e0 <chprintf.constprop.35>
 8005d44:	493f      	ldr	r1, [pc, #252]	; (8005e44 <encode_ssdv+0x754>)
 8005d46:	4838      	ldr	r0, [pc, #224]	; (8005e28 <encode_ssdv+0x738>)
 8005d48:	f00c fcca 	bl	80126e0 <chprintf.constprop.35>
 8005d4c:	4832      	ldr	r0, [pc, #200]	; (8005e18 <encode_ssdv+0x728>)
 8005d4e:	f009 f86f 	bl	800ee30 <chMtxUnlock>
}
 8005d52:	f60d 1d5c 	addw	sp, sp, #2396	; 0x95c
 8005d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			d += 65;
		}
		break;
	
	case J_DRI:
		s->dri = (d[0] << 8) + d[1];
 8005d5a:	782a      	ldrb	r2, [r5, #0]
 8005d5c:	786b      	ldrb	r3, [r5, #1]
		TRACE_ERROR("SSDV > Reset interval: %i blocks", s->dri);
 8005d5e:	482e      	ldr	r0, [pc, #184]	; (8005e18 <encode_ssdv+0x728>)
			d += 65;
		}
		break;
	
	case J_DRI:
		s->dri = (d[0] << 8) + d[1];
 8005d60:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8005d64:	f8a4 3076 	strh.w	r3, [r4, #118]	; 0x76
		TRACE_ERROR("SSDV > Reset interval: %i blocks", s->dri);
 8005d68:	f009 f8c2 	bl	800eef0 <chMtxLock>
 8005d6c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005d70:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8005d74:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005d76:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005d78:	4b28      	ldr	r3, [pc, #160]	; (8005e1c <encode_ssdv+0x72c>)
 8005d7a:	492a      	ldr	r1, [pc, #168]	; (8005e24 <encode_ssdv+0x734>)
 8005d7c:	fb05 f000 	mul.w	r0, r5, r0
 8005d80:	fba3 3000 	umull	r3, r0, r3, r0
 8005d84:	4b26      	ldr	r3, [pc, #152]	; (8005e20 <encode_ssdv+0x730>)
 8005d86:	0b80      	lsrs	r0, r0, #14
 8005d88:	fba3 6300 	umull	r6, r3, r3, r0
 8005d8c:	4e23      	ldr	r6, [pc, #140]	; (8005e1c <encode_ssdv+0x72c>)
 8005d8e:	099b      	lsrs	r3, r3, #6
 8005d90:	fba6 6202 	umull	r6, r2, r6, r2
 8005d94:	fb05 0313 	mls	r3, r5, r3, r0
 8005d98:	0b92      	lsrs	r2, r2, #14
 8005d9a:	4823      	ldr	r0, [pc, #140]	; (8005e28 <encode_ssdv+0x738>)
 8005d9c:	f00c fca0 	bl	80126e0 <chprintf.constprop.35>
 8005da0:	4a2a      	ldr	r2, [pc, #168]	; (8005e4c <encode_ssdv+0x75c>)
 8005da2:	4923      	ldr	r1, [pc, #140]	; (8005e30 <encode_ssdv+0x740>)
 8005da4:	4820      	ldr	r0, [pc, #128]	; (8005e28 <encode_ssdv+0x738>)
 8005da6:	f00c fc9b 	bl	80126e0 <chprintf.constprop.35>
 8005daa:	f240 333b 	movw	r3, #827	; 0x33b
 8005dae:	4a28      	ldr	r2, [pc, #160]	; (8005e50 <encode_ssdv+0x760>)
 8005db0:	4921      	ldr	r1, [pc, #132]	; (8005e38 <encode_ssdv+0x748>)
 8005db2:	481d      	ldr	r0, [pc, #116]	; (8005e28 <encode_ssdv+0x738>)
 8005db4:	f00c fc94 	bl	80126e0 <chprintf.constprop.35>
 8005db8:	4920      	ldr	r1, [pc, #128]	; (8005e3c <encode_ssdv+0x74c>)
 8005dba:	481b      	ldr	r0, [pc, #108]	; (8005e28 <encode_ssdv+0x738>)
 8005dbc:	f00c fc90 	bl	80126e0 <chprintf.constprop.35>
 8005dc0:	f8b4 2076 	ldrh.w	r2, [r4, #118]	; 0x76
 8005dc4:	4923      	ldr	r1, [pc, #140]	; (8005e54 <encode_ssdv+0x764>)
 8005dc6:	4818      	ldr	r0, [pc, #96]	; (8005e28 <encode_ssdv+0x738>)
 8005dc8:	f00c fc8a 	bl	80126e0 <chprintf.constprop.35>
 8005dcc:	491d      	ldr	r1, [pc, #116]	; (8005e44 <encode_ssdv+0x754>)
 8005dce:	4816      	ldr	r0, [pc, #88]	; (8005e28 <encode_ssdv+0x738>)
 8005dd0:	f00c fc86 	bl	80126e0 <chprintf.constprop.35>
 8005dd4:	4810      	ldr	r0, [pc, #64]	; (8005e18 <encode_ssdv+0x728>)
 8005dd6:	f009 f82b 	bl	800ee30 <chMtxUnlock>
 8005dda:	f240 313b 	movw	r1, #827	; 0x33b
 8005dde:	481c      	ldr	r0, [pc, #112]	; (8005e50 <encode_ssdv+0x760>)
 8005de0:	f00a f8be 	bl	800ff60 <log_error>
		break;
	}
	
	s->state = S_MARKER;
 8005de4:	2300      	movs	r3, #0
 8005de6:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
 8005dea:	e537      	b.n	800585c <encode_ssdv+0x16c>
			d += j;
		}
		break;
	
	case J_DQT:
		s->stbl_len += l;
 8005dec:	f8b4 22cc 	ldrh.w	r2, [r4, #716]	; 0x2cc
 8005df0:	441a      	add	r2, r3
 8005df2:	f8a4 22cc 	strh.w	r2, [r4, #716]	; 0x2cc
		while(l > 0)
 8005df6:	2b00      	cmp	r3, #0
 8005df8:	d0f4      	beq.n	8005de4 <encode_ssdv+0x6f4>
 8005dfa:	442b      	add	r3, r5
 8005dfc:	e006      	b.n	8005e0c <encode_ssdv+0x71c>
		{
			switch(d[0])
 8005dfe:	2a01      	cmp	r2, #1
 8005e00:	d101      	bne.n	8005e06 <encode_ssdv+0x716>
			{
			case 0x00: s->sdqt[0] = d; break;
			case 0x01: s->sdqt[1] = d; break;
 8005e02:	f8c4 52c8 	str.w	r5, [r4, #712]	; 0x2c8
			}
			
			/* Skip to the next one, if present */
			l -= 65;
			d += 65;
 8005e06:	3541      	adds	r5, #65	; 0x41
		}
		break;
	
	case J_DQT:
		s->stbl_len += l;
		while(l > 0)
 8005e08:	429d      	cmp	r5, r3
 8005e0a:	d0eb      	beq.n	8005de4 <encode_ssdv+0x6f4>
		{
			switch(d[0])
 8005e0c:	782a      	ldrb	r2, [r5, #0]
 8005e0e:	2a00      	cmp	r2, #0
 8005e10:	d1f5      	bne.n	8005dfe <encode_ssdv+0x70e>
			{
			case 0x00: s->sdqt[0] = d; break;
 8005e12:	f8c4 52c4 	str.w	r5, [r4, #708]	; 0x2c4
 8005e16:	e7f6      	b.n	8005e06 <encode_ssdv+0x716>
 8005e18:	20027b2c 	.word	0x20027b2c
 8005e1c:	d1b71759 	.word	0xd1b71759
 8005e20:	10624dd3 	.word	0x10624dd3
 8005e24:	08013c50 	.word	0x08013c50
 8005e28:	20027e60 	.word	0x20027e60
 8005e2c:	08013cfc 	.word	0x08013cfc
 8005e30:	08013c5c 	.word	0x08013c5c
 8005e34:	08014340 	.word	0x08014340
 8005e38:	08013c78 	.word	0x08013c78
 8005e3c:	08013d00 	.word	0x08013d00
 8005e40:	08014c70 	.word	0x08014c70
 8005e44:	08013cac 	.word	0x08013cac
 8005e48:	08014c94 	.word	0x08014c94
 8005e4c:	08013d9c 	.word	0x08013d9c
 8005e50:	0801491f 	.word	0x0801491f
 8005e54:	08014bec 	.word	0x08014bec
 8005e58:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
		s->mcu_count = l;
		
		break;
	
	case J_SOS:
		TRACE_INFO("SSDV > Components: %i", d[0]);
 8005e5c:	4872      	ldr	r0, [pc, #456]	; (8006028 <encode_ssdv+0x938>)
 8005e5e:	f8df 81fc 	ldr.w	r8, [pc, #508]	; 800605c <encode_ssdv+0x96c>
 8005e62:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 8006030 <encode_ssdv+0x940>
 8005e66:	f009 f843 	bl	800eef0 <chMtxLock>
 8005e6a:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8005e6c:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8005e6e:	496f      	ldr	r1, [pc, #444]	; (800602c <encode_ssdv+0x93c>)
 8005e70:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8005e74:	4640      	mov	r0, r8
 8005e76:	fb07 f303 	mul.w	r3, r7, r3
 8005e7a:	fba0 0303 	umull	r0, r3, r0, r3
 8005e7e:	486c      	ldr	r0, [pc, #432]	; (8006030 <encode_ssdv+0x940>)
 8005e80:	0b9b      	lsrs	r3, r3, #14
 8005e82:	fba0 0e03 	umull	r0, lr, r0, r3
 8005e86:	4640      	mov	r0, r8
 8005e88:	fba0 0202 	umull	r0, r2, r0, r2
 8005e8c:	ea4f 109e 	mov.w	r0, lr, lsr #6
 8005e90:	fb07 3310 	mls	r3, r7, r0, r3
 8005e94:	0b92      	lsrs	r2, r2, #14
 8005e96:	4867      	ldr	r0, [pc, #412]	; (8006034 <encode_ssdv+0x944>)
 8005e98:	f00c fc22 	bl	80126e0 <chprintf.constprop.35>
 8005e9c:	4a66      	ldr	r2, [pc, #408]	; (8006038 <encode_ssdv+0x948>)
 8005e9e:	4967      	ldr	r1, [pc, #412]	; (800603c <encode_ssdv+0x94c>)
 8005ea0:	4864      	ldr	r0, [pc, #400]	; (8006034 <encode_ssdv+0x944>)
 8005ea2:	f00c fc1d 	bl	80126e0 <chprintf.constprop.35>
 8005ea6:	f240 23e7 	movw	r3, #743	; 0x2e7
 8005eaa:	4a65      	ldr	r2, [pc, #404]	; (8006040 <encode_ssdv+0x950>)
 8005eac:	4965      	ldr	r1, [pc, #404]	; (8006044 <encode_ssdv+0x954>)
 8005eae:	4861      	ldr	r0, [pc, #388]	; (8006034 <encode_ssdv+0x944>)
 8005eb0:	f00c fc16 	bl	80126e0 <chprintf.constprop.35>
 8005eb4:	4964      	ldr	r1, [pc, #400]	; (8006048 <encode_ssdv+0x958>)
 8005eb6:	485f      	ldr	r0, [pc, #380]	; (8006034 <encode_ssdv+0x944>)
 8005eb8:	f00c fc12 	bl	80126e0 <chprintf.constprop.35>
 8005ebc:	782a      	ldrb	r2, [r5, #0]
 8005ebe:	4963      	ldr	r1, [pc, #396]	; (800604c <encode_ssdv+0x95c>)
 8005ec0:	485c      	ldr	r0, [pc, #368]	; (8006034 <encode_ssdv+0x944>)
 8005ec2:	f00c fc0d 	bl	80126e0 <chprintf.constprop.35>
 8005ec6:	4962      	ldr	r1, [pc, #392]	; (8006050 <encode_ssdv+0x960>)
 8005ec8:	485a      	ldr	r0, [pc, #360]	; (8006034 <encode_ssdv+0x944>)
 8005eca:	f00c fc09 	bl	80126e0 <chprintf.constprop.35>
 8005ece:	4856      	ldr	r0, [pc, #344]	; (8006028 <encode_ssdv+0x938>)
 8005ed0:	f008 ffae 	bl	800ee30 <chMtxUnlock>
		
		/* The image must have 3 components (Y'Cb'Cr) */
		if(d[0] != 3)
 8005ed4:	782b      	ldrb	r3, [r5, #0]
 8005ed6:	2b03      	cmp	r3, #3
 8005ed8:	f000 8576 	beq.w	80069c8 <encode_ssdv+0x12d8>
		{
			TRACE_ERROR("SSDV > The image must have 3 components");
 8005edc:	4852      	ldr	r0, [pc, #328]	; (8006028 <encode_ssdv+0x938>)
 8005ede:	f009 f807 	bl	800eef0 <chMtxLock>
 8005ee2:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8005ee4:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8005ee6:	4951      	ldr	r1, [pc, #324]	; (800602c <encode_ssdv+0x93c>)
 8005ee8:	4852      	ldr	r0, [pc, #328]	; (8006034 <encode_ssdv+0x944>)
 8005eea:	fb07 f303 	mul.w	r3, r7, r3
 8005eee:	fba8 4303 	umull	r4, r3, r8, r3
 8005ef2:	0b9b      	lsrs	r3, r3, #14
 8005ef4:	fba9 5403 	umull	r5, r4, r9, r3
 8005ef8:	09a4      	lsrs	r4, r4, #6
 8005efa:	fba8 5202 	umull	r5, r2, r8, r2
 8005efe:	fb07 3314 	mls	r3, r7, r4, r3
 8005f02:	0b92      	lsrs	r2, r2, #14
 8005f04:	f00c fbec 	bl	80126e0 <chprintf.constprop.35>
 8005f08:	4a52      	ldr	r2, [pc, #328]	; (8006054 <encode_ssdv+0x964>)
 8005f0a:	494c      	ldr	r1, [pc, #304]	; (800603c <encode_ssdv+0x94c>)
 8005f0c:	4849      	ldr	r0, [pc, #292]	; (8006034 <encode_ssdv+0x944>)
 8005f0e:	f00c fbe7 	bl	80126e0 <chprintf.constprop.35>
 8005f12:	f44f 733b 	mov.w	r3, #748	; 0x2ec
 8005f16:	4a4a      	ldr	r2, [pc, #296]	; (8006040 <encode_ssdv+0x950>)
 8005f18:	494a      	ldr	r1, [pc, #296]	; (8006044 <encode_ssdv+0x954>)
 8005f1a:	4846      	ldr	r0, [pc, #280]	; (8006034 <encode_ssdv+0x944>)
 8005f1c:	f00c fbe0 	bl	80126e0 <chprintf.constprop.35>
 8005f20:	4949      	ldr	r1, [pc, #292]	; (8006048 <encode_ssdv+0x958>)
 8005f22:	4844      	ldr	r0, [pc, #272]	; (8006034 <encode_ssdv+0x944>)
 8005f24:	f00c fbdc 	bl	80126e0 <chprintf.constprop.35>
 8005f28:	494b      	ldr	r1, [pc, #300]	; (8006058 <encode_ssdv+0x968>)
 8005f2a:	4842      	ldr	r0, [pc, #264]	; (8006034 <encode_ssdv+0x944>)
 8005f2c:	f00c fbd8 	bl	80126e0 <chprintf.constprop.35>
 8005f30:	4947      	ldr	r1, [pc, #284]	; (8006050 <encode_ssdv+0x960>)
 8005f32:	4840      	ldr	r0, [pc, #256]	; (8006034 <encode_ssdv+0x944>)
 8005f34:	f00c fbd4 	bl	80126e0 <chprintf.constprop.35>
 8005f38:	483b      	ldr	r0, [pc, #236]	; (8006028 <encode_ssdv+0x938>)
 8005f3a:	f008 ff79 	bl	800ee30 <chMtxUnlock>
 8005f3e:	f44f 713b 	mov.w	r1, #748	; 0x2ec
 8005f42:	483f      	ldr	r0, [pc, #252]	; (8006040 <encode_ssdv+0x950>)
 8005f44:	f00a f80c 	bl	800ff60 <log_error>
	memset(parity, 0, NROOTS * sizeof(uint8_t));
	
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
		if(feedback != A0) /* feedback term is non-zero */
 8005f48:	20ff      	movs	r0, #255	; 0xff
 8005f4a:	4604      	mov	r4, r0
		if(c == SSDV_EOI)
		{
			TRACE_INFO("SSDV > ssdv_enc_get_packet said EOI");
			break;
		} else if(c != SSDV_OK) {
			TRACE_ERROR("SSDV > ssdv_enc_get_packet failed: %i", c);
 8005f4c:	4836      	ldr	r0, [pc, #216]	; (8006028 <encode_ssdv+0x938>)
 8005f4e:	4f43      	ldr	r7, [pc, #268]	; (800605c <encode_ssdv+0x96c>)
 8005f50:	f008 ffce 	bl	800eef0 <chMtxLock>
 8005f54:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005f58:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8005f5c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005f5e:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 8005f60:	4b33      	ldr	r3, [pc, #204]	; (8006030 <encode_ssdv+0x940>)
 8005f62:	4932      	ldr	r1, [pc, #200]	; (800602c <encode_ssdv+0x93c>)
 8005f64:	4833      	ldr	r0, [pc, #204]	; (8006034 <encode_ssdv+0x944>)
 8005f66:	fb06 f505 	mul.w	r5, r6, r5
 8005f6a:	fba7 e505 	umull	lr, r5, r7, r5
 8005f6e:	0bad      	lsrs	r5, r5, #14
 8005f70:	fba3 e305 	umull	lr, r3, r3, r5
 8005f74:	fba7 7202 	umull	r7, r2, r7, r2
 8005f78:	099b      	lsrs	r3, r3, #6
 8005f7a:	fb06 5313 	mls	r3, r6, r3, r5
 8005f7e:	0b92      	lsrs	r2, r2, #14
 8005f80:	f00c fbae 	bl	80126e0 <chprintf.constprop.35>
 8005f84:	4a33      	ldr	r2, [pc, #204]	; (8006054 <encode_ssdv+0x964>)
 8005f86:	492d      	ldr	r1, [pc, #180]	; (800603c <encode_ssdv+0x94c>)
 8005f88:	482a      	ldr	r0, [pc, #168]	; (8006034 <encode_ssdv+0x944>)
 8005f8a:	f00c fba9 	bl	80126e0 <chprintf.constprop.35>
 8005f8e:	2339      	movs	r3, #57	; 0x39
 8005f90:	4a33      	ldr	r2, [pc, #204]	; (8006060 <encode_ssdv+0x970>)
 8005f92:	492c      	ldr	r1, [pc, #176]	; (8006044 <encode_ssdv+0x954>)
 8005f94:	4827      	ldr	r0, [pc, #156]	; (8006034 <encode_ssdv+0x944>)
 8005f96:	f00c fba3 	bl	80126e0 <chprintf.constprop.35>
 8005f9a:	492b      	ldr	r1, [pc, #172]	; (8006048 <encode_ssdv+0x958>)
 8005f9c:	4825      	ldr	r0, [pc, #148]	; (8006034 <encode_ssdv+0x944>)
 8005f9e:	f00c fb9f 	bl	80126e0 <chprintf.constprop.35>
 8005fa2:	4622      	mov	r2, r4
 8005fa4:	492f      	ldr	r1, [pc, #188]	; (8006064 <encode_ssdv+0x974>)
 8005fa6:	4823      	ldr	r0, [pc, #140]	; (8006034 <encode_ssdv+0x944>)
 8005fa8:	f00c fb9a 	bl	80126e0 <chprintf.constprop.35>
 8005fac:	4928      	ldr	r1, [pc, #160]	; (8006050 <encode_ssdv+0x960>)
 8005fae:	4821      	ldr	r0, [pc, #132]	; (8006034 <encode_ssdv+0x944>)
 8005fb0:	f00c fb96 	bl	80126e0 <chprintf.constprop.35>
 8005fb4:	481c      	ldr	r0, [pc, #112]	; (8006028 <encode_ssdv+0x938>)
 8005fb6:	f008 ff3b 	bl	800ee30 <chMtxUnlock>
 8005fba:	2139      	movs	r1, #57	; 0x39
 8005fbc:	4828      	ldr	r0, [pc, #160]	; (8006060 <encode_ssdv+0x970>)
 8005fbe:	f009 ffcf 	bl	800ff60 <log_error>

		i++;
	}

	TRACE_INFO("SSDV > %i packets", i);
}
 8005fc2:	f60d 1d5c 	addw	sp, sp, #2396	; 0x95c
 8005fc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		s->state = S_HUFF;
		
		return(SSDV_OK);
	
	case J_DHT:
		s->stbl_len += l;
 8005fca:	f8b4 22cc 	ldrh.w	r2, [r4, #716]	; 0x2cc
 8005fce:	441a      	add	r2, r3
 8005fd0:	f8a4 22cc 	strh.w	r2, [r4, #716]	; 0x2cc
		while(l > 0)
 8005fd4:	2b00      	cmp	r3, #0
 8005fd6:	f43f af05 	beq.w	8005de4 <encode_ssdv+0x6f4>
		{
			int i, j;
			
			switch(d[0])
 8005fda:	782b      	ldrb	r3, [r5, #0]
 8005fdc:	2b11      	cmp	r3, #17
 8005fde:	d80c      	bhi.n	8005ffa <encode_ssdv+0x90a>
 8005fe0:	e8df f003 	tbb	[pc, r3]
 8005fe4:	0b0b1b1e 	.word	0x0b0b1b1e
 8005fe8:	0b0b0b0b 	.word	0x0b0b0b0b
 8005fec:	0b0b0b0b 	.word	0x0b0b0b0b
 8005ff0:	0b0b0b0b 	.word	0x0b0b0b0b
 8005ff4:	0918      	.short	0x0918
			{
			case 0x00: s->sdht[0][0] = d; break;
			case 0x01: s->sdht[0][1] = d; break;
			case 0x10: s->sdht[1][0] = d; break;
			case 0x11: s->sdht[1][1] = d; break;
 8005ff6:	f8c4 52c0 	str.w	r5, [r4, #704]	; 0x2c0
 8005ffa:	462b      	mov	r3, r5
 8005ffc:	f105 0010 	add.w	r0, r5, #16
			}
			
			/* Skip to the next DHT table */
			for(j = 17, i = 1; i <= 16; i++)
 8006000:	2211      	movs	r2, #17
				j += d[i];
 8006002:	f813 1f01 	ldrb.w	r1, [r3, #1]!
			case 0x10: s->sdht[1][0] = d; break;
			case 0x11: s->sdht[1][1] = d; break;
			}
			
			/* Skip to the next DHT table */
			for(j = 17, i = 1; i <= 16; i++)
 8006006:	4283      	cmp	r3, r0
				j += d[i];
 8006008:	440a      	add	r2, r1
			case 0x10: s->sdht[1][0] = d; break;
			case 0x11: s->sdht[1][1] = d; break;
			}
			
			/* Skip to the next DHT table */
			for(j = 17, i = 1; i <= 16; i++)
 800600a:	d1fa      	bne.n	8006002 <encode_ssdv+0x912>
		
		return(SSDV_OK);
	
	case J_DHT:
		s->stbl_len += l;
		while(l > 0)
 800600c:	1ab6      	subs	r6, r6, r2
			/* Skip to the next DHT table */
			for(j = 17, i = 1; i <= 16; i++)
				j += d[i];
			
			l -= j;
			d += j;
 800600e:	4415      	add	r5, r2
		
		return(SSDV_OK);
	
	case J_DHT:
		s->stbl_len += l;
		while(l > 0)
 8006010:	d1e3      	bne.n	8005fda <encode_ssdv+0x8ea>
 8006012:	e6e7      	b.n	8005de4 <encode_ssdv+0x6f4>
			
			switch(d[0])
			{
			case 0x00: s->sdht[0][0] = d; break;
			case 0x01: s->sdht[0][1] = d; break;
			case 0x10: s->sdht[1][0] = d; break;
 8006014:	f8c4 52bc 	str.w	r5, [r4, #700]	; 0x2bc
 8006018:	e7ef      	b.n	8005ffa <encode_ssdv+0x90a>
			int i, j;
			
			switch(d[0])
			{
			case 0x00: s->sdht[0][0] = d; break;
			case 0x01: s->sdht[0][1] = d; break;
 800601a:	f8c4 52b8 	str.w	r5, [r4, #696]	; 0x2b8
 800601e:	e7ec      	b.n	8005ffa <encode_ssdv+0x90a>
		{
			int i, j;
			
			switch(d[0])
			{
			case 0x00: s->sdht[0][0] = d; break;
 8006020:	f8c4 52b4 	str.w	r5, [r4, #692]	; 0x2b4
 8006024:	e7e9      	b.n	8005ffa <encode_ssdv+0x90a>
 8006026:	bf00      	nop
 8006028:	20027b2c 	.word	0x20027b2c
 800602c:	08013c50 	.word	0x08013c50
 8006030:	10624dd3 	.word	0x10624dd3
 8006034:	20027e60 	.word	0x20027e60
 8006038:	08013cfc 	.word	0x08013cfc
 800603c:	08013c5c 	.word	0x08013c5c
 8006040:	0801491f 	.word	0x0801491f
 8006044:	08013c78 	.word	0x08013c78
 8006048:	08013d00 	.word	0x08013d00
 800604c:	0801495c 	.word	0x0801495c
 8006050:	08013cac 	.word	0x08013cac
 8006054:	08013d9c 	.word	0x08013d9c
 8006058:	080149a0 	.word	0x080149a0
 800605c:	d1b71759 	.word	0xd1b71759
 8006060:	08014340 	.word	0x08014340
 8006064:	08014c10 	.word	0x08014c10
	int i;
	
	switch(s->marker)
	{
	case J_SOF0:
		s->width  = (d[3] << 8) | d[4];
 8006068:	78ea      	ldrb	r2, [r5, #3]
 800606a:	792b      	ldrb	r3, [r5, #4]
		s->height = (d[1] << 8) | d[2];
		
		/* Display information about the image... */
		TRACE_INFO("SSDV > Precision: %i", d[0]);
 800606c:	48b7      	ldr	r0, [pc, #732]	; (800634c <encode_ssdv+0xc5c>)
 800606e:	f8df 9318 	ldr.w	r9, [pc, #792]	; 8006388 <encode_ssdv+0xc98>
 8006072:	f8df a2e0 	ldr.w	sl, [pc, #736]	; 8006354 <encode_ssdv+0xc64>
	int i;
	
	switch(s->marker)
	{
	case J_SOF0:
		s->width  = (d[3] << 8) | d[4];
 8006076:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800607a:	80e3      	strh	r3, [r4, #6]
		s->height = (d[1] << 8) | d[2];
 800607c:	786a      	ldrb	r2, [r5, #1]
 800607e:	78ab      	ldrb	r3, [r5, #2]
 8006080:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 8006084:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006088:	8123      	strh	r3, [r4, #8]
		
		/* Display information about the image... */
		TRACE_INFO("SSDV > Precision: %i", d[0]);
 800608a:	f008 ff31 	bl	800eef0 <chMtxLock>
 800608e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006090:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006092:	49af      	ldr	r1, [pc, #700]	; (8006350 <encode_ssdv+0xc60>)
 8006094:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
 8006098:	4648      	mov	r0, r9
 800609a:	fb08 f303 	mul.w	r3, r8, r3
 800609e:	fba0 0303 	umull	r0, r3, r0, r3
 80060a2:	48ac      	ldr	r0, [pc, #688]	; (8006354 <encode_ssdv+0xc64>)
 80060a4:	0b9b      	lsrs	r3, r3, #14
 80060a6:	fba0 0e03 	umull	r0, lr, r0, r3
 80060aa:	4648      	mov	r0, r9
 80060ac:	fba0 0202 	umull	r0, r2, r0, r2
 80060b0:	ea4f 109e 	mov.w	r0, lr, lsr #6
 80060b4:	fb08 3310 	mls	r3, r8, r0, r3
 80060b8:	0b92      	lsrs	r2, r2, #14
 80060ba:	48a7      	ldr	r0, [pc, #668]	; (8006358 <encode_ssdv+0xc68>)
 80060bc:	f00c fb10 	bl	80126e0 <chprintf.constprop.35>
 80060c0:	4aa6      	ldr	r2, [pc, #664]	; (800635c <encode_ssdv+0xc6c>)
 80060c2:	49a7      	ldr	r1, [pc, #668]	; (8006360 <encode_ssdv+0xc70>)
 80060c4:	48a4      	ldr	r0, [pc, #656]	; (8006358 <encode_ssdv+0xc68>)
 80060c6:	f00c fb0b 	bl	80126e0 <chprintf.constprop.35>
 80060ca:	f240 238f 	movw	r3, #655	; 0x28f
 80060ce:	4aa5      	ldr	r2, [pc, #660]	; (8006364 <encode_ssdv+0xc74>)
 80060d0:	49a5      	ldr	r1, [pc, #660]	; (8006368 <encode_ssdv+0xc78>)
 80060d2:	48a1      	ldr	r0, [pc, #644]	; (8006358 <encode_ssdv+0xc68>)
 80060d4:	f00c fb04 	bl	80126e0 <chprintf.constprop.35>
 80060d8:	49a4      	ldr	r1, [pc, #656]	; (800636c <encode_ssdv+0xc7c>)
 80060da:	489f      	ldr	r0, [pc, #636]	; (8006358 <encode_ssdv+0xc68>)
 80060dc:	f00c fb00 	bl	80126e0 <chprintf.constprop.35>
 80060e0:	782a      	ldrb	r2, [r5, #0]
 80060e2:	49a3      	ldr	r1, [pc, #652]	; (8006370 <encode_ssdv+0xc80>)
 80060e4:	489c      	ldr	r0, [pc, #624]	; (8006358 <encode_ssdv+0xc68>)
 80060e6:	f00c fafb 	bl	80126e0 <chprintf.constprop.35>
 80060ea:	49a2      	ldr	r1, [pc, #648]	; (8006374 <encode_ssdv+0xc84>)
 80060ec:	489a      	ldr	r0, [pc, #616]	; (8006358 <encode_ssdv+0xc68>)
 80060ee:	f00c faf7 	bl	80126e0 <chprintf.constprop.35>
 80060f2:	4896      	ldr	r0, [pc, #600]	; (800634c <encode_ssdv+0xc5c>)
 80060f4:	f008 fe9c 	bl	800ee30 <chMtxUnlock>
		TRACE_INFO("SSDV > Resolution: %ix%i", s->width, s->height);
 80060f8:	4894      	ldr	r0, [pc, #592]	; (800634c <encode_ssdv+0xc5c>)
 80060fa:	f008 fef9 	bl	800eef0 <chMtxLock>
 80060fe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006100:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006102:	4993      	ldr	r1, [pc, #588]	; (8006350 <encode_ssdv+0xc60>)
 8006104:	4648      	mov	r0, r9
 8006106:	fb08 f303 	mul.w	r3, r8, r3
 800610a:	fba0 0303 	umull	r0, r3, r0, r3
 800610e:	4891      	ldr	r0, [pc, #580]	; (8006354 <encode_ssdv+0xc64>)
 8006110:	0b9b      	lsrs	r3, r3, #14
 8006112:	fba0 0e03 	umull	r0, lr, r0, r3
 8006116:	4648      	mov	r0, r9
 8006118:	fba0 0202 	umull	r0, r2, r0, r2
 800611c:	ea4f 109e 	mov.w	r0, lr, lsr #6
 8006120:	fb08 3310 	mls	r3, r8, r0, r3
 8006124:	0b92      	lsrs	r2, r2, #14
 8006126:	488c      	ldr	r0, [pc, #560]	; (8006358 <encode_ssdv+0xc68>)
 8006128:	f00c fada 	bl	80126e0 <chprintf.constprop.35>
 800612c:	4a8b      	ldr	r2, [pc, #556]	; (800635c <encode_ssdv+0xc6c>)
 800612e:	498c      	ldr	r1, [pc, #560]	; (8006360 <encode_ssdv+0xc70>)
 8006130:	4889      	ldr	r0, [pc, #548]	; (8006358 <encode_ssdv+0xc68>)
 8006132:	f00c fad5 	bl	80126e0 <chprintf.constprop.35>
 8006136:	f44f 7324 	mov.w	r3, #656	; 0x290
 800613a:	4a8a      	ldr	r2, [pc, #552]	; (8006364 <encode_ssdv+0xc74>)
 800613c:	498a      	ldr	r1, [pc, #552]	; (8006368 <encode_ssdv+0xc78>)
 800613e:	4886      	ldr	r0, [pc, #536]	; (8006358 <encode_ssdv+0xc68>)
 8006140:	f00c face 	bl	80126e0 <chprintf.constprop.35>
 8006144:	4989      	ldr	r1, [pc, #548]	; (800636c <encode_ssdv+0xc7c>)
 8006146:	4884      	ldr	r0, [pc, #528]	; (8006358 <encode_ssdv+0xc68>)
 8006148:	f00c faca 	bl	80126e0 <chprintf.constprop.35>
 800614c:	8923      	ldrh	r3, [r4, #8]
 800614e:	88e2      	ldrh	r2, [r4, #6]
 8006150:	4989      	ldr	r1, [pc, #548]	; (8006378 <encode_ssdv+0xc88>)
 8006152:	4881      	ldr	r0, [pc, #516]	; (8006358 <encode_ssdv+0xc68>)
 8006154:	f00c fac4 	bl	80126e0 <chprintf.constprop.35>
 8006158:	4986      	ldr	r1, [pc, #536]	; (8006374 <encode_ssdv+0xc84>)
 800615a:	487f      	ldr	r0, [pc, #508]	; (8006358 <encode_ssdv+0xc68>)
 800615c:	f00c fac0 	bl	80126e0 <chprintf.constprop.35>
 8006160:	487a      	ldr	r0, [pc, #488]	; (800634c <encode_ssdv+0xc5c>)
 8006162:	f008 fe65 	bl	800ee30 <chMtxUnlock>
		TRACE_INFO("SSDV > Components: %i", d[5]);
 8006166:	4879      	ldr	r0, [pc, #484]	; (800634c <encode_ssdv+0xc5c>)
 8006168:	f008 fec2 	bl	800eef0 <chMtxLock>
 800616c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800616e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006170:	4977      	ldr	r1, [pc, #476]	; (8006350 <encode_ssdv+0xc60>)
 8006172:	4648      	mov	r0, r9
 8006174:	fb08 f303 	mul.w	r3, r8, r3
 8006178:	fba0 0303 	umull	r0, r3, r0, r3
 800617c:	4875      	ldr	r0, [pc, #468]	; (8006354 <encode_ssdv+0xc64>)
 800617e:	0b9b      	lsrs	r3, r3, #14
 8006180:	fba0 0e03 	umull	r0, lr, r0, r3
 8006184:	4648      	mov	r0, r9
 8006186:	fba0 0202 	umull	r0, r2, r0, r2
 800618a:	ea4f 109e 	mov.w	r0, lr, lsr #6
 800618e:	fb08 3310 	mls	r3, r8, r0, r3
 8006192:	0b92      	lsrs	r2, r2, #14
 8006194:	4870      	ldr	r0, [pc, #448]	; (8006358 <encode_ssdv+0xc68>)
 8006196:	f00c faa3 	bl	80126e0 <chprintf.constprop.35>
 800619a:	4a70      	ldr	r2, [pc, #448]	; (800635c <encode_ssdv+0xc6c>)
 800619c:	4970      	ldr	r1, [pc, #448]	; (8006360 <encode_ssdv+0xc70>)
 800619e:	486e      	ldr	r0, [pc, #440]	; (8006358 <encode_ssdv+0xc68>)
 80061a0:	f00c fa9e 	bl	80126e0 <chprintf.constprop.35>
 80061a4:	f240 2391 	movw	r3, #657	; 0x291
 80061a8:	4a6e      	ldr	r2, [pc, #440]	; (8006364 <encode_ssdv+0xc74>)
 80061aa:	496f      	ldr	r1, [pc, #444]	; (8006368 <encode_ssdv+0xc78>)
 80061ac:	486a      	ldr	r0, [pc, #424]	; (8006358 <encode_ssdv+0xc68>)
 80061ae:	f00c fa97 	bl	80126e0 <chprintf.constprop.35>
 80061b2:	496e      	ldr	r1, [pc, #440]	; (800636c <encode_ssdv+0xc7c>)
 80061b4:	4868      	ldr	r0, [pc, #416]	; (8006358 <encode_ssdv+0xc68>)
 80061b6:	f00c fa93 	bl	80126e0 <chprintf.constprop.35>
 80061ba:	796a      	ldrb	r2, [r5, #5]
 80061bc:	496f      	ldr	r1, [pc, #444]	; (800637c <encode_ssdv+0xc8c>)
 80061be:	4866      	ldr	r0, [pc, #408]	; (8006358 <encode_ssdv+0xc68>)
 80061c0:	f00c fa8e 	bl	80126e0 <chprintf.constprop.35>
 80061c4:	496b      	ldr	r1, [pc, #428]	; (8006374 <encode_ssdv+0xc84>)
 80061c6:	4864      	ldr	r0, [pc, #400]	; (8006358 <encode_ssdv+0xc68>)
 80061c8:	f00c fa8a 	bl	80126e0 <chprintf.constprop.35>
 80061cc:	485f      	ldr	r0, [pc, #380]	; (800634c <encode_ssdv+0xc5c>)
 80061ce:	f008 fe2f 	bl	800ee30 <chMtxUnlock>
		
		/* The image must have a precision of 8 */
		if(d[0] != 8)
 80061d2:	782b      	ldrb	r3, [r5, #0]
 80061d4:	2b08      	cmp	r3, #8
 80061d6:	f000 8496 	beq.w	8006b06 <encode_ssdv+0x1416>
		{
			TRACE_ERROR("SSDV > The image must have a precision of 8");
 80061da:	485c      	ldr	r0, [pc, #368]	; (800634c <encode_ssdv+0xc5c>)
 80061dc:	f008 fe88 	bl	800eef0 <chMtxLock>
 80061e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80061e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80061e4:	495a      	ldr	r1, [pc, #360]	; (8006350 <encode_ssdv+0xc60>)
 80061e6:	485c      	ldr	r0, [pc, #368]	; (8006358 <encode_ssdv+0xc68>)
 80061e8:	fb08 f303 	mul.w	r3, r8, r3
 80061ec:	fba9 4303 	umull	r4, r3, r9, r3
 80061f0:	0b9b      	lsrs	r3, r3, #14
 80061f2:	fbaa 5403 	umull	r5, r4, sl, r3
 80061f6:	09a4      	lsrs	r4, r4, #6
 80061f8:	fba9 5202 	umull	r5, r2, r9, r2
 80061fc:	fb08 3314 	mls	r3, r8, r4, r3
 8006200:	0b92      	lsrs	r2, r2, #14
 8006202:	f00c fa6d 	bl	80126e0 <chprintf.constprop.35>
 8006206:	4a5e      	ldr	r2, [pc, #376]	; (8006380 <encode_ssdv+0xc90>)
 8006208:	4955      	ldr	r1, [pc, #340]	; (8006360 <encode_ssdv+0xc70>)
 800620a:	4853      	ldr	r0, [pc, #332]	; (8006358 <encode_ssdv+0xc68>)
 800620c:	f00c fa68 	bl	80126e0 <chprintf.constprop.35>
 8006210:	f240 2396 	movw	r3, #662	; 0x296
 8006214:	4a53      	ldr	r2, [pc, #332]	; (8006364 <encode_ssdv+0xc74>)
 8006216:	4954      	ldr	r1, [pc, #336]	; (8006368 <encode_ssdv+0xc78>)
 8006218:	484f      	ldr	r0, [pc, #316]	; (8006358 <encode_ssdv+0xc68>)
 800621a:	f00c fa61 	bl	80126e0 <chprintf.constprop.35>
 800621e:	4953      	ldr	r1, [pc, #332]	; (800636c <encode_ssdv+0xc7c>)
 8006220:	484d      	ldr	r0, [pc, #308]	; (8006358 <encode_ssdv+0xc68>)
 8006222:	f00c fa5d 	bl	80126e0 <chprintf.constprop.35>
 8006226:	4957      	ldr	r1, [pc, #348]	; (8006384 <encode_ssdv+0xc94>)
 8006228:	484b      	ldr	r0, [pc, #300]	; (8006358 <encode_ssdv+0xc68>)
 800622a:	f00c fa59 	bl	80126e0 <chprintf.constprop.35>
 800622e:	4951      	ldr	r1, [pc, #324]	; (8006374 <encode_ssdv+0xc84>)
 8006230:	4849      	ldr	r0, [pc, #292]	; (8006358 <encode_ssdv+0xc68>)
 8006232:	f00c fa55 	bl	80126e0 <chprintf.constprop.35>
 8006236:	4845      	ldr	r0, [pc, #276]	; (800634c <encode_ssdv+0xc5c>)
 8006238:	f008 fdfa 	bl	800ee30 <chMtxUnlock>
 800623c:	f240 2196 	movw	r1, #662	; 0x296
 8006240:	4848      	ldr	r0, [pc, #288]	; (8006364 <encode_ssdv+0xc74>)
 8006242:	f009 fe8d 	bl	800ff60 <log_error>
 8006246:	e67f      	b.n	8005f48 <encode_ssdv+0x858>
 8006248:	f894 2049 	ldrb.w	r2, [r4, #73]	; 0x49
	return(SSDV_OK);
}

static char ssdv_process(ssdv_t *s)
{
	if(s->state == S_HUFF)
 800624c:	2a03      	cmp	r2, #3
 800624e:	f47f ab45 	bne.w	80058dc <encode_ssdv+0x1ec>
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	/* Select the appropriate huffman table */
	dht = SDHT;
 8006252:	f894 7059 	ldrb.w	r7, [r4, #89]	; 0x59
 8006256:	f894 b056 	ldrb.w	fp, [r4, #86]	; 0x56
 800625a:	f894 e030 	ldrb.w	lr, [r4, #48]	; 0x30
		if(cw > s->worklen) return(SSDV_FEED_ME);
		
		/* Compare against each code 'cw' bits wide */
		for(n = dht[cw]; n > 0; n--)
		{
			if(s->workbits >> (s->worklen - cw) == code)
 800625e:	f8d4 902c 	ldr.w	r9, [r4, #44]	; 0x2c
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	/* Select the appropriate huffman table */
	dht = SDHT;
 8006262:	1c3a      	adds	r2, r7, #0
 8006264:	bf18      	it	ne
 8006266:	2201      	movne	r2, #1
 8006268:	0052      	lsls	r2, r2, #1
 800626a:	f1bb 0f00 	cmp.w	fp, #0
 800626e:	bf18      	it	ne
 8006270:	3201      	addne	r2, #1
 8006272:	eb04 0282 	add.w	r2, r4, r2, lsl #2
	return(callsign);
}

static inline char jpeg_dht_lookup(ssdv_t *s, uint8_t *symbol, uint8_t *width)
{
	uint16_t code = 0;
 8006276:	2300      	movs	r3, #0
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	/* Select the appropriate huffman table */
	dht = SDHT;
 8006278:	f8d2 a2b4 	ldr.w	sl, [r2, #692]	; 0x2b4
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 800627c:	f04f 0801 	mov.w	r8, #1
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	/* Select the appropriate huffman table */
	dht = SDHT;
	ss = &dht[17];
 8006280:	f10a 0211 	add.w	r2, sl, #17
 8006284:	46d4      	mov	ip, sl
	
	for(cw = 1; cw <= 16; cw++)
	{
		/* Got enough bits? */
		if(cw > s->worklen) return(SSDV_FEED_ME);
 8006286:	45f0      	cmp	r8, lr
 8006288:	f63f aae8 	bhi.w	800585c <encode_ssdv+0x16c>
		
		/* Compare against each code 'cw' bits wide */
		for(n = dht[cw]; n > 0; n--)
 800628c:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
 8006290:	b1a1      	cbz	r1, 80062bc <encode_ssdv+0xbcc>
		{
			if(s->workbits >> (s->worklen - cw) == code)
 8006292:	ebcc 000e 	rsb	r0, ip, lr
 8006296:	4450      	add	r0, sl
 8006298:	fa29 f000 	lsr.w	r0, r9, r0
 800629c:	4283      	cmp	r3, r0
 800629e:	f000 811c 	beq.w	80064da <encode_ssdv+0xdea>
 80062a2:	3901      	subs	r1, #1
 80062a4:	b2c9      	uxtb	r1, r1
 80062a6:	3101      	adds	r1, #1
 80062a8:	4411      	add	r1, r2
 80062aa:	e002      	b.n	80062b2 <encode_ssdv+0xbc2>
 80062ac:	4283      	cmp	r3, r0
 80062ae:	f000 8114 	beq.w	80064da <encode_ssdv+0xdea>
				/* Found a match */
				*symbol = *ss;
				*width = cw;
				return(SSDV_OK);
			}
			ss++; code++;
 80062b2:	3201      	adds	r2, #1
 80062b4:	3301      	adds	r3, #1
	{
		/* Got enough bits? */
		if(cw > s->worklen) return(SSDV_FEED_ME);
		
		/* Compare against each code 'cw' bits wide */
		for(n = dht[cw]; n > 0; n--)
 80062b6:	428a      	cmp	r2, r1
				/* Found a match */
				*symbol = *ss;
				*width = cw;
				return(SSDV_OK);
			}
			ss++; code++;
 80062b8:	b29b      	uxth	r3, r3
	{
		/* Got enough bits? */
		if(cw > s->worklen) return(SSDV_FEED_ME);
		
		/* Compare against each code 'cw' bits wide */
		for(n = dht[cw]; n > 0; n--)
 80062ba:	d1f7      	bne.n	80062ac <encode_ssdv+0xbbc>
	
	/* Select the appropriate huffman table */
	dht = SDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 80062bc:	f108 0801 	add.w	r8, r8, #1
 80062c0:	fa5f f888 	uxtb.w	r8, r8
				return(SSDV_OK);
			}
			ss++; code++;
		}
		
		code <<= 1;
 80062c4:	005b      	lsls	r3, r3, #1
	
	/* Select the appropriate huffman table */
	dht = SDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 80062c6:	f1b8 0f11 	cmp.w	r8, #17
				return(SSDV_OK);
			}
			ss++; code++;
		}
		
		code <<= 1;
 80062ca:	b29b      	uxth	r3, r3
	
	/* Select the appropriate huffman table */
	dht = SDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 80062cc:	d1db      	bne.n	8006286 <encode_ssdv+0xb96>
				return(SSDV_OK);
			}
			else if(r != SSDV_FEED_ME)
			{
				/* An error occured */
				TRACE_ERROR("SSDV > ssdv_process() failed: %i", r);
 80062ce:	481f      	ldr	r0, [pc, #124]	; (800634c <encode_ssdv+0xc5c>)
 80062d0:	4e2d      	ldr	r6, [pc, #180]	; (8006388 <encode_ssdv+0xc98>)
 80062d2:	f008 fe0d 	bl	800eef0 <chMtxLock>
 80062d6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80062da:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 80062de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80062e0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80062e2:	4b1c      	ldr	r3, [pc, #112]	; (8006354 <encode_ssdv+0xc64>)
 80062e4:	491a      	ldr	r1, [pc, #104]	; (8006350 <encode_ssdv+0xc60>)
 80062e6:	481c      	ldr	r0, [pc, #112]	; (8006358 <encode_ssdv+0xc68>)
 80062e8:	fb05 f404 	mul.w	r4, r5, r4
 80062ec:	fba6 7404 	umull	r7, r4, r6, r4
 80062f0:	0ba4      	lsrs	r4, r4, #14
 80062f2:	fba3 7304 	umull	r7, r3, r3, r4
 80062f6:	fba6 6202 	umull	r6, r2, r6, r2
 80062fa:	099b      	lsrs	r3, r3, #6
 80062fc:	fb05 4313 	mls	r3, r5, r3, r4
 8006300:	0b92      	lsrs	r2, r2, #14
 8006302:	f00c f9ed 	bl	80126e0 <chprintf.constprop.35>
 8006306:	4a1e      	ldr	r2, [pc, #120]	; (8006380 <encode_ssdv+0xc90>)
 8006308:	4915      	ldr	r1, [pc, #84]	; (8006360 <encode_ssdv+0xc70>)
 800630a:	4813      	ldr	r0, [pc, #76]	; (8006358 <encode_ssdv+0xc68>)
 800630c:	f00c f9e8 	bl	80126e0 <chprintf.constprop.35>
 8006310:	f44f 737c 	mov.w	r3, #1008	; 0x3f0
 8006314:	4a13      	ldr	r2, [pc, #76]	; (8006364 <encode_ssdv+0xc74>)
 8006316:	4914      	ldr	r1, [pc, #80]	; (8006368 <encode_ssdv+0xc78>)
 8006318:	480f      	ldr	r0, [pc, #60]	; (8006358 <encode_ssdv+0xc68>)
 800631a:	f00c f9e1 	bl	80126e0 <chprintf.constprop.35>
 800631e:	4913      	ldr	r1, [pc, #76]	; (800636c <encode_ssdv+0xc7c>)
 8006320:	480d      	ldr	r0, [pc, #52]	; (8006358 <encode_ssdv+0xc68>)
 8006322:	f00c f9dd 	bl	80126e0 <chprintf.constprop.35>
 8006326:	22ff      	movs	r2, #255	; 0xff
 8006328:	4918      	ldr	r1, [pc, #96]	; (800638c <encode_ssdv+0xc9c>)
 800632a:	480b      	ldr	r0, [pc, #44]	; (8006358 <encode_ssdv+0xc68>)
 800632c:	f00c f9d8 	bl	80126e0 <chprintf.constprop.35>
 8006330:	4910      	ldr	r1, [pc, #64]	; (8006374 <encode_ssdv+0xc84>)
 8006332:	4809      	ldr	r0, [pc, #36]	; (8006358 <encode_ssdv+0xc68>)
 8006334:	f00c f9d4 	bl	80126e0 <chprintf.constprop.35>
 8006338:	4804      	ldr	r0, [pc, #16]	; (800634c <encode_ssdv+0xc5c>)
 800633a:	f008 fd79 	bl	800ee30 <chMtxUnlock>
 800633e:	f44f 717c 	mov.w	r1, #1008	; 0x3f0
 8006342:	4808      	ldr	r0, [pc, #32]	; (8006364 <encode_ssdv+0xc74>)
 8006344:	f009 fe0c 	bl	800ff60 <log_error>
 8006348:	e5fe      	b.n	8005f48 <encode_ssdv+0x858>
 800634a:	bf00      	nop
 800634c:	20027b2c 	.word	0x20027b2c
 8006350:	08013c50 	.word	0x08013c50
 8006354:	10624dd3 	.word	0x10624dd3
 8006358:	20027e60 	.word	0x20027e60
 800635c:	08013cfc 	.word	0x08013cfc
 8006360:	08013c5c 	.word	0x08013c5c
 8006364:	0801491f 	.word	0x0801491f
 8006368:	08013c78 	.word	0x08013c78
 800636c:	08013d00 	.word	0x08013d00
 8006370:	08014928 	.word	0x08014928
 8006374:	08013cac 	.word	0x08013cac
 8006378:	08014940 	.word	0x08014940
 800637c:	0801495c 	.word	0x0801495c
 8006380:	08013d9c 	.word	0x08013d9c
 8006384:	08014974 	.word	0x08014974
 8006388:	d1b71759 	.word	0xd1b71759
 800638c:	08014ca8 	.word	0x08014ca8
	else if(s->state == S_INT)
	{
		int i;
		
		/* Not enough bits yet? */
		if(s->worklen < s->needbits) return(SSDV_FEED_ME);
 8006390:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 8006394:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8006398:	429a      	cmp	r2, r3
 800639a:	f4ff aa5f 	bcc.w	800585c <encode_ssdv+0x16c>
		
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
 800639e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
		
		if(s->acpart == 0) /* DC */
 80063a0:	f894 c059 	ldrb.w	ip, [r4, #89]	; 0x59
		
		/* Not enough bits yet? */
		if(s->worklen < s->needbits) return(SSDV_FEED_ME);
		
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
 80063a4:	1ad2      	subs	r2, r2, r3
	return(SSDV_ERROR);
}

static inline int jpeg_int(int bits, int width)
{
	int b = (1 << width) - 1;
 80063a6:	fa05 f303 	lsl.w	r3, r5, r3
		
		/* Not enough bits yet? */
		if(s->worklen < s->needbits) return(SSDV_FEED_ME);
		
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
 80063aa:	fa21 f702 	lsr.w	r7, r1, r2
	return(SSDV_ERROR);
}

static inline int jpeg_int(int bits, int width)
{
	int b = (1 << width) - 1;
 80063ae:	3b01      	subs	r3, #1
	if(bits <= b >> 1) bits = -(bits ^ b);
 80063b0:	ebb7 0f63 	cmp.w	r7, r3, asr #1
 80063b4:	bfdc      	itt	le
 80063b6:	405f      	eorle	r7, r3
 80063b8:	427f      	negle	r7, r7
		if(s->worklen < s->needbits) return(SSDV_FEED_ME);
		
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
		
		if(s->acpart == 0) /* DC */
 80063ba:	f1bc 0f00 	cmp.w	ip, #0
 80063be:	f040 80c4 	bne.w	800654a <encode_ssdv+0xe5a>
		{
			if(s->reset_mcu == s->mcu_id && (s->mcupart == 0 || s->mcupart >= s->ycparts))
 80063c2:	8ae3      	ldrh	r3, [r4, #22]
 80063c4:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 80063c6:	429a      	cmp	r2, r3
 80063c8:	f000 8169 	beq.w	800669e <encode_ssdv+0xfae>
					s->dc[s->component] = i;
				}
			}
			else
			{
				if(s->mode == S_DECODING)
 80063cc:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
 80063d0:	2b01      	cmp	r3, #1
				{
					s->dc[s->component] += UADJ(i);
 80063d2:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
					s->dc[s->component] = i;
				}
			}
			else
			{
				if(s->mode == S_DECODING)
 80063d6:	f000 81bc 	beq.w	8006752 <encode_ssdv+0x1062>
					ssdv_out_jpeg_int(s, 0, i);
				}
				else
				{
					/* Output relative DC value */
					s->dc[s->component] += UADJ(i);
 80063da:	1c1a      	adds	r2, r3, #0
 80063dc:	bf18      	it	ne
 80063de:	2201      	movne	r2, #1
 80063e0:	f102 01b0 	add.w	r1, r2, #176	; 0xb0
 80063e4:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 80063e8:	f502 72a0 	add.w	r2, r2, #320	; 0x140
 80063ec:	6848      	ldr	r0, [r1, #4]
 80063ee:	f854 e022 	ldr.w	lr, [r4, r2, lsl #2]
 80063f2:	7841      	ldrb	r1, [r0, #1]
 80063f4:	f89e 8001 	ldrb.w	r8, [lr, #1]
 80063f8:	f103 0216 	add.w	r2, r3, #22
 80063fc:	eb04 0c82 	add.w	ip, r4, r2, lsl #2
 8006400:	4588      	cmp	r8, r1
 8006402:	f8dc c004 	ldr.w	ip, [ip, #4]
 8006406:	bf18      	it	ne
 8006408:	434f      	mulne	r7, r1
 800640a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800640e:	4467      	add	r7, ip
 8006410:	6057      	str	r7, [r2, #4]
					
					/* Calculate closest adjusted DC value */
					i = AADJ(s->dc[s->component]);
 8006412:	f89e 2001 	ldrb.w	r2, [lr, #1]
 8006416:	7841      	ldrb	r1, [r0, #1]
 8006418:	4291      	cmp	r1, r2
 800641a:	d00d      	beq.n	8006438 <encode_ssdv+0xd48>
#define BADJ(i) (SDQT == DDQT ? (i) : irdiv(i * SDQT, DDQT))

/* Integer-only division with rounding */
static int irdiv(int i, int div)
{
	i = i * 2 / div;
 800641c:	007f      	lsls	r7, r7, #1
 800641e:	fb97 f7f2 	sdiv	r7, r7, r2
	if(i & 1) i += (i > 0 ? 1 : -1);
 8006422:	07f9      	lsls	r1, r7, #31
 8006424:	d505      	bpl.n	8006432 <encode_ssdv+0xd42>
 8006426:	2f00      	cmp	r7, #0
 8006428:	bfd4      	ite	le
 800642a:	f04f 32ff 	movle.w	r2, #4294967295
 800642e:	2201      	movgt	r2, #1
 8006430:	4417      	add	r7, r2
	return(i / 2);
 8006432:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 8006436:	107f      	asrs	r7, r7, #1
					/* Output relative DC value */
					s->dc[s->component] += UADJ(i);
					
					/* Calculate closest adjusted DC value */
					i = AADJ(s->dc[s->component]);
					ssdv_out_jpeg_int(s, 0, i - s->adc[s->component]);
 8006438:	331a      	adds	r3, #26
 800643a:	2100      	movs	r1, #0
 800643c:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 8006440:	4620      	mov	r0, r4
 8006442:	1aba      	subs	r2, r7, r2
 8006444:	f009 fdcc 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
					s->adc[s->component] = i;
 8006448:	f894 1056 	ldrb.w	r1, [r4, #86]	; 0x56
 800644c:	f894 c059 	ldrb.w	ip, [r4, #89]	; 0x59
 8006450:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 8006454:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8006458:	311a      	adds	r1, #26
 800645a:	f10c 0e01 	add.w	lr, ip, #1
 800645e:	f844 7021 	str.w	r7, [r4, r1, lsl #2]
 8006462:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8006464:	1ad2      	subs	r2, r2, r3
		
		/* Next bits are a huffman code */
		s->state = S_HUFF;
		
		/* Clear processed bits */
		s->worklen -= s->needbits;
 8006466:	b2d3      	uxtb	r3, r2
		s->workbits &= (1 << s->worklen) - 1;
 8006468:	fa05 f203 	lsl.w	r2, r5, r3
 800646c:	3a01      	subs	r2, #1
 800646e:	400a      	ands	r2, r1
				else s->accrle += s->acrle + 1;
			}
		}
		
		/* Next AC part to expect */
		s->acpart++;
 8006470:	fa5f f78e 	uxtb.w	r7, lr
		
		/* Next bits are a huffman code */
		s->state = S_HUFF;
 8006474:	2103      	movs	r1, #3
		
		/* Clear processed bits */
		s->worklen -= s->needbits;
 8006476:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
		s->workbits &= (1 << s->worklen) - 1;
 800647a:	62e2      	str	r2, [r4, #44]	; 0x2c
				else s->accrle += s->acrle + 1;
			}
		}
		
		/* Next AC part to expect */
		s->acpart++;
 800647c:	f884 7059 	strb.w	r7, [r4, #89]	; 0x59
		
		/* Next bits are a huffman code */
		s->state = S_HUFF;
 8006480:	f884 1049 	strb.w	r1, [r4, #73]	; 0x49
 8006484:	f7ff ba2f 	b.w	80058e6 <encode_ssdv+0x1f6>
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
			s->mcu_id++;
 8006488:	8ae3      	ldrh	r3, [r4, #22]
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
 800648a:	8b22      	ldrh	r2, [r4, #24]
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
			s->mcu_id++;
 800648c:	3301      	adds	r3, #1
 800648e:	b29b      	uxth	r3, r3
	if(s->acpart >= 64)
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
 8006490:	2100      	movs	r1, #0
			s->mcu_id++;
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
 8006492:	429a      	cmp	r2, r3
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
			s->mcu_id++;
 8006494:	82e3      	strh	r3, [r4, #22]
	if(s->acpart >= 64)
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
 8006496:	f884 1058 	strb.w	r1, [r4, #88]	; 0x58
			s->mcu_id++;
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
 800649a:	f240 80a7 	bls.w	80065ec <encode_ssdv+0xefc>
				ssdv_outbits_sync(s);
				return(SSDV_EOI);
			}
			
			/* Set the packet MCU marker - encoder only */
			if(s->mode == S_ENCODING && s->packet_mcu_id == 0xFFFF)
 800649e:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 80064a2:	2a00      	cmp	r2, #0
 80064a4:	f040 80e9 	bne.w	800667a <encode_ssdv+0xf8a>
 80064a8:	8b62      	ldrh	r2, [r4, #26]
 80064aa:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80064ae:	429a      	cmp	r2, r3
 80064b0:	f000 81bf 	beq.w	8006832 <encode_ssdv+0x1142>
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
				s->workbits = s->worklen = 0;
			
			/* Test for a reset marker */
			if(s->dri > 0 && s->mcu_id > 0 && s->mcu_id % s->dri == 0)
 80064b4:	f8b4 3076 	ldrh.w	r3, [r4, #118]	; 0x76
 80064b8:	b14b      	cbz	r3, 80064ce <encode_ssdv+0xdde>
 80064ba:	8ae1      	ldrh	r1, [r4, #22]
 80064bc:	b139      	cbz	r1, 80064ce <encode_ssdv+0xdde>
 80064be:	fbb1 f2f3 	udiv	r2, r1, r3
 80064c2:	fb03 1312 	mls	r3, r3, r2, r1
 80064c6:	b29b      	uxth	r3, r3
 80064c8:	2b00      	cmp	r3, #0
 80064ca:	f43f ac8c 	beq.w	8005de6 <encode_ssdv+0x6f6>
 80064ce:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 80064d2:	f894 2057 	ldrb.w	r2, [r4, #87]	; 0x57
 80064d6:	f7ff ba14 	b.w	8005902 <encode_ssdv+0x212>
		for(n = dht[cw]; n > 0; n--)
		{
			if(s->workbits >> (s->worklen - cw) == code)
			{
				/* Found a match */
				*symbol = *ss;
 80064da:	7812      	ldrb	r2, [r2, #0]
		
		/* Lookup the code, return if error or not enough bits yet */
		if((r = jpeg_dht_lookup(s, &symbol, &width)) != SSDV_OK)
			return(r);
		
		if(s->acpart == 0) /* DC */
 80064dc:	2f00      	cmp	r7, #0
 80064de:	f040 80a7 	bne.w	8006630 <encode_ssdv+0xf40>
		{
			if(symbol == 0x00)
 80064e2:	2a00      	cmp	r2, #0
 80064e4:	f040 80d5 	bne.w	8006692 <encode_ssdv+0xfa2>
			{
				/* No change in DC from last block */
				if(s->reset_mcu == s->mcu_id && (s->mcupart == 0 || s->mcupart >= s->ycparts))
 80064e8:	8ae3      	ldrh	r3, [r4, #22]
 80064ea:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 80064ec:	429a      	cmp	r2, r3
 80064ee:	f040 8150 	bne.w	8006792 <encode_ssdv+0x10a2>
 80064f2:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 80064f6:	b123      	cbz	r3, 8006502 <encode_ssdv+0xe12>
 80064f8:	f894 2057 	ldrb.w	r2, [r4, #87]	; 0x57
 80064fc:	429a      	cmp	r2, r3
 80064fe:	f200 8148 	bhi.w	8006792 <encode_ssdv+0x10a2>
				{
					if(s->mode == S_ENCODING) ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
 8006502:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
 8006506:	2900      	cmp	r1, #0
 8006508:	f040 81b7 	bne.w	800687a <encode_ssdv+0x118a>
 800650c:	f10b 0b1a 	add.w	fp, fp, #26
 8006510:	4620      	mov	r0, r4
 8006512:	f854 202b 	ldr.w	r2, [r4, fp, lsl #2]
 8006516:	f009 fd63 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
					}
				}
				else ssdv_out_jpeg_int(s, 0, 0);
				
				/* skip to the next AC part immediately */
				s->acpart++;
 800651a:	f894 7059 	ldrb.w	r7, [r4, #89]	; 0x59
 800651e:	f894 e030 	ldrb.w	lr, [r4, #48]	; 0x30
 8006522:	f8d4 902c 	ldr.w	r9, [r4, #44]	; 0x2c
 8006526:	3701      	adds	r7, #1
 8006528:	b2ff      	uxtb	r7, r7
 800652a:	f884 7059 	strb.w	r7, [r4, #89]	; 0x59
				s->needbits = symbol & 0x0F;
			}
		}
		
		/* Clear processed bits */
		s->worklen -= width;
 800652e:	ebc8 0e0e 	rsb	lr, r8, lr
 8006532:	fa5f fe8e 	uxtb.w	lr, lr
		s->workbits &= (1 << s->worklen) - 1;
 8006536:	fa05 f30e 	lsl.w	r3, r5, lr
 800653a:	3b01      	subs	r3, #1
 800653c:	ea03 0309 	and.w	r3, r3, r9
				s->needbits = symbol & 0x0F;
			}
		}
		
		/* Clear processed bits */
		s->worklen -= width;
 8006540:	f884 e030 	strb.w	lr, [r4, #48]	; 0x30
		s->workbits &= (1 << s->worklen) - 1;
 8006544:	62e3      	str	r3, [r4, #44]	; 0x2c
 8006546:	f7ff b9ce 	b.w	80058e6 <encode_ssdv+0x1f6>
				}
			}
		}
		else /* AC */
		{
			if((i = BADJ(i)))
 800654a:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
 800654e:	3300      	adds	r3, #0
 8006550:	bf18      	it	ne
 8006552:	2301      	movne	r3, #1
 8006554:	f103 00b0 	add.w	r0, r3, #176	; 0xb0
 8006558:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 800655c:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 8006560:	f10c 0e01 	add.w	lr, ip, #1
 8006564:	6840      	ldr	r0, [r0, #4]
 8006566:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 800656a:	f810 000e 	ldrb.w	r0, [r0, lr]
 800656e:	f813 300e 	ldrb.w	r3, [r3, lr]
 8006572:	4298      	cmp	r0, r3
 8006574:	d00f      	beq.n	8006596 <encode_ssdv+0xea6>
#define BADJ(i) (SDQT == DDQT ? (i) : irdiv(i * SDQT, DDQT))

/* Integer-only division with rounding */
static int irdiv(int i, int div)
{
	i = i * 2 / div;
 8006576:	fb07 f000 	mul.w	r0, r7, r0
 800657a:	0040      	lsls	r0, r0, #1
 800657c:	fb90 f3f3 	sdiv	r3, r0, r3
	if(i & 1) i += (i > 0 ? 1 : -1);
 8006580:	07df      	lsls	r7, r3, #31
 8006582:	d505      	bpl.n	8006590 <encode_ssdv+0xea0>
 8006584:	2b00      	cmp	r3, #0
 8006586:	bfd4      	ite	le
 8006588:	f04f 30ff 	movle.w	r0, #4294967295
 800658c:	2001      	movgt	r0, #1
 800658e:	4403      	add	r3, r0
	return(i / 2);
 8006590:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 8006594:	105f      	asrs	r7, r3, #1
				}
			}
		}
		else /* AC */
		{
			if((i = BADJ(i)))
 8006596:	2f00      	cmp	r7, #0
 8006598:	d062      	beq.n	8006660 <encode_ssdv+0xf70>
			{
				s->accrle += s->acrle;
 800659a:	f894 1075 	ldrb.w	r1, [r4, #117]	; 0x75
 800659e:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 80065a2:	4419      	add	r1, r3
 80065a4:	b2c9      	uxtb	r1, r1
				while(s->accrle >= 16)
 80065a6:	290f      	cmp	r1, #15
		}
		else /* AC */
		{
			if((i = BADJ(i)))
			{
				s->accrle += s->acrle;
 80065a8:	f884 1075 	strb.w	r1, [r4, #117]	; 0x75
				while(s->accrle >= 16)
 80065ac:	d90c      	bls.n	80065c8 <encode_ssdv+0xed8>
				{
					ssdv_out_jpeg_int(s, 15, 0);
 80065ae:	210f      	movs	r1, #15
 80065b0:	2200      	movs	r2, #0
 80065b2:	4620      	mov	r0, r4
 80065b4:	f009 fd14 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
					s->accrle -= 16;
 80065b8:	f894 1075 	ldrb.w	r1, [r4, #117]	; 0x75
 80065bc:	3910      	subs	r1, #16
 80065be:	b2c9      	uxtb	r1, r1
		else /* AC */
		{
			if((i = BADJ(i)))
			{
				s->accrle += s->acrle;
				while(s->accrle >= 16)
 80065c0:	290f      	cmp	r1, #15
				{
					ssdv_out_jpeg_int(s, 15, 0);
					s->accrle -= 16;
 80065c2:	f884 1075 	strb.w	r1, [r4, #117]	; 0x75
		else /* AC */
		{
			if((i = BADJ(i)))
			{
				s->accrle += s->acrle;
				while(s->accrle >= 16)
 80065c6:	d8f2      	bhi.n	80065ae <encode_ssdv+0xebe>
				{
					ssdv_out_jpeg_int(s, 15, 0);
					s->accrle -= 16;
				}
				ssdv_out_jpeg_int(s, s->accrle, i);
 80065c8:	463a      	mov	r2, r7
 80065ca:	4620      	mov	r0, r4
 80065cc:	f009 fd08 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
 80065d0:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 80065d4:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 80065d8:	f894 c059 	ldrb.w	ip, [r4, #89]	; 0x59
 80065dc:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80065de:	1ad2      	subs	r2, r2, r3
				s->accrle = 0;
 80065e0:	2300      	movs	r3, #0
 80065e2:	f10c 0e01 	add.w	lr, ip, #1
 80065e6:	f884 3075 	strb.w	r3, [r4, #117]	; 0x75
 80065ea:	e73c      	b.n	8006466 <encode_ssdv+0xd76>
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
			{
				/* Flush any remaining bits */
				ssdv_outbits_sync(s);
 80065ec:	4620      	mov	r0, r4
 80065ee:	f009 fca7 	bl	800ff40 <ssdv_outbits_sync.lto_priv.159>
			while((r = ssdv_process(s)) == SSDV_OK);
			
			if(r == SSDV_BUFFER_FULL || r == SSDV_EOI)
			{
				uint16_t mcu_id     = s->packet_mcu_id;
				uint8_t i, mcu_offset = s->packet_mcu_offset;
 80065f2:	7f23      	ldrb	r3, [r4, #28]
				uint32_t x;
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
 80065f4:	2bff      	cmp	r3, #255	; 0xff
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
			{
				/* Flush any remaining bits */
				ssdv_outbits_sync(s);
 80065f6:	f04f 0504 	mov.w	r5, #4
			{
				uint16_t mcu_id     = s->packet_mcu_id;
				uint8_t i, mcu_offset = s->packet_mcu_offset;
				uint32_t x;
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
 80065fa:	f47f a998 	bne.w	800592e <encode_ssdv+0x23e>
			/* Process the new data until more needed, or an error occurs */
			while((r = ssdv_process(s)) == SSDV_OK);
			
			if(r == SSDV_BUFFER_FULL || r == SSDV_EOI)
			{
				uint16_t mcu_id     = s->packet_mcu_id;
 80065fe:	8b61      	ldrh	r1, [r4, #26]
					s->packet_mcu_offset -= s->pkt_size_payload;
				}
				else
				{
					/* Clear the MCU data for the next packet */
					s->packet_mcu_id = 0xFFFF;
 8006600:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006604:	0a0f      	lsrs	r7, r1, #8
 8006606:	8362      	strh	r2, [r4, #26]
 8006608:	b2c9      	uxtb	r1, r1
					s->packet_mcu_offset = 0xFF;
 800660a:	7722      	strb	r2, [r4, #28]
 800660c:	f7ff b998 	b.w	8005940 <encode_ssdv+0x250>
			
			if(s->marker == J_TEM ||
			   (s->marker >= J_RST0 && s->marker <= J_EOI))
			{
				/* Marker without data */
				s->marker_len = 0;
 8006610:	2300      	movs	r3, #0
				r = ssdv_have_marker(s);
 8006612:	4620      	mov	r0, r4
			
			if(s->marker == J_TEM ||
			   (s->marker >= J_RST0 && s->marker <= J_EOI))
			{
				/* Marker without data */
				s->marker_len = 0;
 8006614:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
				r = ssdv_have_marker(s);
 8006618:	f004 f882 	bl	800a720 <ssdv_have_marker.lto_priv.157>
				if(r != SSDV_OK) return(r);
 800661c:	2800      	cmp	r0, #0
 800661e:	f43f a91d 	beq.w	800585c <encode_ssdv+0x16c>

	while(true)
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
 8006622:	2801      	cmp	r0, #1
 8006624:	f43f ab14 	beq.w	8005c50 <encode_ssdv+0x560>
				break;
			}
			ssdv_enc_feed(&ssdv, b, r);
		}

		if(c == SSDV_EOI)
 8006628:	2804      	cmp	r0, #4
 800662a:	f43f ab29 	beq.w	8005c80 <encode_ssdv+0x590>
 800662e:	e48c      	b.n	8005f4a <encode_ssdv+0x85a>
				s->needbits = symbol;
			}
		}
		else /* AC */
		{
			s->acrle = 0;
 8006630:	2300      	movs	r3, #0
 8006632:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
			if(symbol == 0x00)
 8006636:	2a00      	cmp	r2, #0
 8006638:	f000 80b1 	beq.w	800679e <encode_ssdv+0x10ae>
			{
				/* EOB -- all remaining AC parts are zero */
				ssdv_out_jpeg_int(s, 0, 0);
				s->acpart = 64;
			}
			else if(symbol == 0xF0)
 800663c:	2af0      	cmp	r2, #240	; 0xf0
 800663e:	f000 810c 	beq.w	800685a <encode_ssdv+0x116a>
			}
			else
			{
				/* Next bits are an integer value */
				s->state = S_INT;
				s->acrle = symbol >> 4;
 8006642:	0913      	lsrs	r3, r2, #4
				s->acpart += s->acrle;
 8006644:	441f      	add	r7, r3
 8006646:	b2ff      	uxtb	r7, r7
				s->needbits = symbol & 0x0F;
 8006648:	f002 020f 	and.w	r2, r2, #15
				s->acpart += 16;
			}
			else
			{
				/* Next bits are an integer value */
				s->state = S_INT;
 800664c:	2104      	movs	r1, #4
				s->acrle = symbol >> 4;
				s->acpart += s->acrle;
 800664e:	f884 7059 	strb.w	r7, [r4, #89]	; 0x59
			}
			else
			{
				/* Next bits are an integer value */
				s->state = S_INT;
				s->acrle = symbol >> 4;
 8006652:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
				s->acpart += s->acrle;
				s->needbits = symbol & 0x0F;
 8006656:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
				s->acpart += 16;
			}
			else
			{
				/* Next bits are an integer value */
				s->state = S_INT;
 800665a:	f884 1049 	strb.w	r1, [r4, #73]	; 0x49
 800665e:	e766      	b.n	800652e <encode_ssdv+0xe3e>
				s->accrle = 0;
			}
			else
			{
				/* AC value got reduced to 0 in the DQT conversion */
				if(s->acpart >= 63)
 8006660:	f1bc 0f3e 	cmp.w	ip, #62	; 0x3e
 8006664:	f200 80a7 	bhi.w	80067b6 <encode_ssdv+0x10c6>
				{
					ssdv_out_jpeg_int(s, 0, 0);
					s->accrle = 0;
				}
				else s->accrle += s->acrle + 1;
 8006668:	f894 0075 	ldrb.w	r0, [r4, #117]	; 0x75
 800666c:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8006670:	4403      	add	r3, r0
 8006672:	3301      	adds	r3, #1
 8006674:	f884 3075 	strb.w	r3, [r4, #117]	; 0x75
 8006678:	e6f5      	b.n	8006466 <encode_ssdv+0xd76>
				s->reset_mcu = s->mcu_id;
				s->packet_mcu_id = s->mcu_id;
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
			}
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
 800667a:	2a01      	cmp	r2, #1
 800667c:	f47f af1a 	bne.w	80064b4 <encode_ssdv+0xdc4>
 8006680:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8006682:	4293      	cmp	r3, r2
 8006684:	f47f af16 	bne.w	80064b4 <encode_ssdv+0xdc4>
				s->workbits = s->worklen = 0;
 8006688:	2300      	movs	r3, #0
 800668a:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
 800668e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8006690:	e710      	b.n	80064b4 <encode_ssdv+0xdc4>
				s->acpart++;
			}
			else
			{
				/* DC value follows, 'symbol' bits wide */
				s->state = S_INT;
 8006692:	2304      	movs	r3, #4
				s->needbits = symbol;
 8006694:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
				s->acpart++;
			}
			else
			{
				/* DC value follows, 'symbol' bits wide */
				s->state = S_INT;
 8006698:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
 800669c:	e747      	b.n	800652e <encode_ssdv+0xe3e>
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
		
		if(s->acpart == 0) /* DC */
		{
			if(s->reset_mcu == s->mcu_id && (s->mcupart == 0 || s->mcupart >= s->ycparts))
 800669e:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
 80066a2:	b123      	cbz	r3, 80066ae <encode_ssdv+0xfbe>
 80066a4:	f894 2057 	ldrb.w	r2, [r4, #87]	; 0x57
 80066a8:	429a      	cmp	r2, r3
 80066aa:	f63f ae8f 	bhi.w	80063cc <encode_ssdv+0xcdc>
			{
				if(s->mode == S_ENCODING)
 80066ae:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
 80066b2:	2b00      	cmp	r3, #0
 80066b4:	f040 80a3 	bne.w	80067fe <encode_ssdv+0x110e>
				{
					/* Output absolute DC value */
					s->dc[s->component] += UADJ(i);
 80066b8:	f894 1056 	ldrb.w	r1, [r4, #86]	; 0x56
 80066bc:	1c0b      	adds	r3, r1, #0
 80066be:	bf18      	it	ne
 80066c0:	2301      	movne	r3, #1
 80066c2:	f103 02b0 	add.w	r2, r3, #176	; 0xb0
 80066c6:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80066ca:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80066ce:	f8d2 e004 	ldr.w	lr, [r2, #4]
 80066d2:	f854 c023 	ldr.w	ip, [r4, r3, lsl #2]
 80066d6:	f89e 2001 	ldrb.w	r2, [lr, #1]
 80066da:	f89c 8001 	ldrb.w	r8, [ip, #1]
 80066de:	f101 0016 	add.w	r0, r1, #22
 80066e2:	eb04 0380 	add.w	r3, r4, r0, lsl #2
 80066e6:	4590      	cmp	r8, r2
 80066e8:	685b      	ldr	r3, [r3, #4]
 80066ea:	bf18      	it	ne
 80066ec:	4357      	mulne	r7, r2
 80066ee:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80066f2:	443b      	add	r3, r7
 80066f4:	6043      	str	r3, [r0, #4]
					s->adc[s->component] = AADJ(s->dc[s->component]);
 80066f6:	f89c 2001 	ldrb.w	r2, [ip, #1]
 80066fa:	f89e 0001 	ldrb.w	r0, [lr, #1]
 80066fe:	4290      	cmp	r0, r2
 8006700:	d00d      	beq.n	800671e <encode_ssdv+0x102e>
#define BADJ(i) (SDQT == DDQT ? (i) : irdiv(i * SDQT, DDQT))

/* Integer-only division with rounding */
static int irdiv(int i, int div)
{
	i = i * 2 / div;
 8006702:	005b      	lsls	r3, r3, #1
 8006704:	fb93 f3f2 	sdiv	r3, r3, r2
	if(i & 1) i += (i > 0 ? 1 : -1);
 8006708:	07d8      	lsls	r0, r3, #31
 800670a:	d505      	bpl.n	8006718 <encode_ssdv+0x1028>
 800670c:	2b00      	cmp	r3, #0
 800670e:	bfd4      	ite	le
 8006710:	f04f 32ff 	movle.w	r2, #4294967295
 8006714:	2201      	movgt	r2, #1
 8006716:	4413      	add	r3, r2
	return(i / 2);
 8006718:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800671c:	105b      	asrs	r3, r3, #1
			{
				if(s->mode == S_ENCODING)
				{
					/* Output absolute DC value */
					s->dc[s->component] += UADJ(i);
					s->adc[s->component] = AADJ(s->dc[s->component]);
 800671e:	f101 001a 	add.w	r0, r1, #26
					ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
 8006722:	461a      	mov	r2, r3
			{
				if(s->mode == S_ENCODING)
				{
					/* Output absolute DC value */
					s->dc[s->component] += UADJ(i);
					s->adc[s->component] = AADJ(s->dc[s->component]);
 8006724:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
					ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
 8006728:	2100      	movs	r1, #0
 800672a:	4620      	mov	r0, r4
			else
			{
				if(s->mode == S_DECODING)
				{
					s->dc[s->component] += UADJ(i);
					ssdv_out_jpeg_int(s, 0, i);
 800672c:	f009 fc58 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
 8006730:	f894 c059 	ldrb.w	ip, [r4, #89]	; 0x59
 8006734:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 8006738:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 800673c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800673e:	f10c 0e01 	add.w	lr, ip, #1
 8006742:	1ad2      	subs	r2, r2, r3
 8006744:	e68f      	b.n	8006466 <encode_ssdv+0xd76>

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
		{
			b = &image[bi];
			uint8_t r = bi < image_len-128 ? 128 : image_len - bi;
			bi += r;
 8006746:	9b03      	ldr	r3, [sp, #12]
 8006748:	3380      	adds	r3, #128	; 0x80
 800674a:	9303      	str	r3, [sp, #12]
 800674c:	2380      	movs	r3, #128	; 0x80
 800674e:	f7ff ba90 	b.w	8005c72 <encode_ssdv+0x582>
			}
			else
			{
				if(s->mode == S_DECODING)
				{
					s->dc[s->component] += UADJ(i);
 8006752:	1c1a      	adds	r2, r3, #0
 8006754:	bf18      	it	ne
 8006756:	2201      	movne	r2, #1
 8006758:	f102 01b0 	add.w	r1, r2, #176	; 0xb0
 800675c:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8006760:	f502 72a0 	add.w	r2, r2, #320	; 0x140
 8006764:	6848      	ldr	r0, [r1, #4]
 8006766:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 800676a:	7842      	ldrb	r2, [r0, #1]
 800676c:	7848      	ldrb	r0, [r1, #1]
 800676e:	3316      	adds	r3, #22
 8006770:	eb04 0183 	add.w	r1, r4, r3, lsl #2
 8006774:	4290      	cmp	r0, r2
 8006776:	6849      	ldr	r1, [r1, #4]
 8006778:	bf14      	ite	ne
 800677a:	437a      	mulne	r2, r7
 800677c:	463a      	moveq	r2, r7
 800677e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8006782:	eb01 0e02 	add.w	lr, r1, r2
					ssdv_out_jpeg_int(s, 0, i);
 8006786:	4620      	mov	r0, r4
 8006788:	463a      	mov	r2, r7
 800678a:	2100      	movs	r1, #0
			}
			else
			{
				if(s->mode == S_DECODING)
				{
					s->dc[s->component] += UADJ(i);
 800678c:	f8c3 e004 	str.w	lr, [r3, #4]
 8006790:	e7cc      	b.n	800672c <encode_ssdv+0x103c>
					{
						ssdv_out_jpeg_int(s, 0, 0 - s->dc[s->component]);
						s->dc[s->component] = 0;
					}
				}
				else ssdv_out_jpeg_int(s, 0, 0);
 8006792:	2200      	movs	r2, #0
 8006794:	4611      	mov	r1, r2
 8006796:	4620      	mov	r0, r4
 8006798:	f009 fc22 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
 800679c:	e6bd      	b.n	800651a <encode_ssdv+0xe2a>
		{
			s->acrle = 0;
			if(symbol == 0x00)
			{
				/* EOB -- all remaining AC parts are zero */
				ssdv_out_jpeg_int(s, 0, 0);
 800679e:	4611      	mov	r1, r2
 80067a0:	4620      	mov	r0, r4
 80067a2:	f009 fc1d 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
				s->acpart = 64;
 80067a6:	2740      	movs	r7, #64	; 0x40
 80067a8:	f884 6059 	strb.w	r6, [r4, #89]	; 0x59
 80067ac:	f894 e030 	ldrb.w	lr, [r4, #48]	; 0x30
 80067b0:	f8d4 902c 	ldr.w	r9, [r4, #44]	; 0x2c
 80067b4:	e6bb      	b.n	800652e <encode_ssdv+0xe3e>
			else
			{
				/* AC value got reduced to 0 in the DQT conversion */
				if(s->acpart >= 63)
				{
					ssdv_out_jpeg_int(s, 0, 0);
 80067b6:	463a      	mov	r2, r7
 80067b8:	4639      	mov	r1, r7
 80067ba:	4620      	mov	r0, r4
 80067bc:	f009 fc10 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
 80067c0:	f894 c059 	ldrb.w	ip, [r4, #89]	; 0x59
 80067c4:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 80067c8:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
					s->accrle = 0;
 80067cc:	f884 7075 	strb.w	r7, [r4, #117]	; 0x75
 80067d0:	f10c 0e01 	add.w	lr, ip, #1
 80067d4:	1ad2      	subs	r2, r2, r3
 80067d6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80067d8:	e645      	b.n	8006466 <encode_ssdv+0xd76>
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
	
	/* If the output buffer is empty, re-initialise */
	if(s->out_len == 0) ssdv_enc_set_buffer(s, s->out);
 80067da:	6b60      	ldr	r0, [r4, #52]	; 0x34

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
	s->out_len = s->pkt_size_payload;
 80067dc:	8863      	ldrh	r3, [r4, #2]
 80067de:	63e3      	str	r3, [r4, #60]	; 0x3c
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 80067e0:	4629      	mov	r1, r5
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
 80067e2:	f100 030f 	add.w	r3, r0, #15
	s->out_len = s->pkt_size_payload;
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 80067e6:	f44f 7280 	mov.w	r2, #256	; 0x100
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
 80067ea:	63a3      	str	r3, [r4, #56]	; 0x38
	s->out_len = s->pkt_size_payload;
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 80067ec:	f00d f938 	bl	8013a60 <memset>
	
	/* Flush the output bits */
	ssdv_outbits(s, 0, 0);
 80067f0:	462a      	mov	r2, r5
 80067f2:	4629      	mov	r1, r5
 80067f4:	4620      	mov	r0, r4
 80067f6:	f009 fb53 	bl	800fea0 <ssdv_outbits.lto_priv.158>
 80067fa:	f7ff b82f 	b.w	800585c <encode_ssdv+0x16c>
					ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
				}
				else
				{
					/* Output relative DC value */
					ssdv_out_jpeg_int(s, 0, i - s->dc[s->component]);
 80067fe:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
 8006802:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8006806:	2100      	movs	r1, #0
 8006808:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800680a:	4620      	mov	r0, r4
 800680c:	1aba      	subs	r2, r7, r2
 800680e:	f009 fbe7 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
					s->dc[s->component] = i;
 8006812:	f894 1056 	ldrb.w	r1, [r4, #86]	; 0x56
 8006816:	f894 c059 	ldrb.w	ip, [r4, #89]	; 0x59
 800681a:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 800681e:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8006822:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8006826:	f10c 0e01 	add.w	lr, ip, #1
 800682a:	65cf      	str	r7, [r1, #92]	; 0x5c
 800682c:	1ad2      	subs	r2, r2, r3
 800682e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8006830:	e619      	b.n	8006466 <encode_ssdv+0xd76>
			
			/* Set the packet MCU marker - encoder only */
			if(s->mode == S_ENCODING && s->packet_mcu_id == 0xFFFF)
			{
				/* The first MCU of each packet should be byte aligned */
				ssdv_outbits_sync(s);
 8006832:	4620      	mov	r0, r4
 8006834:	f009 fb84 	bl	800ff40 <ssdv_outbits_sync.lto_priv.159>
				
				s->reset_mcu = s->mcu_id;
				s->packet_mcu_id = s->mcu_id;
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
 8006838:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800683a:	78a3      	ldrb	r3, [r4, #2]
			}
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
 800683c:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
				/* The first MCU of each packet should be byte aligned */
				ssdv_outbits_sync(s);
				
				s->reset_mcu = s->mcu_id;
				s->packet_mcu_id = s->mcu_id;
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
 8006840:	1a9b      	subs	r3, r3, r2
			}
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
 8006842:	2901      	cmp	r1, #1
			if(s->mode == S_ENCODING && s->packet_mcu_id == 0xFFFF)
			{
				/* The first MCU of each packet should be byte aligned */
				ssdv_outbits_sync(s);
				
				s->reset_mcu = s->mcu_id;
 8006844:	8ae2      	ldrh	r2, [r4, #22]
				s->packet_mcu_id = s->mcu_id;
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
 8006846:	7723      	strb	r3, [r4, #28]
			if(s->mode == S_ENCODING && s->packet_mcu_id == 0xFFFF)
			{
				/* The first MCU of each packet should be byte aligned */
				ssdv_outbits_sync(s);
				
				s->reset_mcu = s->mcu_id;
 8006848:	67e2      	str	r2, [r4, #124]	; 0x7c
				s->packet_mcu_id = s->mcu_id;
 800684a:	8362      	strh	r2, [r4, #26]
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
			}
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
 800684c:	f47f ae32 	bne.w	80064b4 <encode_ssdv+0xdc4>
				s->workbits = s->worklen = 0;
 8006850:	2300      	movs	r3, #0
 8006852:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
 8006856:	62e3      	str	r3, [r4, #44]	; 0x2c
 8006858:	e62c      	b.n	80064b4 <encode_ssdv+0xdc4>
				s->acpart = 64;
			}
			else if(symbol == 0xF0)
			{
				/* The next 16 AC parts are zero */
				ssdv_out_jpeg_int(s, 15, 0);
 800685a:	461a      	mov	r2, r3
 800685c:	210f      	movs	r1, #15
 800685e:	4620      	mov	r0, r4
 8006860:	f009 fbbe 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
				s->acpart += 16;
 8006864:	f894 7059 	ldrb.w	r7, [r4, #89]	; 0x59
 8006868:	f894 e030 	ldrb.w	lr, [r4, #48]	; 0x30
 800686c:	f8d4 902c 	ldr.w	r9, [r4, #44]	; 0x2c
 8006870:	3710      	adds	r7, #16
 8006872:	b2ff      	uxtb	r7, r7
 8006874:	f884 7059 	strb.w	r7, [r4, #89]	; 0x59
 8006878:	e659      	b.n	800652e <encode_ssdv+0xe3e>
				if(s->reset_mcu == s->mcu_id && (s->mcupart == 0 || s->mcupart >= s->ycparts))
				{
					if(s->mode == S_ENCODING) ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
					else
					{
						ssdv_out_jpeg_int(s, 0, 0 - s->dc[s->component]);
 800687a:	eb04 0b8b 	add.w	fp, r4, fp, lsl #2
 800687e:	2100      	movs	r1, #0
 8006880:	f8db 205c 	ldr.w	r2, [fp, #92]	; 0x5c
 8006884:	4620      	mov	r0, r4
 8006886:	4252      	negs	r2, r2
 8006888:	f009 fbaa 	bl	800ffe0 <ssdv_out_jpeg_int.lto_priv.160>
						s->dc[s->component] = 0;
 800688c:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
 8006890:	3316      	adds	r3, #22
 8006892:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8006896:	2200      	movs	r2, #0
 8006898:	605a      	str	r2, [r3, #4]
 800689a:	e63e      	b.n	800651a <encode_ssdv+0xe2a>

			if(r <= 0)
			{
				TRACE_ERROR("SSDV > Premature end of file");
 800689c:	48ba      	ldr	r0, [pc, #744]	; (8006b88 <encode_ssdv+0x1498>)
 800689e:	4ebb      	ldr	r6, [pc, #748]	; (8006b8c <encode_ssdv+0x149c>)
 80068a0:	f008 fb26 	bl	800eef0 <chMtxLock>
 80068a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80068a8:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 80068ac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80068ae:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80068b0:	4bb7      	ldr	r3, [pc, #732]	; (8006b90 <encode_ssdv+0x14a0>)
 80068b2:	49b8      	ldr	r1, [pc, #736]	; (8006b94 <encode_ssdv+0x14a4>)
 80068b4:	48b8      	ldr	r0, [pc, #736]	; (8006b98 <encode_ssdv+0x14a8>)
 80068b6:	fb05 f404 	mul.w	r4, r5, r4
 80068ba:	fba6 7404 	umull	r7, r4, r6, r4
 80068be:	0ba4      	lsrs	r4, r4, #14
 80068c0:	fba3 7304 	umull	r7, r3, r3, r4
 80068c4:	fba6 6202 	umull	r6, r2, r6, r2
 80068c8:	099b      	lsrs	r3, r3, #6
 80068ca:	fb05 4313 	mls	r3, r5, r3, r4
 80068ce:	0b92      	lsrs	r2, r2, #14
 80068d0:	f00b ff06 	bl	80126e0 <chprintf.constprop.35>
 80068d4:	4ab1      	ldr	r2, [pc, #708]	; (8006b9c <encode_ssdv+0x14ac>)
 80068d6:	49b2      	ldr	r1, [pc, #712]	; (8006ba0 <encode_ssdv+0x14b0>)
 80068d8:	48af      	ldr	r0, [pc, #700]	; (8006b98 <encode_ssdv+0x14a8>)
 80068da:	f00b ff01 	bl	80126e0 <chprintf.constprop.35>
 80068de:	232e      	movs	r3, #46	; 0x2e
 80068e0:	4ab0      	ldr	r2, [pc, #704]	; (8006ba4 <encode_ssdv+0x14b4>)
 80068e2:	49b1      	ldr	r1, [pc, #708]	; (8006ba8 <encode_ssdv+0x14b8>)
 80068e4:	48ac      	ldr	r0, [pc, #688]	; (8006b98 <encode_ssdv+0x14a8>)
 80068e6:	f00b fefb 	bl	80126e0 <chprintf.constprop.35>
 80068ea:	49b0      	ldr	r1, [pc, #704]	; (8006bac <encode_ssdv+0x14bc>)
 80068ec:	48aa      	ldr	r0, [pc, #680]	; (8006b98 <encode_ssdv+0x14a8>)
 80068ee:	f00b fef7 	bl	80126e0 <chprintf.constprop.35>
 80068f2:	49af      	ldr	r1, [pc, #700]	; (8006bb0 <encode_ssdv+0x14c0>)
 80068f4:	48a8      	ldr	r0, [pc, #672]	; (8006b98 <encode_ssdv+0x14a8>)
 80068f6:	f00b fef3 	bl	80126e0 <chprintf.constprop.35>
 80068fa:	49ae      	ldr	r1, [pc, #696]	; (8006bb4 <encode_ssdv+0x14c4>)
 80068fc:	48a6      	ldr	r0, [pc, #664]	; (8006b98 <encode_ssdv+0x14a8>)
 80068fe:	f00b feef 	bl	80126e0 <chprintf.constprop.35>
 8006902:	48a1      	ldr	r0, [pc, #644]	; (8006b88 <encode_ssdv+0x1498>)
 8006904:	f008 fa94 	bl	800ee30 <chMtxUnlock>
 8006908:	212e      	movs	r1, #46	; 0x2e
 800690a:	48a6      	ldr	r0, [pc, #664]	; (8006ba4 <encode_ssdv+0x14b4>)
 800690c:	f009 fb28 	bl	800ff60 <log_error>
 8006910:	2401      	movs	r4, #1
 8006912:	f7ff bb1b 	b.w	8005f4c <encode_ssdv+0x85c>
		msg.power = config->power;

		switch(config->protocol) {
			case PROT_APRS_2GFSK:
			case PROT_APRS_AFSK:
				msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8006916:	2b01      	cmp	r3, #1
				msg.afsk_config = &(config->afsk_config);
 8006918:	9b07      	ldr	r3, [sp, #28]
		msg.power = config->power;

		switch(config->protocol) {
			case PROT_APRS_2GFSK:
			case PROT_APRS_AFSK:
				msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 800691a:	bf18      	it	ne
 800691c:	2202      	movne	r2, #2
				msg.afsk_config = &(config->afsk_config);
 800691e:	f103 0350 	add.w	r3, r3, #80	; 0x50
		msg.power = config->power;

		switch(config->protocol) {
			case PROT_APRS_2GFSK:
			case PROT_APRS_AFSK:
				msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8006922:	bf08      	it	eq
 8006924:	2204      	moveq	r2, #4
 8006926:	f88d 2439 	strb.w	r2, [sp, #1081]	; 0x439
				msg.afsk_config = &(config->afsk_config);
 800692a:	f8cd 3444 	str.w	r3, [sp, #1092]	; 0x444
				msg.gfsk_config = &(config->gfsk_config);
 800692e:	f8cd 3448 	str.w	r3, [sp, #1096]	; 0x448
 8006932:	f20d 211f 	addw	r1, sp, #543	; 0x21f
 8006936:	f20d 131f 	addw	r3, sp, #287	; 0x11f

				// Deleting buffer
				for(uint16_t t=0; t<256; t++)
					pkt_base91[t] = 0;
 800693a:	2200      	movs	r2, #0
 800693c:	f803 2f01 	strb.w	r2, [r3, #1]!
				msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
				msg.afsk_config = &(config->afsk_config);
				msg.gfsk_config = &(config->gfsk_config);

				// Deleting buffer
				for(uint16_t t=0; t<256; t++)
 8006940:	428b      	cmp	r3, r1
 8006942:	d1fb      	bne.n	800693c <encode_ssdv+0x124c>
					pkt_base91[t] = 0;

				base91_encode(&pkt[1], pkt_base91, sizeof(pkt)-37); // Sync byte, CRC and FEC of SSDV not transmitted
 8006944:	ad48      	add	r5, sp, #288	; 0x120
 8006946:	4629      	mov	r1, r5
 8006948:	22db      	movs	r2, #219	; 0xdb
 800694a:	f10d 0021 	add.w	r0, sp, #33	; 0x21
 800694e:	f00b fc4f 	bl	80121f0 <base91_encode>
				msg.bin_len = aprs_encode_experimental('I', msg.msg, msg.mod, &config->aprs_config, pkt_base91, strlen((char*)pkt_base91));
 8006952:	4628      	mov	r0, r5
 8006954:	f7fb f8ac 	bl	8001ab0 <strlen>
 8006958:	9b07      	ldr	r3, [sp, #28]
 800695a:	f89d 2439 	ldrb.w	r2, [sp, #1081]	; 0x439
 800695e:	9001      	str	r0, [sp, #4]
 8006960:	3358      	adds	r3, #88	; 0x58
 8006962:	a98c      	add	r1, sp, #560	; 0x230
 8006964:	9500      	str	r5, [sp, #0]
 8006966:	2049      	movs	r0, #73	; 0x49
 8006968:	f003 fe9a 	bl	800a6a0 <aprs_encode_experimental>
 800696c:	f8cd 0430 	str.w	r0, [sp, #1072]	; 0x430

				transmitOnRadio(&msg);
 8006970:	a88c      	add	r0, sp, #560	; 0x230
 8006972:	f00a fdfd 	bl	8011570 <transmitOnRadio>
			default:
				TRACE_ERROR("IMG  > Unsupported protocol selected for module IMAGE");
		}

		// Packet spacing (delay)
		if(config->packet_spacing)
 8006976:	9b07      	ldr	r3, [sp, #28]
 8006978:	6b98      	ldr	r0, [r3, #56]	; 0x38
 800697a:	2800      	cmp	r0, #0
 800697c:	f43f a8d3 	beq.w	8005b26 <encode_ssdv+0x436>
			chThdSleepMilliseconds(config->packet_spacing);
 8006980:	f644 6320 	movw	r3, #20000	; 0x4e20
 8006984:	fb03 f000 	mul.w	r0, r3, r0
 8006988:	4b81      	ldr	r3, [pc, #516]	; (8006b90 <encode_ssdv+0x14a0>)
 800698a:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
 800698e:	fba3 3000 	umull	r3, r0, r3, r0
 8006992:	0980      	lsrs	r0, r0, #6
 8006994:	f008 fb7c 	bl	800f090 <chThdSleep>
 8006998:	f7ff b8c5 	b.w	8005b26 <encode_ssdv+0x436>
				transmitOnRadio(&msg);
				break;

			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
				msg.fsk_config = &(config->fsk_config);
 800699c:	9b07      	ldr	r3, [sp, #28]

				transmitOnRadio(&msg);
				break;

			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
 800699e:	2001      	movs	r0, #1
				msg.fsk_config = &(config->fsk_config);
 80069a0:	3350      	adds	r3, #80	; 0x50

				transmitOnRadio(&msg);
				break;

			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
 80069a2:	f88d 0439 	strb.w	r0, [sp, #1081]	; 0x439
				msg.fsk_config = &(config->fsk_config);

				memcpy(msg.msg, pkt, sizeof(pkt));
 80069a6:	f44f 7280 	mov.w	r2, #256	; 0x100
 80069aa:	a908      	add	r1, sp, #32
 80069ac:	a88c      	add	r0, sp, #560	; 0x230
				transmitOnRadio(&msg);
				break;

			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
				msg.fsk_config = &(config->fsk_config);
 80069ae:	f8cd 3440 	str.w	r3, [sp, #1088]	; 0x440

				memcpy(msg.msg, pkt, sizeof(pkt));
 80069b2:	f7fa fe6d 	bl	8001690 <memcpy>
				msg.bin_len = 8*sizeof(pkt);
 80069b6:	f44f 6300 	mov.w	r3, #2048	; 0x800

				transmitOnRadio(&msg);
 80069ba:	a88c      	add	r0, sp, #560	; 0x230
			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
				msg.fsk_config = &(config->fsk_config);

				memcpy(msg.msg, pkt, sizeof(pkt));
				msg.bin_len = 8*sizeof(pkt);
 80069bc:	f8cd 3430 	str.w	r3, [sp, #1072]	; 0x430

				transmitOnRadio(&msg);
 80069c0:	f00a fdd6 	bl	8011570 <transmitOnRadio>
 80069c4:	f7ff b8aa 	b.w	8005b1c <encode_ssdv+0x42c>
	
	case J_SOS:
		TRACE_INFO("SSDV > Components: %i", d[0]);
		
		/* The image must have 3 components (Y'Cb'Cr) */
		if(d[0] != 3)
 80069c8:	2300      	movs	r3, #0
			return(SSDV_ERROR);
		}
		
		for(i = 0; i < 3; i++)
		{
			uint8_t *dh = &d[i * 2 + 1];
 80069ca:	005f      	lsls	r7, r3, #1
 80069cc:	3701      	adds	r7, #1
			if(dh[0] != i + 1)
 80069ce:	3301      	adds	r3, #1
 80069d0:	5dee      	ldrb	r6, [r5, r7]
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > Component %i DHT: %02X", dh[0], dh[1]);
 80069d2:	486d      	ldr	r0, [pc, #436]	; (8006b88 <encode_ssdv+0x1498>)
		}
		
		for(i = 0; i < 3; i++)
		{
			uint8_t *dh = &d[i * 2 + 1];
			if(dh[0] != i + 1)
 80069d4:	429e      	cmp	r6, r3
			return(SSDV_ERROR);
		}
		
		for(i = 0; i < 3; i++)
		{
			uint8_t *dh = &d[i * 2 + 1];
 80069d6:	eb05 0807 	add.w	r8, r5, r7
			if(dh[0] != i + 1)
 80069da:	f040 8203 	bne.w	8006de4 <encode_ssdv+0x16f4>
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > Component %i DHT: %02X", dh[0], dh[1]);
 80069de:	f008 fa87 	bl	800eef0 <chMtxLock>
 80069e2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80069e6:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
 80069ea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80069ec:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80069ee:	4b67      	ldr	r3, [pc, #412]	; (8006b8c <encode_ssdv+0x149c>)
 80069f0:	4968      	ldr	r1, [pc, #416]	; (8006b94 <encode_ssdv+0x14a4>)
 80069f2:	fb0e f000 	mul.w	r0, lr, r0
 80069f6:	fba3 3000 	umull	r3, r0, r3, r0
 80069fa:	4b65      	ldr	r3, [pc, #404]	; (8006b90 <encode_ssdv+0x14a0>)
 80069fc:	0b80      	lsrs	r0, r0, #14
 80069fe:	fba3 3c00 	umull	r3, ip, r3, r0
 8006a02:	4b62      	ldr	r3, [pc, #392]	; (8006b8c <encode_ssdv+0x149c>)
 8006a04:	fba3 3202 	umull	r3, r2, r3, r2
 8006a08:	ea4f 139c 	mov.w	r3, ip, lsr #6
 8006a0c:	fb0e 0313 	mls	r3, lr, r3, r0
 8006a10:	0b92      	lsrs	r2, r2, #14
 8006a12:	4861      	ldr	r0, [pc, #388]	; (8006b98 <encode_ssdv+0x14a8>)
 8006a14:	f00b fe64 	bl	80126e0 <chprintf.constprop.35>
 8006a18:	4a67      	ldr	r2, [pc, #412]	; (8006bb8 <encode_ssdv+0x14c8>)
 8006a1a:	4961      	ldr	r1, [pc, #388]	; (8006ba0 <encode_ssdv+0x14b0>)
 8006a1c:	485e      	ldr	r0, [pc, #376]	; (8006b98 <encode_ssdv+0x14a8>)
 8006a1e:	f00b fe5f 	bl	80126e0 <chprintf.constprop.35>
 8006a22:	f240 23f9 	movw	r3, #761	; 0x2f9
 8006a26:	4a65      	ldr	r2, [pc, #404]	; (8006bbc <encode_ssdv+0x14cc>)
 8006a28:	495f      	ldr	r1, [pc, #380]	; (8006ba8 <encode_ssdv+0x14b8>)
 8006a2a:	485b      	ldr	r0, [pc, #364]	; (8006b98 <encode_ssdv+0x14a8>)
 8006a2c:	f00b fe58 	bl	80126e0 <chprintf.constprop.35>
 8006a30:	495e      	ldr	r1, [pc, #376]	; (8006bac <encode_ssdv+0x14bc>)
 8006a32:	4859      	ldr	r0, [pc, #356]	; (8006b98 <encode_ssdv+0x14a8>)
 8006a34:	f00b fe54 	bl	80126e0 <chprintf.constprop.35>
 8006a38:	f898 3001 	ldrb.w	r3, [r8, #1]
 8006a3c:	5dea      	ldrb	r2, [r5, r7]
 8006a3e:	4960      	ldr	r1, [pc, #384]	; (8006bc0 <encode_ssdv+0x14d0>)
 8006a40:	4855      	ldr	r0, [pc, #340]	; (8006b98 <encode_ssdv+0x14a8>)
 8006a42:	f00b fe4d 	bl	80126e0 <chprintf.constprop.35>
 8006a46:	495b      	ldr	r1, [pc, #364]	; (8006bb4 <encode_ssdv+0x14c4>)
 8006a48:	4853      	ldr	r0, [pc, #332]	; (8006b98 <encode_ssdv+0x14a8>)
 8006a4a:	f00b fe49 	bl	80126e0 <chprintf.constprop.35>
 8006a4e:	484e      	ldr	r0, [pc, #312]	; (8006b88 <encode_ssdv+0x1498>)
 8006a50:	f008 f9ee 	bl	800ee30 <chMtxUnlock>
		{
			TRACE_ERROR("SSDV > The image must have 3 components");
			return(SSDV_ERROR);
		}
		
		for(i = 0; i < 3; i++)
 8006a54:	2e03      	cmp	r6, #3
 8006a56:	4633      	mov	r3, r6
 8006a58:	d1b7      	bne.n	80069ca <encode_ssdv+0x12da>
		
		/* Do I need to look at the last three bytes of the SOS data? */
		/* 00 3F 00 */
		
		/* Verify all of the DQT and DHT tables where loaded */
		if(!s->sdqt[0] || !s->sdqt[1])
 8006a5a:	f8d4 22c4 	ldr.w	r2, [r4, #708]	; 0x2c4
 8006a5e:	2a00      	cmp	r2, #0
 8006a60:	f000 8145 	beq.w	8006cee <encode_ssdv+0x15fe>
 8006a64:	f8d4 22c8 	ldr.w	r2, [r4, #712]	; 0x2c8
 8006a68:	2a00      	cmp	r2, #0
 8006a6a:	f000 8140 	beq.w	8006cee <encode_ssdv+0x15fe>
		{
			TRACE_ERROR("SSDV > The image is missing one or more DQT tables");
			return(SSDV_ERROR);
		}
		
		if(!s->sdht[0][0] || !s->sdht[0][1] ||
 8006a6e:	f8d4 22b4 	ldr.w	r2, [r4, #692]	; 0x2b4
 8006a72:	b152      	cbz	r2, 8006a8a <encode_ssdv+0x139a>
 8006a74:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
 8006a78:	b13a      	cbz	r2, 8006a8a <encode_ssdv+0x139a>
 8006a7a:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
 8006a7e:	b122      	cbz	r2, 8006a8a <encode_ssdv+0x139a>
		   !s->sdht[1][0] || !s->sdht[1][1])
 8006a80:	f8d4 22c0 	ldr.w	r2, [r4, #704]	; 0x2c0
 8006a84:	2a00      	cmp	r2, #0
 8006a86:	f47f a9ae 	bne.w	8005de6 <encode_ssdv+0x6f6>
		{
			TRACE_ERROR("SSDV > The image is missing one or more DHT tables");
 8006a8a:	483f      	ldr	r0, [pc, #252]	; (8006b88 <encode_ssdv+0x1498>)
 8006a8c:	4e3f      	ldr	r6, [pc, #252]	; (8006b8c <encode_ssdv+0x149c>)
 8006a8e:	f008 fa2f 	bl	800eef0 <chMtxLock>
 8006a92:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006a96:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8006a9a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006a9c:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8006a9e:	4b3c      	ldr	r3, [pc, #240]	; (8006b90 <encode_ssdv+0x14a0>)
 8006aa0:	493c      	ldr	r1, [pc, #240]	; (8006b94 <encode_ssdv+0x14a4>)
 8006aa2:	483d      	ldr	r0, [pc, #244]	; (8006b98 <encode_ssdv+0x14a8>)
 8006aa4:	fb05 f404 	mul.w	r4, r5, r4
 8006aa8:	fba6 7404 	umull	r7, r4, r6, r4
 8006aac:	0ba4      	lsrs	r4, r4, #14
 8006aae:	fba3 7304 	umull	r7, r3, r3, r4
 8006ab2:	fba6 6202 	umull	r6, r2, r6, r2
 8006ab6:	099b      	lsrs	r3, r3, #6
 8006ab8:	fb05 4313 	mls	r3, r5, r3, r4
 8006abc:	0b92      	lsrs	r2, r2, #14
 8006abe:	f00b fe0f 	bl	80126e0 <chprintf.constprop.35>
 8006ac2:	4a36      	ldr	r2, [pc, #216]	; (8006b9c <encode_ssdv+0x14ac>)
 8006ac4:	4936      	ldr	r1, [pc, #216]	; (8006ba0 <encode_ssdv+0x14b0>)
 8006ac6:	4834      	ldr	r0, [pc, #208]	; (8006b98 <encode_ssdv+0x14a8>)
 8006ac8:	f00b fe0a 	bl	80126e0 <chprintf.constprop.35>
 8006acc:	f240 3309 	movw	r3, #777	; 0x309
 8006ad0:	4a3a      	ldr	r2, [pc, #232]	; (8006bbc <encode_ssdv+0x14cc>)
 8006ad2:	4935      	ldr	r1, [pc, #212]	; (8006ba8 <encode_ssdv+0x14b8>)
 8006ad4:	4830      	ldr	r0, [pc, #192]	; (8006b98 <encode_ssdv+0x14a8>)
 8006ad6:	f00b fe03 	bl	80126e0 <chprintf.constprop.35>
 8006ada:	4934      	ldr	r1, [pc, #208]	; (8006bac <encode_ssdv+0x14bc>)
 8006adc:	482e      	ldr	r0, [pc, #184]	; (8006b98 <encode_ssdv+0x14a8>)
 8006ade:	f00b fdff 	bl	80126e0 <chprintf.constprop.35>
 8006ae2:	4938      	ldr	r1, [pc, #224]	; (8006bc4 <encode_ssdv+0x14d4>)
 8006ae4:	482c      	ldr	r0, [pc, #176]	; (8006b98 <encode_ssdv+0x14a8>)
 8006ae6:	f00b fdfb 	bl	80126e0 <chprintf.constprop.35>
 8006aea:	4932      	ldr	r1, [pc, #200]	; (8006bb4 <encode_ssdv+0x14c4>)
 8006aec:	482a      	ldr	r0, [pc, #168]	; (8006b98 <encode_ssdv+0x14a8>)
 8006aee:	f00b fdf7 	bl	80126e0 <chprintf.constprop.35>
 8006af2:	4825      	ldr	r0, [pc, #148]	; (8006b88 <encode_ssdv+0x1498>)
 8006af4:	f008 f99c 	bl	800ee30 <chMtxUnlock>
 8006af8:	f240 3109 	movw	r1, #777	; 0x309
 8006afc:	482f      	ldr	r0, [pc, #188]	; (8006bbc <encode_ssdv+0x14cc>)
 8006afe:	f009 fa2f 	bl	800ff60 <log_error>
 8006b02:	f7ff ba21 	b.w	8005f48 <encode_ssdv+0x858>
			TRACE_ERROR("SSDV > The image must have a precision of 8");
			return(SSDV_ERROR);
		}
		
		/* The image must have 3 components (Y'Cb'Cr) */
		if(d[5] != 3)
 8006b06:	796b      	ldrb	r3, [r5, #5]
 8006b08:	2b03      	cmp	r3, #3
 8006b0a:	f000 80aa 	beq.w	8006c62 <encode_ssdv+0x1572>
		{
			TRACE_ERROR("SSDV > The image must have 3 components");
 8006b0e:	481e      	ldr	r0, [pc, #120]	; (8006b88 <encode_ssdv+0x1498>)
 8006b10:	f008 f9ee 	bl	800eef0 <chMtxLock>
 8006b14:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006b16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006b18:	491e      	ldr	r1, [pc, #120]	; (8006b94 <encode_ssdv+0x14a4>)
 8006b1a:	481f      	ldr	r0, [pc, #124]	; (8006b98 <encode_ssdv+0x14a8>)
 8006b1c:	fb08 f303 	mul.w	r3, r8, r3
 8006b20:	fba9 4303 	umull	r4, r3, r9, r3
 8006b24:	0b9b      	lsrs	r3, r3, #14
 8006b26:	fbaa 5403 	umull	r5, r4, sl, r3
 8006b2a:	09a4      	lsrs	r4, r4, #6
 8006b2c:	fba9 5202 	umull	r5, r2, r9, r2
 8006b30:	fb08 3314 	mls	r3, r8, r4, r3
 8006b34:	0b92      	lsrs	r2, r2, #14
 8006b36:	f00b fdd3 	bl	80126e0 <chprintf.constprop.35>
 8006b3a:	4a18      	ldr	r2, [pc, #96]	; (8006b9c <encode_ssdv+0x14ac>)
 8006b3c:	4918      	ldr	r1, [pc, #96]	; (8006ba0 <encode_ssdv+0x14b0>)
 8006b3e:	4816      	ldr	r0, [pc, #88]	; (8006b98 <encode_ssdv+0x14a8>)
 8006b40:	f00b fdce 	bl	80126e0 <chprintf.constprop.35>
 8006b44:	f240 239d 	movw	r3, #669	; 0x29d
 8006b48:	4a1c      	ldr	r2, [pc, #112]	; (8006bbc <encode_ssdv+0x14cc>)
 8006b4a:	4917      	ldr	r1, [pc, #92]	; (8006ba8 <encode_ssdv+0x14b8>)
 8006b4c:	4812      	ldr	r0, [pc, #72]	; (8006b98 <encode_ssdv+0x14a8>)
 8006b4e:	f00b fdc7 	bl	80126e0 <chprintf.constprop.35>
 8006b52:	4916      	ldr	r1, [pc, #88]	; (8006bac <encode_ssdv+0x14bc>)
 8006b54:	4810      	ldr	r0, [pc, #64]	; (8006b98 <encode_ssdv+0x14a8>)
 8006b56:	f00b fdc3 	bl	80126e0 <chprintf.constprop.35>
 8006b5a:	491b      	ldr	r1, [pc, #108]	; (8006bc8 <encode_ssdv+0x14d8>)
 8006b5c:	480e      	ldr	r0, [pc, #56]	; (8006b98 <encode_ssdv+0x14a8>)
 8006b5e:	f00b fdbf 	bl	80126e0 <chprintf.constprop.35>
 8006b62:	4914      	ldr	r1, [pc, #80]	; (8006bb4 <encode_ssdv+0x14c4>)
 8006b64:	480c      	ldr	r0, [pc, #48]	; (8006b98 <encode_ssdv+0x14a8>)
 8006b66:	f00b fdbb 	bl	80126e0 <chprintf.constprop.35>
 8006b6a:	4807      	ldr	r0, [pc, #28]	; (8006b88 <encode_ssdv+0x1498>)
 8006b6c:	f008 f960 	bl	800ee30 <chMtxUnlock>
 8006b70:	f240 219d 	movw	r1, #669	; 0x29d
 8006b74:	4811      	ldr	r0, [pc, #68]	; (8006bbc <encode_ssdv+0x14cc>)
 8006b76:	f009 f9f3 	bl	800ff60 <log_error>
 8006b7a:	f7ff b9e5 	b.w	8005f48 <encode_ssdv+0x858>
					encode_rs_8(&s->out[1], &s->out[i], 0);
				
				s->packet_id++;
				
				/* Have we reached the end of the image data? */
				if(r == SSDV_EOI) s->state = S_EOI;
 8006b7e:	2305      	movs	r3, #5
 8006b80:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
 8006b84:	f7fe bf7c 	b.w	8005a80 <encode_ssdv+0x390>
 8006b88:	20027b2c 	.word	0x20027b2c
 8006b8c:	d1b71759 	.word	0xd1b71759
 8006b90:	10624dd3 	.word	0x10624dd3
 8006b94:	08013c50 	.word	0x08013c50
 8006b98:	20027e60 	.word	0x20027e60
 8006b9c:	08013d9c 	.word	0x08013d9c
 8006ba0:	08013c5c 	.word	0x08013c5c
 8006ba4:	08014340 	.word	0x08014340
 8006ba8:	08013c78 	.word	0x08013c78
 8006bac:	08013d00 	.word	0x08013d00
 8006bb0:	080148f0 	.word	0x080148f0
 8006bb4:	08013cac 	.word	0x08013cac
 8006bb8:	08013cfc 	.word	0x08013cfc
 8006bbc:	0801491f 	.word	0x0801491f
 8006bc0:	08014b64 	.word	0x08014b64
 8006bc4:	08014bb8 	.word	0x08014bb8
 8006bc8:	080149a0 	.word	0x080149a0
				s->out[i++] = (x >> 8) & 0xFF;
				s->out[i++] = x & 0xFF;
				
				/* Generate the RS codes */
				if(s->type == SSDV_TYPE_NORMAL)
					encode_rs_8(&s->out[1], &s->out[i], 0);
 8006bcc:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8006bce:	4fa4      	ldr	r7, [pc, #656]	; (8006e60 <encode_ssdv+0x1770>)
 8006bd0:	f108 0805 	add.w	r8, r8, #5
 8006bd4:	fa56 f888 	uxtab	r8, r6, r8
void encode_rs_8(uint8_t *data, uint8_t *parity, int pad)
{
	int i, j;
	uint8_t feedback;
	
	memset(parity, 0, NROOTS * sizeof(uint8_t));
 8006bd8:	4640      	mov	r0, r8
 8006bda:	2220      	movs	r2, #32
 8006bdc:	f00c ff40 	bl	8013a60 <memset>
 8006be0:	46b3      	mov	fp, r6
 8006be2:	f106 09df 	add.w	r9, r6, #223	; 0xdf
 8006be6:	f108 0a01 	add.w	sl, r8, #1
	
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
 8006bea:	f81b 2f01 	ldrb.w	r2, [fp, #1]!
 8006bee:	f898 3000 	ldrb.w	r3, [r8]
 8006bf2:	4053      	eors	r3, r2
 8006bf4:	4a9b      	ldr	r2, [pc, #620]	; (8006e64 <encode_ssdv+0x1774>)
 8006bf6:	5cd6      	ldrb	r6, [r2, r3]
		if(feedback != A0) /* feedback term is non-zero */
 8006bf8:	2eff      	cmp	r6, #255	; 0xff
 8006bfa:	d023      	beq.n	8006c44 <encode_ssdv+0x1554>
 8006bfc:	f8df e2a4 	ldr.w	lr, [pc, #676]	; 8006ea4 <encode_ssdv+0x17b4>
 8006c00:	4640      	mov	r0, r8
 8006c02:	4641      	mov	r1, r8
 8006c04:	23f9      	movs	r3, #249	; 0xf9
 8006c06:	2201      	movs	r2, #1
 8006c08:	e001      	b.n	8006c0e <encode_ssdv+0x151e>
 8006c0a:	f81e 3d01 	ldrb.w	r3, [lr, #-1]!
		{
			for(j = 1; j < NROOTS; j++)
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
 8006c0e:	f810 cf01 	ldrb.w	ip, [r0, #1]!
 8006c12:	4433      	add	r3, r6
0x00,
};

static inline int mod255(int x)
{
	while(x >= 255)
 8006c14:	2bfe      	cmp	r3, #254	; 0xfe
	{
		x -= 255;
 8006c16:	bfc8      	it	gt
 8006c18:	3bff      	subgt	r3, #255	; 0xff
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
		if(feedback != A0) /* feedback term is non-zero */
		{
			for(j = 1; j < NROOTS; j++)
 8006c1a:	3201      	adds	r2, #1
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
 8006c1c:	5cfb      	ldrb	r3, [r7, r3]
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
		if(feedback != A0) /* feedback term is non-zero */
		{
			for(j = 1; j < NROOTS; j++)
 8006c1e:	2a20      	cmp	r2, #32
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
 8006c20:	ea83 030c 	eor.w	r3, r3, ip
 8006c24:	f801 3f01 	strb.w	r3, [r1, #1]!
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
		if(feedback != A0) /* feedback term is non-zero */
		{
			for(j = 1; j < NROOTS; j++)
 8006c28:	d1ef      	bne.n	8006c0a <encode_ssdv+0x151a>
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
		}
		
		/* Shift */
		memmove(&parity[0], &parity[1], sizeof(uint8_t) * (NROOTS - 1));
 8006c2a:	221f      	movs	r2, #31
 8006c2c:	4651      	mov	r1, sl
 8006c2e:	4640      	mov	r0, r8
 8006c30:	f00c feae 	bl	8013990 <memmove>
		if(feedback != A0)
			parity[NROOTS - 1] = ALPHA_TO[mod255(feedback + GENPOLY[0])];
 8006c34:	4b8a      	ldr	r3, [pc, #552]	; (8006e60 <encode_ssdv+0x1770>)
 8006c36:	5d9b      	ldrb	r3, [r3, r6]
 8006c38:	f888 301f 	strb.w	r3, [r8, #31]
	int i, j;
	uint8_t feedback;
	
	memset(parity, 0, NROOTS * sizeof(uint8_t));
	
	for(i = 0; i < NN - NROOTS - pad; i++)
 8006c3c:	45d9      	cmp	r9, fp
 8006c3e:	d1d4      	bne.n	8006bea <encode_ssdv+0x14fa>
 8006c40:	f7fe bf17 	b.w	8005a72 <encode_ssdv+0x382>
			for(j = 1; j < NROOTS; j++)
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
		}
		
		/* Shift */
		memmove(&parity[0], &parity[1], sizeof(uint8_t) * (NROOTS - 1));
 8006c44:	221f      	movs	r2, #31
 8006c46:	4651      	mov	r1, sl
 8006c48:	4640      	mov	r0, r8
 8006c4a:	f00c fea1 	bl	8013990 <memmove>
		if(feedback != A0)
			parity[NROOTS - 1] = ALPHA_TO[mod255(feedback + GENPOLY[0])];
		else
			parity[NROOTS - 1] = 0;
 8006c4e:	2300      	movs	r3, #0
 8006c50:	f888 301f 	strb.w	r3, [r8, #31]
 8006c54:	e7f2      	b.n	8006c3c <encode_ssdv+0x154c>
static uint32_t crc32(void *data, size_t length)
{
	uint32_t crc, x;
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
 8006c56:	4638      	mov	r0, r7
 8006c58:	463e      	mov	r6, r7
 8006c5a:	4639      	mov	r1, r7
 8006c5c:	46bc      	mov	ip, r7
 8006c5e:	f7fe beee 	b.w	8005a3e <encode_ssdv+0x34e>
			TRACE_ERROR("SSDV > The image must have 3 components");
			return(SSDV_ERROR);
		}
		
		/* Maximum image is 4080x4080 */
		if(s->width > 4080 || s->height > 4080)
 8006c62:	88e2      	ldrh	r2, [r4, #6]
 8006c64:	f5b2 6f7f 	cmp.w	r2, #4080	; 0xff0
 8006c68:	d803      	bhi.n	8006c72 <encode_ssdv+0x1582>
 8006c6a:	8923      	ldrh	r3, [r4, #8]
 8006c6c:	f5b3 6f7f 	cmp.w	r3, #4080	; 0xff0
 8006c70:	d97b      	bls.n	8006d6a <encode_ssdv+0x167a>
		{
			TRACE_ERROR("SSDV > The image is too big. Maximum resolution is 4080x4080");
 8006c72:	487d      	ldr	r0, [pc, #500]	; (8006e68 <encode_ssdv+0x1778>)
 8006c74:	4e7d      	ldr	r6, [pc, #500]	; (8006e6c <encode_ssdv+0x177c>)
 8006c76:	f008 f93b 	bl	800eef0 <chMtxLock>
 8006c7a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006c7e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8006c82:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006c84:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8006c86:	4b7a      	ldr	r3, [pc, #488]	; (8006e70 <encode_ssdv+0x1780>)
 8006c88:	497a      	ldr	r1, [pc, #488]	; (8006e74 <encode_ssdv+0x1784>)
 8006c8a:	487b      	ldr	r0, [pc, #492]	; (8006e78 <encode_ssdv+0x1788>)
 8006c8c:	fb05 f404 	mul.w	r4, r5, r4
 8006c90:	fba6 7404 	umull	r7, r4, r6, r4
 8006c94:	0ba4      	lsrs	r4, r4, #14
 8006c96:	fba3 7304 	umull	r7, r3, r3, r4
 8006c9a:	fba6 6202 	umull	r6, r2, r6, r2
 8006c9e:	099b      	lsrs	r3, r3, #6
 8006ca0:	fb05 4313 	mls	r3, r5, r3, r4
 8006ca4:	0b92      	lsrs	r2, r2, #14
 8006ca6:	f00b fd1b 	bl	80126e0 <chprintf.constprop.35>
 8006caa:	4a74      	ldr	r2, [pc, #464]	; (8006e7c <encode_ssdv+0x178c>)
 8006cac:	4974      	ldr	r1, [pc, #464]	; (8006e80 <encode_ssdv+0x1790>)
 8006cae:	4872      	ldr	r0, [pc, #456]	; (8006e78 <encode_ssdv+0x1788>)
 8006cb0:	f00b fd16 	bl	80126e0 <chprintf.constprop.35>
 8006cb4:	f44f 7329 	mov.w	r3, #676	; 0x2a4
 8006cb8:	4a72      	ldr	r2, [pc, #456]	; (8006e84 <encode_ssdv+0x1794>)
 8006cba:	4973      	ldr	r1, [pc, #460]	; (8006e88 <encode_ssdv+0x1798>)
 8006cbc:	486e      	ldr	r0, [pc, #440]	; (8006e78 <encode_ssdv+0x1788>)
 8006cbe:	f00b fd0f 	bl	80126e0 <chprintf.constprop.35>
 8006cc2:	4972      	ldr	r1, [pc, #456]	; (8006e8c <encode_ssdv+0x179c>)
 8006cc4:	486c      	ldr	r0, [pc, #432]	; (8006e78 <encode_ssdv+0x1788>)
 8006cc6:	f00b fd0b 	bl	80126e0 <chprintf.constprop.35>
 8006cca:	4971      	ldr	r1, [pc, #452]	; (8006e90 <encode_ssdv+0x17a0>)
 8006ccc:	486a      	ldr	r0, [pc, #424]	; (8006e78 <encode_ssdv+0x1788>)
 8006cce:	f00b fd07 	bl	80126e0 <chprintf.constprop.35>
 8006cd2:	4970      	ldr	r1, [pc, #448]	; (8006e94 <encode_ssdv+0x17a4>)
 8006cd4:	4868      	ldr	r0, [pc, #416]	; (8006e78 <encode_ssdv+0x1788>)
 8006cd6:	f00b fd03 	bl	80126e0 <chprintf.constprop.35>
 8006cda:	4863      	ldr	r0, [pc, #396]	; (8006e68 <encode_ssdv+0x1778>)
 8006cdc:	f008 f8a8 	bl	800ee30 <chMtxUnlock>
 8006ce0:	f44f 7129 	mov.w	r1, #676	; 0x2a4
 8006ce4:	4867      	ldr	r0, [pc, #412]	; (8006e84 <encode_ssdv+0x1794>)
 8006ce6:	f009 f93b 	bl	800ff60 <log_error>
 8006cea:	f7ff b92d 	b.w	8005f48 <encode_ssdv+0x858>
		/* 00 3F 00 */
		
		/* Verify all of the DQT and DHT tables where loaded */
		if(!s->sdqt[0] || !s->sdqt[1])
		{
			TRACE_ERROR("SSDV > The image is missing one or more DQT tables");
 8006cee:	485e      	ldr	r0, [pc, #376]	; (8006e68 <encode_ssdv+0x1778>)
 8006cf0:	4e5e      	ldr	r6, [pc, #376]	; (8006e6c <encode_ssdv+0x177c>)
 8006cf2:	f008 f8fd 	bl	800eef0 <chMtxLock>
 8006cf6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006cfa:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8006cfe:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006d00:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8006d02:	4b5b      	ldr	r3, [pc, #364]	; (8006e70 <encode_ssdv+0x1780>)
 8006d04:	495b      	ldr	r1, [pc, #364]	; (8006e74 <encode_ssdv+0x1784>)
 8006d06:	485c      	ldr	r0, [pc, #368]	; (8006e78 <encode_ssdv+0x1788>)
 8006d08:	fb05 f404 	mul.w	r4, r5, r4
 8006d0c:	fba6 7404 	umull	r7, r4, r6, r4
 8006d10:	0ba4      	lsrs	r4, r4, #14
 8006d12:	fba3 7304 	umull	r7, r3, r3, r4
 8006d16:	fba6 6202 	umull	r6, r2, r6, r2
 8006d1a:	099b      	lsrs	r3, r3, #6
 8006d1c:	fb05 4313 	mls	r3, r5, r3, r4
 8006d20:	0b92      	lsrs	r2, r2, #14
 8006d22:	f00b fcdd 	bl	80126e0 <chprintf.constprop.35>
 8006d26:	4a55      	ldr	r2, [pc, #340]	; (8006e7c <encode_ssdv+0x178c>)
 8006d28:	4955      	ldr	r1, [pc, #340]	; (8006e80 <encode_ssdv+0x1790>)
 8006d2a:	4853      	ldr	r0, [pc, #332]	; (8006e78 <encode_ssdv+0x1788>)
 8006d2c:	f00b fcd8 	bl	80126e0 <chprintf.constprop.35>
 8006d30:	f240 3302 	movw	r3, #770	; 0x302
 8006d34:	4a53      	ldr	r2, [pc, #332]	; (8006e84 <encode_ssdv+0x1794>)
 8006d36:	4954      	ldr	r1, [pc, #336]	; (8006e88 <encode_ssdv+0x1798>)
 8006d38:	484f      	ldr	r0, [pc, #316]	; (8006e78 <encode_ssdv+0x1788>)
 8006d3a:	f00b fcd1 	bl	80126e0 <chprintf.constprop.35>
 8006d3e:	4953      	ldr	r1, [pc, #332]	; (8006e8c <encode_ssdv+0x179c>)
 8006d40:	484d      	ldr	r0, [pc, #308]	; (8006e78 <encode_ssdv+0x1788>)
 8006d42:	f00b fccd 	bl	80126e0 <chprintf.constprop.35>
 8006d46:	4954      	ldr	r1, [pc, #336]	; (8006e98 <encode_ssdv+0x17a8>)
 8006d48:	484b      	ldr	r0, [pc, #300]	; (8006e78 <encode_ssdv+0x1788>)
 8006d4a:	f00b fcc9 	bl	80126e0 <chprintf.constprop.35>
 8006d4e:	4951      	ldr	r1, [pc, #324]	; (8006e94 <encode_ssdv+0x17a4>)
 8006d50:	4849      	ldr	r0, [pc, #292]	; (8006e78 <encode_ssdv+0x1788>)
 8006d52:	f00b fcc5 	bl	80126e0 <chprintf.constprop.35>
 8006d56:	4844      	ldr	r0, [pc, #272]	; (8006e68 <encode_ssdv+0x1778>)
 8006d58:	f008 f86a 	bl	800ee30 <chMtxUnlock>
 8006d5c:	f240 3102 	movw	r1, #770	; 0x302
 8006d60:	4848      	ldr	r0, [pc, #288]	; (8006e84 <encode_ssdv+0x1794>)
 8006d62:	f009 f8fd 	bl	800ff60 <log_error>
 8006d66:	f7ff b8ef 	b.w	8005f48 <encode_ssdv+0x858>
			TRACE_ERROR("SSDV > The image is too big. Maximum resolution is 4080x4080");
			return(SSDV_ERROR);
		}
		
		/* The image dimensions must be a multiple of 16 */
		if((s->width & 0x0F) || (s->height & 0x0F))
 8006d6a:	4313      	orrs	r3, r2
 8006d6c:	f013 030f 	ands.w	r3, r3, #15
 8006d70:	f000 809a 	beq.w	8006ea8 <encode_ssdv+0x17b8>
		{
			TRACE_ERROR("SSDV > The image dimensions must be a multiple of 16");
 8006d74:	483c      	ldr	r0, [pc, #240]	; (8006e68 <encode_ssdv+0x1778>)
 8006d76:	f008 f8bb 	bl	800eef0 <chMtxLock>
 8006d7a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006d7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006d7e:	493d      	ldr	r1, [pc, #244]	; (8006e74 <encode_ssdv+0x1784>)
 8006d80:	483d      	ldr	r0, [pc, #244]	; (8006e78 <encode_ssdv+0x1788>)
 8006d82:	fb08 f303 	mul.w	r3, r8, r3
 8006d86:	fba9 4303 	umull	r4, r3, r9, r3
 8006d8a:	0b9b      	lsrs	r3, r3, #14
 8006d8c:	fbaa 5403 	umull	r5, r4, sl, r3
 8006d90:	09a4      	lsrs	r4, r4, #6
 8006d92:	fba9 5202 	umull	r5, r2, r9, r2
 8006d96:	fb08 3314 	mls	r3, r8, r4, r3
 8006d9a:	0b92      	lsrs	r2, r2, #14
 8006d9c:	f00b fca0 	bl	80126e0 <chprintf.constprop.35>
 8006da0:	4a36      	ldr	r2, [pc, #216]	; (8006e7c <encode_ssdv+0x178c>)
 8006da2:	4937      	ldr	r1, [pc, #220]	; (8006e80 <encode_ssdv+0x1790>)
 8006da4:	4834      	ldr	r0, [pc, #208]	; (8006e78 <encode_ssdv+0x1788>)
 8006da6:	f00b fc9b 	bl	80126e0 <chprintf.constprop.35>
 8006daa:	f240 23ab 	movw	r3, #683	; 0x2ab
 8006dae:	4a35      	ldr	r2, [pc, #212]	; (8006e84 <encode_ssdv+0x1794>)
 8006db0:	4935      	ldr	r1, [pc, #212]	; (8006e88 <encode_ssdv+0x1798>)
 8006db2:	4831      	ldr	r0, [pc, #196]	; (8006e78 <encode_ssdv+0x1788>)
 8006db4:	f00b fc94 	bl	80126e0 <chprintf.constprop.35>
 8006db8:	4934      	ldr	r1, [pc, #208]	; (8006e8c <encode_ssdv+0x179c>)
 8006dba:	482f      	ldr	r0, [pc, #188]	; (8006e78 <encode_ssdv+0x1788>)
 8006dbc:	f00b fc90 	bl	80126e0 <chprintf.constprop.35>
 8006dc0:	4936      	ldr	r1, [pc, #216]	; (8006e9c <encode_ssdv+0x17ac>)
 8006dc2:	482d      	ldr	r0, [pc, #180]	; (8006e78 <encode_ssdv+0x1788>)
 8006dc4:	f00b fc8c 	bl	80126e0 <chprintf.constprop.35>
 8006dc8:	4932      	ldr	r1, [pc, #200]	; (8006e94 <encode_ssdv+0x17a4>)
 8006dca:	482b      	ldr	r0, [pc, #172]	; (8006e78 <encode_ssdv+0x1788>)
 8006dcc:	f00b fc88 	bl	80126e0 <chprintf.constprop.35>
 8006dd0:	4825      	ldr	r0, [pc, #148]	; (8006e68 <encode_ssdv+0x1778>)
 8006dd2:	f008 f82d 	bl	800ee30 <chMtxUnlock>
 8006dd6:	f240 21ab 	movw	r1, #683	; 0x2ab
 8006dda:	482a      	ldr	r0, [pc, #168]	; (8006e84 <encode_ssdv+0x1794>)
 8006ddc:	f009 f8c0 	bl	800ff60 <log_error>
 8006de0:	f7ff b8b2 	b.w	8005f48 <encode_ssdv+0x858>
		for(i = 0; i < 3; i++)
		{
			uint8_t *dh = &d[i * 2 + 1];
			if(dh[0] != i + 1)
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
 8006de4:	f008 f884 	bl	800eef0 <chMtxLock>
 8006de8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006dec:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8006df0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006df2:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8006df4:	4e1d      	ldr	r6, [pc, #116]	; (8006e6c <encode_ssdv+0x177c>)
 8006df6:	4b1e      	ldr	r3, [pc, #120]	; (8006e70 <encode_ssdv+0x1780>)
 8006df8:	491e      	ldr	r1, [pc, #120]	; (8006e74 <encode_ssdv+0x1784>)
 8006dfa:	481f      	ldr	r0, [pc, #124]	; (8006e78 <encode_ssdv+0x1788>)
 8006dfc:	fb05 f404 	mul.w	r4, r5, r4
 8006e00:	fba6 7404 	umull	r7, r4, r6, r4
 8006e04:	0ba4      	lsrs	r4, r4, #14
 8006e06:	fba3 7304 	umull	r7, r3, r3, r4
 8006e0a:	fba6 6202 	umull	r6, r2, r6, r2
 8006e0e:	099b      	lsrs	r3, r3, #6
 8006e10:	fb05 4313 	mls	r3, r5, r3, r4
 8006e14:	0b92      	lsrs	r2, r2, #14
 8006e16:	f00b fc63 	bl	80126e0 <chprintf.constprop.35>
 8006e1a:	4a18      	ldr	r2, [pc, #96]	; (8006e7c <encode_ssdv+0x178c>)
 8006e1c:	4918      	ldr	r1, [pc, #96]	; (8006e80 <encode_ssdv+0x1790>)
 8006e1e:	4816      	ldr	r0, [pc, #88]	; (8006e78 <encode_ssdv+0x1788>)
 8006e20:	f00b fc5e 	bl	80126e0 <chprintf.constprop.35>
 8006e24:	f240 23f5 	movw	r3, #757	; 0x2f5
 8006e28:	4a16      	ldr	r2, [pc, #88]	; (8006e84 <encode_ssdv+0x1794>)
 8006e2a:	4917      	ldr	r1, [pc, #92]	; (8006e88 <encode_ssdv+0x1798>)
 8006e2c:	4812      	ldr	r0, [pc, #72]	; (8006e78 <encode_ssdv+0x1788>)
 8006e2e:	f00b fc57 	bl	80126e0 <chprintf.constprop.35>
 8006e32:	4916      	ldr	r1, [pc, #88]	; (8006e8c <encode_ssdv+0x179c>)
 8006e34:	4810      	ldr	r0, [pc, #64]	; (8006e78 <encode_ssdv+0x1788>)
 8006e36:	f00b fc53 	bl	80126e0 <chprintf.constprop.35>
 8006e3a:	4919      	ldr	r1, [pc, #100]	; (8006ea0 <encode_ssdv+0x17b0>)
 8006e3c:	480e      	ldr	r0, [pc, #56]	; (8006e78 <encode_ssdv+0x1788>)
 8006e3e:	f00b fc4f 	bl	80126e0 <chprintf.constprop.35>
 8006e42:	4914      	ldr	r1, [pc, #80]	; (8006e94 <encode_ssdv+0x17a4>)
 8006e44:	480c      	ldr	r0, [pc, #48]	; (8006e78 <encode_ssdv+0x1788>)
 8006e46:	f00b fc4b 	bl	80126e0 <chprintf.constprop.35>
 8006e4a:	4807      	ldr	r0, [pc, #28]	; (8006e68 <encode_ssdv+0x1778>)
 8006e4c:	f007 fff0 	bl	800ee30 <chMtxUnlock>
 8006e50:	f240 21f5 	movw	r1, #757	; 0x2f5
 8006e54:	480b      	ldr	r0, [pc, #44]	; (8006e84 <encode_ssdv+0x1794>)
 8006e56:	f009 f883 	bl	800ff60 <log_error>
 8006e5a:	f7ff b875 	b.w	8005f48 <encode_ssdv+0x858>
 8006e5e:	bf00      	nop
 8006e60:	08014dcc 	.word	0x08014dcc
 8006e64:	08014ccc 	.word	0x08014ccc
 8006e68:	20027b2c 	.word	0x20027b2c
 8006e6c:	d1b71759 	.word	0xd1b71759
 8006e70:	10624dd3 	.word	0x10624dd3
 8006e74:	08013c50 	.word	0x08013c50
 8006e78:	20027e60 	.word	0x20027e60
 8006e7c:	08013d9c 	.word	0x08013d9c
 8006e80:	08013c5c 	.word	0x08013c5c
 8006e84:	0801491f 	.word	0x0801491f
 8006e88:	08013c78 	.word	0x08013c78
 8006e8c:	08013d00 	.word	0x08013d00
 8006e90:	080149c8 	.word	0x080149c8
 8006e94:	08013cac 	.word	0x08013cac
 8006e98:	08014b84 	.word	0x08014b84
 8006e9c:	08014a08 	.word	0x08014a08
 8006ea0:	08014a40 	.word	0x08014a40
 8006ea4:	080148eb 	.word	0x080148eb
		
		/* TODO: Read in the quantisation table ID for each component */
		// 01 22 00 02 11 01 03 11 01
		for(i = 0; i < 3; i++)
		{
			uint8_t *dq = &d[i * 3 + 6];
 8006ea8:	eb03 0843 	add.w	r8, r3, r3, lsl #1
 8006eac:	f108 0806 	add.w	r8, r8, #6
			if(dq[0] != i + 1)
 8006eb0:	3301      	adds	r3, #1
 8006eb2:	f815 7008 	ldrb.w	r7, [r5, r8]
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
 8006eb6:	489c      	ldr	r0, [pc, #624]	; (8007128 <encode_ssdv+0x1a38>)
		/* TODO: Read in the quantisation table ID for each component */
		// 01 22 00 02 11 01 03 11 01
		for(i = 0; i < 3; i++)
		{
			uint8_t *dq = &d[i * 3 + 6];
			if(dq[0] != i + 1)
 8006eb8:	429f      	cmp	r7, r3
 8006eba:	f04f 4a80 	mov.w	sl, #1073741824	; 0x40000000
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
 8006ebe:	f44f 7b7a 	mov.w	fp, #1000	; 0x3e8
		
		/* TODO: Read in the quantisation table ID for each component */
		// 01 22 00 02 11 01 03 11 01
		for(i = 0; i < 3; i++)
		{
			uint8_t *dq = &d[i * 3 + 6];
 8006ec2:	eb05 0908 	add.w	r9, r5, r8
			if(dq[0] != i + 1)
 8006ec6:	d157      	bne.n	8006f78 <encode_ssdv+0x1888>
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
 8006ec8:	f008 f812 	bl	800eef0 <chMtxLock>
 8006ecc:	f8da c024 	ldr.w	ip, [sl, #36]	; 0x24
 8006ed0:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 8006ed4:	4a95      	ldr	r2, [pc, #596]	; (800712c <encode_ssdv+0x1a3c>)
 8006ed6:	4996      	ldr	r1, [pc, #600]	; (8007130 <encode_ssdv+0x1a40>)
 8006ed8:	4896      	ldr	r0, [pc, #600]	; (8007134 <encode_ssdv+0x1a44>)
 8006eda:	fb0b f303 	mul.w	r3, fp, r3
 8006ede:	fba2 2303 	umull	r2, r3, r2, r3
 8006ee2:	4a95      	ldr	r2, [pc, #596]	; (8007138 <encode_ssdv+0x1a48>)
 8006ee4:	0b9b      	lsrs	r3, r3, #14
 8006ee6:	fba2 2e03 	umull	r2, lr, r2, r3
 8006eea:	4a90      	ldr	r2, [pc, #576]	; (800712c <encode_ssdv+0x1a3c>)
 8006eec:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8006ef0:	fba2 c20c 	umull	ip, r2, r2, ip
 8006ef4:	fb0b 331e 	mls	r3, fp, lr, r3
 8006ef8:	0b92      	lsrs	r2, r2, #14
 8006efa:	f00b fbf1 	bl	80126e0 <chprintf.constprop.35>
 8006efe:	4a8f      	ldr	r2, [pc, #572]	; (800713c <encode_ssdv+0x1a4c>)
 8006f00:	498f      	ldr	r1, [pc, #572]	; (8007140 <encode_ssdv+0x1a50>)
 8006f02:	488c      	ldr	r0, [pc, #560]	; (8007134 <encode_ssdv+0x1a44>)
 8006f04:	f00b fbec 	bl	80126e0 <chprintf.constprop.35>
 8006f08:	f240 23ba 	movw	r3, #698	; 0x2ba
 8006f0c:	4a8d      	ldr	r2, [pc, #564]	; (8007144 <encode_ssdv+0x1a54>)
 8006f0e:	498e      	ldr	r1, [pc, #568]	; (8007148 <encode_ssdv+0x1a58>)
 8006f10:	4888      	ldr	r0, [pc, #544]	; (8007134 <encode_ssdv+0x1a44>)
 8006f12:	f00b fbe5 	bl	80126e0 <chprintf.constprop.35>
 8006f16:	498d      	ldr	r1, [pc, #564]	; (800714c <encode_ssdv+0x1a5c>)
 8006f18:	4886      	ldr	r0, [pc, #536]	; (8007134 <encode_ssdv+0x1a44>)
 8006f1a:	f00b fbe1 	bl	80126e0 <chprintf.constprop.35>
 8006f1e:	f899 0001 	ldrb.w	r0, [r9, #1]
 8006f22:	f899 3002 	ldrb.w	r3, [r9, #2]
 8006f26:	f815 2008 	ldrb.w	r2, [r5, r8]
 8006f2a:	4989      	ldr	r1, [pc, #548]	; (8007150 <encode_ssdv+0x1a60>)
 8006f2c:	ea4f 1e10 	mov.w	lr, r0, lsr #4
 8006f30:	f000 000f 	and.w	r0, r0, #15
 8006f34:	e88d 4001 	stmia.w	sp, {r0, lr}
 8006f38:	487e      	ldr	r0, [pc, #504]	; (8007134 <encode_ssdv+0x1a44>)
 8006f3a:	f00b fbd1 	bl	80126e0 <chprintf.constprop.35>
 8006f3e:	4985      	ldr	r1, [pc, #532]	; (8007154 <encode_ssdv+0x1a64>)
 8006f40:	487c      	ldr	r0, [pc, #496]	; (8007134 <encode_ssdv+0x1a44>)
 8006f42:	f00b fbcd 	bl	80126e0 <chprintf.constprop.35>
 8006f46:	4878      	ldr	r0, [pc, #480]	; (8007128 <encode_ssdv+0x1a38>)
 8006f48:	f007 ff72 	bl	800ee30 <chMtxUnlock>
			
			/* The first (Y) component must have a factor of 2x2,2x1,1x2 or 1x1 */
			if(dq[0] == 1)
 8006f4c:	f815 3008 	ldrb.w	r3, [r5, r8]
 8006f50:	2b01      	cmp	r3, #1
			{
				switch(dq[1])
 8006f52:	f899 3001 	ldrb.w	r3, [r9, #1]
			}
			
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
			
			/* The first (Y) component must have a factor of 2x2,2x1,1x2 or 1x1 */
			if(dq[0] == 1)
 8006f56:	f000 808a 	beq.w	800706e <encode_ssdv+0x197e>
				default:
					TRACE_ERROR("SSDV > Component 1 sampling factor is not supported");
					return(SSDV_ERROR);
				}
			}
			else if(dq[0] != 1 && dq[1] != 0x11)
 8006f5a:	2b11      	cmp	r3, #17
 8006f5c:	d148      	bne.n	8006ff0 <encode_ssdv+0x1900>
			return(SSDV_ERROR);
		}
		
		/* TODO: Read in the quantisation table ID for each component */
		// 01 22 00 02 11 01 03 11 01
		for(i = 0; i < 3; i++)
 8006f5e:	2f03      	cmp	r7, #3
 8006f60:	463b      	mov	r3, r7
 8006f62:	d1a1      	bne.n	8006ea8 <encode_ssdv+0x17b8>
				return(SSDV_ERROR);
			}
		}
		
		/* Calculate number of MCU blocks in this image */
		switch(s->mcu_mode)
 8006f64:	7d23      	ldrb	r3, [r4, #20]
 8006f66:	2b03      	cmp	r3, #3
 8006f68:	f200 8096 	bhi.w	8007098 <encode_ssdv+0x19a8>
 8006f6c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8006f70:	0191018a 	.word	0x0191018a
 8006f74:	008e0183 	.word	0x008e0183
		for(i = 0; i < 3; i++)
		{
			uint8_t *dq = &d[i * 3 + 6];
			if(dq[0] != i + 1)
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
 8006f78:	f007 ffba 	bl	800eef0 <chMtxLock>
 8006f7c:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
 8006f80:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
 8006f84:	4e69      	ldr	r6, [pc, #420]	; (800712c <encode_ssdv+0x1a3c>)
 8006f86:	4b6c      	ldr	r3, [pc, #432]	; (8007138 <encode_ssdv+0x1a48>)
 8006f88:	4969      	ldr	r1, [pc, #420]	; (8007130 <encode_ssdv+0x1a40>)
 8006f8a:	486a      	ldr	r0, [pc, #424]	; (8007134 <encode_ssdv+0x1a44>)
 8006f8c:	465d      	mov	r5, fp
 8006f8e:	fb05 f404 	mul.w	r4, r5, r4
 8006f92:	fba6 7404 	umull	r7, r4, r6, r4
 8006f96:	0ba4      	lsrs	r4, r4, #14
 8006f98:	fba3 7304 	umull	r7, r3, r3, r4
 8006f9c:	fba6 6202 	umull	r6, r2, r6, r2
 8006fa0:	099b      	lsrs	r3, r3, #6
 8006fa2:	fb0b 4313 	mls	r3, fp, r3, r4
 8006fa6:	0b92      	lsrs	r2, r2, #14
 8006fa8:	f00b fb9a 	bl	80126e0 <chprintf.constprop.35>
 8006fac:	4a6a      	ldr	r2, [pc, #424]	; (8007158 <encode_ssdv+0x1a68>)
 8006fae:	4964      	ldr	r1, [pc, #400]	; (8007140 <encode_ssdv+0x1a50>)
 8006fb0:	4860      	ldr	r0, [pc, #384]	; (8007134 <encode_ssdv+0x1a44>)
 8006fb2:	f00b fb95 	bl	80126e0 <chprintf.constprop.35>
 8006fb6:	f240 23b6 	movw	r3, #694	; 0x2b6
 8006fba:	4a62      	ldr	r2, [pc, #392]	; (8007144 <encode_ssdv+0x1a54>)
 8006fbc:	4962      	ldr	r1, [pc, #392]	; (8007148 <encode_ssdv+0x1a58>)
 8006fbe:	485d      	ldr	r0, [pc, #372]	; (8007134 <encode_ssdv+0x1a44>)
 8006fc0:	f00b fb8e 	bl	80126e0 <chprintf.constprop.35>
 8006fc4:	4961      	ldr	r1, [pc, #388]	; (800714c <encode_ssdv+0x1a5c>)
 8006fc6:	485b      	ldr	r0, [pc, #364]	; (8007134 <encode_ssdv+0x1a44>)
 8006fc8:	f00b fb8a 	bl	80126e0 <chprintf.constprop.35>
 8006fcc:	4963      	ldr	r1, [pc, #396]	; (800715c <encode_ssdv+0x1a6c>)
 8006fce:	4859      	ldr	r0, [pc, #356]	; (8007134 <encode_ssdv+0x1a44>)
 8006fd0:	f00b fb86 	bl	80126e0 <chprintf.constprop.35>
 8006fd4:	495f      	ldr	r1, [pc, #380]	; (8007154 <encode_ssdv+0x1a64>)
 8006fd6:	4857      	ldr	r0, [pc, #348]	; (8007134 <encode_ssdv+0x1a44>)
 8006fd8:	f00b fb82 	bl	80126e0 <chprintf.constprop.35>
 8006fdc:	4852      	ldr	r0, [pc, #328]	; (8007128 <encode_ssdv+0x1a38>)
 8006fde:	f007 ff27 	bl	800ee30 <chMtxUnlock>
 8006fe2:	f240 21b6 	movw	r1, #694	; 0x2b6
 8006fe6:	4857      	ldr	r0, [pc, #348]	; (8007144 <encode_ssdv+0x1a54>)
 8006fe8:	f008 ffba 	bl	800ff60 <log_error>
 8006fec:	f7fe bfac 	b.w	8005f48 <encode_ssdv+0x858>
					return(SSDV_ERROR);
				}
			}
			else if(dq[0] != 1 && dq[1] != 0x11)
			{
				TRACE_ERROR("SSDV > Component %i sampling factor must be 1x1", dq[0]);
 8006ff0:	484d      	ldr	r0, [pc, #308]	; (8007128 <encode_ssdv+0x1a38>)
 8006ff2:	4c4e      	ldr	r4, [pc, #312]	; (800712c <encode_ssdv+0x1a3c>)
 8006ff4:	f007 ff7c 	bl	800eef0 <chMtxLock>
 8006ff8:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
 8006ffc:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 8007000:	494b      	ldr	r1, [pc, #300]	; (8007130 <encode_ssdv+0x1a40>)
 8007002:	484c      	ldr	r0, [pc, #304]	; (8007134 <encode_ssdv+0x1a44>)
 8007004:	fb0b f303 	mul.w	r3, fp, r3
 8007008:	fba4 4303 	umull	r4, r3, r4, r3
 800700c:	4c4a      	ldr	r4, [pc, #296]	; (8007138 <encode_ssdv+0x1a48>)
 800700e:	0b9b      	lsrs	r3, r3, #14
 8007010:	fba4 5403 	umull	r5, r4, r4, r3
 8007014:	4d45      	ldr	r5, [pc, #276]	; (800712c <encode_ssdv+0x1a3c>)
 8007016:	09a4      	lsrs	r4, r4, #6
 8007018:	fba5 5202 	umull	r5, r2, r5, r2
 800701c:	fb0b 3314 	mls	r3, fp, r4, r3
 8007020:	0b92      	lsrs	r2, r2, #14
 8007022:	f00b fb5d 	bl	80126e0 <chprintf.constprop.35>
 8007026:	4a4c      	ldr	r2, [pc, #304]	; (8007158 <encode_ssdv+0x1a68>)
 8007028:	4945      	ldr	r1, [pc, #276]	; (8007140 <encode_ssdv+0x1a50>)
 800702a:	4842      	ldr	r0, [pc, #264]	; (8007134 <encode_ssdv+0x1a44>)
 800702c:	f00b fb58 	bl	80126e0 <chprintf.constprop.35>
 8007030:	f44f 7333 	mov.w	r3, #716	; 0x2cc
 8007034:	4a43      	ldr	r2, [pc, #268]	; (8007144 <encode_ssdv+0x1a54>)
 8007036:	4944      	ldr	r1, [pc, #272]	; (8007148 <encode_ssdv+0x1a58>)
 8007038:	483e      	ldr	r0, [pc, #248]	; (8007134 <encode_ssdv+0x1a44>)
 800703a:	f00b fb51 	bl	80126e0 <chprintf.constprop.35>
 800703e:	4943      	ldr	r1, [pc, #268]	; (800714c <encode_ssdv+0x1a5c>)
 8007040:	483c      	ldr	r0, [pc, #240]	; (8007134 <encode_ssdv+0x1a44>)
 8007042:	f00b fb4d 	bl	80126e0 <chprintf.constprop.35>
 8007046:	f899 2000 	ldrb.w	r2, [r9]
 800704a:	4945      	ldr	r1, [pc, #276]	; (8007160 <encode_ssdv+0x1a70>)
 800704c:	4839      	ldr	r0, [pc, #228]	; (8007134 <encode_ssdv+0x1a44>)
 800704e:	f00b fb47 	bl	80126e0 <chprintf.constprop.35>
 8007052:	4940      	ldr	r1, [pc, #256]	; (8007154 <encode_ssdv+0x1a64>)
 8007054:	4837      	ldr	r0, [pc, #220]	; (8007134 <encode_ssdv+0x1a44>)
 8007056:	f00b fb43 	bl	80126e0 <chprintf.constprop.35>
 800705a:	4833      	ldr	r0, [pc, #204]	; (8007128 <encode_ssdv+0x1a38>)
 800705c:	f007 fee8 	bl	800ee30 <chMtxUnlock>
 8007060:	f44f 7133 	mov.w	r1, #716	; 0x2cc
 8007064:	4837      	ldr	r0, [pc, #220]	; (8007144 <encode_ssdv+0x1a54>)
 8007066:	f008 ff7b 	bl	800ff60 <log_error>
 800706a:	f7fe bf6d 	b.w	8005f48 <encode_ssdv+0x858>
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
			
			/* The first (Y) component must have a factor of 2x2,2x1,1x2 or 1x1 */
			if(dq[0] == 1)
			{
				switch(dq[1])
 800706e:	3b11      	subs	r3, #17
 8007070:	2b11      	cmp	r3, #17
 8007072:	f200 80c2 	bhi.w	80071fa <encode_ssdv+0x1b0a>
 8007076:	e8df f003 	tbb	[pc, r3]
 800707a:	b4ba      	.short	0xb4ba
 800707c:	c0c0c0c0 	.word	0xc0c0c0c0
 8007080:	c0c0c0c0 	.word	0xc0c0c0c0
 8007084:	c0c0c0c0 	.word	0xc0c0c0c0
 8007088:	51afc0c0 	.word	0x51afc0c0
		switch(s->mcu_mode)
		{
		case 0: l = (s->width >> 4) * (s->height >> 4); break;
		case 1: l = (s->width >> 4) * (s->height >> 3); break;
		case 2: l = (s->width >> 3) * (s->height >> 4); break;
		case 3: l = (s->width >> 3) * (s->height >> 3); break;
 800708c:	88e3      	ldrh	r3, [r4, #6]
 800708e:	8926      	ldrh	r6, [r4, #8]
 8007090:	08db      	lsrs	r3, r3, #3
 8007092:	08f6      	lsrs	r6, r6, #3
 8007094:	fb06 f603 	mul.w	r6, r6, r3
 8007098:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
		}
		
		TRACE_INFO("SSDV > MCU blocks: %i", (int) l);
 800709c:	4822      	ldr	r0, [pc, #136]	; (8007128 <encode_ssdv+0x1a38>)
 800709e:	f8df 908c 	ldr.w	r9, [pc, #140]	; 800712c <encode_ssdv+0x1a3c>
 80070a2:	f007 ff25 	bl	800eef0 <chMtxLock>
 80070a6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80070a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80070aa:	4921      	ldr	r1, [pc, #132]	; (8007130 <encode_ssdv+0x1a40>)
 80070ac:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
 80070b0:	4648      	mov	r0, r9
 80070b2:	fb08 f303 	mul.w	r3, r8, r3
 80070b6:	fba0 0303 	umull	r0, r3, r0, r3
 80070ba:	481f      	ldr	r0, [pc, #124]	; (8007138 <encode_ssdv+0x1a48>)
 80070bc:	0b9b      	lsrs	r3, r3, #14
 80070be:	fba0 5003 	umull	r5, r0, r0, r3
 80070c2:	464d      	mov	r5, r9
 80070c4:	fba5 5202 	umull	r5, r2, r5, r2
 80070c8:	0980      	lsrs	r0, r0, #6
 80070ca:	fb08 3310 	mls	r3, r8, r0, r3
 80070ce:	0b92      	lsrs	r2, r2, #14
 80070d0:	4818      	ldr	r0, [pc, #96]	; (8007134 <encode_ssdv+0x1a44>)
 80070d2:	4d19      	ldr	r5, [pc, #100]	; (8007138 <encode_ssdv+0x1a48>)
 80070d4:	f00b fb04 	bl	80126e0 <chprintf.constprop.35>
 80070d8:	4a18      	ldr	r2, [pc, #96]	; (800713c <encode_ssdv+0x1a4c>)
 80070da:	4919      	ldr	r1, [pc, #100]	; (8007140 <encode_ssdv+0x1a50>)
 80070dc:	4815      	ldr	r0, [pc, #84]	; (8007134 <encode_ssdv+0x1a44>)
 80070de:	f00b faff 	bl	80126e0 <chprintf.constprop.35>
 80070e2:	f240 23da 	movw	r3, #730	; 0x2da
 80070e6:	4a17      	ldr	r2, [pc, #92]	; (8007144 <encode_ssdv+0x1a54>)
 80070e8:	4917      	ldr	r1, [pc, #92]	; (8007148 <encode_ssdv+0x1a58>)
 80070ea:	4812      	ldr	r0, [pc, #72]	; (8007134 <encode_ssdv+0x1a44>)
 80070ec:	f00b faf8 	bl	80126e0 <chprintf.constprop.35>
 80070f0:	4916      	ldr	r1, [pc, #88]	; (800714c <encode_ssdv+0x1a5c>)
 80070f2:	4810      	ldr	r0, [pc, #64]	; (8007134 <encode_ssdv+0x1a44>)
 80070f4:	f00b faf4 	bl	80126e0 <chprintf.constprop.35>
 80070f8:	4632      	mov	r2, r6
 80070fa:	491a      	ldr	r1, [pc, #104]	; (8007164 <encode_ssdv+0x1a74>)
 80070fc:	480d      	ldr	r0, [pc, #52]	; (8007134 <encode_ssdv+0x1a44>)
 80070fe:	f00b faef 	bl	80126e0 <chprintf.constprop.35>
 8007102:	4914      	ldr	r1, [pc, #80]	; (8007154 <encode_ssdv+0x1a64>)
 8007104:	480b      	ldr	r0, [pc, #44]	; (8007134 <encode_ssdv+0x1a44>)
 8007106:	f00b faeb 	bl	80126e0 <chprintf.constprop.35>
 800710a:	4807      	ldr	r0, [pc, #28]	; (8007128 <encode_ssdv+0x1a38>)
 800710c:	f007 fe90 	bl	800ee30 <chMtxUnlock>
		
		if(l > 0xFFFF)
 8007110:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
 8007114:	d228      	bcs.n	8007168 <encode_ssdv+0x1a78>
		{
			TRACE_ERROR("SSDV > Maximum number of MCU blocks is 65535");
			return(SSDV_ERROR);
		}
		
		s->mcu_count = l;
 8007116:	8326      	strh	r6, [r4, #24]
 8007118:	f7fe be64 	b.w	8005de4 <encode_ssdv+0x6f4>
			/* The first (Y) component must have a factor of 2x2,2x1,1x2 or 1x1 */
			if(dq[0] == 1)
			{
				switch(dq[1])
				{
				case 0x22: s->mcu_mode = 0; s->ycparts = 4; break;
 800711c:	2200      	movs	r2, #0
 800711e:	2304      	movs	r3, #4
 8007120:	7522      	strb	r2, [r4, #20]
 8007122:	f884 3057 	strb.w	r3, [r4, #87]	; 0x57
 8007126:	e71a      	b.n	8006f5e <encode_ssdv+0x186e>
 8007128:	20027b2c 	.word	0x20027b2c
 800712c:	d1b71759 	.word	0xd1b71759
 8007130:	08013c50 	.word	0x08013c50
 8007134:	20027e60 	.word	0x20027e60
 8007138:	10624dd3 	.word	0x10624dd3
 800713c:	08013cfc 	.word	0x08013cfc
 8007140:	08013c5c 	.word	0x08013c5c
 8007144:	0801491f 	.word	0x0801491f
 8007148:	08013c78 	.word	0x08013c78
 800714c:	08013d00 	.word	0x08013d00
 8007150:	08014a78 	.word	0x08014a78
 8007154:	08013cac 	.word	0x08013cac
 8007158:	08013d9c 	.word	0x08013d9c
 800715c:	08014a40 	.word	0x08014a40
 8007160:	08014aec 	.word	0x08014aec
 8007164:	08014b1c 	.word	0x08014b1c
		
		TRACE_INFO("SSDV > MCU blocks: %i", (int) l);
		
		if(l > 0xFFFF)
		{
			TRACE_ERROR("SSDV > Maximum number of MCU blocks is 65535");
 8007168:	484d      	ldr	r0, [pc, #308]	; (80072a0 <encode_ssdv+0x1bb0>)
 800716a:	f007 fec1 	bl	800eef0 <chMtxLock>
 800716e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007170:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007172:	494c      	ldr	r1, [pc, #304]	; (80072a4 <encode_ssdv+0x1bb4>)
 8007174:	484c      	ldr	r0, [pc, #304]	; (80072a8 <encode_ssdv+0x1bb8>)
 8007176:	fb08 f303 	mul.w	r3, r8, r3
 800717a:	fba9 4303 	umull	r4, r3, r9, r3
 800717e:	0b9b      	lsrs	r3, r3, #14
 8007180:	fba5 5403 	umull	r5, r4, r5, r3
 8007184:	09a4      	lsrs	r4, r4, #6
 8007186:	fba9 5202 	umull	r5, r2, r9, r2
 800718a:	fb08 3314 	mls	r3, r8, r4, r3
 800718e:	0b92      	lsrs	r2, r2, #14
 8007190:	f00b faa6 	bl	80126e0 <chprintf.constprop.35>
 8007194:	4a45      	ldr	r2, [pc, #276]	; (80072ac <encode_ssdv+0x1bbc>)
 8007196:	4946      	ldr	r1, [pc, #280]	; (80072b0 <encode_ssdv+0x1bc0>)
 8007198:	4843      	ldr	r0, [pc, #268]	; (80072a8 <encode_ssdv+0x1bb8>)
 800719a:	f00b faa1 	bl	80126e0 <chprintf.constprop.35>
 800719e:	f240 23de 	movw	r3, #734	; 0x2de
 80071a2:	4a44      	ldr	r2, [pc, #272]	; (80072b4 <encode_ssdv+0x1bc4>)
 80071a4:	4944      	ldr	r1, [pc, #272]	; (80072b8 <encode_ssdv+0x1bc8>)
 80071a6:	4840      	ldr	r0, [pc, #256]	; (80072a8 <encode_ssdv+0x1bb8>)
 80071a8:	f00b fa9a 	bl	80126e0 <chprintf.constprop.35>
 80071ac:	4943      	ldr	r1, [pc, #268]	; (80072bc <encode_ssdv+0x1bcc>)
 80071ae:	483e      	ldr	r0, [pc, #248]	; (80072a8 <encode_ssdv+0x1bb8>)
 80071b0:	f00b fa96 	bl	80126e0 <chprintf.constprop.35>
 80071b4:	4942      	ldr	r1, [pc, #264]	; (80072c0 <encode_ssdv+0x1bd0>)
 80071b6:	483c      	ldr	r0, [pc, #240]	; (80072a8 <encode_ssdv+0x1bb8>)
 80071b8:	f00b fa92 	bl	80126e0 <chprintf.constprop.35>
 80071bc:	4941      	ldr	r1, [pc, #260]	; (80072c4 <encode_ssdv+0x1bd4>)
 80071be:	483a      	ldr	r0, [pc, #232]	; (80072a8 <encode_ssdv+0x1bb8>)
 80071c0:	f00b fa8e 	bl	80126e0 <chprintf.constprop.35>
 80071c4:	4836      	ldr	r0, [pc, #216]	; (80072a0 <encode_ssdv+0x1bb0>)
 80071c6:	f007 fe33 	bl	800ee30 <chMtxUnlock>
 80071ca:	f240 21de 	movw	r1, #734	; 0x2de
 80071ce:	4839      	ldr	r0, [pc, #228]	; (80072b4 <encode_ssdv+0x1bc4>)
 80071d0:	f008 fec6 	bl	800ff60 <log_error>
 80071d4:	f7fe beb8 	b.w	8005f48 <encode_ssdv+0x858>
			{
				switch(dq[1])
				{
				case 0x22: s->mcu_mode = 0; s->ycparts = 4; break;
				case 0x12: s->mcu_mode = 1; s->ycparts = 2; break;
				case 0x21: s->mcu_mode = 2; s->ycparts = 2; break;
 80071d8:	2302      	movs	r3, #2
 80071da:	7523      	strb	r3, [r4, #20]
 80071dc:	f884 3057 	strb.w	r3, [r4, #87]	; 0x57
 80071e0:	e6bd      	b.n	8006f5e <encode_ssdv+0x186e>
			if(dq[0] == 1)
			{
				switch(dq[1])
				{
				case 0x22: s->mcu_mode = 0; s->ycparts = 4; break;
				case 0x12: s->mcu_mode = 1; s->ycparts = 2; break;
 80071e2:	2201      	movs	r2, #1
 80071e4:	2302      	movs	r3, #2
 80071e6:	7522      	strb	r2, [r4, #20]
 80071e8:	f884 3057 	strb.w	r3, [r4, #87]	; 0x57
 80071ec:	e6b7      	b.n	8006f5e <encode_ssdv+0x186e>
				case 0x21: s->mcu_mode = 2; s->ycparts = 2; break;
				case 0x11: s->mcu_mode = 3; s->ycparts = 1; break;
 80071ee:	2203      	movs	r2, #3
 80071f0:	2301      	movs	r3, #1
 80071f2:	7522      	strb	r2, [r4, #20]
 80071f4:	f884 3057 	strb.w	r3, [r4, #87]	; 0x57
 80071f8:	e6b1      	b.n	8006f5e <encode_ssdv+0x186e>
				default:
					TRACE_ERROR("SSDV > Component 1 sampling factor is not supported");
 80071fa:	4829      	ldr	r0, [pc, #164]	; (80072a0 <encode_ssdv+0x1bb0>)
 80071fc:	4e32      	ldr	r6, [pc, #200]	; (80072c8 <encode_ssdv+0x1bd8>)
 80071fe:	f007 fe77 	bl	800eef0 <chMtxLock>
 8007202:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007206:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800720a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800720c:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800720e:	4b2f      	ldr	r3, [pc, #188]	; (80072cc <encode_ssdv+0x1bdc>)
 8007210:	4924      	ldr	r1, [pc, #144]	; (80072a4 <encode_ssdv+0x1bb4>)
 8007212:	4825      	ldr	r0, [pc, #148]	; (80072a8 <encode_ssdv+0x1bb8>)
 8007214:	fb05 f404 	mul.w	r4, r5, r4
 8007218:	fba6 7404 	umull	r7, r4, r6, r4
 800721c:	0ba4      	lsrs	r4, r4, #14
 800721e:	fba3 7304 	umull	r7, r3, r3, r4
 8007222:	fba6 6202 	umull	r6, r2, r6, r2
 8007226:	099b      	lsrs	r3, r3, #6
 8007228:	fb05 4313 	mls	r3, r5, r3, r4
 800722c:	0b92      	lsrs	r2, r2, #14
 800722e:	f00b fa57 	bl	80126e0 <chprintf.constprop.35>
 8007232:	4a1e      	ldr	r2, [pc, #120]	; (80072ac <encode_ssdv+0x1bbc>)
 8007234:	491e      	ldr	r1, [pc, #120]	; (80072b0 <encode_ssdv+0x1bc0>)
 8007236:	481c      	ldr	r0, [pc, #112]	; (80072a8 <encode_ssdv+0x1bb8>)
 8007238:	f00b fa52 	bl	80126e0 <chprintf.constprop.35>
 800723c:	f240 23c6 	movw	r3, #710	; 0x2c6
 8007240:	4a1c      	ldr	r2, [pc, #112]	; (80072b4 <encode_ssdv+0x1bc4>)
 8007242:	491d      	ldr	r1, [pc, #116]	; (80072b8 <encode_ssdv+0x1bc8>)
 8007244:	4818      	ldr	r0, [pc, #96]	; (80072a8 <encode_ssdv+0x1bb8>)
 8007246:	f00b fa4b 	bl	80126e0 <chprintf.constprop.35>
 800724a:	491c      	ldr	r1, [pc, #112]	; (80072bc <encode_ssdv+0x1bcc>)
 800724c:	4816      	ldr	r0, [pc, #88]	; (80072a8 <encode_ssdv+0x1bb8>)
 800724e:	f00b fa47 	bl	80126e0 <chprintf.constprop.35>
 8007252:	491f      	ldr	r1, [pc, #124]	; (80072d0 <encode_ssdv+0x1be0>)
 8007254:	4814      	ldr	r0, [pc, #80]	; (80072a8 <encode_ssdv+0x1bb8>)
 8007256:	f00b fa43 	bl	80126e0 <chprintf.constprop.35>
 800725a:	491a      	ldr	r1, [pc, #104]	; (80072c4 <encode_ssdv+0x1bd4>)
 800725c:	4812      	ldr	r0, [pc, #72]	; (80072a8 <encode_ssdv+0x1bb8>)
 800725e:	f00b fa3f 	bl	80126e0 <chprintf.constprop.35>
 8007262:	480f      	ldr	r0, [pc, #60]	; (80072a0 <encode_ssdv+0x1bb0>)
 8007264:	f007 fde4 	bl	800ee30 <chMtxUnlock>
 8007268:	f240 21c6 	movw	r1, #710	; 0x2c6
 800726c:	4811      	ldr	r0, [pc, #68]	; (80072b4 <encode_ssdv+0x1bc4>)
 800726e:	f008 fe77 	bl	800ff60 <log_error>
 8007272:	f7fe be69 	b.w	8005f48 <encode_ssdv+0x858>
		/* Calculate number of MCU blocks in this image */
		switch(s->mcu_mode)
		{
		case 0: l = (s->width >> 4) * (s->height >> 4); break;
		case 1: l = (s->width >> 4) * (s->height >> 3); break;
		case 2: l = (s->width >> 3) * (s->height >> 4); break;
 8007276:	88e3      	ldrh	r3, [r4, #6]
 8007278:	8926      	ldrh	r6, [r4, #8]
 800727a:	08db      	lsrs	r3, r3, #3
 800727c:	0936      	lsrs	r6, r6, #4
 800727e:	fb06 f603 	mul.w	r6, r6, r3
 8007282:	e709      	b.n	8007098 <encode_ssdv+0x19a8>
		}
		
		/* Calculate number of MCU blocks in this image */
		switch(s->mcu_mode)
		{
		case 0: l = (s->width >> 4) * (s->height >> 4); break;
 8007284:	88e3      	ldrh	r3, [r4, #6]
 8007286:	8926      	ldrh	r6, [r4, #8]
 8007288:	091b      	lsrs	r3, r3, #4
 800728a:	0936      	lsrs	r6, r6, #4
 800728c:	fb06 f603 	mul.w	r6, r6, r3
 8007290:	e702      	b.n	8007098 <encode_ssdv+0x19a8>
		case 1: l = (s->width >> 4) * (s->height >> 3); break;
 8007292:	88e3      	ldrh	r3, [r4, #6]
 8007294:	8926      	ldrh	r6, [r4, #8]
 8007296:	091b      	lsrs	r3, r3, #4
 8007298:	08f6      	lsrs	r6, r6, #3
 800729a:	fb06 f603 	mul.w	r6, r6, r3
 800729e:	e6fb      	b.n	8007098 <encode_ssdv+0x19a8>
 80072a0:	20027b2c 	.word	0x20027b2c
 80072a4:	08013c50 	.word	0x08013c50
 80072a8:	20027e60 	.word	0x20027e60
 80072ac:	08013d9c 	.word	0x08013d9c
 80072b0:	08013c5c 	.word	0x08013c5c
 80072b4:	0801491f 	.word	0x0801491f
 80072b8:	08013c78 	.word	0x08013c78
 80072bc:	08013d00 	.word	0x08013d00
 80072c0:	08014b34 	.word	0x08014b34
 80072c4:	08013cac 	.word	0x08013cac
 80072c8:	d1b71759 	.word	0xd1b71759
 80072cc:	10624dd3 	.word	0x10624dd3
 80072d0:	08014ab8 	.word	0x08014ab8
	...

080072e0 <main>:
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 80072e0:	4b20      	ldr	r3, [pc, #128]	; (8007364 <main+0x84>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80072e2:	4c21      	ldr	r4, [pc, #132]	; (8007368 <main+0x88>)
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 80072e4:	691a      	ldr	r2, [r3, #16]
 80072e6:	f04f 31ff 	mov.w	r1, #4294967295
 80072ea:	2200      	movs	r2, #0
}

/**
  * Main routine is starting up system, runs the software watchdog (module monitoring), controls LEDs
  */
int main(void) {
 80072ec:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80072f0:	6119      	str	r1, [r3, #16]
 80072f2:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 80072f4:	6958      	ldr	r0, [r3, #20]
 80072f6:	6159      	str	r1, [r3, #20]
 80072f8:	615a      	str	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80072fa:	6a18      	ldr	r0, [r3, #32]
 80072fc:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8007300:	6218      	str	r0, [r3, #32]
 8007302:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8007304:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8007306:	6259      	str	r1, [r3, #36]	; 0x24
 8007308:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800730a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800730c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8007310:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8007312:	6821      	ldr	r1, [r4, #0]
 8007314:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8007318:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800731a:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800731c:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8007320:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8007324:	b08f      	sub	sp, #60	; 0x3c
 8007326:	d003      	beq.n	8007330 <main+0x50>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8007328:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800732c:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800732e:	671a      	str	r2, [r3, #112]	; 0x70
#endif

#if HAL_USE_RTC
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8007330:	4b0c      	ldr	r3, [pc, #48]	; (8007364 <main+0x84>)
 8007332:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8007334:	0412      	lsls	r2, r2, #16
 8007336:	d407      	bmi.n	8007348 <main+0x68>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8007338:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800733a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800733e:	671a      	str	r2, [r3, #112]	; 0x70

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8007340:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8007342:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8007346:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8007348:	4e07      	ldr	r6, [pc, #28]	; (8007368 <main+0x88>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 800734a:	4f08      	ldr	r7, [pc, #32]	; (800736c <main+0x8c>)
 800734c:	6870      	ldr	r0, [r6, #4]
 800734e:	4908      	ldr	r1, [pc, #32]	; (8007370 <main+0x90>)
 8007350:	4a08      	ldr	r2, [pc, #32]	; (8007374 <main+0x94>)
 8007352:	4c09      	ldr	r4, [pc, #36]	; (8007378 <main+0x98>)
 8007354:	2500      	movs	r5, #0
 8007356:	f420 7000 	bic.w	r0, r0, #512	; 0x200
 800735a:	6070      	str	r0, [r6, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 800735c:	462b      	mov	r3, r5
    _stm32_dma_streams[i].stream->CR = 0U;
 800735e:	4628      	mov	r0, r5
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 8007360:	603d      	str	r5, [r7, #0]
 8007362:	e00d      	b.n	8007380 <main+0xa0>
 8007364:	40023800 	.word	0x40023800
 8007368:	40007000 	.word	0x40007000
 800736c:	20027728 	.word	0x20027728
 8007370:	08014f98 	.word	0x08014f98
 8007374:	40026010 	.word	0x40026010
 8007378:	20005f28 	.word	0x20005f28
 800737c:	f851 2c0c 	ldr.w	r2, [r1, #-12]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
 8007380:	6010      	str	r0, [r2, #0]
    dma_isr_redir[i].dma_func = NULL;
 8007382:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8007386:	3301      	adds	r3, #1
 8007388:	2b10      	cmp	r3, #16
 800738a:	f101 010c 	add.w	r1, r1, #12
    _stm32_dma_streams[i].stream->CR = 0U;
 800738e:	f04f 0200 	mov.w	r2, #0
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8007392:	d1f3      	bne.n	800737c <main+0x9c>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8007394:	4cba      	ldr	r4, [pc, #744]	; (8007680 <main+0x3a0>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8007396:	48bb      	ldr	r0, [pc, #748]	; (8007684 <main+0x3a4>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8007398:	f8df e358 	ldr.w	lr, [pc, #856]	; 80076f4 <main+0x414>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800739c:	f8df c360 	ldr.w	ip, [pc, #864]	; 8007700 <main+0x420>
 80073a0:	4eb9      	ldr	r6, [pc, #740]	; (8007688 <main+0x3a8>)
 80073a2:	4fba      	ldr	r7, [pc, #744]	; (800768c <main+0x3ac>)
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80073a4:	4dba      	ldr	r5, [pc, #744]	; (8007690 <main+0x3b0>)
  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80073a6:	f04f 31ff 	mov.w	r1, #4294967295
 80073aa:	60a1      	str	r1, [r4, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 80073ac:	60e1      	str	r1, [r4, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 80073ae:	6081      	str	r1, [r0, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 80073b0:	60c1      	str	r1, [r0, #12]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80073b2:	f8de 1030 	ldr.w	r1, [lr, #48]	; 0x30
 80073b6:	ea6f 2151 	mvn.w	r1, r1, lsr #9
 80073ba:	ea6f 2141 	mvn.w	r1, r1, lsl #9
 80073be:	f8ce 1030 	str.w	r1, [lr, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80073c2:	f8de 1050 	ldr.w	r1, [lr, #80]	; 0x50
 80073c6:	ea6f 2151 	mvn.w	r1, r1, lsr #9
 80073ca:	ea6f 2141 	mvn.w	r1, r1, lsl #9
 80073ce:	f8ce 1050 	str.w	r1, [lr, #80]	; 0x50
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80073d2:	f8df e330 	ldr.w	lr, [pc, #816]	; 8007704 <main+0x424>
  gpiop->PUPDR   = config->pupdr;
 80073d6:	49af      	ldr	r1, [pc, #700]	; (8007694 <main+0x3b4>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80073d8:	f8cc 2004 	str.w	r2, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80073dc:	f8cc e008 	str.w	lr, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 80073e0:	f8cc 100c 	str.w	r1, [ip, #12]
  gpiop->ODR     = config->odr;
 80073e4:	f64f 7eff 	movw	lr, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
 80073e8:	49ab      	ldr	r1, [pc, #684]	; (8007698 <main+0x3b8>)
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80073ea:	f8cc e014 	str.w	lr, [ip, #20]
  gpiop->AFRL    = config->afrl;
 80073ee:	f8cc 1020 	str.w	r1, [ip, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80073f2:	49aa      	ldr	r1, [pc, #680]	; (800769c <main+0x3bc>)
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80073f4:	f8cc 2024 	str.w	r2, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80073f8:	f8cc 1000 	str.w	r1, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80073fc:	f44f 6140 	mov.w	r1, #3072	; 0xc00
 8007400:	6071      	str	r1, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8007402:	49a7      	ldr	r1, [pc, #668]	; (80076a0 <main+0x3c0>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007404:	f8df c300 	ldr.w	ip, [pc, #768]	; 8007708 <main+0x428>
 8007408:	f8c6 c008 	str.w	ip, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 800740c:	60f1      	str	r1, [r6, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 800740e:	f501 0195 	add.w	r1, r1, #4882432	; 0x4a8000
 8007412:	f501 41de 	add.w	r1, r1, #28416	; 0x6f00

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8007416:	f04f 4c5d 	mov.w	ip, #3707764736	; 0xdd000000
  gpiop->AFRH    = config->afrh;
 800741a:	312f      	adds	r1, #47	; 0x2f
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800741c:	f8c6 e014 	str.w	lr, [r6, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007420:	f5a4 44b0 	sub.w	r4, r4, #22528	; 0x5800
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8007424:	f8c6 c020 	str.w	ip, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8007428:	6271      	str	r1, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800742a:	499e      	ldr	r1, [pc, #632]	; (80076a4 <main+0x3c4>)
 800742c:	6031      	str	r1, [r6, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800742e:	4e9e      	ldr	r6, [pc, #632]	; (80076a8 <main+0x3c8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007430:	6062      	str	r2, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007432:	60a6      	str	r6, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8007434:	4e9d      	ldr	r6, [pc, #628]	; (80076ac <main+0x3cc>)
 8007436:	60e6      	str	r6, [r4, #12]
  gpiop->ODR     = config->odr;
 8007438:	f8c4 e014 	str.w	lr, [r4, #20]
  gpiop->AFRL    = config->afrl;
 800743c:	f8c4 c020 	str.w	ip, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8007440:	f8df c2c8 	ldr.w	ip, [pc, #712]	; 800770c <main+0x42c>
 8007444:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007448:	f8df c2c4 	ldr.w	ip, [pc, #708]	; 8007710 <main+0x430>
 800744c:	f8c4 c000 	str.w	ip, [r4]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007450:	f8df c2c0 	ldr.w	ip, [pc, #704]	; 8007714 <main+0x434>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007454:	607a      	str	r2, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007456:	f8c7 c008 	str.w	ip, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 800745a:	f8df c2bc 	ldr.w	ip, [pc, #700]	; 8007718 <main+0x438>
 800745e:	f8c7 c00c 	str.w	ip, [r7, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8007462:	f5a0 40a8 	sub.w	r0, r0, #21504	; 0x5400
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8007466:	f8df c2b4 	ldr.w	ip, [pc, #692]	; 800771c <main+0x43c>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800746a:	f8c7 e014 	str.w	lr, [r7, #20]
  gpiop->AFRL    = config->afrl;
 800746e:	623a      	str	r2, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8007470:	627a      	str	r2, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8007472:	f8c7 c000 	str.w	ip, [r7]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007476:	f44f 5c7c 	mov.w	ip, #16128	; 0x3f00
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800747a:	6042      	str	r2, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800747c:	f04f 3755 	mov.w	r7, #1431655765	; 0x55555555
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8007480:	f8c0 c008 	str.w	ip, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8007484:	f8df c298 	ldr.w	ip, [pc, #664]	; 8007720 <main+0x440>

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8007488:	60c7      	str	r7, [r0, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800748a:	4989      	ldr	r1, [pc, #548]	; (80076b0 <main+0x3d0>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800748c:	f8c0 e014 	str.w	lr, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8007490:	f8c0 c020 	str.w	ip, [r0, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8007494:	f8df c28c 	ldr.w	ip, [pc, #652]	; 8007724 <main+0x444>
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8007498:	6242      	str	r2, [r0, #36]	; 0x24
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800749a:	4e86      	ldr	r6, [pc, #536]	; (80076b4 <main+0x3d4>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800749c:	f8c0 c000 	str.w	ip, [r0]
 80074a0:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80074a4:	604a      	str	r2, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80074a6:	608a      	str	r2, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 80074a8:	60cf      	str	r7, [r1, #12]
  gpiop->ODR     = config->odr;
 80074aa:	f8c1 e014 	str.w	lr, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80074ae:	620a      	str	r2, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80074b0:	624a      	str	r2, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80074b2:	f8c1 c000 	str.w	ip, [r1]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80074b6:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80074ba:	6072      	str	r2, [r6, #4]
 80074bc:	f504 54a0 	add.w	r4, r4, #5120	; 0x1400
  gpiop->OSPEEDR = config->ospeedr;
 80074c0:	f8c6 c008 	str.w	ip, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80074c4:	f241 0c50 	movw	ip, #4176	; 0x1050

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80074c8:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 80074ca:	f8c6 e014 	str.w	lr, [r6, #20]
  gpiop->AFRL    = config->afrl;
 80074ce:	6232      	str	r2, [r6, #32]
  gpiop->AFRH    = config->afrh;
 80074d0:	6272      	str	r2, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80074d2:	f8c6 c000 	str.w	ip, [r6]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80074d6:	f04f 0c0f 	mov.w	ip, #15
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80074da:	6062      	str	r2, [r4, #4]
 80074dc:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
  gpiop->OSPEEDR = config->ospeedr;
 80074e0:	f8c4 c008 	str.w	ip, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80074e4:	f8df c240 	ldr.w	ip, [pc, #576]	; 8007728 <main+0x448>
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 80074e8:	4973      	ldr	r1, [pc, #460]	; (80076b8 <main+0x3d8>)
 80074ea:	f8c4 c00c 	str.w	ip, [r4, #12]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80074ee:	4e73      	ldr	r6, [pc, #460]	; (80076bc <main+0x3dc>)
  gpiop->ODR     = config->odr;
 80074f0:	f8c4 e014 	str.w	lr, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80074f4:	6222      	str	r2, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80074f6:	6262      	str	r2, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80074f8:	6022      	str	r2, [r4, #0]
 80074fa:	f44f 3480 	mov.w	r4, #65536	; 0x10000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80074fe:	6042      	str	r2, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8007500:	6082      	str	r2, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8007502:	60c7      	str	r7, [r0, #12]
  gpiop->ODR     = config->odr;
 8007504:	f8c0 e014 	str.w	lr, [r0, #20]
 8007508:	2701      	movs	r7, #1
  gpiop->AFRL    = config->afrl;
 800750a:	6202      	str	r2, [r0, #32]
  gpiop->AFRH    = config->afrh;
 800750c:	6242      	str	r2, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800750e:	6004      	str	r4, [r0, #0]
 8007510:	2060      	movs	r0, #96	; 0x60
 8007512:	700f      	strb	r7, [r1, #0]
 8007514:	f886 0312 	strb.w	r0, [r6, #786]	; 0x312
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007518:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800751c:	f8c6 0180 	str.w	r0, [r6, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007520:	6030      	str	r0, [r6, #0]

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8007522:	4e67      	ldr	r6, [pc, #412]	; (80076c0 <main+0x3e0>)
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8007524:	4c67      	ldr	r4, [pc, #412]	; (80076c4 <main+0x3e4>)
 8007526:	4868      	ldr	r0, [pc, #416]	; (80076c8 <main+0x3e8>)
  adcp->config   = NULL;
 8007528:	604a      	str	r2, [r1, #4]
 800752a:	46ac      	mov	ip, r5

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 800752c:	f1a6 0e78 	sub.w	lr, r6, #120	; 0x78
 8007530:	f8c4 e02c 	str.w	lr, [r4, #44]	; 0x2c
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 8007534:	f8df e1f4 	ldr.w	lr, [pc, #500]	; 800772c <main+0x44c>
 8007538:	f84c 0b04 	str.w	r0, [ip], #4
 800753c:	f8c4 e034 	str.w	lr, [r4, #52]	; 0x34
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 8007540:	4862      	ldr	r0, [pc, #392]	; (80076cc <main+0x3ec>)
 8007542:	6288      	str	r0, [r1, #40]	; 0x28
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8007544:	f1a6 0e3c 	sub.w	lr, r6, #60	; 0x3c
 8007548:	f8c4 e030 	str.w	lr, [r4, #48]	; 0x30
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 800754c:	4860      	ldr	r0, [pc, #384]	; (80076d0 <main+0x3f0>)
 800754e:	6308      	str	r0, [r1, #48]	; 0x30
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007550:	f104 0e0c 	add.w	lr, r4, #12
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8007554:	485f      	ldr	r0, [pc, #380]	; (80076d4 <main+0x3f4>)
 8007556:	f8c4 e00c 	str.w	lr, [r4, #12]
  tqp->prev = (thread_t *)tqp;
 800755a:	f8c4 e010 	str.w	lr, [r4, #16]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 800755e:	f8c5 c004 	str.w	ip, [r5, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007562:	f101 0e18 	add.w	lr, r1, #24

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;
 8007566:	f8df c1c8 	ldr.w	ip, [pc, #456]	; 8007730 <main+0x450>
  adcp->samples  = NULL;
 800756a:	608a      	str	r2, [r1, #8]
  adcp->depth    = 0;
 800756c:	60ca      	str	r2, [r1, #12]
  adcp->grpp     = NULL;
 800756e:	610a      	str	r2, [r1, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8007570:	614a      	str	r2, [r1, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8007572:	620a      	str	r2, [r1, #32]

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8007574:	62ce      	str	r6, [r1, #44]	; 0x2c
 8007576:	7027      	strb	r7, [r4, #0]
  i2cp->config = NULL;
 8007578:	6062      	str	r2, [r4, #4]
 800757a:	6162      	str	r2, [r4, #20]
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 800757c:	61e2      	str	r2, [r4, #28]
 800757e:	f8c1 e018 	str.w	lr, [r1, #24]
 8007582:	f105 040c 	add.w	r4, r5, #12
  tqp->prev = (thread_t *)tqp;
 8007586:	f8c1 e01c 	str.w	lr, [r1, #28]
 800758a:	4953      	ldr	r1, [pc, #332]	; (80076d8 <main+0x3f8>)
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800758c:	722f      	strb	r7, [r5, #8]
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 800758e:	f8df e1a4 	ldr.w	lr, [pc, #420]	; 8007734 <main+0x454>
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007592:	60ec      	str	r4, [r5, #12]
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8007594:	616a      	str	r2, [r5, #20]
 8007596:	7007      	strb	r7, [r0, #0]
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8007598:	63ab      	str	r3, [r5, #56]	; 0x38
 800759a:	f8cc 1000 	str.w	r1, [ip]

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 800759e:	27ca      	movs	r7, #202	; 0xca
  RTCD1.rtc->WPR = 0x53;
 80075a0:	2353      	movs	r3, #83	; 0x53
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80075a2:	f105 0c74 	add.w	ip, r5, #116	; 0x74

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 80075a6:	624f      	str	r7, [r1, #36]	; 0x24
  RTCD1.rtc->WPR = 0x53;
 80075a8:	624b      	str	r3, [r1, #36]	; 0x24
  SD3.usart = USART3;
#endif

#if STM32_SERIAL_USE_UART4
  sdObjectInit(&SD4, NULL, notify4);
  SD4.usart = UART4;
 80075aa:	4f4c      	ldr	r7, [pc, #304]	; (80076dc <main+0x3fc>)
  tqp->prev = (thread_t *)tqp;
 80075ac:	612c      	str	r4, [r5, #16]
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 80075ae:	4b4c      	ldr	r3, [pc, #304]	; (80076e0 <main+0x400>)
 80075b0:	f8c5 c040 	str.w	ip, [r5, #64]	; 0x40
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 80075b4:	f1a6 046c 	sub.w	r4, r6, #108	; 0x6c
  oqp->q_notify  = onfy;
 80075b8:	f8c5 e04c 	str.w	lr, [r5, #76]	; 0x4c
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 80075bc:	f8df c178 	ldr.w	ip, [pc, #376]	; 8007738 <main+0x458>
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 80075c0:	f8df e178 	ldr.w	lr, [pc, #376]	; 800773c <main+0x45c>
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 80075c4:	62aa      	str	r2, [r5, #40]	; 0x28
  spip->config = NULL;
 80075c6:	6042      	str	r2, [r0, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 80075c8:	6082      	str	r2, [r0, #8]
 80075ca:	6142      	str	r2, [r0, #20]
 80075cc:	676f      	str	r7, [r5, #116]	; 0x74
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80075ce:	f105 0254 	add.w	r2, r5, #84	; 0x54
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 80075d2:	61c3      	str	r3, [r0, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 80075d4:	6204      	str	r4, [r0, #32]
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80075d6:	f105 0364 	add.w	r3, r5, #100	; 0x64
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80075da:	f105 0730 	add.w	r7, r5, #48	; 0x30
 80075de:	f100 040c 	add.w	r4, r0, #12
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 80075e2:	3e60      	subs	r6, #96	; 0x60
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 80075e4:	f8c0 c028 	str.w	ip, [r0, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 80075e8:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 80075ec:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 80075ee:	652d      	str	r5, [r5, #80]	; 0x50

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 80075f0:	6246      	str	r6, [r0, #36]	; 0x24
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80075f2:	61aa      	str	r2, [r5, #24]
  iqp->q_rdptr   = bp;
 80075f4:	626a      	str	r2, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80075f6:	622a      	str	r2, [r5, #32]
  iqp->q_top     = bp + size;
 80075f8:	61eb      	str	r3, [r5, #28]
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 80075fa:	63eb      	str	r3, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80075fc:	64ab      	str	r3, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80075fe:	646b      	str	r3, [r5, #68]	; 0x44
 8007600:	632f      	str	r7, [r5, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8007602:	636f      	str	r7, [r5, #52]	; 0x34
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007604:	60c4      	str	r4, [r0, #12]
  tqp->prev = (thread_t *)tqp;
 8007606:	6104      	str	r4, [r0, #16]

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8007608:	68cb      	ldr	r3, [r1, #12]
 800760a:	f013 0f10 	tst.w	r3, #16
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 800760e:	68cb      	ldr	r3, [r1, #12]
  RTCD1.rtc->WPR = 0xCA;
  RTCD1.rtc->WPR = 0x53;

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8007610:	f040 8149 	bne.w	80078a6 <main+0x5c6>
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 8007614:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007618:	60cb      	str	r3, [r1, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 800761a:	68cb      	ldr	r3, [r1, #12]
 800761c:	4a2e      	ldr	r2, [pc, #184]	; (80076d8 <main+0x3f8>)
 800761e:	065b      	lsls	r3, r3, #25
 8007620:	d5fb      	bpl.n	800761a <main+0x33a>

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8007622:	4b30      	ldr	r3, [pc, #192]	; (80076e4 <main+0x404>)
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
 8007624:	2000      	movs	r0, #0
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 8007626:	2180      	movs	r1, #128	; 0x80
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
 8007628:	6090      	str	r0, [r2, #8]
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 800762a:	60d1      	str	r1, [r2, #12]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 800762c:	6113      	str	r3, [r2, #16]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 800762e:	6113      	str	r3, [r2, #16]
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 8007630:	68d3      	ldr	r3, [r2, #12]
 8007632:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8007636:	60d3      	str	r3, [r2, #12]
 * @notapi
 */
void wdg_lld_init(void) {

#if STM32_WDG_USE_IWDG
  WDGD1.state = WDG_STOP;
 8007638:	4e2b      	ldr	r6, [pc, #172]	; (80076e8 <main+0x408>)
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
	palClearPad(PORT(LED_4GREEN), PIN(LED_4GREEN));	// Show I'M ALIVE
 800763a:	4f1d      	ldr	r7, [pc, #116]	; (80076b0 <main+0x3d0>)
	palClearPad(PORT(CAM_EN), PIN(CAM_EN));			// Disable camera
 800763c:	4b2b      	ldr	r3, [pc, #172]	; (80076ec <main+0x40c>)
  WDGD1.wdg   = IWDG;
 800763e:	492c      	ldr	r1, [pc, #176]	; (80076f0 <main+0x410>)
 8007640:	60b1      	str	r1, [r6, #8]
 * @notapi
 */
void wdg_lld_init(void) {

#if STM32_WDG_USE_IWDG
  WDGD1.state = WDG_STOP;
 8007642:	2001      	movs	r0, #1
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
	palClearPad(PORT(LED_4GREEN), PIN(LED_4GREEN));	// Show I'M ALIVE
 8007644:	2180      	movs	r1, #128	; 0x80

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8007646:	4a2b      	ldr	r2, [pc, #172]	; (80076f4 <main+0x414>)
 8007648:	7030      	strb	r0, [r6, #0]
	palClearPad(PORT(CAM_EN), PIN(CAM_EN));			// Disable camera
 800764a:	2408      	movs	r4, #8
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
	palClearPad(PORT(LED_4GREEN), PIN(LED_4GREEN));	// Show I'M ALIVE
 800764c:	8379      	strh	r1, [r7, #26]
	palClearPad(PORT(CAM_EN), PIN(CAM_EN));			// Disable camera
 800764e:	835c      	strh	r4, [r3, #26]
 8007650:	6c13      	ldr	r3, [r2, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8007652:	4f29      	ldr	r7, [pc, #164]	; (80076f8 <main+0x418>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007654:	4c29      	ldr	r4, [pc, #164]	; (80076fc <main+0x41c>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8007656:	4303      	orrs	r3, r0
 8007658:	6413      	str	r3, [r2, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800765a:	68bb      	ldr	r3, [r7, #8]
  tqp->prev = (thread_t *)tqp;
 800765c:	6064      	str	r4, [r4, #4]
 800765e:	4303      	orrs	r3, r0
 8007660:	60bb      	str	r3, [r7, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8007662:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007666:	f240 5713 	movw	r7, #1299	; 0x513
 800766a:	629f      	str	r7, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800766c:	f04f 37ff 	mov.w	r7, #4294967295
 8007670:	62df      	str	r7, [r3, #44]	; 0x2c

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007672:	4a12      	ldr	r2, [pc, #72]	; (80076bc <main+0x3dc>)
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8007674:	6267      	str	r7, [r4, #36]	; 0x24
  STM32_ST_TIM->CCMR1  = 0;
 8007676:	2700      	movs	r7, #0
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8007678:	8761      	strh	r1, [r4, #58]	; 0x3a
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 800767a:	6124      	str	r4, [r4, #16]
 800767c:	e060      	b.n	8007740 <main+0x460>
 800767e:	bf00      	nop
 8007680:	40026000 	.word	0x40026000
 8007684:	40026400 	.word	0x40026400
 8007688:	40020400 	.word	0x40020400
 800768c:	40020c00 	.word	0x40020c00
 8007690:	20027e60 	.word	0x20027e60
 8007694:	65545555 	.word	0x65545555
 8007698:	0d0d0088 	.word	0x0d0d0088
 800769c:	6802224a 	.word	0x6802224a
 80076a0:	55055515 	.word	0x55055515
 80076a4:	a8aaa081 	.word	0xa8aaa081
 80076a8:	300ff000 	.word	0x300ff000
 80076ac:	45555055 	.word	0x45555055
 80076b0:	40021400 	.word	0x40021400
 80076b4:	40021800 	.word	0x40021800
 80076b8:	2002773c 	.word	0x2002773c
 80076bc:	e000e100 	.word	0xe000e100
 80076c0:	0801501c 	.word	0x0801501c
 80076c4:	200287cc 	.word	0x200287cc
 80076c8:	08015310 	.word	0x08015310
 80076cc:	40012000 	.word	0x40012000
 80076d0:	00022c16 	.word	0x00022c16
 80076d4:	2002879c 	.word	0x2002879c
 80076d8:	40002800 	.word	0x40002800
 80076dc:	40004c00 	.word	0x40004c00
 80076e0:	40003800 	.word	0x40003800
 80076e4:	001f03ff 	.word	0x001f03ff
 80076e8:	20028804 	.word	0x20028804
 80076ec:	40021000 	.word	0x40021000
 80076f0:	40003000 	.word	0x40003000
 80076f4:	40023800 	.word	0x40023800
 80076f8:	e0042000 	.word	0xe0042000
 80076fc:	20027edc 	.word	0x20027edc
 8007700:	40020000 	.word	0x40020000
 8007704:	3c0333cf 	.word	0x3c0333cf
 8007708:	fcf0f0fc 	.word	0xfcf0f0fc
 800770c:	000666dd 	.word	0x000666dd
 8007710:	040aa000 	.word	0x040aa000
 8007714:	0c0f0c00 	.word	0x0c0f0c00
 8007718:	55655555 	.word	0x55655555
 800771c:	04050400 	.word	0x04050400
 8007720:	0ddd0000 	.word	0x0ddd0000
 8007724:	40002a40 	.word	0x40002a40
 8007728:	55555550 	.word	0x55555550
 800772c:	40005800 	.word	0x40005800
 8007730:	20028798 	.word	0x20028798
 8007734:	0800b731 	.word	0x0800b731
 8007738:	00010016 	.word	0x00010016
 800773c:	00010046 	.word	0x00010046
  ch.rlist.older = (thread_t *)&ch.rlist;
 8007740:	6164      	str	r4, [r4, #20]
 8007742:	619f      	str	r7, [r3, #24]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8007744:	60a7      	str	r7, [r4, #8]
  STM32_ST_TIM->CCR[0] = 0;
 8007746:	635f      	str	r7, [r3, #52]	; 0x34
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8007748:	62a7      	str	r7, [r4, #40]	; 0x28
  STM32_ST_TIM->DIER   = 0;
 800774a:	60df      	str	r7, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 800774c:	605f      	str	r7, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800774e:	6158      	str	r0, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8007750:	6018      	str	r0, [r3, #0]
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8007752:	230f      	movs	r3, #15
 8007754:	f882 131c 	strb.w	r1, [r2, #796]	; 0x31c
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8007758:	f104 0040 	add.w	r0, r4, #64	; 0x40
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 800775c:	8723      	strh	r3, [r4, #56]	; 0x38
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800775e:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8007762:	f104 031c 	add.w	r3, r4, #28
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8007766:	63e0      	str	r0, [r4, #60]	; 0x3c
 8007768:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
 800776c:	61e3      	str	r3, [r4, #28]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800776e:	6011      	str	r1, [r2, #0]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8007770:	6223      	str	r3, [r4, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007772:	6024      	str	r4, [r4, #0]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8007774:	3701      	adds	r7, #1
 8007776:	eb04 1307 	add.w	r3, r4, r7, lsl #4
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800777a:	2f80      	cmp	r7, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800777c:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 8007780:	49af      	ldr	r1, [pc, #700]	; (8007a40 <main+0x760>)
 8007782:	f36f 0202 	bfc	r2, #0, #3
 8007786:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800778a:	d1f3      	bne.n	8007774 <main+0x494>
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 800778c:	f04f 0800 	mov.w	r8, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8007790:	f04f 3eff 	mov.w	lr, #4294967295
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8007794:	2200      	movs	r2, #0
 8007796:	2300      	movs	r3, #0
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8007798:	a808      	add	r0, sp, #32

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800779a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 800779e:	f8c1 8030 	str.w	r8, [r1, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 80077a2:	f8c1 8034 	str.w	r8, [r1, #52]	; 0x34
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80077a6:	f8c1 8884 	str.w	r8, [r1, #2180]	; 0x884
 80077aa:	9107      	str	r1, [sp, #28]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80077ac:	f8cd e020 	str.w	lr, [sp, #32]
  tmp->worst      = (rtcnt_t)0;
 80077b0:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  tmp->last       = (rtcnt_t)0;
 80077b4:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
  tmp->n          = (ucnt_t)0;
 80077b8:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80077bc:	f00a fea8 	bl	8012510 <chTMStartMeasurementX.constprop.94>
  chTMStopMeasurementX(&tm);
 80077c0:	a808      	add	r0, sp, #32
 80077c2:	f006 ff4d 	bl	800e660 <chTMStopMeasurementX>
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 80077c6:	489f      	ldr	r0, [pc, #636]	; (8007a44 <main+0x764>)
  endmem  = __heap_end__;
 80077c8:	4a9f      	ldr	r2, [pc, #636]	; (8007a48 <main+0x768>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 80077ca:	f8df e2bc 	ldr.w	lr, [pc, #700]	; 8007a88 <main+0x7a8>
 80077ce:	f8c0 e000 	str.w	lr, [r0]
  endmem  = __heap_end__;
 80077d2:	f8df e2b8 	ldr.w	lr, [pc, #696]	; 8007a8c <main+0x7ac>
 80077d6:	f8c2 e000 	str.w	lr, [r2]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80077da:	4a9c      	ldr	r2, [pc, #624]	; (8007a4c <main+0x76c>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 80077dc:	4b9c      	ldr	r3, [pc, #624]	; (8007a50 <main+0x770>)
 80077de:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 80077e2:	489c      	ldr	r0, [pc, #624]	; (8007a54 <main+0x774>)
 80077e4:	6018      	str	r0, [r3, #0]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80077e6:	f8df e2a8 	ldr.w	lr, [pc, #680]	; 8007a90 <main+0x7b0>
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80077ea:	9907      	ldr	r1, [sp, #28]
 80077ec:	f8c3 8018 	str.w	r8, [r3, #24]
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80077f0:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 80077f4:	ea0c 0000 	and.w	r0, ip, r0
  reg_value  =  (reg_value                                   |
 80077f8:	ea40 0e0e 	orr.w	lr, r0, lr
 80077fc:	f103 0010 	add.w	r0, r3, #16
 8007800:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8007802:	6158      	str	r0, [r3, #20]
  ch.tm.offset = tm.last;
 8007804:	980a      	ldr	r0, [sp, #40]	; 0x28
 8007806:	f8d1 9014 	ldr.w	r9, [r1, #20]
 800780a:	f8c1 0884 	str.w	r0, [r1, #2180]	; 0x884
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800780e:	4892      	ldr	r0, [pc, #584]	; (8007a58 <main+0x778>)
 8007810:	f8c1 0858 	str.w	r0, [r1, #2136]	; 0x858
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8007814:	f04f 0c01 	mov.w	ip, #1
  tp->name      = name;
  REG_INSERT(tp);
 8007818:	f501 6004 	add.w	r0, r1, #2112	; 0x840
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800781c:	f881 c862 	strb.w	ip, [r1, #2146]	; 0x862
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8007820:	f881 8861 	strb.w	r8, [r1, #2145]	; 0x861
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8007824:	f8c1 8874 	str.w	r8, [r1, #2164]	; 0x874
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8007828:	f8c1 7848 	str.w	r7, [r1, #2120]	; 0x848
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800782c:	f8c1 787c 	str.w	r7, [r1, #2172]	; 0x87c
  tp->mtxlist   = NULL;
 8007830:	f8c1 8878 	str.w	r8, [r1, #2168]	; 0x878
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8007834:	f8c1 1850 	str.w	r1, [r1, #2128]	; 0x850
 8007838:	f8c1 9854 	str.w	r9, [r1, #2132]	; 0x854
 800783c:	f8c9 0010 	str.w	r0, [r9, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8007840:	f8c2 e00c 	str.w	lr, [r2, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8007844:	f8df e24c 	ldr.w	lr, [pc, #588]	; 8007a94 <main+0x7b4>
  H_NEXT(&default_heap.header) = NULL;
 8007848:	f8c3 8008 	str.w	r8, [r3, #8]
 800784c:	f8de 700c 	ldr.w	r7, [lr, #12]
  H_PAGES(&default_heap.header) = 0;
 8007850:	f8c3 800c 	str.w	r8, [r3, #12]
 8007854:	f047 7380 	orr.w	r3, r7, #16777216	; 0x1000000
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8007858:	4f80      	ldr	r7, [pc, #512]	; (8007a5c <main+0x77c>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800785a:	f8ce 300c 	str.w	r3, [lr, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800785e:	f601 036c 	addw	r3, r1, #2156	; 0x86c
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8007862:	f601 0e68 	addw	lr, r1, #2152	; 0x868
 8007866:	6148      	str	r0, [r1, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8007868:	6188      	str	r0, [r1, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 800786a:	487d      	ldr	r0, [pc, #500]	; (8007a60 <main+0x780>)
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 800786c:	f881 c860 	strb.w	ip, [r1, #2144]	; 0x860
 8007870:	f8c1 e868 	str.w	lr, [r1, #2152]	; 0x868
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007874:	f8c1 386c 	str.w	r3, [r1, #2156]	; 0x86c
  tqp->prev = (thread_t *)tqp;
 8007878:	f8c1 3870 	str.w	r3, [r1, #2160]	; 0x870
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 800787c:	f8c1 085c 	str.w	r0, [r1, #2140]	; 0x85c
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8007880:	683b      	ldr	r3, [r7, #0]
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8007882:	6b08      	ldr	r0, [r1, #48]	; 0x30
 8007884:	ea43 030c 	orr.w	r3, r3, ip
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8007888:	f04f 0e20 	mov.w	lr, #32
 800788c:	f04f 0c10 	mov.w	ip, #16
 8007890:	603b      	str	r3, [r7, #0]
 8007892:	f882 c01f 	strb.w	ip, [r2, #31]
 8007896:	f882 e022 	strb.w	lr, [r2, #34]	; 0x22
 800789a:	b908      	cbnz	r0, 80078a0 <main+0x5c0>
 800789c:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800789e:	b133      	cbz	r3, 80078ae <main+0x5ce>
    chSysHalt("SV#3");
 80078a0:	4870      	ldr	r0, [pc, #448]	; (8007a64 <main+0x784>)
 80078a2:	f006 ff5d 	bl	800e760 <chSysHalt>
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;

    rtc_exit_init();
  }
  else
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
 80078a6:	f023 0320 	bic.w	r3, r3, #32
 80078aa:	60cb      	str	r3, [r1, #12]
 80078ac:	e6c4      	b.n	8007638 <main+0x358>
 80078ae:	9107      	str	r1, [sp, #28]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80078b0:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80078b4:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80078b6:	f38e 8811 	msr	BASEPRI, lr
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80078ba:	f007 fa61 	bl	800ed80 <_dbg_check_lock>
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 80078be:	9907      	ldr	r1, [sp, #28]
 80078c0:	f8d1 8010 	ldr.w	r8, [r1, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 80078c4:	f898 3022 	ldrb.w	r3, [r8, #34]	; 0x22
 80078c8:	3301      	adds	r3, #1
 80078ca:	f888 3022 	strb.w	r3, [r8, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80078ce:	f007 fa47 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80078d2:	9907      	ldr	r1, [sp, #28]
 80078d4:	680b      	ldr	r3, [r1, #0]
 80078d6:	428b      	cmp	r3, r1
 80078d8:	d004      	beq.n	80078e4 <main+0x604>
 80078da:	698a      	ldr	r2, [r1, #24]
 80078dc:	689b      	ldr	r3, [r3, #8]
 80078de:	6892      	ldr	r2, [r2, #8]
 80078e0:	429a      	cmp	r2, r3
 80078e2:	d34c      	bcc.n	800797e <main+0x69e>
 80078e4:	f04f 0900 	mov.w	r9, #0
 80078e8:	f389 8811 	msr	BASEPRI, r9
 80078ec:	f8df a150 	ldr.w	sl, [pc, #336]	; 8007a40 <main+0x760>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 80078f0:	f8d8 301c 	ldr.w	r3, [r8, #28]
 80078f4:	4a5c      	ldr	r2, [pc, #368]	; (8007a68 <main+0x788>)
 80078f6:	4293      	cmp	r3, r2
 80078f8:	f000 8091 	beq.w	8007a1e <main+0x73e>
 80078fc:	2320      	movs	r3, #32
 80078fe:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007902:	f007 fa3d 	bl	800ed80 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 8007906:	f8d8 7010 	ldr.w	r7, [r8, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800790a:	42a7      	cmp	r7, r4
 800790c:	f000 8095 	beq.w	8007a3a <main+0x75a>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8007910:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8007914:	2bff      	cmp	r3, #255	; 0xff
 8007916:	d03b      	beq.n	8007990 <main+0x6b0>
    ntp->refs++;
 8007918:	3301      	adds	r3, #1
 800791a:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800791e:	f007 fa1f 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007922:	6823      	ldr	r3, [r4, #0]
 8007924:	42a3      	cmp	r3, r4
 8007926:	d005      	beq.n	8007934 <main+0x654>
 8007928:	f8da 2018 	ldr.w	r2, [sl, #24]
 800792c:	689b      	ldr	r3, [r3, #8]
 800792e:	6892      	ldr	r2, [r2, #8]
 8007930:	429a      	cmp	r2, r3
 8007932:	d324      	bcc.n	800797e <main+0x69e>
 8007934:	f389 8811 	msr	BASEPRI, r9
 8007938:	2320      	movs	r3, #32
 800793a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800793e:	f007 fa1f 	bl	800ed80 <_dbg_check_lock>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8007942:	f898 3022 	ldrb.w	r3, [r8, #34]	; 0x22
 8007946:	b303      	cbz	r3, 800798a <main+0x6aa>
  tp->refs--;
 8007948:	3b01      	subs	r3, #1
 800794a:	f888 3022 	strb.w	r3, [r8, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800794e:	f8d8 3020 	ldr.w	r3, [r8, #32]
 8007952:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8007956:	2b0f      	cmp	r3, #15
 8007958:	d01d      	beq.n	8007996 <main+0x6b6>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800795a:	f007 fa01 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800795e:	6823      	ldr	r3, [r4, #0]
 8007960:	42a3      	cmp	r3, r4
 8007962:	d005      	beq.n	8007970 <main+0x690>
 8007964:	f8da 2018 	ldr.w	r2, [sl, #24]
 8007968:	689b      	ldr	r3, [r3, #8]
 800796a:	6892      	ldr	r2, [r2, #8]
 800796c:	429a      	cmp	r2, r3
 800796e:	d309      	bcc.n	8007984 <main+0x6a4>
 8007970:	f389 8811 	msr	BASEPRI, r9
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 8007974:	2f00      	cmp	r7, #0
 8007976:	f000 808f 	beq.w	8007a98 <main+0x7b8>
 800797a:	46b8      	mov	r8, r7
 800797c:	e7b8      	b.n	80078f0 <main+0x610>
 800797e:	483b      	ldr	r0, [pc, #236]	; (8007a6c <main+0x78c>)
 8007980:	f006 feee 	bl	800e760 <chSysHalt>
 8007984:	483a      	ldr	r0, [pc, #232]	; (8007a70 <main+0x790>)
 8007986:	f006 feeb 	bl	800e760 <chSysHalt>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800798a:	483a      	ldr	r0, [pc, #232]	; (8007a74 <main+0x794>)
 800798c:	f006 fee8 	bl	800e760 <chSysHalt>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8007990:	4839      	ldr	r0, [pc, #228]	; (8007a78 <main+0x798>)
 8007992:	f006 fee5 	bl	800e760 <chSysHalt>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
 8007996:	f8d8 3014 	ldr.w	r3, [r8, #20]
 800799a:	f8d8 2010 	ldr.w	r2, [r8, #16]
 800799e:	611a      	str	r2, [r3, #16]
 80079a0:	f8d8 2010 	ldr.w	r2, [r8, #16]
 80079a4:	6153      	str	r3, [r2, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80079a6:	f007 f9db 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80079aa:	6823      	ldr	r3, [r4, #0]
 80079ac:	42a3      	cmp	r3, r4
 80079ae:	d005      	beq.n	80079bc <main+0x6dc>
 80079b0:	f8da 2018 	ldr.w	r2, [sl, #24]
 80079b4:	689b      	ldr	r3, [r3, #8]
 80079b6:	6892      	ldr	r2, [r2, #8]
 80079b8:	429a      	cmp	r2, r3
 80079ba:	d3e3      	bcc.n	8007984 <main+0x6a4>
 80079bc:	f389 8811 	msr	BASEPRI, r9
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80079c0:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 80079c4:	f003 0303 	and.w	r3, r3, #3
 80079c8:	2b01      	cmp	r3, #1
 80079ca:	d02b      	beq.n	8007a24 <main+0x744>
 80079cc:	2b02      	cmp	r3, #2
 80079ce:	d1d1      	bne.n	8007974 <main+0x694>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 80079d0:	f8d8 b040 	ldr.w	fp, [r8, #64]	; 0x40
 80079d4:	f8d8 801c 	ldr.w	r8, [r8, #28]
 80079d8:	2320      	movs	r3, #32
 80079da:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80079de:	f007 f9cf 	bl	800ed80 <_dbg_check_lock>
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
 80079e2:	f006 ff35 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 80079e6:	f1bb 0f00 	cmp.w	fp, #0
 80079ea:	f000 8096 	beq.w	8007b1a <main+0x83a>
 80079ee:	f1b8 0f00 	cmp.w	r8, #0
 80079f2:	f000 8092 	beq.w	8007b1a <main+0x83a>

  php->next = mp->next;
 80079f6:	f8db 3000 	ldr.w	r3, [fp]
 80079fa:	f8c8 3000 	str.w	r3, [r8]
  mp->next = php;
 80079fe:	f8cb 8000 	str.w	r8, [fp]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007a02:	f007 f9ad 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007a06:	6823      	ldr	r3, [r4, #0]
 8007a08:	42a3      	cmp	r3, r4
 8007a0a:	d0b1      	beq.n	8007970 <main+0x690>
 8007a0c:	f8da 2018 	ldr.w	r2, [sl, #24]
 8007a10:	689b      	ldr	r3, [r3, #8]
 8007a12:	6892      	ldr	r2, [r2, #8]
 8007a14:	429a      	cmp	r2, r3
 8007a16:	d2ab      	bcs.n	8007970 <main+0x690>
 8007a18:	4818      	ldr	r0, [pc, #96]	; (8007a7c <main+0x79c>)
 8007a1a:	f006 fea1 	bl	800e760 <chSysHalt>
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8007a1e:	4818      	ldr	r0, [pc, #96]	; (8007a80 <main+0x7a0>)
 8007a20:	f006 fe9e 	bl	800e760 <chSysHalt>
 8007a24:	f8d8 801c 	ldr.w	r8, [r8, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8007a28:	f1b8 0f00 	cmp.w	r8, #0
 8007a2c:	d002      	beq.n	8007a34 <main+0x754>
 8007a2e:	f018 0f07 	tst.w	r8, #7
 8007a32:	d075      	beq.n	8007b20 <main+0x840>
 8007a34:	4813      	ldr	r0, [pc, #76]	; (8007a84 <main+0x7a4>)
 8007a36:	f006 fe93 	bl	800e760 <chSysHalt>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8007a3a:	2700      	movs	r7, #0
 8007a3c:	e76f      	b.n	800791e <main+0x63e>
 8007a3e:	bf00      	nop
 8007a40:	20027edc 	.word	0x20027edc
 8007a44:	20005f14 	.word	0x20005f14
 8007a48:	20027780 	.word	0x20027780
 8007a4c:	e000ed00 	.word	0xe000ed00
 8007a50:	20027e40 	.word	0x20027e40
 8007a54:	0800eda1 	.word	0x0800eda1
 8007a58:	08015064 	.word	0x08015064
 8007a5c:	e0001000 	.word	0xe0001000
 8007a60:	20000400 	.word	0x20000400
 8007a64:	0801507c 	.word	0x0801507c
 8007a68:	200277a0 	.word	0x200277a0
 8007a6c:	08015360 	.word	0x08015360
 8007a70:	08014f38 	.word	0x08014f38
 8007a74:	08015054 	.word	0x08015054
 8007a78:	08015350 	.word	0x08015350
 8007a7c:	08014f44 	.word	0x08014f44
 8007a80:	08015344 	.word	0x08015344
 8007a84:	08014f80 	.word	0x08014f80
 8007a88:	20028810 	.word	0x20028810
 8007a8c:	20030000 	.word	0x20030000
 8007a90:	05fa0300 	.word	0x05fa0300
 8007a94:	e000edf0 	.word	0xe000edf0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8007a98:	2355      	movs	r3, #85	; 0x55
 8007a9a:	4aa8      	ldr	r2, [pc, #672]	; (8007d3c <main+0xa5c>)
 8007a9c:	55d3      	strb	r3, [r2, r7]
 8007a9e:	3701      	adds	r7, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8007aa0:	2fd8      	cmp	r7, #216	; 0xd8
 8007aa2:	d1fa      	bne.n	8007a9a <main+0x7ba>
 8007aa4:	2320      	movs	r3, #32
 8007aa6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007aaa:	f007 f969 	bl	800ed80 <_dbg_check_lock>
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8007aae:	48a4      	ldr	r0, [pc, #656]	; (8007d40 <main+0xa60>)
 8007ab0:	f006 fede 	bl	800e870 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8007ab4:	f00a fcec 	bl	8012490 <chSchWakeupS.constprop.97>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007ab8:	f007 f952 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007abc:	6823      	ldr	r3, [r4, #0]
 8007abe:	4aa1      	ldr	r2, [pc, #644]	; (8007d44 <main+0xa64>)
 8007ac0:	42a3      	cmp	r3, r4
 8007ac2:	d005      	beq.n	8007ad0 <main+0x7f0>
 8007ac4:	6992      	ldr	r2, [r2, #24]
 8007ac6:	689b      	ldr	r3, [r3, #8]
 8007ac8:	6892      	ldr	r2, [r2, #8]
 8007aca:	429a      	cmp	r2, r3
 8007acc:	f4ff af5a 	bcc.w	8007984 <main+0x6a4>
 8007ad0:	2300      	movs	r3, #0
 8007ad2:	f383 8811 	msr	BASEPRI, r3
	halInit();					// Startup HAL
	chSysInit();				// Startup RTOS

	DEBUG_INIT();				// Debug Init (Serial debug port, LEDs)
 8007ad6:	2201      	movs	r2, #1
 8007ad8:	2180      	movs	r1, #128	; 0x80
 8007ada:	489b      	ldr	r0, [pc, #620]	; (8007d48 <main+0xa68>)
 8007adc:	f004 fc50 	bl	800c380 <_pal_lld_setgroupmode>
 8007ae0:	2201      	movs	r2, #1
 8007ae2:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8007ae6:	4899      	ldr	r0, [pc, #612]	; (8007d4c <main+0xa6c>)
 8007ae8:	f004 fc4a 	bl	800c380 <_pal_lld_setgroupmode>
 8007aec:	2201      	movs	r2, #1
 8007aee:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007af2:	4897      	ldr	r0, [pc, #604]	; (8007d50 <main+0xa70>)
 8007af4:	f004 fc44 	bl	800c380 <_pal_lld_setgroupmode>
 8007af8:	2201      	movs	r2, #1
 8007afa:	2102      	movs	r1, #2
 8007afc:	4895      	ldr	r0, [pc, #596]	; (8007d54 <main+0xa74>)
 8007afe:	f004 fc3f 	bl	800c380 <_pal_lld_setgroupmode>
 8007b02:	2320      	movs	r3, #32
 8007b04:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007b08:	f007 f93a 	bl	800ed80 <_dbg_check_lock>
void sdStart(SerialDriver *sdp, const SerialConfig *config) {

  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8007b0c:	7a2b      	ldrb	r3, [r5, #8]
 8007b0e:	1e5a      	subs	r2, r3, #1
 8007b10:	2a01      	cmp	r2, #1
 8007b12:	d952      	bls.n	8007bba <main+0x8da>
 8007b14:	4890      	ldr	r0, [pc, #576]	; (8007d58 <main+0xa78>)
 8007b16:	f006 fe23 	bl	800e760 <chSysHalt>
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
 8007b1a:	4890      	ldr	r0, [pc, #576]	; (8007d5c <main+0xa7c>)
 8007b1c:	f006 fe20 	bl	800e760 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8007b20:	e918 000c 	ldmdb	r8, {r2, r3}
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8007b24:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8007b26:	f102 0110 	add.w	r1, r2, #16
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8007b2a:	08db      	lsrs	r3, r3, #3
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8007b2c:	4608      	mov	r0, r1
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8007b2e:	f848 3c04 	str.w	r3, [r8, #-4]

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8007b32:	f102 0b08 	add.w	fp, r2, #8
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8007b36:	9107      	str	r1, [sp, #28]
 8007b38:	f007 f9da 	bl	800eef0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8007b3c:	9907      	ldr	r1, [sp, #28]
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8007b3e:	f1a8 0008 	sub.w	r0, r8, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8007b42:	465b      	mov	r3, fp

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8007b44:	4298      	cmp	r0, r3
 8007b46:	d306      	bcc.n	8007b56 <main+0x876>
 8007b48:	685a      	ldr	r2, [r3, #4]
 8007b4a:	3201      	adds	r2, #1
 8007b4c:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8007b50:	4290      	cmp	r0, r2
 8007b52:	f4ff af6f 	bcc.w	8007a34 <main+0x754>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8007b56:	459b      	cmp	fp, r3
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8007b58:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8007b5a:	d001      	beq.n	8007b60 <main+0x880>
 8007b5c:	4298      	cmp	r0, r3
 8007b5e:	d92a      	bls.n	8007bb6 <main+0x8d6>
 8007b60:	b10a      	cbz	r2, 8007b66 <main+0x886>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8007b62:	4290      	cmp	r0, r2
 8007b64:	d227      	bcs.n	8007bb6 <main+0x8d6>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8007b66:	f848 2c08 	str.w	r2, [r8, #-8]
      H_NEXT(qp) = hp;
 8007b6a:	6018      	str	r0, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8007b6c:	e918 1004 	ldmdb	r8, {r2, ip}
 8007b70:	f10c 0e01 	add.w	lr, ip, #1
 8007b74:	eb00 0bce 	add.w	fp, r0, lr, lsl #3
 8007b78:	4593      	cmp	fp, r2
 8007b7a:	d109      	bne.n	8007b90 <main+0x8b0>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8007b7c:	f8db 2004 	ldr.w	r2, [fp, #4]
 8007b80:	4462      	add	r2, ip
 8007b82:	3201      	adds	r2, #1
 8007b84:	f848 2c04 	str.w	r2, [r8, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8007b88:	f850 203e 	ldr.w	r2, [r0, lr, lsl #3]
 8007b8c:	f848 2c08 	str.w	r2, [r8, #-8]
      }
      if ((H_LIMIT(qp) == hp)) {
 8007b90:	685a      	ldr	r2, [r3, #4]
 8007b92:	f102 0e01 	add.w	lr, r2, #1
 8007b96:	eb03 0ece 	add.w	lr, r3, lr, lsl #3
 8007b9a:	4570      	cmp	r0, lr
 8007b9c:	d107      	bne.n	8007bae <main+0x8ce>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8007b9e:	f858 0c04 	ldr.w	r0, [r8, #-4]
 8007ba2:	4402      	add	r2, r0
 8007ba4:	3201      	adds	r2, #1
 8007ba6:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8007ba8:	f858 2c08 	ldr.w	r2, [r8, #-8]
 8007bac:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8007bae:	4608      	mov	r0, r1
 8007bb0:	f007 f93e 	bl	800ee30 <chMtxUnlock>
 8007bb4:	e6de      	b.n	8007974 <main+0x694>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8007bb6:	4613      	mov	r3, r2
 8007bb8:	e7c4      	b.n	8007b44 <main+0x864>
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8007bba:	2b01      	cmp	r3, #1
 8007bbc:	d10d      	bne.n	8007bda <main+0x8fa>
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART4
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
 8007bbe:	4968      	ldr	r1, [pc, #416]	; (8007d60 <main+0xa80>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007bc0:	4b68      	ldr	r3, [pc, #416]	; (8007d64 <main+0xa84>)
 8007bc2:	6c0a      	ldr	r2, [r1, #64]	; 0x40
 8007bc4:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8007bc8:	640a      	str	r2, [r1, #64]	; 0x40
 8007bca:	20c0      	movs	r0, #192	; 0xc0
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007bcc:	f44f 1280 	mov.w	r2, #1048576	; 0x100000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007bd0:	f883 0334 	strb.w	r0, [r3, #820]	; 0x334
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007bd4:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007bd8:	605a      	str	r2, [r3, #4]
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8007bda:	6f6b      	ldr	r3, [r5, #116]	; 0x74
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8007bdc:	22e1      	movs	r2, #225	; 0xe1
 8007bde:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8007be0:	2240      	movs	r2, #64	; 0x40
 8007be2:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8007be4:	2001      	movs	r0, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8007be6:	f242 112c 	movw	r1, #8492	; 0x212c
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8007bea:	2200      	movs	r2, #0
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8007bec:	6158      	str	r0, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8007bee:	60d9      	str	r1, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8007bf0:	601a      	str	r2, [r3, #0]
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
    sdp->rxmask = 0x7F;
  }
  else {
    sdp->rxmask = 0xFF;
 8007bf2:	21ff      	movs	r1, #255	; 0xff
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8007bf4:	2202      	movs	r2, #2
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
  (void)u->SR;  /* SR reset step 1.*/
 8007bf6:	6818      	ldr	r0, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8007bf8:	685b      	ldr	r3, [r3, #4]
 8007bfa:	722a      	strb	r2, [r5, #8]
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
    sdp->rxmask = 0x7F;
  }
  else {
    sdp->rxmask = 0xFF;
 8007bfc:	f885 1078 	strb.w	r1, [r5, #120]	; 0x78
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007c00:	f007 f8ae 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007c04:	6823      	ldr	r3, [r4, #0]
 8007c06:	4a4f      	ldr	r2, [pc, #316]	; (8007d44 <main+0xa64>)
 8007c08:	42a3      	cmp	r3, r4
 8007c0a:	d005      	beq.n	8007c18 <main+0x938>
 8007c0c:	6992      	ldr	r2, [r2, #24]
 8007c0e:	689b      	ldr	r3, [r3, #8]
 8007c10:	6892      	ldr	r2, [r2, #8]
 8007c12:	429a      	cmp	r2, r3
 8007c14:	f0c0 808e 	bcc.w	8007d34 <main+0xa54>
 8007c18:	2700      	movs	r7, #0
 8007c1a:	f387 8811 	msr	BASEPRI, r7
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007c1e:	4d52      	ldr	r5, [pc, #328]	; (8007d68 <main+0xa88>)
 8007c20:	4852      	ldr	r0, [pc, #328]	; (8007d6c <main+0xa8c>)
 8007c22:	f240 4202 	movw	r2, #1026	; 0x402
 8007c26:	2101      	movs	r1, #1
 8007c28:	f004 fbaa 	bl	800c380 <_pal_lld_setgroupmode>
 8007c2c:	f240 4202 	movw	r2, #1026	; 0x402
 8007c30:	2102      	movs	r1, #2
 8007c32:	484e      	ldr	r0, [pc, #312]	; (8007d6c <main+0xa8c>)
 8007c34:	f004 fba4 	bl	800c380 <_pal_lld_setgroupmode>
 8007c38:	4628      	mov	r0, r5
 8007c3a:	602d      	str	r5, [r5, #0]
  tqp->prev = (thread_t *)tqp;
 8007c3c:	606d      	str	r5, [r5, #4]
 8007c3e:	60af      	str	r7, [r5, #8]
 8007c40:	f007 f956 	bl	800eef0 <chMtxLock>
 8007c44:	494a      	ldr	r1, [pc, #296]	; (8007d70 <main+0xa90>)
 8007c46:	484b      	ldr	r0, [pc, #300]	; (8007d74 <main+0xa94>)
 8007c48:	f00a fd4a 	bl	80126e0 <chprintf.constprop.35>
 8007c4c:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
 8007c50:	4628      	mov	r0, r5
 8007c52:	f007 f8ed 	bl	800ee30 <chMtxUnlock>
	TRACE_INFO("MAIN > Startup");
 8007c56:	4628      	mov	r0, r5
 8007c58:	f007 f94a 	bl	800eef0 <chMtxLock>
 8007c5c:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8007c60:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8007c64:	4944      	ldr	r1, [pc, #272]	; (8007d78 <main+0xa98>)
 8007c66:	4843      	ldr	r0, [pc, #268]	; (8007d74 <main+0xa94>)
 8007c68:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8007c6c:	f644 6820 	movw	r8, #20000	; 0x4e20
 8007c70:	fb07 f303 	mul.w	r3, r7, r3
 8007c74:	fbb2 f2f8 	udiv	r2, r2, r8
 8007c78:	fbb3 f3f8 	udiv	r3, r3, r8
 8007c7c:	fbb3 fef7 	udiv	lr, r3, r7
 8007c80:	fb07 331e 	mls	r3, r7, lr, r3
 8007c84:	f00a fd2c 	bl	80126e0 <chprintf.constprop.35>
 8007c88:	4a3c      	ldr	r2, [pc, #240]	; (8007d7c <main+0xa9c>)
 8007c8a:	493d      	ldr	r1, [pc, #244]	; (8007d80 <main+0xaa0>)
 8007c8c:	4839      	ldr	r0, [pc, #228]	; (8007d74 <main+0xa94>)
 8007c8e:	f00a fd27 	bl	80126e0 <chprintf.constprop.35>
 8007c92:	233b      	movs	r3, #59	; 0x3b
 8007c94:	4a3b      	ldr	r2, [pc, #236]	; (8007d84 <main+0xaa4>)
 8007c96:	493c      	ldr	r1, [pc, #240]	; (8007d88 <main+0xaa8>)
 8007c98:	4836      	ldr	r0, [pc, #216]	; (8007d74 <main+0xa94>)
 8007c9a:	f00a fd21 	bl	80126e0 <chprintf.constprop.35>
 8007c9e:	493b      	ldr	r1, [pc, #236]	; (8007d8c <main+0xaac>)
 8007ca0:	4834      	ldr	r0, [pc, #208]	; (8007d74 <main+0xa94>)
 8007ca2:	f00a fd1d 	bl	80126e0 <chprintf.constprop.35>
 8007ca6:	493a      	ldr	r1, [pc, #232]	; (8007d90 <main+0xab0>)
 8007ca8:	4832      	ldr	r0, [pc, #200]	; (8007d74 <main+0xa94>)
 8007caa:	f00a fd19 	bl	80126e0 <chprintf.constprop.35>
 8007cae:	4930      	ldr	r1, [pc, #192]	; (8007d70 <main+0xa90>)
 8007cb0:	4830      	ldr	r0, [pc, #192]	; (8007d74 <main+0xa94>)
 8007cb2:	f00a fd15 	bl	80126e0 <chprintf.constprop.35>
 8007cb6:	4628      	mov	r0, r5
 8007cb8:	f007 f8ba 	bl	800ee30 <chMtxUnlock>

	// Initialize Watchdog
	TRACE_INFO("MAIN > Initialize Watchdog");
 8007cbc:	4628      	mov	r0, r5
 8007cbe:	f007 f917 	bl	800eef0 <chMtxLock>
 8007cc2:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8007cc6:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8007cca:	fbb2 f2f8 	udiv	r2, r2, r8
 8007cce:	fb07 f303 	mul.w	r3, r7, r3
 8007cd2:	4929      	ldr	r1, [pc, #164]	; (8007d78 <main+0xa98>)
 8007cd4:	fbb3 f3f8 	udiv	r3, r3, r8
 8007cd8:	4826      	ldr	r0, [pc, #152]	; (8007d74 <main+0xa94>)
 8007cda:	fbb3 fef7 	udiv	lr, r3, r7
 8007cde:	fb07 331e 	mls	r3, r7, lr, r3
 8007ce2:	f00a fcfd 	bl	80126e0 <chprintf.constprop.35>
 8007ce6:	4a25      	ldr	r2, [pc, #148]	; (8007d7c <main+0xa9c>)
 8007ce8:	4925      	ldr	r1, [pc, #148]	; (8007d80 <main+0xaa0>)
 8007cea:	4822      	ldr	r0, [pc, #136]	; (8007d74 <main+0xa94>)
 8007cec:	f00a fcf8 	bl	80126e0 <chprintf.constprop.35>
 8007cf0:	233e      	movs	r3, #62	; 0x3e
 8007cf2:	4a24      	ldr	r2, [pc, #144]	; (8007d84 <main+0xaa4>)
 8007cf4:	4924      	ldr	r1, [pc, #144]	; (8007d88 <main+0xaa8>)
 8007cf6:	481f      	ldr	r0, [pc, #124]	; (8007d74 <main+0xa94>)
 8007cf8:	f00a fcf2 	bl	80126e0 <chprintf.constprop.35>
 8007cfc:	4923      	ldr	r1, [pc, #140]	; (8007d8c <main+0xaac>)
 8007cfe:	481d      	ldr	r0, [pc, #116]	; (8007d74 <main+0xa94>)
 8007d00:	f00a fcee 	bl	80126e0 <chprintf.constprop.35>
 8007d04:	4923      	ldr	r1, [pc, #140]	; (8007d94 <main+0xab4>)
 8007d06:	481b      	ldr	r0, [pc, #108]	; (8007d74 <main+0xa94>)
 8007d08:	f00a fcea 	bl	80126e0 <chprintf.constprop.35>
 8007d0c:	4918      	ldr	r1, [pc, #96]	; (8007d70 <main+0xa90>)
 8007d0e:	4819      	ldr	r0, [pc, #100]	; (8007d74 <main+0xa94>)
 8007d10:	f00a fce6 	bl	80126e0 <chprintf.constprop.35>
 8007d14:	4628      	mov	r0, r5
 8007d16:	f007 f88b 	bl	800ee30 <chMtxUnlock>
 8007d1a:	2320      	movs	r3, #32
 8007d1c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007d20:	f007 f82e 	bl	800ed80 <_dbg_check_lock>
void wdgStart(WDGDriver *wdgp, const WDGConfig *config) {

  osalDbgCheck((wdgp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((wdgp->state == WDG_STOP) || (wdgp->state == WDG_READY),
 8007d24:	7833      	ldrb	r3, [r6, #0]
 8007d26:	4a1c      	ldr	r2, [pc, #112]	; (8007d98 <main+0xab8>)
 8007d28:	3b01      	subs	r3, #1
 8007d2a:	2b01      	cmp	r3, #1
 8007d2c:	d93a      	bls.n	8007da4 <main+0xac4>
 8007d2e:	481b      	ldr	r0, [pc, #108]	; (8007d9c <main+0xabc>)
 8007d30:	f006 fd16 	bl	800e760 <chSysHalt>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007d34:	481a      	ldr	r0, [pc, #104]	; (8007da0 <main+0xac0>)
 8007d36:	f006 fd13 	bl	800e760 <chSysHalt>
 8007d3a:	bf00      	nop
 8007d3c:	200277a0 	.word	0x200277a0
 8007d40:	08014f68 	.word	0x08014f68
 8007d44:	20027edc 	.word	0x20027edc
 8007d48:	40021400 	.word	0x40021400
 8007d4c:	40020800 	.word	0x40020800
 8007d50:	40022000 	.word	0x40022000
 8007d54:	40021c00 	.word	0x40021c00
 8007d58:	0801533c 	.word	0x0801533c
 8007d5c:	08014f5c 	.word	0x08014f5c
 8007d60:	40023800 	.word	0x40023800
 8007d64:	e000e100 	.word	0xe000e100
 8007d68:	20027b2c 	.word	0x20027b2c
 8007d6c:	40020000 	.word	0x40020000
 8007d70:	08013cac 	.word	0x08013cac
 8007d74:	20027e60 	.word	0x20027e60
 8007d78:	08013c50 	.word	0x08013c50
 8007d7c:	08013cfc 	.word	0x08013cfc
 8007d80:	08013c5c 	.word	0x08013c5c
 8007d84:	08015084 	.word	0x08015084
 8007d88:	08013c78 	.word	0x08013c78
 8007d8c:	08013d00 	.word	0x08013d00
 8007d90:	0801508c 	.word	0x0801508c
 8007d94:	0801509c 	.word	0x0801509c
 8007d98:	20028804 	.word	0x20028804
 8007d9c:	08015330 	.word	0x08015330
 8007da0:	08014f0c 	.word	0x08014f0c

  /* This also triggers a refresh.*/
  wdgp->wdg->WINR = wdgp->config->winr;
#else
  /* Unlock IWDG.*/
  wdgp->wdg->KR   = KR_KEY_WRITE;
 8007da4:	6893      	ldr	r3, [r2, #8]
                "invalid state");
  wdgp->config = config;
 8007da6:	49dc      	ldr	r1, [pc, #880]	; (8008118 <main+0xe38>)
 8007da8:	6051      	str	r1, [r2, #4]
 8007daa:	f245 5255 	movw	r2, #21845	; 0x5555
 8007dae:	601a      	str	r2, [r3, #0]

  /* Write configuration.*/
  while (wdgp->wdg->SR != 0)
 8007db0:	68da      	ldr	r2, [r3, #12]
 8007db2:	2a00      	cmp	r2, #0
 8007db4:	d1fc      	bne.n	8007db0 <main+0xad0>
    ;
  wdgp->wdg->PR   = wdgp->config->pr;
  wdgp->wdg->RLR  = wdgp->config->rlr;
 8007db6:	f242 7210 	movw	r2, #10000	; 0x2710

  /* Start operations.*/
  wdgp->wdg->KR   = KR_KEY_RELOAD;
 8007dba:	f64a 20aa 	movw	r0, #43690	; 0xaaaa
  wdgp->wdg->KR   = KR_KEY_ENABLE;
 8007dbe:	f64c 41cc 	movw	r1, #52428	; 0xcccc
  wdgp->wdg->KR   = KR_KEY_WRITE;

  /* Write configuration.*/
  while (wdgp->wdg->SR != 0)
    ;
  wdgp->wdg->PR   = wdgp->config->pr;
 8007dc2:	2506      	movs	r5, #6
 8007dc4:	605d      	str	r5, [r3, #4]
  wdgp->wdg->RLR  = wdgp->config->rlr;
 8007dc6:	609a      	str	r2, [r3, #8]

  /* Start operations.*/
  wdgp->wdg->KR   = KR_KEY_RELOAD;
 8007dc8:	6018      	str	r0, [r3, #0]
  wdg_lld_start(wdgp);
  wdgp->state = WDG_READY;
 8007dca:	2202      	movs	r2, #2
  wdgp->wdg->KR   = KR_KEY_ENABLE;
 8007dcc:	6019      	str	r1, [r3, #0]
 8007dce:	7032      	strb	r2, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007dd0:	f006 ffc6 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007dd4:	6823      	ldr	r3, [r4, #0]
 8007dd6:	4ad1      	ldr	r2, [pc, #836]	; (800811c <main+0xe3c>)
 8007dd8:	42a3      	cmp	r3, r4
 8007dda:	d005      	beq.n	8007de8 <main+0xb08>
 8007ddc:	6992      	ldr	r2, [r2, #24]
 8007dde:	689b      	ldr	r3, [r3, #8]
 8007de0:	6892      	ldr	r2, [r2, #8]
 8007de2:	429a      	cmp	r2, r3
 8007de4:	f0c0 8609 	bcc.w	80089fa <main+0x171a>
 8007de8:	f04f 0a00 	mov.w	sl, #0
 8007dec:	f38a 8811 	msr	BASEPRI, sl
 8007df0:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
	wdgStart(&WDGD1, &wdgcfg);
	wdgReset(&WDGD1);
 8007df4:	f00a feec 	bl	8012bd0 <wdgReset.constprop.41>
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
}

void pi2cInit(void)
{
	TRACE_INFO("I2C  > Initialize I2C");
 8007df8:	48c9      	ldr	r0, [pc, #804]	; (8008120 <main+0xe40>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007dfa:	f8df b398 	ldr.w	fp, [pc, #920]	; 8008194 <main+0xeb4>

// Put your configuration settings here
void initModules(void)
{
	// Module POSITION, APRS 2m AFSK
	chsnprintf(config[0].name, 17, "POS APRS 2m AFSK");		// Instance name
 8007dfe:	4dc9      	ldr	r5, [pc, #804]	; (8008124 <main+0xe44>)
 8007e00:	f007 f876 	bl	800eef0 <chMtxLock>
 8007e04:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8007e08:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8007e0c:	49c6      	ldr	r1, [pc, #792]	; (8008128 <main+0xe48>)
 8007e0e:	48c7      	ldr	r0, [pc, #796]	; (800812c <main+0xe4c>)
 8007e10:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8007e14:	f644 6820 	movw	r8, #20000	; 0x4e20
 8007e18:	fb07 f303 	mul.w	r3, r7, r3
 8007e1c:	fbb2 f2f8 	udiv	r2, r2, r8
 8007e20:	fbb3 f3f8 	udiv	r3, r3, r8
 8007e24:	fbb3 f6f7 	udiv	r6, r3, r7
 8007e28:	fb07 3316 	mls	r3, r7, r6, r3
 8007e2c:	f00a fc58 	bl	80126e0 <chprintf.constprop.35>
 8007e30:	4abf      	ldr	r2, [pc, #764]	; (8008130 <main+0xe50>)
 8007e32:	49c0      	ldr	r1, [pc, #768]	; (8008134 <main+0xe54>)
 8007e34:	48bd      	ldr	r0, [pc, #756]	; (800812c <main+0xe4c>)
 8007e36:	4ec0      	ldr	r6, [pc, #768]	; (8008138 <main+0xe58>)
 8007e38:	f00a fc52 	bl	80126e0 <chprintf.constprop.35>
 8007e3c:	2326      	movs	r3, #38	; 0x26
 8007e3e:	4abf      	ldr	r2, [pc, #764]	; (800813c <main+0xe5c>)
 8007e40:	49bf      	ldr	r1, [pc, #764]	; (8008140 <main+0xe60>)
 8007e42:	48ba      	ldr	r0, [pc, #744]	; (800812c <main+0xe4c>)
 8007e44:	f00a fc4c 	bl	80126e0 <chprintf.constprop.35>
 8007e48:	49be      	ldr	r1, [pc, #760]	; (8008144 <main+0xe64>)
 8007e4a:	48b8      	ldr	r0, [pc, #736]	; (800812c <main+0xe4c>)
 8007e4c:	f00a fc48 	bl	80126e0 <chprintf.constprop.35>
 8007e50:	49bd      	ldr	r1, [pc, #756]	; (8008148 <main+0xe68>)
 8007e52:	48b6      	ldr	r0, [pc, #728]	; (800812c <main+0xe4c>)
 8007e54:	f00a fc44 	bl	80126e0 <chprintf.constprop.35>
 8007e58:	49bc      	ldr	r1, [pc, #752]	; (800814c <main+0xe6c>)
 8007e5a:	48b4      	ldr	r0, [pc, #720]	; (800812c <main+0xe4c>)
 8007e5c:	f00a fc40 	bl	80126e0 <chprintf.constprop.35>
 8007e60:	48af      	ldr	r0, [pc, #700]	; (8008120 <main+0xe40>)
 8007e62:	f006 ffe5 	bl	800ee30 <chMtxUnlock>
	i2cStart(&I2CD2, &_i2cfg);
 8007e66:	f00a fd3b 	bl	80128e0 <i2cStart.constprop.66>
 8007e6a:	f8df c32c 	ldr.w	ip, [pc, #812]	; 8008198 <main+0xeb8>
 8007e6e:	f8df e32c 	ldr.w	lr, [pc, #812]	; 800819c <main+0xebc>
 8007e72:	f8cc c000 	str.w	ip, [ip]
  tqp->prev = (thread_t *)tqp;
 8007e76:	f8cc c004 	str.w	ip, [ip, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007e7a:	f8ce e000 	str.w	lr, [lr]
  tqp->prev = (thread_t *)tqp;
 8007e7e:	f8ce e004 	str.w	lr, [lr, #4]

	pi2cInit();					// Startup I2C
	initEssentialModules();		// Startup required modules (input/output modules)
 8007e82:	4653      	mov	r3, sl
 8007e84:	4ab2      	ldr	r2, [pc, #712]	; (8008150 <main+0xe70>)
 8007e86:	49b3      	ldr	r1, [pc, #716]	; (8008154 <main+0xe74>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007e88:	f8cb b000 	str.w	fp, [fp]
  tqp->prev = (thread_t *)tqp;
 8007e8c:	f8cb b004 	str.w	fp, [fp, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8007e90:	6036      	str	r6, [r6, #0]
  tqp->prev = (thread_t *)tqp;
 8007e92:	6076      	str	r6, [r6, #4]
 8007e94:	f640 00c8 	movw	r0, #2248	; 0x8c8
 8007e98:	f8cc a008 	str.w	sl, [ip, #8]
 8007e9c:	f8ce a008 	str.w	sl, [lr, #8]
 8007ea0:	f8cb a008 	str.w	sl, [fp, #8]
 8007ea4:	f8c6 a008 	str.w	sl, [r6, #8]
 8007ea8:	f00a fc5a 	bl	8012760 <chThdCreateFromHeap.constprop.87>
 8007eac:	4640      	mov	r0, r8
 8007eae:	f007 f8ef 	bl	800f090 <chThdSleep>
 8007eb2:	4628      	mov	r0, r5
 8007eb4:	4aa8      	ldr	r2, [pc, #672]	; (8008158 <main+0xe78>)
 8007eb6:	2111      	movs	r1, #17
 8007eb8:	f004 f9ba 	bl	800c230 <chsnprintf>
	config[0].power = 20;									// Power 20 dBm
 8007ebc:	f04f 0314 	mov.w	r3, #20
 8007ec0:	f885 3020 	strb.w	r3, [r5, #32]
	config[0].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
	config[0].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[0].frequency.hz = 144800000;						// Default frequency 144.800 MHz
 8007ec4:	4ba5      	ldr	r3, [pc, #660]	; (800815c <main+0xe7c>)
 8007ec6:	62ab      	str	r3, [r5, #40]	; 0x28
void initModules(void)
{
	// Module POSITION, APRS 2m AFSK
	chsnprintf(config[0].name, 17, "POS APRS 2m AFSK");		// Instance name
	config[0].power = 20;									// Power 20 dBm
	config[0].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
 8007ec8:	2601      	movs	r6, #1
	config[0].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[0].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[0].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 8007eca:	4ba5      	ldr	r3, [pc, #660]	; (8008160 <main+0xe80>)
 8007ecc:	62eb      	str	r3, [r5, #44]	; 0x2c
	config[0].init_delay = 0;								// Module startup delay in msec
	config[0].trigger.type = TRIG_EVENT;					// Trigger transmission on event
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
	chsnprintf(config[0].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 8007ece:	f105 0058 	add.w	r0, r5, #88	; 0x58
 8007ed2:	4aa4      	ldr	r2, [pc, #656]	; (8008164 <main+0xe84>)
	config[0].power = 20;									// Power 20 dBm
	config[0].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
	config[0].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[0].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[0].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[0].init_delay = 0;								// Module startup delay in msec
 8007ed4:	f8c5 a034 	str.w	sl, [r5, #52]	; 0x34
	config[0].trigger.type = TRIG_EVENT;					// Trigger transmission on event
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
	chsnprintf(config[0].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 8007ed8:	2106      	movs	r1, #6
void initModules(void)
{
	// Module POSITION, APRS 2m AFSK
	chsnprintf(config[0].name, 17, "POS APRS 2m AFSK");		// Instance name
	config[0].power = 20;									// Power 20 dBm
	config[0].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
 8007eda:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
	config[0].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
 8007ede:	f885 6024 	strb.w	r6, [r5, #36]	; 0x24
	config[0].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[0].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[0].init_delay = 0;								// Module startup delay in msec
	config[0].trigger.type = TRIG_EVENT;					// Trigger transmission on event
 8007ee2:	f885 6044 	strb.w	r6, [r5, #68]	; 0x44
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
 8007ee6:	f885 604c 	strb.w	r6, [r5, #76]	; 0x4c
	chsnprintf(config[0].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 8007eea:	f004 f9a1 	bl	800c230 <chsnprintf>
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
 8007eee:	f642 734f 	movw	r3, #12111	; 0x2f4f
 8007ef2:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
	config[0].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[0].init_delay = 0;								// Module startup delay in msec
	config[0].trigger.type = TRIG_EVENT;					// Trigger transmission on event
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
	chsnprintf(config[0].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
 8007ef6:	f04f 030b 	mov.w	r3, #11
 8007efa:	f885 3068 	strb.w	r3, [r5, #104]	; 0x68
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
 8007efe:	f105 006c 	add.w	r0, r5, #108	; 0x6c
 8007f02:	4a99      	ldr	r2, [pc, #612]	; (8008168 <main+0xe88>)
 8007f04:	2110      	movs	r1, #16
 8007f06:	f004 f993 	bl	800c230 <chsnprintf>
	config[0].aprs_config.tel[1] = TEL_IPRESS;				// APRS Telemetry parameter 2
	config[0].aprs_config.tel[2] = TEL_ITEMP;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_IHUM;				// APRS Telemetry parameter 4
	config[0].aprs_config.tel[4] = TEL_ETEMP;				// APRS Telemetry parameter 5
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
	config[0].aprs_config.tel_encoding_cycle = 3600;		// Transmit Telemetry encoding information every 3600sec
 8007f0a:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 8007f0e:	f8a5 3084 	strh.w	r3, [r5, #132]	; 0x84
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
	chsnprintf(config[0].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 200;					// APRS Preamble
 8007f12:	f04f 03c8 	mov.w	r3, #200	; 0xc8
 8007f16:	f8a5 307c 	strh.w	r3, [r5, #124]	; 0x7c
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_IPRESS;				// APRS Telemetry parameter 2
 8007f1a:	f04f 0306 	mov.w	r3, #6
	chsnprintf(config[0].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 200;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
 8007f1e:	f04f 0b02 	mov.w	fp, #2
	config[0].aprs_config.tel[1] = TEL_IPRESS;				// APRS Telemetry parameter 2
	config[0].aprs_config.tel[2] = TEL_ITEMP;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_IHUM;				// APRS Telemetry parameter 4
 8007f22:	f04f 0e08 	mov.w	lr, #8
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 200;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_IPRESS;				// APRS Telemetry parameter 2
 8007f26:	f885 307f 	strb.w	r3, [r5, #127]	; 0x7f
	config[0].aprs_config.tel[2] = TEL_ITEMP;				// APRS Telemetry parameter 3
 8007f2a:	2107      	movs	r1, #7
	config[0].aprs_config.tel[3] = TEL_IHUM;				// APRS Telemetry parameter 4
	config[0].aprs_config.tel[4] = TEL_ETEMP;				// APRS Telemetry parameter 5
 8007f2c:	f04f 030a 	mov.w	r3, #10
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 200;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_IPRESS;				// APRS Telemetry parameter 2
	config[0].aprs_config.tel[2] = TEL_ITEMP;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_IHUM;				// APRS Telemetry parameter 4
 8007f30:	f885 e081 	strb.w	lr, [r5, #129]	; 0x81
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 200;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_IPRESS;				// APRS Telemetry parameter 2
	config[0].aprs_config.tel[2] = TEL_ITEMP;				// APRS Telemetry parameter 3
 8007f34:	f885 1080 	strb.w	r1, [r5, #128]	; 0x80
	config[0].aprs_config.tel[3] = TEL_IHUM;				// APRS Telemetry parameter 4
	config[0].aprs_config.tel[4] = TEL_ETEMP;				// APRS Telemetry parameter 5
 8007f38:	f885 3082 	strb.w	r3, [r5, #130]	; 0x82
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
	config[0].aprs_config.tel_encoding_cycle = 3600;		// Transmit Telemetry encoding information every 3600sec
	chsnprintf(config[0].aprs_config.tel_comment, 18, "http://tkrahn.net");// Telemetry comment
 8007f3c:	f105 0086 	add.w	r0, r5, #134	; 0x86
 8007f40:	4a8a      	ldr	r2, [pc, #552]	; (800816c <main+0xe8c>)
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_IPRESS;				// APRS Telemetry parameter 2
	config[0].aprs_config.tel[2] = TEL_ITEMP;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_IHUM;				// APRS Telemetry parameter 4
	config[0].aprs_config.tel[4] = TEL_ETEMP;				// APRS Telemetry parameter 5
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
 8007f42:	f885 6083 	strb.w	r6, [r5, #131]	; 0x83
	config[0].aprs_config.tel_encoding_cycle = 3600;		// Transmit Telemetry encoding information every 3600sec
	chsnprintf(config[0].aprs_config.tel_comment, 18, "http://tkrahn.net");// Telemetry comment
 8007f46:	2112      	movs	r1, #18
	chsnprintf(config[0].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 200;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
 8007f48:	f885 b07e 	strb.w	fp, [r5, #126]	; 0x7e
	config[0].aprs_config.tel[2] = TEL_ITEMP;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_IHUM;				// APRS Telemetry parameter 4
	config[0].aprs_config.tel[4] = TEL_ETEMP;				// APRS Telemetry parameter 5
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
	config[0].aprs_config.tel_encoding_cycle = 3600;		// Transmit Telemetry encoding information every 3600sec
	chsnprintf(config[0].aprs_config.tel_comment, 18, "http://tkrahn.net");// Telemetry comment
 8007f4c:	f004 f970 	bl	800c230 <chsnprintf>
	MODULE_POSITION(&config[0]);
 8007f50:	462b      	mov	r3, r5
 8007f52:	4629      	mov	r1, r5
 8007f54:	4a86      	ldr	r2, [pc, #536]	; (8008170 <main+0xe90>)
 8007f56:	f640 00c8 	movw	r0, #2248	; 0x8c8
 8007f5a:	f00a fc01 	bl	8012760 <chThdCreateFromHeap.constprop.87>
	chsnprintf(config[2].ukhas_config.callsign, 6, "DK0TU");// UKHAS Callsign
	chsnprintf(config[2].ukhas_config.format, 94, "<CALL>,<ID>,<TIME>,<LAT>,<LON>,<ALT>,<SATS>,<TTFF>,<VBAT>,<DISCHARGE>,<IPRESS>,<ITEMP>,<IHUM>"); // UKHAS Format
	MODULE_POSITION(&config[2]);*/

	// Module IMAGE, APRS 2m AFSK low-duty cycle
	chsnprintf(config[3].name, 12, "IMG AFSK 2m");			// Instance name
 8007f5e:	f505 60a5 	add.w	r0, r5, #1320	; 0x528
 8007f62:	4a84      	ldr	r2, [pc, #528]	; (8008174 <main+0xe94>)
	config[0].aprs_config.tel[3] = TEL_IHUM;				// APRS Telemetry parameter 4
	config[0].aprs_config.tel[4] = TEL_ETEMP;				// APRS Telemetry parameter 5
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
	config[0].aprs_config.tel_encoding_cycle = 3600;		// Transmit Telemetry encoding information every 3600sec
	chsnprintf(config[0].aprs_config.tel_comment, 18, "http://tkrahn.net");// Telemetry comment
	MODULE_POSITION(&config[0]);
 8007f64:	f885 61b4 	strb.w	r6, [r5, #436]	; 0x1b4
	chsnprintf(config[2].ukhas_config.callsign, 6, "DK0TU");// UKHAS Callsign
	chsnprintf(config[2].ukhas_config.format, 94, "<CALL>,<ID>,<TIME>,<LAT>,<LON>,<ALT>,<SATS>,<TTFF>,<VBAT>,<DISCHARGE>,<IPRESS>,<ITEMP>,<IHUM>"); // UKHAS Format
	MODULE_POSITION(&config[2]);*/

	// Module IMAGE, APRS 2m AFSK low-duty cycle
	chsnprintf(config[3].name, 12, "IMG AFSK 2m");			// Instance name
 8007f68:	210c      	movs	r1, #12
 8007f6a:	f004 f961 	bl	800c230 <chsnprintf>
	config[3].power = 20;									// Power 20 dBm
 8007f6e:	f04f 0314 	mov.w	r3, #20
 8007f72:	f885 3548 	strb.w	r3, [r5, #1352]	; 0x548
	config[3].protocol = PROT_APRS_AFSK;					// Protocol APRS SSDV, modulation AFSK
	config[3].frequency.type = FREQ_DYNAMIC;				// Static frequency allocation
	config[3].frequency.hz = 144800000;						// Transmission frequency 144.800 MHz
 8007f76:	4b79      	ldr	r3, [pc, #484]	; (800815c <main+0xe7c>)
 8007f78:	f8c5 3550 	str.w	r3, [r5, #1360]	; 0x550
	config[3].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 8007f7c:	4b78      	ldr	r3, [pc, #480]	; (8008160 <main+0xe80>)
 8007f7e:	f8c5 3554 	str.w	r3, [r5, #1364]	; 0x554
	config[3].init_delay = 10000;							// Module startup delay in msec
	config[3].packet_spacing = 20000;						// Packet spacing in ms
	config[3].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[3].sleep_config.vbat_thres = 2700;				// Sleeping voltage threshold
 8007f82:	f640 2c8c 	movw	ip, #2700	; 0xa8c
	config[3].power = 20;									// Power 20 dBm
	config[3].protocol = PROT_APRS_AFSK;					// Protocol APRS SSDV, modulation AFSK
	config[3].frequency.type = FREQ_DYNAMIC;				// Static frequency allocation
	config[3].frequency.hz = 144800000;						// Transmission frequency 144.800 MHz
	config[3].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[3].init_delay = 10000;							// Module startup delay in msec
 8007f86:	f242 7e10 	movw	lr, #10000	; 0x2710
	config[3].packet_spacing = 20000;						// Packet spacing in ms
	config[3].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[3].sleep_config.vbat_thres = 2700;				// Sleeping voltage threshold
	config[3].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[3].trigger.timeout = 10;							// Timeout 10 sec
 8007f8a:	230a      	movs	r3, #10
	config[3].frequency.hz = 144800000;						// Transmission frequency 144.800 MHz
	config[3].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[3].init_delay = 10000;							// Module startup delay in msec
	config[3].packet_spacing = 20000;						// Packet spacing in ms
	config[3].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[3].sleep_config.vbat_thres = 2700;				// Sleeping voltage threshold
 8007f8c:	f8a5 c566 	strh.w	ip, [r5, #1382]	; 0x566
	config[3].power = 20;									// Power 20 dBm
	config[3].protocol = PROT_APRS_AFSK;					// Protocol APRS SSDV, modulation AFSK
	config[3].frequency.type = FREQ_DYNAMIC;				// Static frequency allocation
	config[3].frequency.hz = 144800000;						// Transmission frequency 144.800 MHz
	config[3].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[3].init_delay = 10000;							// Module startup delay in msec
 8007f90:	f8c5 e55c 	str.w	lr, [r5, #1372]	; 0x55c
	config[3].packet_spacing = 20000;						// Packet spacing in ms
	config[3].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[3].sleep_config.vbat_thres = 2700;				// Sleeping voltage threshold
	config[3].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[3].trigger.timeout = 10;							// Timeout 10 sec
 8007f94:	f8c5 3570 	str.w	r3, [r5, #1392]	; 0x570
	chsnprintf(config[3].aprs_config.callsign, 6, "DL7AD");// APRS Callsign
 8007f98:	2106      	movs	r1, #6
 8007f9a:	f505 60b0 	add.w	r0, r5, #1408	; 0x580
 8007f9e:	4a71      	ldr	r2, [pc, #452]	; (8008164 <main+0xe84>)
	MODULE_POSITION(&config[2]);*/

	// Module IMAGE, APRS 2m AFSK low-duty cycle
	chsnprintf(config[3].name, 12, "IMG AFSK 2m");			// Instance name
	config[3].power = 20;									// Power 20 dBm
	config[3].protocol = PROT_APRS_AFSK;					// Protocol APRS SSDV, modulation AFSK
 8007fa0:	f885 6558 	strb.w	r6, [r5, #1368]	; 0x558
	config[3].frequency.type = FREQ_DYNAMIC;				// Static frequency allocation
 8007fa4:	f885 654c 	strb.w	r6, [r5, #1356]	; 0x54c
	config[3].frequency.hz = 144800000;						// Transmission frequency 144.800 MHz
	config[3].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[3].init_delay = 10000;							// Module startup delay in msec
	config[3].packet_spacing = 20000;						// Packet spacing in ms
 8007fa8:	f8c5 8560 	str.w	r8, [r5, #1376]	; 0x560
	config[3].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
 8007fac:	f885 b564 	strb.w	fp, [r5, #1380]	; 0x564
	config[3].sleep_config.vbat_thres = 2700;				// Sleeping voltage threshold
	config[3].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
 8007fb0:	f885 b56c 	strb.w	fp, [r5, #1388]	; 0x56c
	config[3].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[3].aprs_config.callsign, 6, "DL7AD");// APRS Callsign
 8007fb4:	f004 f93c 	bl	800c230 <chsnprintf>
	config[3].aprs_config.ssid = 11;						// APRS SSID
 8007fb8:	f04f 030b 	mov.w	r3, #11
 8007fbc:	f885 3590 	strb.w	r3, [r5, #1424]	; 0x590
	config[3].aprs_config.preamble = 200;					// APRS Preamble
 8007fc0:	f04f 03c8 	mov.w	r3, #200	; 0xc8
 8007fc4:	f8a5 35a4 	strh.w	r3, [r5, #1444]	; 0x5a4
	chsnprintf(config[3].ssdv_config.callsign, 6, "DL7AD");// SSDV Callsign
 8007fc8:	2106      	movs	r1, #6
 8007fca:	f205 6034 	addw	r0, r5, #1588	; 0x634
 8007fce:	4a65      	ldr	r2, [pc, #404]	; (8008164 <main+0xe84>)
 8007fd0:	f004 f92e 	bl	800c230 <chsnprintf>
	config[3].ssdv_config.ram_buffer = ssdv1_buffer;		// Camera buffer
	config[3].ssdv_config.ram_size = sizeof(ssdv1_buffer);	// Buffer size
	config[3].ssdv_config.res = RES_QVGA;					// Resolution QVGA
	MODULE_IMAGE(&config[3]);
 8007fd4:	f505 63a5 	add.w	r3, r5, #1320	; 0x528
	chsnprintf(config[3].aprs_config.callsign, 6, "DL7AD");// APRS Callsign
	config[3].aprs_config.ssid = 11;						// APRS SSID
	config[3].aprs_config.preamble = 200;					// APRS Preamble
	chsnprintf(config[3].ssdv_config.callsign, 6, "DL7AD");// SSDV Callsign
	config[3].ssdv_config.ram_buffer = ssdv1_buffer;		// Camera buffer
	config[3].ssdv_config.ram_size = sizeof(ssdv1_buffer);	// Buffer size
 8007fd8:	f44f 4ea0 	mov.w	lr, #20480	; 0x5000
	config[3].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[3].aprs_config.callsign, 6, "DL7AD");// APRS Callsign
	config[3].aprs_config.ssid = 11;						// APRS SSID
	config[3].aprs_config.preamble = 200;					// APRS Preamble
	chsnprintf(config[3].ssdv_config.callsign, 6, "DL7AD");// SSDV Callsign
	config[3].ssdv_config.ram_buffer = ssdv1_buffer;		// Camera buffer
 8007fdc:	4866      	ldr	r0, [pc, #408]	; (8008178 <main+0xe98>)
	config[3].ssdv_config.ram_size = sizeof(ssdv1_buffer);	// Buffer size
 8007fde:	f8c5 e644 	str.w	lr, [r5, #1604]	; 0x644
	config[3].ssdv_config.res = RES_QVGA;					// Resolution QVGA
	MODULE_IMAGE(&config[3]);
 8007fe2:	4619      	mov	r1, r3
	config[3].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[3].aprs_config.callsign, 6, "DL7AD");// APRS Callsign
	config[3].aprs_config.ssid = 11;						// APRS SSID
	config[3].aprs_config.preamble = 200;					// APRS Preamble
	chsnprintf(config[3].ssdv_config.callsign, 6, "DL7AD");// SSDV Callsign
	config[3].ssdv_config.ram_buffer = ssdv1_buffer;		// Camera buffer
 8007fe4:	f8c5 0640 	str.w	r0, [r5, #1600]	; 0x640
	config[3].ssdv_config.ram_size = sizeof(ssdv1_buffer);	// Buffer size
	config[3].ssdv_config.res = RES_QVGA;					// Resolution QVGA
	MODULE_IMAGE(&config[3]);
 8007fe8:	4a64      	ldr	r2, [pc, #400]	; (800817c <main+0xe9c>)
	config[3].aprs_config.ssid = 11;						// APRS SSID
	config[3].aprs_config.preamble = 200;					// APRS Preamble
	chsnprintf(config[3].ssdv_config.callsign, 6, "DL7AD");// SSDV Callsign
	config[3].ssdv_config.ram_buffer = ssdv1_buffer;		// Camera buffer
	config[3].ssdv_config.ram_size = sizeof(ssdv1_buffer);	// Buffer size
	config[3].ssdv_config.res = RES_QVGA;					// Resolution QVGA
 8007fea:	f885 663c 	strb.w	r6, [r5, #1596]	; 0x63c
	MODULE_IMAGE(&config[3]);
 8007fee:	f641 00c8 	movw	r0, #6344	; 0x18c8
 8007ff2:	f00a fbb5 	bl	8012760 <chThdCreateFromHeap.constprop.87>
	chsnprintf(config[4].morse_config.callsign, 6, "DK0TU");// Morse Callsign
	chsnprintf(config[4].morse_config.format, 43, "BALLOON <CALL> <LOC> <ALT>M WWW.TKRAHN.NET"); // Morse Format
	MODULE_POSITION(&config[4]);*/

	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
 8007ff6:	f605 0098 	addw	r0, r5, #2200	; 0x898
 8007ffa:	4a61      	ldr	r2, [pc, #388]	; (8008180 <main+0xea0>)
	config[3].aprs_config.preamble = 200;					// APRS Preamble
	chsnprintf(config[3].ssdv_config.callsign, 6, "DL7AD");// SSDV Callsign
	config[3].ssdv_config.ram_buffer = ssdv1_buffer;		// Camera buffer
	config[3].ssdv_config.ram_size = sizeof(ssdv1_buffer);	// Buffer size
	config[3].ssdv_config.res = RES_QVGA;					// Resolution QVGA
	MODULE_IMAGE(&config[3]);
 8007ffc:	f885 66dc 	strb.w	r6, [r5, #1756]	; 0x6dc
	chsnprintf(config[4].morse_config.callsign, 6, "DK0TU");// Morse Callsign
	chsnprintf(config[4].morse_config.format, 43, "BALLOON <CALL> <LOC> <ALT>M WWW.TKRAHN.NET"); // Morse Format
	MODULE_POSITION(&config[4]);*/

	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
 8008000:	210d      	movs	r1, #13
 8008002:	f004 f915 	bl	800c230 <chsnprintf>
	config[5].power = 20;									// Power 20 dBm
 8008006:	f04f 0314 	mov.w	r3, #20
 800800a:	f885 38b8 	strb.w	r3, [r5, #2232]	; 0x8b8
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
	config[5].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 800800e:	4b54      	ldr	r3, [pc, #336]	; (8008160 <main+0xe80>)
	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
 8008010:	f8df e18c 	ldr.w	lr, [pc, #396]	; 80081a0 <main+0xec0>
	config[5].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 8008014:	f8c5 38c4 	str.w	r3, [r5, #2244]	; 0x8c4
	config[5].init_delay = 20000;							// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 3000;				// Sleeping voltage threshold
 8008018:	f640 3cb8 	movw	ip, #3000	; 0xbb8
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
 800801c:	230a      	movs	r3, #10
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
	config[5].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[5].init_delay = 20000;							// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 3000;				// Sleeping voltage threshold
 800801e:	f8a5 c8d6 	strh.w	ip, [r5, #2262]	; 0x8d6
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
 8008022:	f8c5 38e0 	str.w	r3, [r5, #2272]	; 0x8e0
	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
 8008026:	f8c5 e8c0 	str.w	lr, [r5, #2240]	; 0x8c0
	config[5].init_delay = 20000;							// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 3000;				// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 800802a:	4a4e      	ldr	r2, [pc, #312]	; (8008164 <main+0xe84>)

	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
 800802c:	f885 a8bc 	strb.w	sl, [r5, #2236]	; 0x8bc
	config[5].init_delay = 20000;							// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 3000;				// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 8008030:	2106      	movs	r1, #6
 8008032:	f505 600f 	add.w	r0, r5, #2288	; 0x8f0
	MODULE_POSITION(&config[4]);*/

	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
 8008036:	f885 b8c8 	strb.w	fp, [r5, #2248]	; 0x8c8
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
	config[5].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[5].init_delay = 20000;							// Module startup delay in msec
 800803a:	f8c5 88cc 	str.w	r8, [r5, #2252]	; 0x8cc
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
 800803e:	f885 b8d4 	strb.w	fp, [r5, #2260]	; 0x8d4
	config[5].sleep_config.vbat_thres = 3000;				// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
 8008042:	f885 b8dc 	strb.w	fp, [r5, #2268]	; 0x8dc
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 8008046:	f004 f8f3 	bl	800c230 <chsnprintf>
	config[5].aprs_config.ssid = 11;						// APRS SSID
	config[5].aprs_config.preamble = 40;					// APRS Preamble
 800804a:	2328      	movs	r3, #40	; 0x28
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 3000;				// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 11;						// APRS SSID
 800804c:	f04f 0e0b 	mov.w	lr, #11
 8008050:	f885 e900 	strb.w	lr, [r5, #2304]	; 0x900
	config[5].aprs_config.preamble = 40;					// APRS Preamble
 8008054:	f8a5 3914 	strh.w	r3, [r5, #2324]	; 0x914
	chsnprintf(config[5].ssdv_config.callsign, 6, "DL7AD");	// SSDV Callsign
 8008058:	2106      	movs	r1, #6
 800805a:	f605 10a4 	addw	r0, r5, #2468	; 0x9a4
 800805e:	4a41      	ldr	r2, [pc, #260]	; (8008164 <main+0xe84>)
 8008060:	f004 f8e6 	bl	800c230 <chsnprintf>
	config[5].ssdv_config.ram_buffer = ssdv2_buffer;		// Camera buffer
	config[5].ssdv_config.ram_size = sizeof(ssdv2_buffer);	// Buffer size
	config[5].ssdv_config.res = RES_XGA;					// Resolution XGA
	MODULE_IMAGE(&config[5]);
 8008064:	f605 0398 	addw	r3, r5, #2200	; 0x898
	config[5].aprs_config.ssid = 11;						// APRS SSID
	config[5].aprs_config.preamble = 40;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 6, "DL7AD");	// SSDV Callsign
	config[5].ssdv_config.ram_buffer = ssdv2_buffer;		// Camera buffer
	config[5].ssdv_config.ram_size = sizeof(ssdv2_buffer);	// Buffer size
	config[5].ssdv_config.res = RES_XGA;					// Resolution XGA
 8008068:	f04f 0e03 	mov.w	lr, #3
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 11;						// APRS SSID
	config[5].aprs_config.preamble = 40;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 6, "DL7AD");	// SSDV Callsign
	config[5].ssdv_config.ram_buffer = ssdv2_buffer;		// Camera buffer
 800806c:	4945      	ldr	r1, [pc, #276]	; (8008184 <main+0xea4>)
	config[5].ssdv_config.ram_size = sizeof(ssdv2_buffer);	// Buffer size
	config[5].ssdv_config.res = RES_XGA;					// Resolution XGA
 800806e:	f885 e9ac 	strb.w	lr, [r5, #2476]	; 0x9ac
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 11;						// APRS SSID
	config[5].aprs_config.preamble = 40;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 6, "DL7AD");	// SSDV Callsign
	config[5].ssdv_config.ram_buffer = ssdv2_buffer;		// Camera buffer
	config[5].ssdv_config.ram_size = sizeof(ssdv2_buffer);	// Buffer size
 8008072:	f44f 3002 	mov.w	r0, #133120	; 0x20800
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 11;						// APRS SSID
	config[5].aprs_config.preamble = 40;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 6, "DL7AD");	// SSDV Callsign
	config[5].ssdv_config.ram_buffer = ssdv2_buffer;		// Camera buffer
 8008076:	f8c5 19b0 	str.w	r1, [r5, #2480]	; 0x9b0
	config[5].ssdv_config.ram_size = sizeof(ssdv2_buffer);	// Buffer size
 800807a:	f8c5 09b4 	str.w	r0, [r5, #2484]	; 0x9b4
	config[5].ssdv_config.res = RES_XGA;					// Resolution XGA
	MODULE_IMAGE(&config[5]);
 800807e:	4619      	mov	r1, r3
 8008080:	4a3e      	ldr	r2, [pc, #248]	; (800817c <main+0xe9c>)
 8008082:	f641 00c8 	movw	r0, #6344	; 0x18c8
 8008086:	f00a fb6b 	bl	8012760 <chThdCreateFromHeap.constprop.87>
	config[6].ssdv_config.ram_size = sizeof(ssdv2_buffer);	// Buffer size
	config[6].ssdv_config.res = RES_VGA;					// Resolution VGA
	MODULE_IMAGE(&config[6]);*/

	// Module ERROR, APRS 2m AFSK
	chsnprintf(config[7].name, 17, "ERR APRS 2m AFSK");		// Instance name
 800808a:	f605 4008 	addw	r0, r5, #3080	; 0xc08
 800808e:	4a3e      	ldr	r2, [pc, #248]	; (8008188 <main+0xea8>)
	config[5].aprs_config.preamble = 40;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 6, "DL7AD");	// SSDV Callsign
	config[5].ssdv_config.ram_buffer = ssdv2_buffer;		// Camera buffer
	config[5].ssdv_config.ram_size = sizeof(ssdv2_buffer);	// Buffer size
	config[5].ssdv_config.res = RES_XGA;					// Resolution XGA
	MODULE_IMAGE(&config[5]);
 8008090:	f885 6a4c 	strb.w	r6, [r5, #2636]	; 0xa4c
	config[6].ssdv_config.ram_size = sizeof(ssdv2_buffer);	// Buffer size
	config[6].ssdv_config.res = RES_VGA;					// Resolution VGA
	MODULE_IMAGE(&config[6]);*/

	// Module ERROR, APRS 2m AFSK
	chsnprintf(config[7].name, 17, "ERR APRS 2m AFSK");		// Instance name
 8008094:	2111      	movs	r1, #17
 8008096:	f004 f8cb 	bl	800c230 <chsnprintf>
	config[7].power = 20;									// Power 20 dBm
 800809a:	f04f 0314 	mov.w	r3, #20
 800809e:	f885 3c28 	strb.w	r3, [r5, #3112]	; 0xc28
	config[7].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
	config[7].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[7].frequency.hz = 144800000;						// Default frequency 144.800 MHz
 80080a2:	4b2e      	ldr	r3, [pc, #184]	; (800815c <main+0xe7c>)
 80080a4:	f8c5 3c30 	str.w	r3, [r5, #3120]	; 0xc30
	config[7].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 80080a8:	4b2d      	ldr	r3, [pc, #180]	; (8008160 <main+0xe80>)
 80080aa:	f8c5 3c34 	str.w	r3, [r5, #3124]	; 0xc34
	config[7].init_delay = 60000;							// Module startup delay in msec
 80080ae:	f64e 2e60 	movw	lr, #60000	; 0xea60
	config[7].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[7].trigger.timeout = 600;						// Timeout 600 sec
 80080b2:	f44f 7316 	mov.w	r3, #600	; 0x258
	config[7].power = 20;									// Power 20 dBm
	config[7].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
	config[7].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[7].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[7].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[7].init_delay = 60000;							// Module startup delay in msec
 80080b6:	f8c5 ec3c 	str.w	lr, [r5, #3132]	; 0xc3c
	config[7].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[7].trigger.timeout = 600;						// Timeout 600 sec
 80080ba:	f8c5 3c50 	str.w	r3, [r5, #3152]	; 0xc50
	chsnprintf(config[7].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 80080be:	2106      	movs	r1, #6
 80080c0:	f505 6046 	add.w	r0, r5, #3168	; 0xc60
 80080c4:	4a27      	ldr	r2, [pc, #156]	; (8008164 <main+0xe84>)
	MODULE_IMAGE(&config[6]);*/

	// Module ERROR, APRS 2m AFSK
	chsnprintf(config[7].name, 17, "ERR APRS 2m AFSK");		// Instance name
	config[7].power = 20;									// Power 20 dBm
	config[7].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
 80080c6:	f885 6c38 	strb.w	r6, [r5, #3128]	; 0xc38
	config[7].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
 80080ca:	f885 6c2c 	strb.w	r6, [r5, #3116]	; 0xc2c
	config[7].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[7].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[7].init_delay = 60000;							// Module startup delay in msec
	config[7].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
 80080ce:	f885 bc4c 	strb.w	fp, [r5, #3148]	; 0xc4c
	config[7].trigger.timeout = 600;						// Timeout 600 sec
	chsnprintf(config[7].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 80080d2:	f004 f8ad 	bl	800c230 <chsnprintf>
	config[7].aprs_config.ssid = 11;						// APRS SSID
 80080d6:	f04f 030b 	mov.w	r3, #11
 80080da:	f885 3c70 	strb.w	r3, [r5, #3184]	; 0xc70
	chsnprintf(config[7].aprs_config.path, 16, "WIDE1-1");	// APRS Path
 80080de:	f605 4074 	addw	r0, r5, #3188	; 0xc74
 80080e2:	4a21      	ldr	r2, [pc, #132]	; (8008168 <main+0xe88>)
 80080e4:	2110      	movs	r1, #16
 80080e6:	f004 f8a3 	bl	800c230 <chsnprintf>
	config[7].aprs_config.preamble = 200;					// APRS Preamble
	MODULE_ERROR(&config[7]);
 80080ea:	f605 4308 	addw	r3, r5, #3080	; 0xc08
	config[7].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[7].trigger.timeout = 600;						// Timeout 600 sec
	chsnprintf(config[7].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[7].aprs_config.ssid = 11;						// APRS SSID
	chsnprintf(config[7].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[7].aprs_config.preamble = 200;					// APRS Preamble
 80080ee:	f04f 00c8 	mov.w	r0, #200	; 0xc8
	MODULE_ERROR(&config[7]);
 80080f2:	4619      	mov	r1, r3
	config[7].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[7].trigger.timeout = 600;						// Timeout 600 sec
	chsnprintf(config[7].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[7].aprs_config.ssid = 11;						// APRS SSID
	chsnprintf(config[7].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[7].aprs_config.preamble = 200;					// APRS Preamble
 80080f4:	f8a5 0c84 	strh.w	r0, [r5, #3204]	; 0xc84
	MODULE_ERROR(&config[7]);
 80080f8:	4a24      	ldr	r2, [pc, #144]	; (800818c <main+0xeac>)
 80080fa:	f640 00c8 	movw	r0, #2248	; 0x8c8
 80080fe:	f00a fb2f 	bl	8012760 <chThdCreateFromHeap.constprop.87>

	// Module LOG, APRS 2m AFSK
	chsnprintf(config[8].name, 17, "LOG APRS 2m AFSK");		// Instance name
 8008102:	f505 605c 	add.w	r0, r5, #3520	; 0xdc0
 8008106:	4a22      	ldr	r2, [pc, #136]	; (8008190 <main+0xeb0>)
	config[7].trigger.timeout = 600;						// Timeout 600 sec
	chsnprintf(config[7].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[7].aprs_config.ssid = 11;						// APRS SSID
	chsnprintf(config[7].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[7].aprs_config.preamble = 200;					// APRS Preamble
	MODULE_ERROR(&config[7]);
 8008108:	f885 6dbc 	strb.w	r6, [r5, #3516]	; 0xdbc

	// Module LOG, APRS 2m AFSK
	chsnprintf(config[8].name, 17, "LOG APRS 2m AFSK");		// Instance name
 800810c:	2111      	movs	r1, #17
 800810e:	f004 f88f 	bl	800c230 <chsnprintf>
	config[8].power = 20;									// Power 20 dBm
 8008112:	f04f 0314 	mov.w	r3, #20
 8008116:	e045      	b.n	80081a4 <main+0xec4>
 8008118:	0801504c 	.word	0x0801504c
 800811c:	20027edc 	.word	0x20027edc
 8008120:	20027b2c 	.word	0x20027b2c
 8008124:	20005fac 	.word	0x20005fac
 8008128:	08013c50 	.word	0x08013c50
 800812c:	20027e60 	.word	0x20027e60
 8008130:	08013cfc 	.word	0x08013cfc
 8008134:	08013c5c 	.word	0x08013c5c
 8008138:	20005f18 	.word	0x20005f18
 800813c:	080150c8 	.word	0x080150c8
 8008140:	08013c78 	.word	0x08013c78
 8008144:	08013d00 	.word	0x08013d00
 8008148:	080150d0 	.word	0x080150d0
 800814c:	08013cac 	.word	0x08013cac
 8008150:	08001b91 	.word	0x08001b91
 8008154:	080150e8 	.word	0x080150e8
 8008158:	080150f4 	.word	0x080150f4
 800815c:	08a17900 	.word	0x08a17900
 8008160:	080113d1 	.word	0x080113d1
 8008164:	08015108 	.word	0x08015108
 8008168:	08015110 	.word	0x08015110
 800816c:	08015118 	.word	0x08015118
 8008170:	08008a51 	.word	0x08008a51
 8008174:	0801512c 	.word	0x0801512c
 8008178:	20000f10 	.word	0x20000f10
 800817c:	08003c61 	.word	0x08003c61
 8008180:	08015138 	.word	0x08015138
 8008184:	20006f24 	.word	0x20006f24
 8008188:	08015148 	.word	0x08015148
 800818c:	08010171 	.word	0x08010171
 8008190:	0801515c 	.word	0x0801515c
 8008194:	200278f8 	.word	0x200278f8
 8008198:	20027770 	.word	0x20027770
 800819c:	2002772c 	.word	0x2002772c
 80081a0:	08a26360 	.word	0x08a26360
 80081a4:	f885 3de0 	strb.w	r3, [r5, #3552]	; 0xde0
	config[8].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
	config[8].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[8].frequency.hz = 144800000;						// Default frequency 144.800 MHz
 80081a8:	4bad      	ldr	r3, [pc, #692]	; (8008460 <main+0x1180>)
 80081aa:	f8c5 3de8 	str.w	r3, [r5, #3560]	; 0xde8
	config[8].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 80081ae:	4bad      	ldr	r3, [pc, #692]	; (8008464 <main+0x1184>)
 80081b0:	f8c5 3dec 	str.w	r3, [r5, #3564]	; 0xdec
	config[8].init_delay = 65000;							// Module startup delay in msec
 80081b4:	f64f 5ee8 	movw	lr, #65000	; 0xfde8
	config[8].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[8].trigger.timeout = 600;						// Timeout 600 sec
 80081b8:	f44f 7316 	mov.w	r3, #600	; 0x258
	config[8].power = 20;									// Power 20 dBm
	config[8].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
	config[8].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[8].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[8].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[8].init_delay = 65000;							// Module startup delay in msec
 80081bc:	f8c5 edf4 	str.w	lr, [r5, #3572]	; 0xdf4
	config[8].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[8].trigger.timeout = 600;						// Timeout 600 sec
 80081c0:	f8c5 3e08 	str.w	r3, [r5, #3592]	; 0xe08
	chsnprintf(config[8].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 80081c4:	2106      	movs	r1, #6
 80081c6:	f605 6018 	addw	r0, r5, #3608	; 0xe18
 80081ca:	4aa7      	ldr	r2, [pc, #668]	; (8008468 <main+0x1188>)
	MODULE_ERROR(&config[7]);

	// Module LOG, APRS 2m AFSK
	chsnprintf(config[8].name, 17, "LOG APRS 2m AFSK");		// Instance name
	config[8].power = 20;									// Power 20 dBm
	config[8].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
 80081cc:	f885 6df0 	strb.w	r6, [r5, #3568]	; 0xdf0
	config[8].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
 80081d0:	f885 6de4 	strb.w	r6, [r5, #3556]	; 0xde4
	config[8].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[8].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[8].init_delay = 65000;							// Module startup delay in msec
	config[8].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
 80081d4:	f885 be04 	strb.w	fp, [r5, #3588]	; 0xe04
	config[8].trigger.timeout = 600;						// Timeout 600 sec
	chsnprintf(config[8].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 80081d8:	f004 f82a 	bl	800c230 <chsnprintf>
	config[8].aprs_config.ssid = 11;						// APRS SSID
 80081dc:	f04f 030b 	mov.w	r3, #11
 80081e0:	f885 3e28 	strb.w	r3, [r5, #3624]	; 0xe28
	chsnprintf(config[8].aprs_config.path, 16, "WIDE1-1");	// APRS Path
 80081e4:	f605 602c 	addw	r0, r5, #3628	; 0xe2c
 80081e8:	4aa0      	ldr	r2, [pc, #640]	; (800846c <main+0x118c>)
 80081ea:	2110      	movs	r1, #16
 80081ec:	f004 f820 	bl	800c230 <chsnprintf>
	config[8].aprs_config.preamble = 200;					// APRS Preamble
	MODULE_LOG(&config[8]);
 80081f0:	f505 635c 	add.w	r3, r5, #3520	; 0xdc0
	config[8].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[8].trigger.timeout = 600;						// Timeout 600 sec
	chsnprintf(config[8].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[8].aprs_config.ssid = 11;						// APRS SSID
	chsnprintf(config[8].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[8].aprs_config.preamble = 200;					// APRS Preamble
 80081f4:	f04f 00c8 	mov.w	r0, #200	; 0xc8
	MODULE_LOG(&config[8]);
 80081f8:	4619      	mov	r1, r3
 80081fa:	4a9d      	ldr	r2, [pc, #628]	; (8008470 <main+0x1190>)
	config[8].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[8].trigger.timeout = 600;						// Timeout 600 sec
	chsnprintf(config[8].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[8].aprs_config.ssid = 11;						// APRS SSID
	chsnprintf(config[8].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[8].aprs_config.preamble = 200;					// APRS Preamble
 80081fc:	f8a5 0e3c 	strh.w	r0, [r5, #3644]	; 0xe3c
	MODULE_LOG(&config[8]);
 8008200:	f640 00c8 	movw	r0, #2248	; 0x8c8
 8008204:	f00a faac 	bl	8012760 <chThdCreateFromHeap.constprop.87>
	}
}

void pac1720_init(void)
{
	TRACE_INFO("PAC  > Init PAC1720");
 8008208:	489a      	ldr	r0, [pc, #616]	; (8008474 <main+0x1194>)
 800820a:	f885 6f74 	strb.w	r6, [r5, #3956]	; 0xf74
 800820e:	f006 fe6f 	bl	800eef0 <chMtxLock>
 8008212:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8008216:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800821a:	fbb2 f2f8 	udiv	r2, r2, r8
 800821e:	4996      	ldr	r1, [pc, #600]	; (8008478 <main+0x1198>)
 8008220:	4896      	ldr	r0, [pc, #600]	; (800847c <main+0x119c>)
 8008222:	fb07 f303 	mul.w	r3, r7, r3
 8008226:	fbb3 f3f8 	udiv	r3, r3, r8
 800822a:	fbb3 f5f7 	udiv	r5, r3, r7
 800822e:	fb07 3315 	mls	r3, r7, r5, r3
 8008232:	f00a fa55 	bl	80126e0 <chprintf.constprop.35>
 8008236:	4a92      	ldr	r2, [pc, #584]	; (8008480 <main+0x11a0>)
 8008238:	4992      	ldr	r1, [pc, #584]	; (8008484 <main+0x11a4>)
 800823a:	4890      	ldr	r0, [pc, #576]	; (800847c <main+0x119c>)
 800823c:	f00a fa50 	bl	80126e0 <chprintf.constprop.35>
 8008240:	236a      	movs	r3, #106	; 0x6a
 8008242:	4a91      	ldr	r2, [pc, #580]	; (8008488 <main+0x11a8>)
 8008244:	4991      	ldr	r1, [pc, #580]	; (800848c <main+0x11ac>)
 8008246:	488d      	ldr	r0, [pc, #564]	; (800847c <main+0x119c>)
 8008248:	f00a fa4a 	bl	80126e0 <chprintf.constprop.35>
 800824c:	4990      	ldr	r1, [pc, #576]	; (8008490 <main+0x11b0>)
 800824e:	488b      	ldr	r0, [pc, #556]	; (800847c <main+0x119c>)
 8008250:	f00a fa46 	bl	80126e0 <chprintf.constprop.35>
 8008254:	498f      	ldr	r1, [pc, #572]	; (8008494 <main+0x11b4>)
 8008256:	4889      	ldr	r0, [pc, #548]	; (800847c <main+0x119c>)
 8008258:	f00a fa42 	bl	80126e0 <chprintf.constprop.35>
 800825c:	498e      	ldr	r1, [pc, #568]	; (8008498 <main+0x11b8>)
 800825e:	4887      	ldr	r0, [pc, #540]	; (800847c <main+0x119c>)
 8008260:	f00a fa3e 	bl	80126e0 <chprintf.constprop.35>
 8008264:	4883      	ldr	r0, [pc, #524]	; (8008474 <main+0x1194>)
 8008266:	f006 fde3 	bl	800ee30 <chMtxUnlock>
	/* Write for both channels
	 * Current sensor sampling time	80ms (Denominator 2047)
	 * Current sensing average disabled
	 * Current sensing range +-80mV (FSR)
	 */
	I2C_write8(PAC1720_ADDRESS, PAC1720_CH1_VSENSE_SAMP_CONFIG, 0x53);
 800826a:	210b      	movs	r1, #11
 800826c:	2253      	movs	r2, #83	; 0x53
 800826e:	204c      	movs	r0, #76	; 0x4c
 8008270:	f002 f846 	bl	800a300 <I2C_write8>
	I2C_write8(PAC1720_ADDRESS, PAC1720_CH2_VSENSE_SAMP_CONFIG, 0x53);
 8008274:	2253      	movs	r2, #83	; 0x53
 8008276:	210c      	movs	r1, #12
 8008278:	204c      	movs	r0, #76	; 0x4c
 800827a:	f002 f841 	bl	800a300 <I2C_write8>
	I2C_write8(PAC1720_ADDRESS, PAC1720_V_SOURCE_SAMP_CONFIG,   0xFF);
 800827e:	210a      	movs	r1, #10
 8008280:	22ff      	movs	r2, #255	; 0xff
 8008282:	204c      	movs	r0, #76	; 0x4c
 8008284:	f002 f83c 	bl	800a300 <I2C_write8>

	TRACE_INFO("PAC  > Init PAC1720 continuous measurement");
 8008288:	487a      	ldr	r0, [pc, #488]	; (8008474 <main+0x1194>)
 800828a:	f006 fe31 	bl	800eef0 <chMtxLock>
 800828e:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8008292:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8008296:	fbb2 f2f8 	udiv	r2, r2, r8
 800829a:	4977      	ldr	r1, [pc, #476]	; (8008478 <main+0x1198>)
 800829c:	4877      	ldr	r0, [pc, #476]	; (800847c <main+0x119c>)
 800829e:	fb07 f303 	mul.w	r3, r7, r3
 80082a2:	fbb3 f3f8 	udiv	r3, r3, r8
 80082a6:	fbb3 f5f7 	udiv	r5, r3, r7
 80082aa:	fb07 3315 	mls	r3, r7, r5, r3
 80082ae:	f00a fa17 	bl	80126e0 <chprintf.constprop.35>
 80082b2:	4a73      	ldr	r2, [pc, #460]	; (8008480 <main+0x11a0>)
 80082b4:	4973      	ldr	r1, [pc, #460]	; (8008484 <main+0x11a4>)
 80082b6:	4871      	ldr	r0, [pc, #452]	; (800847c <main+0x119c>)
 80082b8:	f00a fa12 	bl	80126e0 <chprintf.constprop.35>
 80082bc:	2375      	movs	r3, #117	; 0x75
 80082be:	4a72      	ldr	r2, [pc, #456]	; (8008488 <main+0x11a8>)
 80082c0:	4972      	ldr	r1, [pc, #456]	; (800848c <main+0x11ac>)
 80082c2:	486e      	ldr	r0, [pc, #440]	; (800847c <main+0x119c>)
 80082c4:	f00a fa0c 	bl	80126e0 <chprintf.constprop.35>
 80082c8:	4971      	ldr	r1, [pc, #452]	; (8008490 <main+0x11b0>)
 80082ca:	486c      	ldr	r0, [pc, #432]	; (800847c <main+0x119c>)
 80082cc:	f00a fa08 	bl	80126e0 <chprintf.constprop.35>
 80082d0:	4972      	ldr	r1, [pc, #456]	; (800849c <main+0x11bc>)
 80082d2:	486a      	ldr	r0, [pc, #424]	; (800847c <main+0x119c>)
 80082d4:	f00a fa04 	bl	80126e0 <chprintf.constprop.35>
 80082d8:	496f      	ldr	r1, [pc, #444]	; (8008498 <main+0x11b8>)
 80082da:	4868      	ldr	r0, [pc, #416]	; (800847c <main+0x119c>)
 80082dc:	f00a fa00 	bl	80126e0 <chprintf.constprop.35>
 80082e0:	4864      	ldr	r0, [pc, #400]	; (8008474 <main+0x1194>)
 80082e2:	f006 fda5 	bl	800ee30 <chMtxUnlock>
	chThdCreateFromHeap(NULL, THD_WORKING_AREA_SIZE(256), "PAC1720", NORMALPRIO, pac1720_thd, NULL);
 80082e6:	4653      	mov	r3, sl
 80082e8:	4a6d      	ldr	r2, [pc, #436]	; (80084a0 <main+0x11c0>)
 80082ea:	496e      	ldr	r1, [pc, #440]	; (80084a4 <main+0x11c4>)
 80082ec:	f44f 70e4 	mov.w	r0, #456	; 0x1c8
 80082f0:	f00a fa36 	bl	8012760 <chThdCreateFromHeap.constprop.87>
MMCDriver MMCD1;
bool sdInitialized = false;

bool initSD(void)
{
	TRACE_INFO("SD   > Initialize SD card");
 80082f4:	485f      	ldr	r0, [pc, #380]	; (8008474 <main+0x1194>)
 80082f6:	f006 fdfb 	bl	800eef0 <chMtxLock>
 80082fa:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 80082fe:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8008302:	fbb2 f2f8 	udiv	r2, r2, r8
 8008306:	495c      	ldr	r1, [pc, #368]	; (8008478 <main+0x1198>)
 8008308:	485c      	ldr	r0, [pc, #368]	; (800847c <main+0x119c>)
 800830a:	fb07 f303 	mul.w	r3, r7, r3
 800830e:	fbb3 f3f8 	udiv	r3, r3, r8
 8008312:	fbb3 f5f7 	udiv	r5, r3, r7
 8008316:	fb07 3315 	mls	r3, r7, r5, r3
 800831a:	f00a f9e1 	bl	80126e0 <chprintf.constprop.35>
 800831e:	4a58      	ldr	r2, [pc, #352]	; (8008480 <main+0x11a0>)
 8008320:	4958      	ldr	r1, [pc, #352]	; (8008484 <main+0x11a4>)
 8008322:	4856      	ldr	r0, [pc, #344]	; (800847c <main+0x119c>)
 8008324:	f00a f9dc 	bl	80126e0 <chprintf.constprop.35>
 8008328:	230c      	movs	r3, #12
 800832a:	4a5f      	ldr	r2, [pc, #380]	; (80084a8 <main+0x11c8>)
 800832c:	4957      	ldr	r1, [pc, #348]	; (800848c <main+0x11ac>)
 800832e:	4853      	ldr	r0, [pc, #332]	; (800847c <main+0x119c>)
 8008330:	f00a f9d6 	bl	80126e0 <chprintf.constprop.35>
 8008334:	4956      	ldr	r1, [pc, #344]	; (8008490 <main+0x11b0>)
 8008336:	4851      	ldr	r0, [pc, #324]	; (800847c <main+0x119c>)
 8008338:	f00a f9d2 	bl	80126e0 <chprintf.constprop.35>
 800833c:	495b      	ldr	r1, [pc, #364]	; (80084ac <main+0x11cc>)
 800833e:	484f      	ldr	r0, [pc, #316]	; (800847c <main+0x119c>)
 8008340:	f00a f9ce 	bl	80126e0 <chprintf.constprop.35>
 8008344:	4954      	ldr	r1, [pc, #336]	; (8008498 <main+0x11b8>)
 8008346:	484d      	ldr	r0, [pc, #308]	; (800847c <main+0x119c>)
 8008348:	f00a f9ca 	bl	80126e0 <chprintf.constprop.35>
 800834c:	4849      	ldr	r0, [pc, #292]	; (8008474 <main+0x1194>)
 800834e:	f006 fd6f 	bl	800ee30 <chMtxUnlock>
  osalDbgCheck((mmcp != NULL) && (config != NULL));
  osalDbgAssert((mmcp->state == BLK_STOP) || (mmcp->state == BLK_ACTIVE),
                "invalid state");

  mmcp->config = config;
  mmcp->state = BLK_ACTIVE;
 8008352:	4957      	ldr	r1, [pc, #348]	; (80084b0 <main+0x11d0>)
 *
 * @init
 */
void mmcObjectInit(MMCDriver *mmcp) {

  mmcp->vmt = &mmc_vmt;
 8008354:	4a57      	ldr	r2, [pc, #348]	; (80084b4 <main+0x11d4>)

  osalDbgCheck((mmcp != NULL) && (config != NULL));
  osalDbgAssert((mmcp->state == BLK_STOP) || (mmcp->state == BLK_ACTIVE),
                "invalid state");

  mmcp->config = config;
 8008356:	4b58      	ldr	r3, [pc, #352]	; (80084b8 <main+0x11d8>)
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8008358:	4858      	ldr	r0, [pc, #352]	; (80084bc <main+0x11dc>)
  mmcp->state = BLK_ACTIVE;
 800835a:	f881 b004 	strb.w	fp, [r1, #4]
void mmcObjectInit(MMCDriver *mmcp) {

  mmcp->vmt = &mmc_vmt;
  mmcp->state = BLK_STOP;
  mmcp->config = NULL;
  mmcp->block_addresses = false;
 800835e:	f881 a030 	strb.w	sl, [r1, #48]	; 0x30
 *
 * @init
 */
void mmcObjectInit(MMCDriver *mmcp) {

  mmcp->vmt = &mmc_vmt;
 8008362:	600a      	str	r2, [r1, #0]

  osalDbgCheck((mmcp != NULL) && (config != NULL));
  osalDbgAssert((mmcp->state == BLK_STOP) || (mmcp->state == BLK_ACTIVE),
                "invalid state");

  mmcp->config = config;
 8008364:	62cb      	str	r3, [r1, #44]	; 0x2c
 8008366:	f006 fdc3 	bl	800eef0 <chMtxLock>
	mmcObjectInit(&MMCD1);
	mmcStart(&MMCD1, &mmccfg);

	// Check SD card presence
	spiAcquireBus(&SPID2);
	if(mmcConnect(&MMCD1)) {
 800836a:	4851      	ldr	r0, [pc, #324]	; (80084b0 <main+0x11d0>)
 800836c:	f002 fd38 	bl	800ade0 <mmcConnect>
 8008370:	2800      	cmp	r0, #0
 8008372:	f040 830e 	bne.w	8008992 <main+0x16b2>
		TRACE_ERROR("SD   > No SD card found");
	} else {
		TRACE_INFO("SD   > SD card found");
 8008376:	483f      	ldr	r0, [pc, #252]	; (8008474 <main+0x1194>)
 8008378:	f006 fdba 	bl	800eef0 <chMtxLock>
 800837c:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8008380:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8008384:	fbb2 f2f8 	udiv	r2, r2, r8
 8008388:	fb07 f303 	mul.w	r3, r7, r3
 800838c:	493a      	ldr	r1, [pc, #232]	; (8008478 <main+0x1198>)
 800838e:	fbb3 f8f8 	udiv	r8, r3, r8
 8008392:	483a      	ldr	r0, [pc, #232]	; (800847c <main+0x119c>)
 8008394:	fbb8 f3f7 	udiv	r3, r8, r7
 8008398:	fb07 8313 	mls	r3, r7, r3, r8
 800839c:	f00a f9a0 	bl	80126e0 <chprintf.constprop.35>
 80083a0:	4a37      	ldr	r2, [pc, #220]	; (8008480 <main+0x11a0>)
 80083a2:	4938      	ldr	r1, [pc, #224]	; (8008484 <main+0x11a4>)
 80083a4:	4835      	ldr	r0, [pc, #212]	; (800847c <main+0x119c>)
 80083a6:	f00a f99b 	bl	80126e0 <chprintf.constprop.35>
 80083aa:	2327      	movs	r3, #39	; 0x27
 80083ac:	4a3e      	ldr	r2, [pc, #248]	; (80084a8 <main+0x11c8>)
 80083ae:	4937      	ldr	r1, [pc, #220]	; (800848c <main+0x11ac>)
 80083b0:	4832      	ldr	r0, [pc, #200]	; (800847c <main+0x119c>)
 80083b2:	f00a f995 	bl	80126e0 <chprintf.constprop.35>
 80083b6:	4936      	ldr	r1, [pc, #216]	; (8008490 <main+0x11b0>)
 80083b8:	4830      	ldr	r0, [pc, #192]	; (800847c <main+0x119c>)
 80083ba:	f00a f991 	bl	80126e0 <chprintf.constprop.35>
 80083be:	4940      	ldr	r1, [pc, #256]	; (80084c0 <main+0x11e0>)
 80083c0:	482e      	ldr	r0, [pc, #184]	; (800847c <main+0x119c>)
 80083c2:	f00a f98d 	bl	80126e0 <chprintf.constprop.35>
 80083c6:	4934      	ldr	r1, [pc, #208]	; (8008498 <main+0x11b8>)
 80083c8:	482c      	ldr	r0, [pc, #176]	; (800847c <main+0x119c>)
 80083ca:	f00a f989 	bl	80126e0 <chprintf.constprop.35>
 80083ce:	4829      	ldr	r0, [pc, #164]	; (8008474 <main+0x1194>)
 80083d0:	f006 fd2e 	bl	800ee30 <chMtxUnlock>
		sdInitialized = true;
 80083d4:	4b3b      	ldr	r3, [pc, #236]	; (80084c4 <main+0x11e4>)
 80083d6:	701e      	strb	r6, [r3, #0]
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80083d8:	4838      	ldr	r0, [pc, #224]	; (80084bc <main+0x11dc>)
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 80083da:	4d3b      	ldr	r5, [pc, #236]	; (80084c8 <main+0x11e8>)
 80083dc:	f006 fd28 	bl	800ee30 <chMtxUnlock>
	initModules();				// Startup optional modules (eg. POSITION, LOG, ...)
	pac1720_init();				// Startup current measurement
	initSD();					// Startup SD

	chThdSleepMilliseconds(100);
 80083e0:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80083e4:	f006 fe54 	bl	800f090 <chThdSleep>
 80083e8:	2300      	movs	r3, #0
 80083ea:	60eb      	str	r3, [r5, #12]
 80083ec:	2320      	movs	r3, #32
 80083ee:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80083f2:	f006 fcc5 	bl	800ed80 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 80083f6:	f006 fa2b 	bl	800e850 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 80083fa:	68eb      	ldr	r3, [r5, #12]
 80083fc:	b113      	cbz	r3, 8008404 <main+0x1124>
    chVTDoResetI(vtp);
 80083fe:	4628      	mov	r0, r5
 8008400:	f006 fb2e 	bl	800ea60 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8008404:	2300      	movs	r3, #0
 8008406:	4a31      	ldr	r2, [pc, #196]	; (80084cc <main+0x11ec>)
 8008408:	482f      	ldr	r0, [pc, #188]	; (80084c8 <main+0x11e8>)
 800840a:	f242 7110 	movw	r1, #10000	; 0x2710
 800840e:	f006 fb6f 	bl	800eaf0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8008412:	f006 fca5 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008416:	6823      	ldr	r3, [r4, #0]
 8008418:	4a2d      	ldr	r2, [pc, #180]	; (80084d0 <main+0x11f0>)
 800841a:	42a3      	cmp	r3, r4
 800841c:	d005      	beq.n	800842a <main+0x114a>
 800841e:	6992      	ldr	r2, [r2, #24]
 8008420:	689b      	ldr	r3, [r3, #8]
 8008422:	6892      	ldr	r2, [r2, #8]
 8008424:	429a      	cmp	r2, r3
 8008426:	f0c0 82b1 	bcc.w	800898c <main+0x16ac>
 800842a:	2300      	movs	r3, #0
 800842c:	f383 8811 	msr	BASEPRI, r3

	// Initialize LED timer
	chVTObjectInit(&vt);
	chVTSet(&vt, MS2ST(500), led_cb, 0);

	chThdSleepMilliseconds(1000);
 8008430:	f644 6020 	movw	r0, #20000	; 0x4e20
 8008434:	f006 fe2c 	bl	800f090 <chThdSleep>
 8008438:	f8df 909c 	ldr.w	r9, [pc, #156]	; 80084d8 <main+0x11f8>

				// Debugging every 10 sec
				if(counter % 10 == 0) {
					lu = chVTGetSystemTimeX() - config[i].last_update;
					if(healthy) {
						TRACE_INFO("WDG  > Module %s OK (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
 800843c:	f8df b09c 	ldr.w	fp, [pc, #156]	; 80084dc <main+0x11fc>

	chThdSleepMilliseconds(1000);

	while(true) {
		// Print time every 10 sec
		if(counter % 10 == 0)
 8008440:	f8d9 1000 	ldr.w	r1, [r9]
 8008444:	230a      	movs	r3, #10
 8008446:	fbb1 f2f3 	udiv	r2, r1, r3
 800844a:	fb03 1312 	mls	r3, r3, r2, r1
 800844e:	2b00      	cmp	r3, #0
 8008450:	f000 820b 	beq.w	800886a <main+0x158a>
 8008454:	4c1f      	ldr	r4, [pc, #124]	; (80084d4 <main+0x11f4>)
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 8008456:	2600      	movs	r6, #0
 8008458:	f604 7578 	addw	r5, r4, #3960	; 0xf78
 800845c:	e09d      	b.n	800859a <main+0x12ba>
 800845e:	bf00      	nop
 8008460:	08a17900 	.word	0x08a17900
 8008464:	080113d1 	.word	0x080113d1
 8008468:	08015108 	.word	0x08015108
 800846c:	08015110 	.word	0x08015110
 8008470:	08010471 	.word	0x08010471
 8008474:	20027b2c 	.word	0x20027b2c
 8008478:	08013c50 	.word	0x08013c50
 800847c:	20027e60 	.word	0x20027e60
 8008480:	08013cfc 	.word	0x08013cfc
 8008484:	08013c5c 	.word	0x08013c5c
 8008488:	08015178 	.word	0x08015178
 800848c:	08013c78 	.word	0x08013c78
 8008490:	08013d00 	.word	0x08013d00
 8008494:	08015184 	.word	0x08015184
 8008498:	08013cac 	.word	0x08013cac
 800849c:	08015198 	.word	0x08015198
 80084a0:	0800fa61 	.word	0x0800fa61
 80084a4:	08015190 	.word	0x08015190
 80084a8:	08014484 	.word	0x08014484
 80084ac:	080151c4 	.word	0x080151c4
 80084b0:	20028764 	.word	0x20028764
 80084b4:	08014f18 	.word	0x08014f18
 80084b8:	20000810 	.word	0x20000810
 80084bc:	200287a8 	.word	0x200287a8
 80084c0:	080151f8 	.word	0x080151f8
 80084c4:	20027798 	.word	0x20027798
 80084c8:	20027784 	.word	0x20027784
 80084cc:	08011b91 	.word	0x08011b91
 80084d0:	20027edc 	.word	0x20027edc
 80084d4:	20005fac 	.word	0x20005fac
 80084d8:	20005fa8 	.word	0x20005fa8
 80084dc:	01312d00 	.word	0x01312d00
			
			if(config[i].active) { // Is active?

				// Determine health
				healthy = true;
				switch(config[i].trigger.type)
 80084e0:	2b03      	cmp	r3, #3
 80084e2:	f000 80f4 	beq.w	80086ce <main+0x13ee>
 80084e6:	2b01      	cmp	r3, #1
 80084e8:	f000 80de 	beq.w	80086a8 <main+0x13c8>
						break;
				}
				healthy = healthy || config[i].init_delay + wdg_buffer > chVTGetSystemTimeX();

				// Debugging every 10 sec
				if(counter % 10 == 0) {
 80084ec:	f8d9 1000 	ldr.w	r1, [r9]
 80084f0:	230a      	movs	r3, #10
 80084f2:	fbb1 f2f3 	udiv	r2, r1, r3
 80084f6:	fb03 1312 	mls	r3, r3, r2, r1
 80084fa:	2b00      	cmp	r3, #0
 80084fc:	d148      	bne.n	8008590 <main+0x12b0>
 80084fe:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
					lu = chVTGetSystemTimeX() - config[i].last_update;
 8008502:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
 8008506:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8008508:	ebc3 0a02 	rsb	sl, r3, r2
					if(healthy) {
						TRACE_INFO("WDG  > Module %s OK (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
 800850c:	48a9      	ldr	r0, [pc, #676]	; (80087b4 <main+0x14d4>)
 800850e:	f006 fcef 	bl	800eef0 <chMtxLock>
 8008512:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008516:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 800851a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800851c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800851e:	49a6      	ldr	r1, [pc, #664]	; (80087b8 <main+0x14d8>)
 8008520:	48a6      	ldr	r0, [pc, #664]	; (80087bc <main+0x14dc>)
 8008522:	f644 6820 	movw	r8, #20000	; 0x4e20
 8008526:	fb07 f303 	mul.w	r3, r7, r3
 800852a:	fbb2 f2f8 	udiv	r2, r2, r8
 800852e:	fbb3 f3f8 	udiv	r3, r3, r8
 8008532:	fbb3 fef7 	udiv	lr, r3, r7
 8008536:	fb07 331e 	mls	r3, r7, lr, r3
 800853a:	f00a f8d1 	bl	80126e0 <chprintf.constprop.35>
 800853e:	4aa0      	ldr	r2, [pc, #640]	; (80087c0 <main+0x14e0>)
 8008540:	49a0      	ldr	r1, [pc, #640]	; (80087c4 <main+0x14e4>)
 8008542:	489e      	ldr	r0, [pc, #632]	; (80087bc <main+0x14dc>)
 8008544:	f00a f8cc 	bl	80126e0 <chprintf.constprop.35>
 8008548:	2380      	movs	r3, #128	; 0x80
 800854a:	4a9f      	ldr	r2, [pc, #636]	; (80087c8 <main+0x14e8>)
 800854c:	499f      	ldr	r1, [pc, #636]	; (80087cc <main+0x14ec>)
 800854e:	489b      	ldr	r0, [pc, #620]	; (80087bc <main+0x14dc>)
 8008550:	f00a f8c6 	bl	80126e0 <chprintf.constprop.35>
 8008554:	499e      	ldr	r1, [pc, #632]	; (80087d0 <main+0x14f0>)
 8008556:	4899      	ldr	r0, [pc, #612]	; (80087bc <main+0x14dc>)
 8008558:	f00a f8c2 	bl	80126e0 <chprintf.constprop.35>
 800855c:	fb07 f30a 	mul.w	r3, r7, sl
 8008560:	f503 439c 	add.w	r3, r3, #19968	; 0x4e00
 8008564:	331f      	adds	r3, #31
 8008566:	fbb3 f8f8 	udiv	r8, r3, r8
 800856a:	fbb8 f2f7 	udiv	r2, r8, r7
 800856e:	fb07 8712 	mls	r7, r7, r2, r8
 8008572:	fbb3 f3fb 	udiv	r3, r3, fp
 8008576:	4622      	mov	r2, r4
 8008578:	4996      	ldr	r1, [pc, #600]	; (80087d4 <main+0x14f4>)
 800857a:	9700      	str	r7, [sp, #0]
 800857c:	488f      	ldr	r0, [pc, #572]	; (80087bc <main+0x14dc>)
 800857e:	f00a f8af 	bl	80126e0 <chprintf.constprop.35>
 8008582:	4995      	ldr	r1, [pc, #596]	; (80087d8 <main+0x14f8>)
 8008584:	488d      	ldr	r0, [pc, #564]	; (80087bc <main+0x14dc>)
 8008586:	f00a f8ab 	bl	80126e0 <chprintf.constprop.35>
 800858a:	488a      	ldr	r0, [pc, #552]	; (80087b4 <main+0x14d4>)
 800858c:	f006 fc50 	bl	800ee30 <chMtxUnlock>
 8008590:	f504 74dc 	add.w	r4, r4, #440	; 0x1b8
		// Thread monitor
		bool aerror = false; // Temporary error flag
		bool healthy;
		systime_t lu;

		for(uint8_t i=0; i<sizeof(config)/sizeof(module_conf_t); i++) {
 8008594:	42ac      	cmp	r4, r5
 8008596:	f000 80a8 	beq.w	80086ea <main+0x140a>
			
			if(config[i].active) { // Is active?
 800859a:	f894 31b4 	ldrb.w	r3, [r4, #436]	; 0x1b4
 800859e:	2b00      	cmp	r3, #0
 80085a0:	d0f6      	beq.n	8008590 <main+0x12b0>

				// Determine health
				healthy = true;
				switch(config[i].trigger.type)
 80085a2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80085a6:	2b02      	cmp	r3, #2
 80085a8:	d19a      	bne.n	80084e0 <main+0x1200>
								break;
						}
						break;

					case TRIG_TIMEOUT:
						healthy = config[i].last_update + S2ST(config[i].trigger.timeout) + wdg_buffer > chVTGetSystemTimeX();
 80085aa:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
 80085ae:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80085b0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80085b4:	f502 1092 	add.w	r0, r2, #1196032	; 0x124000
 80085b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80085ba:	f500 6078 	add.w	r0, r0, #3968	; 0xf80
 80085be:	f644 6720 	movw	r7, #20000	; 0x4e20
 80085c2:	fb07 0101 	mla	r1, r7, r1, r0
 80085c6:	428b      	cmp	r3, r1
 80085c8:	bf2c      	ite	cs
 80085ca:	2300      	movcs	r3, #0
 80085cc:	2301      	movcc	r3, #1

					case TRIG_CONTINOUSLY:
						healthy = config[i].last_update + wdg_buffer > chVTGetSystemTimeX();
						break;
				}
				healthy = healthy || config[i].init_delay + wdg_buffer > chVTGetSystemTimeX();
 80085ce:	2b00      	cmp	r3, #0
 80085d0:	d15a      	bne.n	8008688 <main+0x13a8>
 80085d2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80085d4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 80085d8:	f503 1392 	add.w	r3, r3, #1196032	; 0x124000
 80085dc:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80085de:	f503 6378 	add.w	r3, r3, #3968	; 0xf80
 80085e2:	4299      	cmp	r1, r3
 80085e4:	d350      	bcc.n	8008688 <main+0x13a8>

				// Debugging every 10 sec
				if(counter % 10 == 0) {
 80085e6:	f8d9 0000 	ldr.w	r0, [r9]
 80085ea:	230a      	movs	r3, #10
 80085ec:	fbb0 f1f3 	udiv	r1, r0, r3
 80085f0:	fb03 0311 	mls	r3, r3, r1, r0
 80085f4:	2b00      	cmp	r3, #0
 80085f6:	d145      	bne.n	8008684 <main+0x13a4>
 80085f8:	6a7e      	ldr	r6, [r7, #36]	; 0x24
					lu = chVTGetSystemTimeX() - config[i].last_update;
					if(healthy) {
						TRACE_INFO("WDG  > Module %s OK (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
					} else {
						TRACE_ERROR("WDG  > Module %s failed (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
 80085fa:	486e      	ldr	r0, [pc, #440]	; (80087b4 <main+0x14d4>)
				}
				healthy = healthy || config[i].init_delay + wdg_buffer > chVTGetSystemTimeX();

				// Debugging every 10 sec
				if(counter % 10 == 0) {
					lu = chVTGetSystemTimeX() - config[i].last_update;
 80085fc:	1ab6      	subs	r6, r6, r2
					if(healthy) {
						TRACE_INFO("WDG  > Module %s OK (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
					} else {
						TRACE_ERROR("WDG  > Module %s failed (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
 80085fe:	f006 fc77 	bl	800eef0 <chMtxLock>
 8008602:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008604:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008606:	496c      	ldr	r1, [pc, #432]	; (80087b8 <main+0x14d8>)
 8008608:	486c      	ldr	r0, [pc, #432]	; (80087bc <main+0x14dc>)
 800860a:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 800860e:	f644 6820 	movw	r8, #20000	; 0x4e20
 8008612:	fb07 f303 	mul.w	r3, r7, r3
 8008616:	fbb2 f2f8 	udiv	r2, r2, r8
 800861a:	fbb3 f3f8 	udiv	r3, r3, r8
 800861e:	fbb3 fef7 	udiv	lr, r3, r7
 8008622:	fb07 331e 	mls	r3, r7, lr, r3
 8008626:	f00a f85b 	bl	80126e0 <chprintf.constprop.35>
 800862a:	4a6c      	ldr	r2, [pc, #432]	; (80087dc <main+0x14fc>)
 800862c:	4965      	ldr	r1, [pc, #404]	; (80087c4 <main+0x14e4>)
 800862e:	4863      	ldr	r0, [pc, #396]	; (80087bc <main+0x14dc>)
 8008630:	f00a f856 	bl	80126e0 <chprintf.constprop.35>
 8008634:	2382      	movs	r3, #130	; 0x82
 8008636:	4a64      	ldr	r2, [pc, #400]	; (80087c8 <main+0x14e8>)
 8008638:	4964      	ldr	r1, [pc, #400]	; (80087cc <main+0x14ec>)
 800863a:	4860      	ldr	r0, [pc, #384]	; (80087bc <main+0x14dc>)
 800863c:	f00a f850 	bl	80126e0 <chprintf.constprop.35>
 8008640:	4963      	ldr	r1, [pc, #396]	; (80087d0 <main+0x14f0>)
 8008642:	485e      	ldr	r0, [pc, #376]	; (80087bc <main+0x14dc>)
 8008644:	f00a f84c 	bl	80126e0 <chprintf.constprop.35>
 8008648:	fb07 f306 	mul.w	r3, r7, r6
 800864c:	f503 439c 	add.w	r3, r3, #19968	; 0x4e00
 8008650:	331f      	adds	r3, #31
 8008652:	fbb3 f8f8 	udiv	r8, r3, r8
 8008656:	fbb8 f2f7 	udiv	r2, r8, r7
 800865a:	fb07 8712 	mls	r7, r7, r2, r8
 800865e:	fbb3 f3fb 	udiv	r3, r3, fp
 8008662:	4622      	mov	r2, r4
 8008664:	495e      	ldr	r1, [pc, #376]	; (80087e0 <main+0x1500>)
 8008666:	9700      	str	r7, [sp, #0]
 8008668:	4854      	ldr	r0, [pc, #336]	; (80087bc <main+0x14dc>)
 800866a:	f00a f839 	bl	80126e0 <chprintf.constprop.35>
 800866e:	495a      	ldr	r1, [pc, #360]	; (80087d8 <main+0x14f8>)
 8008670:	4852      	ldr	r0, [pc, #328]	; (80087bc <main+0x14dc>)
 8008672:	f00a f835 	bl	80126e0 <chprintf.constprop.35>
 8008676:	484f      	ldr	r0, [pc, #316]	; (80087b4 <main+0x14d4>)
 8008678:	f006 fbda 	bl	800ee30 <chMtxUnlock>
 800867c:	2182      	movs	r1, #130	; 0x82
 800867e:	4852      	ldr	r0, [pc, #328]	; (80087c8 <main+0x14e8>)
 8008680:	f007 fc6e 	bl	800ff60 <log_error>
					}
				}

				if(!healthy)
					aerror = true; // Set error flag
 8008684:	2601      	movs	r6, #1
 8008686:	e783      	b.n	8008590 <main+0x12b0>
						break;
				}
				healthy = healthy || config[i].init_delay + wdg_buffer > chVTGetSystemTimeX();

				// Debugging every 10 sec
				if(counter % 10 == 0) {
 8008688:	f8d9 0000 	ldr.w	r0, [r9]
 800868c:	230a      	movs	r3, #10
 800868e:	fbb0 f1f3 	udiv	r1, r0, r3
 8008692:	fb03 0311 	mls	r3, r3, r1, r0
 8008696:	2b00      	cmp	r3, #0
 8008698:	f47f af7a 	bne.w	8008590 <main+0x12b0>
 800869c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
					lu = chVTGetSystemTimeX() - config[i].last_update;
 80086a2:	ebc2 0a03 	rsb	sl, r2, r3
 80086a6:	e731      	b.n	800850c <main+0x122c>
					case TRIG_ONCE:
						healthy = true;
						break;

					case TRIG_EVENT:
						switch(config[i].trigger.event)
 80086a8:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
 80086ac:	2b01      	cmp	r3, #1
 80086ae:	f47f af1d 	bne.w	80084ec <main+0x120c>
						{
							case NO_EVENT:
								healthy = true;
								break;
							case EVENT_NEW_POINT:
								healthy = config[i].last_update + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
 80086b2:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
 80086b6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086ba:	f502 115b 	add.w	r1, r2, #3588096	; 0x36c000
 80086be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80086c0:	f501 513a 	add.w	r1, r1, #11904	; 0x2e80
 80086c4:	428b      	cmp	r3, r1
 80086c6:	bf2c      	ite	cs
 80086c8:	2300      	movcs	r3, #0
 80086ca:	2301      	movcc	r3, #1
 80086cc:	e77f      	b.n	80085ce <main+0x12ee>
					case TRIG_TIMEOUT:
						healthy = config[i].last_update + S2ST(config[i].trigger.timeout) + wdg_buffer > chVTGetSystemTimeX();
						break;

					case TRIG_CONTINOUSLY:
						healthy = config[i].last_update + wdg_buffer > chVTGetSystemTimeX();
 80086ce:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
 80086d2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80086d6:	f502 1192 	add.w	r1, r2, #1196032	; 0x124000
 80086da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80086dc:	f501 6178 	add.w	r1, r1, #3968	; 0xf80
 80086e0:	428b      	cmp	r3, r1
 80086e2:	bf2c      	ite	cs
 80086e4:	2300      	movcs	r3, #0
 80086e6:	2301      	movcc	r3, #1
 80086e8:	e771      	b.n	80085ce <main+0x12ee>

			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
 80086ea:	4b3e      	ldr	r3, [pc, #248]	; (80087e4 <main+0x1504>)
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
 80086ec:	f8d9 0000 	ldr.w	r0, [r9]

			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
 80086f0:	681d      	ldr	r5, [r3, #0]
 80086f2:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
 80086f6:	230a      	movs	r3, #10

			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
 80086f8:	f505 115b 	add.w	r1, r5, #3588096	; 0x36c000
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
 80086fc:	fbb0 f2f3 	udiv	r2, r0, r3
 8008700:	fb03 0312 	mls	r3, r3, r2, r0

			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
 8008704:	f501 513a 	add.w	r1, r1, #11904	; 0x2e80
 8008708:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800870a:	6a60      	ldr	r0, [r4, #36]	; 0x24
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
 800870c:	2b00      	cmp	r3, #0
 800870e:	d16f      	bne.n	80087f0 <main+0x1510>
			if(healthy) {
 8008710:	4291      	cmp	r1, r2
			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
		lu = chVTGetSystemTimeX() - watchdog_tracking;
 8008712:	eba0 0505 	sub.w	r5, r0, r5
		if(counter % 10 == 0) {
			if(healthy) {
				TRACE_INFO("WDG  > Module TRAC OK (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
 8008716:	4827      	ldr	r0, [pc, #156]	; (80087b4 <main+0x14d4>)

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
			if(healthy) {
 8008718:	f240 80f3 	bls.w	8008902 <main+0x1622>
				TRACE_INFO("WDG  > Module TRAC OK (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
 800871c:	f006 fbe8 	bl	800eef0 <chMtxLock>
 8008720:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8008722:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008724:	4924      	ldr	r1, [pc, #144]	; (80087b8 <main+0x14d8>)
 8008726:	4825      	ldr	r0, [pc, #148]	; (80087bc <main+0x14dc>)
 8008728:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 800872c:	f644 6720 	movw	r7, #20000	; 0x4e20
 8008730:	fb04 f303 	mul.w	r3, r4, r3
 8008734:	fbb2 f2f7 	udiv	r2, r2, r7
 8008738:	fbb3 f3f7 	udiv	r3, r3, r7
 800873c:	fbb3 fef4 	udiv	lr, r3, r4
 8008740:	fb04 331e 	mls	r3, r4, lr, r3
 8008744:	f009 ffcc 	bl	80126e0 <chprintf.constprop.35>
 8008748:	4a1d      	ldr	r2, [pc, #116]	; (80087c0 <main+0x14e0>)
 800874a:	491e      	ldr	r1, [pc, #120]	; (80087c4 <main+0x14e4>)
 800874c:	481b      	ldr	r0, [pc, #108]	; (80087bc <main+0x14dc>)
 800874e:	f009 ffc7 	bl	80126e0 <chprintf.constprop.35>
 8008752:	2391      	movs	r3, #145	; 0x91
 8008754:	4a1c      	ldr	r2, [pc, #112]	; (80087c8 <main+0x14e8>)
 8008756:	491d      	ldr	r1, [pc, #116]	; (80087cc <main+0x14ec>)
 8008758:	4818      	ldr	r0, [pc, #96]	; (80087bc <main+0x14dc>)
 800875a:	f009 ffc1 	bl	80126e0 <chprintf.constprop.35>
 800875e:	491c      	ldr	r1, [pc, #112]	; (80087d0 <main+0x14f0>)
 8008760:	4816      	ldr	r0, [pc, #88]	; (80087bc <main+0x14dc>)
 8008762:	f009 ffbd 	bl	80126e0 <chprintf.constprop.35>
 8008766:	fb04 f205 	mul.w	r2, r4, r5
 800876a:	f502 429c 	add.w	r2, r2, #19968	; 0x4e00
 800876e:	321f      	adds	r2, #31
 8008770:	491d      	ldr	r1, [pc, #116]	; (80087e8 <main+0x1508>)
 8008772:	fbb2 f7f7 	udiv	r7, r2, r7
 8008776:	4811      	ldr	r0, [pc, #68]	; (80087bc <main+0x14dc>)
 8008778:	fbb2 f2fb 	udiv	r2, r2, fp
 800877c:	fbb7 f3f4 	udiv	r3, r7, r4
 8008780:	fb04 7313 	mls	r3, r4, r3, r7
 8008784:	f009 ffac 	bl	80126e0 <chprintf.constprop.35>
 8008788:	4913      	ldr	r1, [pc, #76]	; (80087d8 <main+0x14f8>)
 800878a:	480c      	ldr	r0, [pc, #48]	; (80087bc <main+0x14dc>)
 800878c:	f009 ffa8 	bl	80126e0 <chprintf.constprop.35>
 8008790:	4808      	ldr	r0, [pc, #32]	; (80087b4 <main+0x14d4>)
 8008792:	f006 fb4d 	bl	800ee30 <chMtxUnlock>
		}
		if(!healthy)
			aerror = true; // Set error flag

		// Update hardware (LED, WDG)
		error = aerror;			// Update error LED flag
 8008796:	4b15      	ldr	r3, [pc, #84]	; (80087ec <main+0x150c>)
 8008798:	701e      	strb	r6, [r3, #0]
		if(!error)
 800879a:	bb76      	cbnz	r6, 80087fa <main+0x151a>
		{
			wdgReset(&WDGD1);	// Reset hardware watchdog at no error
 800879c:	f00a fa18 	bl	8012bd0 <wdgReset.constprop.41>
		} else {
			TRACE_ERROR("WDG  > No reset");
		}

		chThdSleepMilliseconds(1000);
 80087a0:	f644 6020 	movw	r0, #20000	; 0x4e20
 80087a4:	f006 fc74 	bl	800f090 <chThdSleep>
		counter++;
 80087a8:	f8d9 3000 	ldr.w	r3, [r9]
 80087ac:	3301      	adds	r3, #1
 80087ae:	f8c9 3000 	str.w	r3, [r9]
 80087b2:	e645      	b.n	8008440 <main+0x1160>
 80087b4:	20027b2c 	.word	0x20027b2c
 80087b8:	08013c50 	.word	0x08013c50
 80087bc:	20027e60 	.word	0x20027e60
 80087c0:	08013cfc 	.word	0x08013cfc
 80087c4:	08013c5c 	.word	0x08013c5c
 80087c8:	08015084 	.word	0x08015084
 80087cc:	08013c78 	.word	0x08013c78
 80087d0:	08013d00 	.word	0x08013d00
 80087d4:	08015218 	.word	0x08015218
 80087d8:	08013cac 	.word	0x08013cac
 80087dc:	08013d9c 	.word	0x08013d9c
 80087e0:	080152d0 	.word	0x080152d0
 80087e4:	20027724 	.word	0x20027724
 80087e8:	0801524c 	.word	0x0801524c
 80087ec:	20005f10 	.word	0x20005f10
				TRACE_INFO("WDG  > Module TRAC OK (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
			} else {
				TRACE_ERROR("WDG  > Module TRAC failed (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
			}
		}
		if(!healthy)
 80087f0:	4291      	cmp	r1, r2
 80087f2:	d8d0      	bhi.n	8008796 <main+0x14b6>
			aerror = true; // Set error flag

		// Update hardware (LED, WDG)
		error = aerror;			// Update error LED flag
 80087f4:	4a82      	ldr	r2, [pc, #520]	; (8008a00 <main+0x1720>)
 80087f6:	2301      	movs	r3, #1
 80087f8:	7013      	strb	r3, [r2, #0]
		if(!error)
		{
			wdgReset(&WDGD1);	// Reset hardware watchdog at no error
		} else {
			TRACE_ERROR("WDG  > No reset");
 80087fa:	4882      	ldr	r0, [pc, #520]	; (8008a04 <main+0x1724>)
 80087fc:	f006 fb78 	bl	800eef0 <chMtxLock>
 8008800:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8008804:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008808:	6a4d      	ldr	r5, [r1, #36]	; 0x24
 800880a:	6a4c      	ldr	r4, [r1, #36]	; 0x24
 800880c:	487e      	ldr	r0, [pc, #504]	; (8008a08 <main+0x1728>)
 800880e:	497f      	ldr	r1, [pc, #508]	; (8008a0c <main+0x172c>)
 8008810:	fb03 f404 	mul.w	r4, r3, r4
 8008814:	f644 6220 	movw	r2, #20000	; 0x4e20
 8008818:	fbb4 f4f2 	udiv	r4, r4, r2
 800881c:	fbb5 f2f2 	udiv	r2, r5, r2
 8008820:	fbb4 f5f3 	udiv	r5, r4, r3
 8008824:	fb03 4315 	mls	r3, r3, r5, r4
 8008828:	f009 ff5a 	bl	80126e0 <chprintf.constprop.35>
 800882c:	4a78      	ldr	r2, [pc, #480]	; (8008a10 <main+0x1730>)
 800882e:	4979      	ldr	r1, [pc, #484]	; (8008a14 <main+0x1734>)
 8008830:	4875      	ldr	r0, [pc, #468]	; (8008a08 <main+0x1728>)
 8008832:	f009 ff55 	bl	80126e0 <chprintf.constprop.35>
 8008836:	239f      	movs	r3, #159	; 0x9f
 8008838:	4a77      	ldr	r2, [pc, #476]	; (8008a18 <main+0x1738>)
 800883a:	4978      	ldr	r1, [pc, #480]	; (8008a1c <main+0x173c>)
 800883c:	4872      	ldr	r0, [pc, #456]	; (8008a08 <main+0x1728>)
 800883e:	f009 ff4f 	bl	80126e0 <chprintf.constprop.35>
 8008842:	4977      	ldr	r1, [pc, #476]	; (8008a20 <main+0x1740>)
 8008844:	4870      	ldr	r0, [pc, #448]	; (8008a08 <main+0x1728>)
 8008846:	f009 ff4b 	bl	80126e0 <chprintf.constprop.35>
 800884a:	4976      	ldr	r1, [pc, #472]	; (8008a24 <main+0x1744>)
 800884c:	486e      	ldr	r0, [pc, #440]	; (8008a08 <main+0x1728>)
 800884e:	f009 ff47 	bl	80126e0 <chprintf.constprop.35>
 8008852:	4975      	ldr	r1, [pc, #468]	; (8008a28 <main+0x1748>)
 8008854:	486c      	ldr	r0, [pc, #432]	; (8008a08 <main+0x1728>)
 8008856:	f009 ff43 	bl	80126e0 <chprintf.constprop.35>
 800885a:	486a      	ldr	r0, [pc, #424]	; (8008a04 <main+0x1724>)
 800885c:	f006 fae8 	bl	800ee30 <chMtxUnlock>
 8008860:	219f      	movs	r1, #159	; 0x9f
 8008862:	486d      	ldr	r0, [pc, #436]	; (8008a18 <main+0x1738>)
 8008864:	f007 fb7c 	bl	800ff60 <log_error>
 8008868:	e79a      	b.n	80087a0 <main+0x14c0>
	chThdSleepMilliseconds(1000);

	while(true) {
		// Print time every 10 sec
		if(counter % 10 == 0)
			PRINT_TIME("MAIN");
 800886a:	a808      	add	r0, sp, #32
 800886c:	f001 fce0 	bl	800a230 <getTime>
 8008870:	4864      	ldr	r0, [pc, #400]	; (8008a04 <main+0x1724>)
 8008872:	f006 fb3d 	bl	800eef0 <chMtxLock>
 8008876:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800887a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800887e:	6a4d      	ldr	r5, [r1, #36]	; 0x24
 8008880:	6a4c      	ldr	r4, [r1, #36]	; 0x24
 8008882:	4861      	ldr	r0, [pc, #388]	; (8008a08 <main+0x1728>)
 8008884:	4961      	ldr	r1, [pc, #388]	; (8008a0c <main+0x172c>)
 8008886:	fb03 f404 	mul.w	r4, r3, r4
 800888a:	f644 6220 	movw	r2, #20000	; 0x4e20
 800888e:	fbb4 f4f2 	udiv	r4, r4, r2
 8008892:	fbb5 f2f2 	udiv	r2, r5, r2
 8008896:	fbb4 f5f3 	udiv	r5, r4, r3
 800889a:	fb03 4315 	mls	r3, r3, r5, r4
 800889e:	f009 ff1f 	bl	80126e0 <chprintf.constprop.35>
 80088a2:	4a62      	ldr	r2, [pc, #392]	; (8008a2c <main+0x174c>)
 80088a4:	495b      	ldr	r1, [pc, #364]	; (8008a14 <main+0x1734>)
 80088a6:	4858      	ldr	r0, [pc, #352]	; (8008a08 <main+0x1728>)
 80088a8:	f009 ff1a 	bl	80126e0 <chprintf.constprop.35>
 80088ac:	2353      	movs	r3, #83	; 0x53
 80088ae:	4a5a      	ldr	r2, [pc, #360]	; (8008a18 <main+0x1738>)
 80088b0:	495a      	ldr	r1, [pc, #360]	; (8008a1c <main+0x173c>)
 80088b2:	4855      	ldr	r0, [pc, #340]	; (8008a08 <main+0x1728>)
 80088b4:	f009 ff14 	bl	80126e0 <chprintf.constprop.35>
 80088b8:	4959      	ldr	r1, [pc, #356]	; (8008a20 <main+0x1740>)
 80088ba:	4853      	ldr	r0, [pc, #332]	; (8008a08 <main+0x1728>)
 80088bc:	f009 ff10 	bl	80126e0 <chprintf.constprop.35>
 80088c0:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
 80088c4:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
 80088c8:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
 80088cc:	f89d 4025 	ldrb.w	r4, [sp, #37]	; 0x25
 80088d0:	9105      	str	r1, [sp, #20]
 80088d2:	9204      	str	r2, [sp, #16]
 80088d4:	f89d 1023 	ldrb.w	r1, [sp, #35]	; 0x23
 80088d8:	f89d 2022 	ldrb.w	r2, [sp, #34]	; 0x22
 80088dc:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 80088e0:	9002      	str	r0, [sp, #8]
 80088e2:	9101      	str	r1, [sp, #4]
 80088e4:	9200      	str	r2, [sp, #0]
 80088e6:	9403      	str	r4, [sp, #12]
 80088e8:	4a51      	ldr	r2, [pc, #324]	; (8008a30 <main+0x1750>)
 80088ea:	4952      	ldr	r1, [pc, #328]	; (8008a34 <main+0x1754>)
 80088ec:	4846      	ldr	r0, [pc, #280]	; (8008a08 <main+0x1728>)
 80088ee:	f009 fef7 	bl	80126e0 <chprintf.constprop.35>
 80088f2:	494d      	ldr	r1, [pc, #308]	; (8008a28 <main+0x1748>)
 80088f4:	4844      	ldr	r0, [pc, #272]	; (8008a08 <main+0x1728>)
 80088f6:	f009 fef3 	bl	80126e0 <chprintf.constprop.35>
 80088fa:	4842      	ldr	r0, [pc, #264]	; (8008a04 <main+0x1724>)
 80088fc:	f006 fa98 	bl	800ee30 <chMtxUnlock>
 8008900:	e5a8      	b.n	8008454 <main+0x1174>
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
			if(healthy) {
				TRACE_INFO("WDG  > Module TRAC OK (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
			} else {
				TRACE_ERROR("WDG  > Module TRAC failed (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
 8008902:	f006 faf5 	bl	800eef0 <chMtxLock>
 8008906:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8008908:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800890a:	4940      	ldr	r1, [pc, #256]	; (8008a0c <main+0x172c>)
 800890c:	483e      	ldr	r0, [pc, #248]	; (8008a08 <main+0x1728>)
 800890e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8008912:	f644 6620 	movw	r6, #20000	; 0x4e20
 8008916:	fb04 f303 	mul.w	r3, r4, r3
 800891a:	fbb2 f2f6 	udiv	r2, r2, r6
 800891e:	fbb3 f3f6 	udiv	r3, r3, r6
 8008922:	fbb3 f7f4 	udiv	r7, r3, r4
 8008926:	fb04 3317 	mls	r3, r4, r7, r3
 800892a:	f009 fed9 	bl	80126e0 <chprintf.constprop.35>
 800892e:	4a38      	ldr	r2, [pc, #224]	; (8008a10 <main+0x1730>)
 8008930:	4938      	ldr	r1, [pc, #224]	; (8008a14 <main+0x1734>)
 8008932:	4835      	ldr	r0, [pc, #212]	; (8008a08 <main+0x1728>)
 8008934:	f009 fed4 	bl	80126e0 <chprintf.constprop.35>
 8008938:	2393      	movs	r3, #147	; 0x93
 800893a:	4a37      	ldr	r2, [pc, #220]	; (8008a18 <main+0x1738>)
 800893c:	4937      	ldr	r1, [pc, #220]	; (8008a1c <main+0x173c>)
 800893e:	4832      	ldr	r0, [pc, #200]	; (8008a08 <main+0x1728>)
 8008940:	f009 fece 	bl	80126e0 <chprintf.constprop.35>
 8008944:	4936      	ldr	r1, [pc, #216]	; (8008a20 <main+0x1740>)
 8008946:	4830      	ldr	r0, [pc, #192]	; (8008a08 <main+0x1728>)
 8008948:	f009 feca 	bl	80126e0 <chprintf.constprop.35>
 800894c:	fb04 f205 	mul.w	r2, r4, r5
 8008950:	f502 429c 	add.w	r2, r2, #19968	; 0x4e00
 8008954:	321f      	adds	r2, #31
 8008956:	4938      	ldr	r1, [pc, #224]	; (8008a38 <main+0x1758>)
 8008958:	fbb2 f6f6 	udiv	r6, r2, r6
 800895c:	482a      	ldr	r0, [pc, #168]	; (8008a08 <main+0x1728>)
 800895e:	fbb2 f2fb 	udiv	r2, r2, fp
 8008962:	fbb6 f3f4 	udiv	r3, r6, r4
 8008966:	fb04 6313 	mls	r3, r4, r3, r6
 800896a:	f009 feb9 	bl	80126e0 <chprintf.constprop.35>
 800896e:	492e      	ldr	r1, [pc, #184]	; (8008a28 <main+0x1748>)
 8008970:	4825      	ldr	r0, [pc, #148]	; (8008a08 <main+0x1728>)
 8008972:	f009 feb5 	bl	80126e0 <chprintf.constprop.35>
 8008976:	4823      	ldr	r0, [pc, #140]	; (8008a04 <main+0x1724>)
 8008978:	f006 fa5a 	bl	800ee30 <chMtxUnlock>
 800897c:	2193      	movs	r1, #147	; 0x93
 800897e:	4826      	ldr	r0, [pc, #152]	; (8008a18 <main+0x1738>)
 8008980:	f007 faee 	bl	800ff60 <log_error>
		}
		if(!healthy)
			aerror = true; // Set error flag

		// Update hardware (LED, WDG)
		error = aerror;			// Update error LED flag
 8008984:	4a1e      	ldr	r2, [pc, #120]	; (8008a00 <main+0x1720>)
 8008986:	2301      	movs	r3, #1
 8008988:	7013      	strb	r3, [r2, #0]
 800898a:	e736      	b.n	80087fa <main+0x151a>
 800898c:	482b      	ldr	r0, [pc, #172]	; (8008a3c <main+0x175c>)
 800898e:	f005 fee7 	bl	800e760 <chSysHalt>
	mmcStart(&MMCD1, &mmccfg);

	// Check SD card presence
	spiAcquireBus(&SPID2);
	if(mmcConnect(&MMCD1)) {
		TRACE_ERROR("SD   > No SD card found");
 8008992:	481c      	ldr	r0, [pc, #112]	; (8008a04 <main+0x1724>)
 8008994:	f006 faac 	bl	800eef0 <chMtxLock>
 8008998:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 800899c:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 80089a0:	fbb2 f2f8 	udiv	r2, r2, r8
 80089a4:	fb07 f303 	mul.w	r3, r7, r3
 80089a8:	4918      	ldr	r1, [pc, #96]	; (8008a0c <main+0x172c>)
 80089aa:	fbb3 f8f8 	udiv	r8, r3, r8
 80089ae:	4816      	ldr	r0, [pc, #88]	; (8008a08 <main+0x1728>)
 80089b0:	fbb8 f3f7 	udiv	r3, r8, r7
 80089b4:	fb07 8313 	mls	r3, r7, r3, r8
 80089b8:	f009 fe92 	bl	80126e0 <chprintf.constprop.35>
 80089bc:	4a14      	ldr	r2, [pc, #80]	; (8008a10 <main+0x1730>)
 80089be:	4915      	ldr	r1, [pc, #84]	; (8008a14 <main+0x1734>)
 80089c0:	4811      	ldr	r0, [pc, #68]	; (8008a08 <main+0x1728>)
 80089c2:	f009 fe8d 	bl	80126e0 <chprintf.constprop.35>
 80089c6:	2325      	movs	r3, #37	; 0x25
 80089c8:	4a1d      	ldr	r2, [pc, #116]	; (8008a40 <main+0x1760>)
 80089ca:	4914      	ldr	r1, [pc, #80]	; (8008a1c <main+0x173c>)
 80089cc:	480e      	ldr	r0, [pc, #56]	; (8008a08 <main+0x1728>)
 80089ce:	f009 fe87 	bl	80126e0 <chprintf.constprop.35>
 80089d2:	4913      	ldr	r1, [pc, #76]	; (8008a20 <main+0x1740>)
 80089d4:	480c      	ldr	r0, [pc, #48]	; (8008a08 <main+0x1728>)
 80089d6:	f009 fe83 	bl	80126e0 <chprintf.constprop.35>
 80089da:	491a      	ldr	r1, [pc, #104]	; (8008a44 <main+0x1764>)
 80089dc:	480a      	ldr	r0, [pc, #40]	; (8008a08 <main+0x1728>)
 80089de:	f009 fe7f 	bl	80126e0 <chprintf.constprop.35>
 80089e2:	4911      	ldr	r1, [pc, #68]	; (8008a28 <main+0x1748>)
 80089e4:	4808      	ldr	r0, [pc, #32]	; (8008a08 <main+0x1728>)
 80089e6:	f009 fe7b 	bl	80126e0 <chprintf.constprop.35>
 80089ea:	4806      	ldr	r0, [pc, #24]	; (8008a04 <main+0x1724>)
 80089ec:	f006 fa20 	bl	800ee30 <chMtxUnlock>
 80089f0:	2125      	movs	r1, #37	; 0x25
 80089f2:	4813      	ldr	r0, [pc, #76]	; (8008a40 <main+0x1760>)
 80089f4:	f007 fab4 	bl	800ff60 <log_error>
 80089f8:	e4ee      	b.n	80083d8 <main+0x10f8>
 80089fa:	4813      	ldr	r0, [pc, #76]	; (8008a48 <main+0x1768>)
 80089fc:	f005 feb0 	bl	800e760 <chSysHalt>
 8008a00:	20005f10 	.word	0x20005f10
 8008a04:	20027b2c 	.word	0x20027b2c
 8008a08:	20027e60 	.word	0x20027e60
 8008a0c:	08013c50 	.word	0x08013c50
 8008a10:	08013d9c 	.word	0x08013d9c
 8008a14:	08013c5c 	.word	0x08013c5c
 8008a18:	08015084 	.word	0x08015084
 8008a1c:	08013c78 	.word	0x08013c78
 8008a20:	08013d00 	.word	0x08013d00
 8008a24:	080152c0 	.word	0x080152c0
 8008a28:	08013cac 	.word	0x08013cac
 8008a2c:	08013cfc 	.word	0x08013cfc
 8008a30:	08015210 	.word	0x08015210
 8008a34:	08014130 	.word	0x08014130
 8008a38:	08015284 	.word	0x08015284
 8008a3c:	08014f50 	.word	0x08014f50
 8008a40:	08014484 	.word	0x08014484
 8008a44:	080151e0 	.word	0x080151e0
 8008a48:	080174ec 	.word	0x080174ec
 8008a4c:	00000000 	.word	0x00000000

08008a50 <modulePOS>:
	str_replace(fskmsg, size, "<EHUM>", buf);
	positionToMaidenhead(buf, tp->gps_lat/10000000.0, tp->gps_lon/10000000.0);
	str_replace(fskmsg, size, "<LOC>", buf);
}

THD_FUNCTION(modulePOS, arg) {
 8008a50:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 8008a54:	6b42      	ldr	r2, [r0, #52]	; 0x34
	str_replace(fskmsg, size, "<EHUM>", buf);
	positionToMaidenhead(buf, tp->gps_lat/10000000.0, tp->gps_lon/10000000.0);
	str_replace(fskmsg, size, "<LOC>", buf);
}

THD_FUNCTION(modulePOS, arg) {
 8008a56:	f5ad 7d63 	sub.w	sp, sp, #908	; 0x38c
 8008a5a:	9003      	str	r0, [sp, #12]
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 8008a5c:	b15a      	cbz	r2, 8008a76 <modulePOS+0x26>
		chThdSleepMilliseconds(config->init_delay);
 8008a5e:	f644 6320 	movw	r3, #20000	; 0x4e20
 8008a62:	fb03 f302 	mul.w	r3, r3, r2
 8008a66:	4895      	ldr	r0, [pc, #596]	; (8008cbc <modulePOS+0x26c>)
 8008a68:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 8008a6c:	fba0 3003 	umull	r3, r0, r0, r3
 8008a70:	0980      	lsrs	r0, r0, #6
 8008a72:	f006 fb0d 	bl	800f090 <chThdSleep>
 8008a76:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000

	// Print initialization message
	TRACE_INFO("POS  > Startup module %s", config->name);
 8008a7a:	4891      	ldr	r0, [pc, #580]	; (8008cc0 <modulePOS+0x270>)
 8008a7c:	4f91      	ldr	r7, [pc, #580]	; (8008cc4 <modulePOS+0x274>)
 8008a7e:	f8df a27c 	ldr.w	sl, [pc, #636]	; 8008cfc <modulePOS+0x2ac>
 8008a82:	f006 fa35 	bl	800eef0 <chMtxLock>
 8008a86:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8008a88:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8008a8a:	4a8c      	ldr	r2, [pc, #560]	; (8008cbc <modulePOS+0x26c>)
 8008a8c:	498e      	ldr	r1, [pc, #568]	; (8008cc8 <modulePOS+0x278>)
 8008a8e:	488f      	ldr	r0, [pc, #572]	; (8008ccc <modulePOS+0x27c>)
 8008a90:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008a94:	fb03 f505 	mul.w	r5, r3, r5
 8008a98:	fba7 e505 	umull	lr, r5, r7, r5
 8008a9c:	0bad      	lsrs	r5, r5, #14
 8008a9e:	fba2 2e05 	umull	r2, lr, r2, r5
 8008aa2:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8008aa6:	fba7 6206 	umull	r6, r2, r7, r6
 8008aaa:	fb03 531e 	mls	r3, r3, lr, r5
 8008aae:	0b92      	lsrs	r2, r2, #14
 8008ab0:	f009 fe16 	bl	80126e0 <chprintf.constprop.35>
 8008ab4:	4a86      	ldr	r2, [pc, #536]	; (8008cd0 <modulePOS+0x280>)
 8008ab6:	4987      	ldr	r1, [pc, #540]	; (8008cd4 <modulePOS+0x284>)
 8008ab8:	4884      	ldr	r0, [pc, #528]	; (8008ccc <modulePOS+0x27c>)
 8008aba:	f009 fe11 	bl	80126e0 <chprintf.constprop.35>
 8008abe:	2379      	movs	r3, #121	; 0x79
 8008ac0:	4a85      	ldr	r2, [pc, #532]	; (8008cd8 <modulePOS+0x288>)
 8008ac2:	4986      	ldr	r1, [pc, #536]	; (8008cdc <modulePOS+0x28c>)
 8008ac4:	4881      	ldr	r0, [pc, #516]	; (8008ccc <modulePOS+0x27c>)
 8008ac6:	f009 fe0b 	bl	80126e0 <chprintf.constprop.35>
 8008aca:	4985      	ldr	r1, [pc, #532]	; (8008ce0 <modulePOS+0x290>)
 8008acc:	487f      	ldr	r0, [pc, #508]	; (8008ccc <modulePOS+0x27c>)
 8008ace:	f009 fe07 	bl	80126e0 <chprintf.constprop.35>
 8008ad2:	9d03      	ldr	r5, [sp, #12]
 8008ad4:	4983      	ldr	r1, [pc, #524]	; (8008ce4 <modulePOS+0x294>)
 8008ad6:	487d      	ldr	r0, [pc, #500]	; (8008ccc <modulePOS+0x27c>)
 8008ad8:	462a      	mov	r2, r5
 8008ada:	f009 fe01 	bl	80126e0 <chprintf.constprop.35>
 8008ade:	4982      	ldr	r1, [pc, #520]	; (8008ce8 <modulePOS+0x298>)
 8008ae0:	487a      	ldr	r0, [pc, #488]	; (8008ccc <modulePOS+0x27c>)
 8008ae2:	f009 fdfd 	bl	80126e0 <chprintf.constprop.35>
 8008ae6:	4876      	ldr	r0, [pc, #472]	; (8008cc0 <modulePOS+0x270>)
 8008ae8:	f006 f9a2 	bl	800ee30 <chMtxUnlock>
 8008aec:	462b      	mov	r3, r5
 8008aee:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8008af0:	9102      	str	r1, [sp, #8]
 8008af2:	333c      	adds	r3, #60	; 0x3c
 8008af4:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8008af6:	9304      	str	r3, [sp, #16]
 8008af8:	462b      	mov	r3, r5
 8008afa:	3324      	adds	r3, #36	; 0x24
 8008afc:	f105 027d 	add.w	r2, r5, #125	; 0x7d
 8008b00:	9307      	str	r3, [sp, #28]
 8008b02:	462b      	mov	r3, r5
 8008b04:	3350      	adds	r3, #80	; 0x50
 8008b06:	9212      	str	r2, [sp, #72]	; 0x48
 8008b08:	f105 0282 	add.w	r2, r5, #130	; 0x82
 8008b0c:	9309      	str	r3, [sp, #36]	; 0x24
 8008b0e:	920f      	str	r2, [sp, #60]	; 0x3c
 8008b10:	462b      	mov	r3, r5
 8008b12:	462a      	mov	r2, r5
 8008b14:	3358      	adds	r3, #88	; 0x58
 8008b16:	3286      	adds	r2, #134	; 0x86
 8008b18:	930b      	str	r3, [sp, #44]	; 0x2c
 8008b1a:	9215      	str	r2, [sp, #84]	; 0x54
 8008b1c:	462b      	mov	r3, r5
 8008b1e:	462a      	mov	r2, r5
 8008b20:	336c      	adds	r3, #108	; 0x6c
 8008b22:	3268      	adds	r2, #104	; 0x68
 8008b24:	9311      	str	r3, [sp, #68]	; 0x44
 8008b26:	920c      	str	r2, [sp, #48]	; 0x30

	trackPoint_t *trackPoint = getLastTrackPoint();
	systime_t time = chVTGetSystemTimeX();

	systime_t last_config_transmission = chVTGetSystemTimeX();
	uint32_t current_config_count = 0;
 8008b28:	2300      	movs	r3, #0
 8008b2a:	462a      	mov	r2, r5
 8008b2c:	9313      	str	r3, [sp, #76]	; 0x4c
 8008b2e:	3298      	adds	r2, #152	; 0x98
 8008b30:	f105 0344 	add.w	r3, r5, #68	; 0x44
 8008b34:	9114      	str	r1, [sp, #80]	; 0x50
 8008b36:	9210      	str	r2, [sp, #64]	; 0x40
 8008b38:	f20d 2b6b 	addw	fp, sp, #619	; 0x26b
 8008b3c:	9305      	str	r3, [sp, #20]
 8008b3e:	e004      	b.n	8008b4a <modulePOS+0xfa>
				default:
					TRACE_ERROR("POS  > Unsupported modulation/protocol selected for module POSITION");
			}
		}

		time = waitForTrigger(time, &config->trigger);
 8008b40:	9802      	ldr	r0, [sp, #8]
 8008b42:	9905      	ldr	r1, [sp, #20]
 8008b44:	f009 fbec 	bl	8012320 <waitForTrigger>
 8008b48:	9002      	str	r0, [sp, #8]
 8008b4a:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
	systime_t last_config_transmission = chVTGetSystemTimeX();
	uint32_t current_config_count = 0;

	while(true)
	{
		TRACE_INFO("POS  > Do module POSITION cycle");
 8008b4e:	485c      	ldr	r0, [pc, #368]	; (8008cc0 <modulePOS+0x270>)
 8008b50:	4e5c      	ldr	r6, [pc, #368]	; (8008cc4 <modulePOS+0x274>)
 8008b52:	4f5a      	ldr	r7, [pc, #360]	; (8008cbc <modulePOS+0x26c>)
 8008b54:	f006 f9cc 	bl	800eef0 <chMtxLock>
 8008b58:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8008b5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008b5c:	495a      	ldr	r1, [pc, #360]	; (8008cc8 <modulePOS+0x278>)
 8008b5e:	485b      	ldr	r0, [pc, #364]	; (8008ccc <modulePOS+0x27c>)
 8008b60:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8008b64:	fb05 fe03 	mul.w	lr, r5, r3
 8008b68:	fba6 3e0e 	umull	r3, lr, r6, lr
 8008b6c:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 8008b70:	fba7 c30e 	umull	ip, r3, r7, lr
 8008b74:	fba6 c202 	umull	ip, r2, r6, r2
 8008b78:	099b      	lsrs	r3, r3, #6
 8008b7a:	fb05 e313 	mls	r3, r5, r3, lr
 8008b7e:	0b92      	lsrs	r2, r2, #14
 8008b80:	f009 fdae 	bl	80126e0 <chprintf.constprop.35>
 8008b84:	4a52      	ldr	r2, [pc, #328]	; (8008cd0 <modulePOS+0x280>)
 8008b86:	4953      	ldr	r1, [pc, #332]	; (8008cd4 <modulePOS+0x284>)
 8008b88:	4850      	ldr	r0, [pc, #320]	; (8008ccc <modulePOS+0x27c>)
 8008b8a:	f009 fda9 	bl	80126e0 <chprintf.constprop.35>
 8008b8e:	2383      	movs	r3, #131	; 0x83
 8008b90:	4a51      	ldr	r2, [pc, #324]	; (8008cd8 <modulePOS+0x288>)
 8008b92:	4952      	ldr	r1, [pc, #328]	; (8008cdc <modulePOS+0x28c>)
 8008b94:	484d      	ldr	r0, [pc, #308]	; (8008ccc <modulePOS+0x27c>)
 8008b96:	f009 fda3 	bl	80126e0 <chprintf.constprop.35>
 8008b9a:	4951      	ldr	r1, [pc, #324]	; (8008ce0 <modulePOS+0x290>)
 8008b9c:	484b      	ldr	r0, [pc, #300]	; (8008ccc <modulePOS+0x27c>)
 8008b9e:	f009 fd9f 	bl	80126e0 <chprintf.constprop.35>
 8008ba2:	4952      	ldr	r1, [pc, #328]	; (8008cec <modulePOS+0x29c>)
 8008ba4:	4849      	ldr	r0, [pc, #292]	; (8008ccc <modulePOS+0x27c>)
 8008ba6:	f009 fd9b 	bl	80126e0 <chprintf.constprop.35>
 8008baa:	494f      	ldr	r1, [pc, #316]	; (8008ce8 <modulePOS+0x298>)
 8008bac:	4847      	ldr	r0, [pc, #284]	; (8008ccc <modulePOS+0x27c>)
 8008bae:	f009 fd97 	bl	80126e0 <chprintf.constprop.35>
 8008bb2:	4843      	ldr	r0, [pc, #268]	; (8008cc0 <modulePOS+0x270>)
 8008bb4:	f006 f93c 	bl	800ee30 <chMtxUnlock>
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer
 8008bb8:	9a03      	ldr	r2, [sp, #12]
 8008bba:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008bbc:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0

		TRACE_INFO("POS  > Get last track point");
 8008bc0:	483f      	ldr	r0, [pc, #252]	; (8008cc0 <modulePOS+0x270>)
 8008bc2:	f006 f995 	bl	800eef0 <chMtxLock>
 8008bc6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8008bc8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008bca:	493f      	ldr	r1, [pc, #252]	; (8008cc8 <modulePOS+0x278>)
 8008bcc:	483f      	ldr	r0, [pc, #252]	; (8008ccc <modulePOS+0x27c>)
 8008bce:	fb05 fe03 	mul.w	lr, r5, r3
 8008bd2:	fba6 3e0e 	umull	r3, lr, r6, lr
 8008bd6:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 8008bda:	fba7 c30e 	umull	ip, r3, r7, lr
 8008bde:	fba6 c202 	umull	ip, r2, r6, r2
 8008be2:	099b      	lsrs	r3, r3, #6
 8008be4:	fb05 e313 	mls	r3, r5, r3, lr
 8008be8:	0b92      	lsrs	r2, r2, #14
 8008bea:	f009 fd79 	bl	80126e0 <chprintf.constprop.35>
 8008bee:	4a38      	ldr	r2, [pc, #224]	; (8008cd0 <modulePOS+0x280>)
 8008bf0:	4938      	ldr	r1, [pc, #224]	; (8008cd4 <modulePOS+0x284>)
 8008bf2:	4836      	ldr	r0, [pc, #216]	; (8008ccc <modulePOS+0x27c>)
 8008bf4:	f009 fd74 	bl	80126e0 <chprintf.constprop.35>
 8008bf8:	2386      	movs	r3, #134	; 0x86
 8008bfa:	4a37      	ldr	r2, [pc, #220]	; (8008cd8 <modulePOS+0x288>)
 8008bfc:	4937      	ldr	r1, [pc, #220]	; (8008cdc <modulePOS+0x28c>)
 8008bfe:	4833      	ldr	r0, [pc, #204]	; (8008ccc <modulePOS+0x27c>)
 8008c00:	f009 fd6e 	bl	80126e0 <chprintf.constprop.35>
 8008c04:	4936      	ldr	r1, [pc, #216]	; (8008ce0 <modulePOS+0x290>)
 8008c06:	4831      	ldr	r0, [pc, #196]	; (8008ccc <modulePOS+0x27c>)
 8008c08:	f009 fd6a 	bl	80126e0 <chprintf.constprop.35>
 8008c0c:	4938      	ldr	r1, [pc, #224]	; (8008cf0 <modulePOS+0x2a0>)
 8008c0e:	482f      	ldr	r0, [pc, #188]	; (8008ccc <modulePOS+0x27c>)
 8008c10:	f009 fd66 	bl	80126e0 <chprintf.constprop.35>
 8008c14:	4934      	ldr	r1, [pc, #208]	; (8008ce8 <modulePOS+0x298>)
 8008c16:	482d      	ldr	r0, [pc, #180]	; (8008ccc <modulePOS+0x27c>)
 8008c18:	f009 fd62 	bl	80126e0 <chprintf.constprop.35>
 8008c1c:	4828      	ldr	r0, [pc, #160]	; (8008cc0 <modulePOS+0x270>)
 8008c1e:	f006 f907 	bl	800ee30 <chMtxUnlock>
/**
  * Returns most recent track point witch is complete.
  */
trackPoint_t* getLastTrackPoint(void)
{
	return lastTrackPoint;
 8008c22:	4b34      	ldr	r3, [pc, #208]	; (8008cf4 <modulePOS+0x2a4>)
		trackPoint = getLastTrackPoint();

		if(!p_sleep(&config->sleep_config))
 8008c24:	9804      	ldr	r0, [sp, #16]
 8008c26:	f8d3 9000 	ldr.w	r9, [r3]
 8008c2a:	f009 fba1 	bl	8012370 <p_sleep>
 8008c2e:	2800      	cmp	r0, #0
 8008c30:	d186      	bne.n	8008b40 <modulePOS+0xf0>
		{

			TRACE_INFO("POS  > Transmit GPS position");
 8008c32:	4823      	ldr	r0, [pc, #140]	; (8008cc0 <modulePOS+0x270>)
 8008c34:	f006 f95c 	bl	800eef0 <chMtxLock>
 8008c38:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8008c3a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008c3c:	4922      	ldr	r1, [pc, #136]	; (8008cc8 <modulePOS+0x278>)
 8008c3e:	fb05 f303 	mul.w	r3, r5, r3
 8008c42:	fba6 0303 	umull	r0, r3, r6, r3
 8008c46:	0b9b      	lsrs	r3, r3, #14
 8008c48:	fba7 0703 	umull	r0, r7, r7, r3
 8008c4c:	fba6 0202 	umull	r0, r2, r6, r2
 8008c50:	09bf      	lsrs	r7, r7, #6
 8008c52:	fb05 3317 	mls	r3, r5, r7, r3
 8008c56:	0b92      	lsrs	r2, r2, #14
 8008c58:	481c      	ldr	r0, [pc, #112]	; (8008ccc <modulePOS+0x27c>)
 8008c5a:	f009 fd41 	bl	80126e0 <chprintf.constprop.35>
 8008c5e:	4a1c      	ldr	r2, [pc, #112]	; (8008cd0 <modulePOS+0x280>)
 8008c60:	491c      	ldr	r1, [pc, #112]	; (8008cd4 <modulePOS+0x284>)
 8008c62:	481a      	ldr	r0, [pc, #104]	; (8008ccc <modulePOS+0x27c>)
 8008c64:	f009 fd3c 	bl	80126e0 <chprintf.constprop.35>
 8008c68:	238c      	movs	r3, #140	; 0x8c
 8008c6a:	4a1b      	ldr	r2, [pc, #108]	; (8008cd8 <modulePOS+0x288>)
 8008c6c:	491b      	ldr	r1, [pc, #108]	; (8008cdc <modulePOS+0x28c>)
 8008c6e:	4817      	ldr	r0, [pc, #92]	; (8008ccc <modulePOS+0x27c>)
 8008c70:	f009 fd36 	bl	80126e0 <chprintf.constprop.35>
 8008c74:	491a      	ldr	r1, [pc, #104]	; (8008ce0 <modulePOS+0x290>)
 8008c76:	4815      	ldr	r0, [pc, #84]	; (8008ccc <modulePOS+0x27c>)
 8008c78:	f009 fd32 	bl	80126e0 <chprintf.constprop.35>
 8008c7c:	491e      	ldr	r1, [pc, #120]	; (8008cf8 <modulePOS+0x2a8>)
 8008c7e:	4813      	ldr	r0, [pc, #76]	; (8008ccc <modulePOS+0x27c>)
 8008c80:	f009 fd2e 	bl	80126e0 <chprintf.constprop.35>
 8008c84:	4918      	ldr	r1, [pc, #96]	; (8008ce8 <modulePOS+0x298>)
 8008c86:	4811      	ldr	r0, [pc, #68]	; (8008ccc <modulePOS+0x27c>)
 8008c88:	f009 fd2a 	bl	80126e0 <chprintf.constprop.35>
 8008c8c:	480c      	ldr	r0, [pc, #48]	; (8008cc0 <modulePOS+0x270>)
 8008c8e:	f006 f8cf 	bl	800ee30 <chMtxUnlock>

			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
 8008c92:	9807      	ldr	r0, [sp, #28]
 8008c94:	f009 fbec 	bl	8012470 <getFrequency>
			msg.power = config->power;

			switch(config->protocol) {
 8008c98:	9903      	ldr	r1, [sp, #12]
		{

			TRACE_INFO("POS  > Transmit GPS position");

			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
 8008c9a:	90dc      	str	r0, [sp, #880]	; 0x370
			msg.power = config->power;

			switch(config->protocol) {
 8008c9c:	f891 2030 	ldrb.w	r2, [r1, #48]	; 0x30

			TRACE_INFO("POS  > Transmit GPS position");

			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
			msg.power = config->power;
 8008ca0:	f891 1020 	ldrb.w	r1, [r1, #32]
 8008ca4:	f88d 1374 	strb.w	r1, [sp, #884]	; 0x374

			switch(config->protocol) {
 8008ca8:	1e53      	subs	r3, r2, #1
 8008caa:	2b03      	cmp	r3, #3
 8008cac:	f200 86e7 	bhi.w	8009a7e <modulePOS+0x102e>
 8008cb0:	e8df f013 	tbh	[pc, r3, lsl #1]
 8008cb4:	00e600e6 	.word	0x00e600e6
 8008cb8:	0026009b 	.word	0x0026009b
 8008cbc:	10624dd3 	.word	0x10624dd3
 8008cc0:	20027b2c 	.word	0x20027b2c
 8008cc4:	d1b71759 	.word	0xd1b71759
 8008cc8:	08013c50 	.word	0x08013c50
 8008ccc:	20027e60 	.word	0x20027e60
 8008cd0:	08013cfc 	.word	0x08013cfc
 8008cd4:	08013c5c 	.word	0x08013c5c
 8008cd8:	08015374 	.word	0x08015374
 8008cdc:	08013c78 	.word	0x08013c78
 8008ce0:	08013d00 	.word	0x08013d00
 8008ce4:	08015380 	.word	0x08015380
 8008ce8:	08013cac 	.word	0x08013cac
 8008cec:	0801539c 	.word	0x0801539c
 8008cf0:	080153bc 	.word	0x080153bc
 8008cf4:	20027e3c 	.word	0x20027e3c
 8008cf8:	080153d8 	.word	0x080153d8
 8008cfc:	20027880 	.word	0x20027880
					// Transmit message
					transmitOnRadio(&msg);
					break;

				case PROT_MORSE: // Encode Morse
					msg.mod = MOD_OOK;
 8008d00:	2300      	movs	r3, #0
					msg.ook_config = &(config->ook_config);
 8008d02:	9a09      	ldr	r2, [sp, #36]	; 0x24

					// Encode morse message
					char morse[128];
					memcpy(morse, config->morse_config.format, sizeof(config->morse_config.format));
 8008d04:	9c0c      	ldr	r4, [sp, #48]	; 0x30
					transmitOnRadio(&msg);
					break;

				case PROT_MORSE: // Encode Morse
					msg.mod = MOD_OOK;
					msg.ook_config = &(config->ook_config);
 8008d06:	92de      	str	r2, [sp, #888]	; 0x378
					// Transmit message
					transmitOnRadio(&msg);
					break;

				case PROT_MORSE: // Encode Morse
					msg.mod = MOD_OOK;
 8008d08:	f88d 3375 	strb.w	r3, [sp, #885]	; 0x375
					msg.ook_config = &(config->ook_config);

					// Encode morse message
					char morse[128];
					memcpy(morse, config->morse_config.format, sizeof(config->morse_config.format));
 8008d0c:	ae1b      	add	r6, sp, #108	; 0x6c
 8008d0e:	68e3      	ldr	r3, [r4, #12]
 8008d10:	6820      	ldr	r0, [r4, #0]
 8008d12:	6861      	ldr	r1, [r4, #4]
 8008d14:	68a2      	ldr	r2, [r4, #8]
 8008d16:	4635      	mov	r5, r6
 8008d18:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8008d1a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008d1c:	3410      	adds	r4, #16
 8008d1e:	429c      	cmp	r4, r3
 8008d20:	462e      	mov	r6, r5
 8008d22:	d1f4      	bne.n	8008d0e <modulePOS+0x2be>
 8008d24:	881b      	ldrh	r3, [r3, #0]
 8008d26:	802b      	strh	r3, [r5, #0]
					replace_placeholders(morse, sizeof(morse), trackPoint);
 8008d28:	464a      	mov	r2, r9
 8008d2a:	2180      	movs	r1, #128	; 0x80
 8008d2c:	a81b      	add	r0, sp, #108	; 0x6c
 8008d2e:	f009 ffcf 	bl	8012cd0 <replace_placeholders>
					str_replace(morse, sizeof(morse), "<CALL>", config->morse_config.callsign);
 8008d32:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008d34:	4a4f      	ldr	r2, [pc, #316]	; (8008e74 <modulePOS+0x424>)
 8008d36:	2180      	movs	r1, #128	; 0x80
 8008d38:	a81b      	add	r0, sp, #108	; 0x6c
 8008d3a:	f009 ff79 	bl	8012c30 <str_replace>
 8008d3e:	f20d 136b 	addw	r3, sp, #363	; 0x16b

uint32_t morse_encode(uint8_t* data, const char* letter)
{
	// Blanking bits TODO: Replace this
	for(uint32_t i=0; i<256; i++)
		data[i] = 0;
 8008d42:	2100      	movs	r1, #0
 8008d44:	f803 1f01 	strb.w	r1, [r3, #1]!
}

uint32_t morse_encode(uint8_t* data, const char* letter)
{
	// Blanking bits TODO: Replace this
	for(uint32_t i=0; i<256; i++)
 8008d48:	455b      	cmp	r3, fp
		data[i] = 0;
 8008d4a:	f04f 0200 	mov.w	r2, #0
}

uint32_t morse_encode(uint8_t* data, const char* letter)
{
	// Blanking bits TODO: Replace this
	for(uint32_t i=0; i<256; i++)
 8008d4e:	d1f9      	bne.n	8008d44 <modulePOS+0x2f4>
		data[i] = 0;

	// Encode morse
	buffer = data; // Buffer
 8008d50:	4b49      	ldr	r3, [pc, #292]	; (8008e78 <modulePOS+0x428>)
	c = 0; // Bitlength
	for(uint32_t i=0; letter[i]!=0; i++)
 8008d52:	f89d 106c 	ldrb.w	r1, [sp, #108]	; 0x6c
	for(uint32_t i=0; i<256; i++)
		data[i] = 0;

	// Encode morse
	buffer = data; // Buffer
	c = 0; // Bitlength
 8008d56:	f8ca 2000 	str.w	r2, [sl]
	// Blanking bits TODO: Replace this
	for(uint32_t i=0; i<256; i++)
		data[i] = 0;

	// Encode morse
	buffer = data; // Buffer
 8008d5a:	a85b      	add	r0, sp, #364	; 0x16c
 8008d5c:	6018      	str	r0, [r3, #0]
	c = 0; // Bitlength
	for(uint32_t i=0; letter[i]!=0; i++)
 8008d5e:	2900      	cmp	r1, #0
 8008d60:	f000 8746 	beq.w	8009bf0 <modulePOS+0x11a0>
 8008d64:	ad1b      	add	r5, sp, #108	; 0x6c
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8008d66:	2401      	movs	r4, #1
		ADDB(0);
}

void morse_encode_char(char letter)
{
	switch(letter) {
 8008d68:	3920      	subs	r1, #32
 8008d6a:	293a      	cmp	r1, #58	; 0x3a
 8008d6c:	f200 8364 	bhi.w	8009438 <modulePOS+0x9e8>
 8008d70:	e8df f011 	tbh	[pc, r1, lsl #1]
 8008d74:	03620434 	.word	0x03620434
 8008d78:	03620362 	.word	0x03620362
 8008d7c:	03620362 	.word	0x03620362
 8008d80:	03620362 	.word	0x03620362
 8008d84:	03620362 	.word	0x03620362
 8008d88:	03620362 	.word	0x03620362
 8008d8c:	03620362 	.word	0x03620362
 8008d90:	036203c4 	.word	0x036203c4
 8008d94:	05a00365 	.word	0x05a00365
 8008d98:	0551057d 	.word	0x0551057d
 8008d9c:	04e1051c 	.word	0x04e1051c
 8008da0:	03f80393 	.word	0x03f80393
 8008da4:	02f3032e 	.word	0x02f3032e
 8008da8:	03620362 	.word	0x03620362
 8008dac:	03620362 	.word	0x03620362
 8008db0:	03620362 	.word	0x03620362
 8008db4:	03510362 	.word	0x03510362
 8008db8:	042004a9 	.word	0x042004a9
 8008dbc:	02fb0332 	.word	0x02fb0332
 8008dc0:	02f70462 	.word	0x02f70462
 8008dc4:	03340395 	.word	0x03340395
 8008dc8:	03e40491 	.word	0x03e40491
 8008dcc:	0327047f 	.word	0x0327047f
 8008dd0:	036902f9 	.word	0x036902f9
 8008dd4:	034d04cf 	.word	0x034d04cf
 8008dd8:	03fc0422 	.word	0x03fc0422
 8008ddc:	03740360 	.word	0x03740360
 8008de0:	03180438 	.word	0x03180438
 8008de4:	03160372 	.word	0x03160372
 8008de8:	0330      	.short	0x0330
					}

					break;

				case PROT_UKHAS_2FSK: // Encode UKHAS
					msg.mod = MOD_2FSK;
 8008dea:	2301      	movs	r3, #1
					msg.fsk_config = &(config->fsk_config);

					// Encode packet
					char fskmsg[256];
					memcpy(fskmsg, config->ukhas_config.format, sizeof(config->ukhas_config.format));
 8008dec:	2296      	movs	r2, #150	; 0x96
 8008dee:	990c      	ldr	r1, [sp, #48]	; 0x30

					break;

				case PROT_UKHAS_2FSK: // Encode UKHAS
					msg.mod = MOD_2FSK;
					msg.fsk_config = &(config->fsk_config);
 8008df0:	9c09      	ldr	r4, [sp, #36]	; 0x24
					}

					break;

				case PROT_UKHAS_2FSK: // Encode UKHAS
					msg.mod = MOD_2FSK;
 8008df2:	f88d 3375 	strb.w	r3, [sp, #885]	; 0x375
					msg.fsk_config = &(config->fsk_config);

					// Encode packet
					char fskmsg[256];
					memcpy(fskmsg, config->ukhas_config.format, sizeof(config->ukhas_config.format));
 8008df6:	a81b      	add	r0, sp, #108	; 0x6c

					break;

				case PROT_UKHAS_2FSK: // Encode UKHAS
					msg.mod = MOD_2FSK;
					msg.fsk_config = &(config->fsk_config);
 8008df8:	94df      	str	r4, [sp, #892]	; 0x37c

					// Encode packet
					char fskmsg[256];
					memcpy(fskmsg, config->ukhas_config.format, sizeof(config->ukhas_config.format));
 8008dfa:	f7f8 fc49 	bl	8001690 <memcpy>
					replace_placeholders(fskmsg, sizeof(fskmsg), trackPoint);
 8008dfe:	464a      	mov	r2, r9
 8008e00:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008e04:	a81b      	add	r0, sp, #108	; 0x6c
 8008e06:	f009 ff63 	bl	8012cd0 <replace_placeholders>
					str_replace(fskmsg, sizeof(fskmsg), "<CALL>", config->ukhas_config.callsign);
 8008e0a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008e0c:	4a19      	ldr	r2, [pc, #100]	; (8008e74 <modulePOS+0x424>)
 8008e0e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008e12:	a81b      	add	r0, sp, #108	; 0x6c
 8008e14:	f009 ff0c 	bl	8012c30 <str_replace>
 8008e18:	a81b      	add	r0, sp, #108	; 0x6c
 8008e1a:	f7f8 fe49 	bl	8001ab0 <strlen>
 8008e1e:	a91b      	add	r1, sp, #108	; 0x6c
 8008e20:	4408      	add	r0, r1
	size_t i;
	uint16_t crc;

	crc = 0xFFFF;

	for(i = 0; i < strlen(string); i++) {
 8008e22:	4288      	cmp	r0, r1

uint16_t crc16(char *string) {
	size_t i;
	uint16_t crc;

	crc = 0xFFFF;
 8008e24:	f64f 73ff 	movw	r3, #65535	; 0xffff

	for(i = 0; i < strlen(string); i++) {
 8008e28:	d016      	beq.n	8008e58 <modulePOS+0x408>
		crc = crc ^ ((uint16_t)string[i] << 8);
 8008e2a:	f811 2b01 	ldrb.w	r2, [r1], #1
 8008e2e:	ea83 2302 	eor.w	r3, r3, r2, lsl #8
 8008e32:	2208      	movs	r2, #8
		for(uint8_t j=0; j<8; j++)
		{
		    if(crc & 0x8000)
 8008e34:	f413 4f00 	tst.w	r3, #32768	; 0x8000
		        crc = (crc << 1) ^ 0x1021;
 8008e38:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8008e3c:	bf18      	it	ne
 8008e3e:	f483 5381 	eorne.w	r3, r3, #4128	; 0x1020
 8008e42:	f102 32ff 	add.w	r2, r2, #4294967295
 8008e46:	bf18      	it	ne
 8008e48:	f083 0301 	eorne.w	r3, r3, #1

	crc = 0xFFFF;

	for(i = 0; i < strlen(string); i++) {
		crc = crc ^ ((uint16_t)string[i] << 8);
		for(uint8_t j=0; j<8; j++)
 8008e4c:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		{
		    if(crc & 0x8000)
		        crc = (crc << 1) ^ 0x1021;
		    else
		        crc <<= 1;
 8008e50:	b29b      	uxth	r3, r3

	crc = 0xFFFF;

	for(i = 0; i < strlen(string); i++) {
		crc = crc ^ ((uint16_t)string[i] << 8);
		for(uint8_t j=0; j<8; j++)
 8008e52:	d1ef      	bne.n	8008e34 <modulePOS+0x3e4>
	size_t i;
	uint16_t crc;

	crc = 0xFFFF;

	for(i = 0; i < strlen(string); i++) {
 8008e54:	4288      	cmp	r0, r1
 8008e56:	d1e8      	bne.n	8008e2a <modulePOS+0x3da>
					// Encode packet
					char fskmsg[256];
					memcpy(fskmsg, config->ukhas_config.format, sizeof(config->ukhas_config.format));
					replace_placeholders(fskmsg, sizeof(fskmsg), trackPoint);
					str_replace(fskmsg, sizeof(fskmsg), "<CALL>", config->ukhas_config.callsign);
					msg.bin_len = 8*chsnprintf((char*)msg.msg, sizeof(fskmsg), "$$$$$%s*%04X\n", fskmsg, crc16(fskmsg));
 8008e58:	9300      	str	r3, [sp, #0]
 8008e5a:	4a08      	ldr	r2, [pc, #32]	; (8008e7c <modulePOS+0x42c>)
 8008e5c:	ab1b      	add	r3, sp, #108	; 0x6c
 8008e5e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008e62:	a85b      	add	r0, sp, #364	; 0x16c
 8008e64:	f003 f9e4 	bl	800c230 <chsnprintf>
 8008e68:	00c3      	lsls	r3, r0, #3

					// Transmit message
					transmitOnRadio(&msg);
 8008e6a:	a85b      	add	r0, sp, #364	; 0x16c
					// Encode packet
					char fskmsg[256];
					memcpy(fskmsg, config->ukhas_config.format, sizeof(config->ukhas_config.format));
					replace_placeholders(fskmsg, sizeof(fskmsg), trackPoint);
					str_replace(fskmsg, sizeof(fskmsg), "<CALL>", config->ukhas_config.callsign);
					msg.bin_len = 8*chsnprintf((char*)msg.msg, sizeof(fskmsg), "$$$$$%s*%04X\n", fskmsg, crc16(fskmsg));
 8008e6c:	93db      	str	r3, [sp, #876]	; 0x36c

					// Transmit message
					transmitOnRadio(&msg);
 8008e6e:	f008 fb7f 	bl	8011570 <transmitOnRadio>
 8008e72:	e665      	b.n	8008b40 <modulePOS+0xf0>
 8008e74:	08015538 	.word	0x08015538
 8008e78:	20027890 	.word	0x20027890
 8008e7c:	08015540 	.word	0x08015540
			switch(config->protocol) {

				case PROT_APRS_2GFSK: // Encode APRS
				case PROT_APRS_AFSK:
					// Position transmission
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8008e80:	2a01      	cmp	r2, #1
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8008e82:	9903      	ldr	r1, [sp, #12]
					msg.gfsk_config = &(config->gfsk_config);
 8008e84:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008e86:	93e1      	str	r3, [sp, #900]	; 0x384
			switch(config->protocol) {

				case PROT_APRS_2GFSK: // Encode APRS
				case PROT_APRS_AFSK:
					// Position transmission
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8008e88:	bf14      	ite	ne
 8008e8a:	2702      	movne	r7, #2
 8008e8c:	2704      	moveq	r7, #4
					msg.gfsk_config = &(config->gfsk_config);
					msg.afsk_config = &(config->afsk_config);
 8008e8e:	93e0      	str	r3, [sp, #896]	; 0x380
			switch(config->protocol) {

				case PROT_APRS_2GFSK: // Encode APRS
				case PROT_APRS_AFSK:
					// Position transmission
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8008e90:	f88d 7375 	strb.w	r7, [sp, #885]	; 0x375
 8008e94:	f8b1 307c 	ldrh.w	r3, [r1, #124]	; 0x7c
 * - Number of cycles where GPS has been lost (if applicable in cycle)
 */
uint32_t aprs_encode_position(uint8_t* message, mod_t mod, const aprs_config_t *config, trackPoint_t *trackPoint)
{
	char temp[22];
	ptime_t date = trackPoint->time;
 8008e98:	f899 4008 	ldrb.w	r4, [r9, #8]
 8008e9c:	f899 5009 	ldrb.w	r5, [r9, #9]
 8008ea0:	f899 600a 	ldrb.w	r6, [r9, #10]
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8008ea4:	f891 2068 	ldrb.w	r2, [r1, #104]	; 0x68
	char temp[22];
	ptime_t date = trackPoint->time;
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;
 8008ea8:	f88d 706a 	strb.w	r7, [sp, #106]	; 0x6a
{
	char temp[22];
	ptime_t date = trackPoint->time;
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 8008eac:	f44f 7e00 	mov.w	lr, #512	; 0x200
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8008eb0:	9300      	str	r3, [sp, #0]
 8008eb2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8008eb4:	9b11      	ldr	r3, [sp, #68]	; 0x44
{
	char temp[22];
	ptime_t date = trackPoint->time;
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 8008eb6:	f8ad e066 	strh.w	lr, [sp, #102]	; 0x66
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8008eba:	a817      	add	r0, sp, #92	; 0x5c
uint32_t aprs_encode_position(uint8_t* message, mod_t mod, const aprs_config_t *config, trackPoint_t *trackPoint)
{
	char temp[22];
	ptime_t date = trackPoint->time;
	ax25_t packet;
	packet.data = message;
 8008ebc:	af5b      	add	r7, sp, #364	; 0x16c
 8008ebe:	9718      	str	r7, [sp, #96]	; 0x60
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8008ec0:	f005 f83e 	bl	800df40 <ax25_send_header.constprop.16>
	}
}

void ax25_send_byte(ax25_t *packet, char byte)
{
	send_byte(packet, byte);
 8008ec4:	212f      	movs	r1, #47	; 0x2f
 8008ec6:	a817      	add	r0, sp, #92	; 0x5c
 8008ec8:	f001 fb4a 	bl	800a560 <send_byte.lto_priv.112>
	ax25_send_byte(&packet, '/');                // Report w/ timestamp, no APRS messaging. $ = NMEA raw data

	// 170915 = 17h:09m:15s zulu (not allowed in Status Reports)
	chsnprintf(temp, sizeof(temp), "%02d%02d%02dh", date.hour, date.minute, date.second);
 8008ecc:	4623      	mov	r3, r4
 8008ece:	4aaa      	ldr	r2, [pc, #680]	; (8009178 <modulePOS+0x728>)
 8008ed0:	e88d 0060 	stmia.w	sp, {r5, r6}
 8008ed4:	2116      	movs	r1, #22
 8008ed6:	a81b      	add	r0, sp, #108	; 0x6c
 8008ed8:	f003 f9aa 	bl	800c230 <chsnprintf>
	ax25_send_string(&packet, temp);
 8008edc:	a91b      	add	r1, sp, #108	; 0x6c
 8008ede:	a817      	add	r0, sp, #92	; 0x5c
 8008ee0:	f001 fbce 	bl	800a680 <ax25_send_string>

	// Latitude
	uint32_t y = 380926 * (90 - trackPoint->gps_lat/10000000.0);
 8008ee4:	f8d9 0010 	ldr.w	r0, [r9, #16]
	uint32_t y3  = y   / 753571;
	uint32_t y3r = y   % 753571;
 8008ee8:	4ea4      	ldr	r6, [pc, #656]	; (800917c <modulePOS+0x72c>)
 8008eea:	4da5      	ldr	r5, [pc, #660]	; (8009180 <modulePOS+0x730>)
	// 170915 = 17h:09m:15s zulu (not allowed in Status Reports)
	chsnprintf(temp, sizeof(temp), "%02d%02d%02dh", date.hour, date.minute, date.second);
	ax25_send_string(&packet, temp);

	// Latitude
	uint32_t y = 380926 * (90 - trackPoint->gps_lat/10000000.0);
 8008eec:	f7f7 fb4a 	bl	8000584 <__aeabi_i2d>
 8008ef0:	a39b      	add	r3, pc, #620	; (adr r3, 8009160 <modulePOS+0x710>)
 8008ef2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008ef6:	f7f7 fcd5 	bl	80008a4 <__aeabi_ddiv>
 8008efa:	4602      	mov	r2, r0
 8008efc:	460b      	mov	r3, r1
 8008efe:	2000      	movs	r0, #0
 8008f00:	49a0      	ldr	r1, [pc, #640]	; (8009184 <modulePOS+0x734>)
 8008f02:	f7f7 f9f1 	bl	80002e8 <__aeabi_dsub>
 8008f06:	a398      	add	r3, pc, #608	; (adr r3, 8009168 <modulePOS+0x718>)
 8008f08:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f0c:	f7f7 fba0 	bl	8000650 <__aeabi_dmul>
 8008f10:	f7f7 fe56 	bl	8000bc0 <__aeabi_d2uiz>
	uint32_t y3  = y   / 753571;
	uint32_t y3r = y   % 753571;
 8008f14:	fba6 3400 	umull	r3, r4, r6, r0
 8008f18:	0ce4      	lsrs	r4, r4, #19
	uint32_t y2  = y3r / 8281;
	uint32_t y2r = y3r % 8281;
 8008f1a:	4b9b      	ldr	r3, [pc, #620]	; (8009188 <modulePOS+0x738>)
	ax25_send_string(&packet, temp);

	// Latitude
	uint32_t y = 380926 * (90 - trackPoint->gps_lat/10000000.0);
	uint32_t y3  = y   / 753571;
	uint32_t y3r = y   % 753571;
 8008f1c:	fb05 0414 	mls	r4, r5, r4, r0
	uint32_t y2  = y3r / 8281;
	uint32_t y2r = y3r % 8281;
 8008f20:	fba3 3804 	umull	r3, r8, r3, r4
 8008f24:	ea4f 2398 	mov.w	r3, r8, lsr #10
	// 170915 = 17h:09m:15s zulu (not allowed in Status Reports)
	chsnprintf(temp, sizeof(temp), "%02d%02d%02dh", date.hour, date.minute, date.second);
	ax25_send_string(&packet, temp);

	// Latitude
	uint32_t y = 380926 * (90 - trackPoint->gps_lat/10000000.0);
 8008f28:	4607      	mov	r7, r0
	uint32_t y2r = y3r % 8281;
	uint32_t y1  = y2r / 91;
	uint32_t y1r = y2r % 91;

	// Longitude
	uint32_t x = 190463 * (180 + trackPoint->gps_lon/10000000.0);
 8008f2a:	f8d9 0014 	ldr.w	r0, [r9, #20]
	// Latitude
	uint32_t y = 380926 * (90 - trackPoint->gps_lat/10000000.0);
	uint32_t y3  = y   / 753571;
	uint32_t y3r = y   % 753571;
	uint32_t y2  = y3r / 8281;
	uint32_t y2r = y3r % 8281;
 8008f2e:	9306      	str	r3, [sp, #24]
	uint32_t y1  = y2r / 91;
	uint32_t y1r = y2r % 91;

	// Longitude
	uint32_t x = 190463 * (180 + trackPoint->gps_lon/10000000.0);
 8008f30:	f7f7 fb28 	bl	8000584 <__aeabi_i2d>
 8008f34:	a38a      	add	r3, pc, #552	; (adr r3, 8009160 <modulePOS+0x710>)
 8008f36:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f3a:	f7f7 fcb3 	bl	80008a4 <__aeabi_ddiv>
 8008f3e:	2200      	movs	r2, #0
 8008f40:	4b92      	ldr	r3, [pc, #584]	; (800918c <modulePOS+0x73c>)
 8008f42:	f7f7 f9d3 	bl	80002ec <__adddf3>
 8008f46:	a38a      	add	r3, pc, #552	; (adr r3, 8009170 <modulePOS+0x720>)
 8008f48:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f4c:	f7f7 fb80 	bl	8000650 <__aeabi_dmul>
 8008f50:	f7f7 fe36 	bl	8000bc0 <__aeabi_d2uiz>
	uint32_t x3  = x   / 753571;
	uint32_t x3r = x   % 753571;
 8008f54:	fba6 1300 	umull	r1, r3, r6, r0
	uint32_t x2r = x3r % 8281;
	uint32_t x1  = x2r / 91;
	uint32_t x1r = x2r % 91;

	// Altitude
	uint32_t a = logf(METER_TO_FEET(trackPoint->gps_alt)) / logf(1.002f);
 8008f58:	f8d9 2018 	ldr.w	r2, [r9, #24]
	uint32_t y2r = y3r % 8281;
	uint32_t y1  = y2r / 91;
	uint32_t y1r = y2r % 91;

	// Longitude
	uint32_t x = 190463 * (180 + trackPoint->gps_lon/10000000.0);
 8008f5c:	900a      	str	r0, [sp, #40]	; 0x28
	uint32_t x3  = x   / 753571;
	uint32_t x3r = x   % 753571;
 8008f5e:	ea4f 48d3 	mov.w	r8, r3, lsr #19
 8008f62:	fb05 0818 	mls	r8, r5, r8, r0
	uint32_t x2  = x3r / 8281;
	uint32_t x2r = x3r % 8281;
 8008f66:	4988      	ldr	r1, [pc, #544]	; (8009188 <modulePOS+0x738>)
	uint32_t x1  = x2r / 91;
	uint32_t x1r = x2r % 91;

	// Altitude
	uint32_t a = logf(METER_TO_FEET(trackPoint->gps_alt)) / logf(1.002f);
 8008f68:	f646 00fc 	movw	r0, #26876	; 0x68fc
 8008f6c:	fb00 f002 	mul.w	r0, r0, r2
 8008f70:	2800      	cmp	r0, #0
	// Longitude
	uint32_t x = 190463 * (180 + trackPoint->gps_lon/10000000.0);
	uint32_t x3  = x   / 753571;
	uint32_t x3r = x   % 753571;
	uint32_t x2  = x3r / 8281;
	uint32_t x2r = x3r % 8281;
 8008f72:	fba1 1608 	umull	r1, r6, r1, r8
	uint32_t x1  = x2r / 91;
	uint32_t x1r = x2r % 91;

	// Altitude
	uint32_t a = logf(METER_TO_FEET(trackPoint->gps_alt)) / logf(1.002f);
 8008f76:	bfb8      	it	lt
 8008f78:	f500 50ff 	addlt.w	r0, r0, #8160	; 0x1fe0
	// Longitude
	uint32_t x = 190463 * (180 + trackPoint->gps_lon/10000000.0);
	uint32_t x3  = x   / 753571;
	uint32_t x3r = x   % 753571;
	uint32_t x2  = x3r / 8281;
	uint32_t x2r = x3r % 8281;
 8008f7c:	ea4f 2396 	mov.w	r3, r6, lsr #10
	// Latitude
	uint32_t y = 380926 * (90 - trackPoint->gps_lat/10000000.0);
	uint32_t y3  = y   / 753571;
	uint32_t y3r = y   % 753571;
	uint32_t y2  = y3r / 8281;
	uint32_t y2r = y3r % 8281;
 8008f80:	9a06      	ldr	r2, [sp, #24]
	uint32_t x2r = x3r % 8281;
	uint32_t x1  = x2r / 91;
	uint32_t x1r = x2r % 91;

	// Altitude
	uint32_t a = logf(METER_TO_FEET(trackPoint->gps_alt)) / logf(1.002f);
 8008f82:	bfb8      	it	lt
 8008f84:	301f      	addlt	r0, #31
	// Longitude
	uint32_t x = 190463 * (180 + trackPoint->gps_lon/10000000.0);
	uint32_t x3  = x   / 753571;
	uint32_t x3r = x   % 753571;
	uint32_t x2  = x3r / 8281;
	uint32_t x2r = x3r % 8281;
 8008f86:	4619      	mov	r1, r3
	// Latitude
	uint32_t y = 380926 * (90 - trackPoint->gps_lat/10000000.0);
	uint32_t y3  = y   / 753571;
	uint32_t y3r = y   % 753571;
	uint32_t y2  = y3r / 8281;
	uint32_t y2r = y3r % 8281;
 8008f88:	f242 0359 	movw	r3, #8281	; 0x2059
 8008f8c:	fb03 4212 	mls	r2, r3, r2, r4
	uint32_t x2r = x3r % 8281;
	uint32_t x1  = x2r / 91;
	uint32_t x1r = x2r % 91;

	// Altitude
	uint32_t a = logf(METER_TO_FEET(trackPoint->gps_alt)) / logf(1.002f);
 8008f90:	1340      	asrs	r0, r0, #13
	// Longitude
	uint32_t x = 190463 * (180 + trackPoint->gps_lon/10000000.0);
	uint32_t x3  = x   / 753571;
	uint32_t x3r = x   % 753571;
	uint32_t x2  = x3r / 8281;
	uint32_t x2r = x3r % 8281;
 8008f92:	fb03 8311 	mls	r3, r3, r1, r8
	// Latitude
	uint32_t y = 380926 * (90 - trackPoint->gps_lat/10000000.0);
	uint32_t y3  = y   / 753571;
	uint32_t y3r = y   % 753571;
	uint32_t y2  = y3r / 8281;
	uint32_t y2r = y3r % 8281;
 8008f96:	9206      	str	r2, [sp, #24]
	// Longitude
	uint32_t x = 190463 * (180 + trackPoint->gps_lon/10000000.0);
	uint32_t x3  = x   / 753571;
	uint32_t x3r = x   % 753571;
	uint32_t x2  = x3r / 8281;
	uint32_t x2r = x3r % 8281;
 8008f98:	9308      	str	r3, [sp, #32]
	uint32_t x1  = x2r / 91;
	uint32_t x1r = x2r % 91;

	// Altitude
	uint32_t a = logf(METER_TO_FEET(trackPoint->gps_alt)) / logf(1.002f);
 8008f9a:	f7f7 ff3b 	bl	8000e14 <__aeabi_i2f>
 8008f9e:	f00a f9ff 	bl	80133a0 <logf>
 8008fa2:	497b      	ldr	r1, [pc, #492]	; (8009190 <modulePOS+0x740>)
 8008fa4:	f7f8 f840 	bl	8001028 <__aeabi_fdiv>
 8008fa8:	f7f8 f96a 	bl	8001280 <__aeabi_f2uiz>
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 8008fac:	4b79      	ldr	r3, [pc, #484]	; (8009194 <modulePOS+0x744>)
	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
 8008fae:	4a73      	ldr	r2, [pc, #460]	; (800917c <modulePOS+0x72c>)
	uint32_t x2r = x3r % 8281;
	uint32_t x1  = x2r / 91;
	uint32_t x1r = x2r % 91;

	// Altitude
	uint32_t a = logf(METER_TO_FEET(trackPoint->gps_alt)) / logf(1.002f);
 8008fb0:	4601      	mov	r1, r0
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
 8008fb2:	fba3 6501 	umull	r6, r5, r3, r1
	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
 8008fb6:	fba2 7c07 	umull	r7, ip, r2, r7
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
 8008fba:	ebc5 0e01 	rsb	lr, r5, r1
	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
 8008fbe:	9f0a      	ldr	r7, [sp, #40]	; 0x28
	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
 8008fc0:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
 8008fc4:	eb05 0e5e 	add.w	lr, r5, lr, lsr #1
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 8008fc8:	9d06      	ldr	r5, [sp, #24]
	// Altitude
	uint32_t a = logf(METER_TO_FEET(trackPoint->gps_alt)) / logf(1.002f);
	uint32_t a1  = a / 91;
	uint32_t a1r = a % 91;

	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
 8008fca:	f899 000e 	ldrb.w	r0, [r9, #14]
	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
 8008fce:	fba2 7c07 	umull	r7, ip, r2, r7
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 8008fd2:	9a06      	ldr	r2, [sp, #24]
 8008fd4:	fba3 6505 	umull	r6, r5, r3, r5
 8008fd8:	1b52      	subs	r2, r2, r5
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
 8008fda:	9e08      	ldr	r6, [sp, #32]
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 8008fdc:	eb05 0552 	add.w	r5, r5, r2, lsr #1
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
 8008fe0:	9a08      	ldr	r2, [sp, #32]
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 8008fe2:	09af      	lsrs	r7, r5, #6
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
 8008fe4:	fba3 6306 	umull	r6, r3, r3, r6
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 8008fe8:	970a      	str	r7, [sp, #40]	; 0x28
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
 8008fea:	ea4f 169e 	mov.w	r6, lr, lsr #6
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
 8008fee:	1ad2      	subs	r2, r2, r3

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
 8008ff0:	f04f 0e5b 	mov.w	lr, #91	; 0x5b
 8008ff4:	9d06      	ldr	r5, [sp, #24]
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
	temp[11] = a1r+33;
 8008ff6:	960e      	str	r6, [sp, #56]	; 0x38
 8008ff8:	fb0e 1116 	mls	r1, lr, r6, r1
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
 8008ffc:	eb03 0252 	add.w	r2, r3, r2, lsr #1

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
 8009000:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
 8009002:	4b61      	ldr	r3, [pc, #388]	; (8009188 <modulePOS+0x738>)
 8009004:	fba3 7404 	umull	r7, r4, r3, r4
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
 8009008:	fba3 7308 	umull	r7, r3, r3, r8

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
 800900c:	fb0e 5816 	mls	r8, lr, r6, r5
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
 8009010:	9d08      	ldr	r5, [sp, #32]

	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
 8009012:	9f03      	ldr	r7, [sp, #12]
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
 8009014:	0992      	lsrs	r2, r2, #6
	temp[8]  = x1r+33;
 8009016:	fb0e 5612 	mls	r6, lr, r2, r5
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
 800901a:	9d0e      	ldr	r5, [sp, #56]	; 0x38

	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
 800901c:	f8b7 e06a 	ldrh.w	lr, [r7, #106]	; 0x6a
	temp[1]  = y3+33;
 8009020:	9f0d      	ldr	r7, [sp, #52]	; 0x34
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
 8009022:	f88d e075 	strb.w	lr, [sp, #117]	; 0x75
	temp[10] = a1+33;
 8009026:	3521      	adds	r5, #33	; 0x21
 8009028:	9508      	str	r5, [sp, #32]
	temp[11] = a1r+33;
	temp[12] = ((gpsFix << 5) | (src << 3) | origin) + 33;
 800902a:	0140      	lsls	r0, r0, #5
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 800902c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
 800902e:	0aa4      	lsrs	r4, r4, #10
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
	temp[11] = a1r+33;
 8009030:	3121      	adds	r1, #33	; 0x21
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
 8009032:	3421      	adds	r4, #33	; 0x21
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
	temp[11] = a1r+33;
	temp[12] = ((gpsFix << 5) | (src << 3) | origin) + 33;
 8009034:	f040 0015 	orr.w	r0, r0, #21
	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
 8009038:	0cff      	lsrs	r7, r7, #19
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
 800903a:	ea4f 4cdc 	mov.w	ip, ip, lsr #19
 800903e:	f10c 0c21 	add.w	ip, ip, #33	; 0x21
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
	temp[11] = a1r+33;
	temp[12] = ((gpsFix << 5) | (src << 3) | origin) + 33;
 8009042:	3021      	adds	r0, #33	; 0x21
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
 8009044:	3221      	adds	r2, #33	; 0x21
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
 8009046:	9406      	str	r4, [sp, #24]
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
	temp[11] = a1r+33;
 8009048:	f88d 1077 	strb.w	r1, [sp, #119]	; 0x77
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
 800904c:	0a9b      	lsrs	r3, r3, #10
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
 800904e:	f89d 1020 	ldrb.w	r1, [sp, #32]
	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
 8009052:	f88d c071 	strb.w	ip, [sp, #113]	; 0x71

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
 8009056:	f108 0821 	add.w	r8, r8, #33	; 0x21
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 800905a:	3521      	adds	r5, #33	; 0x21
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
 800905c:	3621      	adds	r6, #33	; 0x21
	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
 800905e:	3721      	adds	r7, #33	; 0x21

	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
 8009060:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
 8009064:	3321      	adds	r3, #33	; 0x21
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
 8009066:	f88d 1076 	strb.w	r1, [sp, #118]	; 0x76
	temp[11] = a1r+33;
	temp[12] = ((gpsFix << 5) | (src << 3) | origin) + 33;
 800906a:	f88d 0078 	strb.w	r0, [sp, #120]	; 0x78
	temp[13] = 0;

	ax25_send_string(&packet, temp);
 800906e:	a91b      	add	r1, sp, #108	; 0x6c
 8009070:	a817      	add	r0, sp, #92	; 0x5c
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
	temp[11] = a1r+33;
	temp[12] = ((gpsFix << 5) | (src << 3) | origin) + 33;
	temp[13] = 0;
 8009072:	2400      	movs	r4, #0

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
 8009074:	f88d 8070 	strb.w	r8, [sp, #112]	; 0x70
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
 8009078:	f88d 506f 	strb.w	r5, [sp, #111]	; 0x6f
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
	temp[8]  = x1r+33;
 800907c:	f88d 6074 	strb.w	r6, [sp, #116]	; 0x74
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
	temp[7]  = x1+33;
 8009080:	f88d 2073 	strb.w	r2, [sp, #115]	; 0x73
	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
	temp[1]  = y3+33;
 8009084:	f88d 706d 	strb.w	r7, [sp, #109]	; 0x6d
	temp[2]  = y2+33;
 8009088:	f89d 2018 	ldrb.w	r2, [sp, #24]
 800908c:	f88d 206e 	strb.w	r2, [sp, #110]	; 0x6e

	uint8_t gpsFix = trackPoint->gps_lock ? GSP_FIX_CURRENT : GSP_FIX_OLD;
	uint8_t src = NMEA_SRC_GGA;
	uint8_t origin = ORIGIN_PICO;

	temp[0]  = (config->symbol >> 8) & 0xFF;
 8009090:	f88d e06c 	strb.w	lr, [sp, #108]	; 0x6c
	temp[1]  = y3+33;
	temp[2]  = y2+33;
	temp[3]  = y1+33;
	temp[4]  = y1r+33;
	temp[5]  = x3+33;
	temp[6]  = x2+33;
 8009094:	f88d 3072 	strb.w	r3, [sp, #114]	; 0x72
	temp[8]  = x1r+33;
	temp[9]  = config->symbol & 0xFF;
	temp[10] = a1+33;
	temp[11] = a1r+33;
	temp[12] = ((gpsFix << 5) | (src << 3) | origin) + 33;
	temp[13] = 0;
 8009098:	f88d 4079 	strb.w	r4, [sp, #121]	; 0x79

	ax25_send_string(&packet, temp);
 800909c:	f001 faf0 	bl	800a680 <ax25_send_string>

	// Comments
	ax25_send_string(&packet, "SATS ");
 80090a0:	493d      	ldr	r1, [pc, #244]	; (8009198 <modulePOS+0x748>)
 80090a2:	a817      	add	r0, sp, #92	; 0x5c
 80090a4:	f001 faec 	bl	800a680 <ax25_send_string>
	chsnprintf(temp, sizeof(temp), "%d", trackPoint->gps_sats);
 80090a8:	f899 301c 	ldrb.w	r3, [r9, #28]
 80090ac:	4a3b      	ldr	r2, [pc, #236]	; (800919c <modulePOS+0x74c>)
 80090ae:	2116      	movs	r1, #22
 80090b0:	a81b      	add	r0, sp, #108	; 0x6c
 80090b2:	f003 f8bd 	bl	800c230 <chsnprintf>
	ax25_send_string(&packet, temp);
 80090b6:	a91b      	add	r1, sp, #108	; 0x6c
 80090b8:	a817      	add	r0, sp, #92	; 0x5c
 80090ba:	f001 fae1 	bl	800a680 <ax25_send_string>

	if(trackPoint->gps_lock)
 80090be:	f899 300e 	ldrb.w	r3, [r9, #14]
 80090c2:	2b00      	cmp	r3, #0
 80090c4:	f040 8517 	bne.w	8009af6 <modulePOS+0x10a6>
	}

	// GPS Loss counter
	if(!trackPoint->gps_lock)
	{
		ax25_send_string(&packet, " GPS LOSS ");
 80090c8:	4935      	ldr	r1, [pc, #212]	; (80091a0 <modulePOS+0x750>)
		chsnprintf(temp, sizeof(temp), "%d", ++loss_of_gps_counter);
 80090ca:	4d36      	ldr	r5, [pc, #216]	; (80091a4 <modulePOS+0x754>)
	}

	// GPS Loss counter
	if(!trackPoint->gps_lock)
	{
		ax25_send_string(&packet, " GPS LOSS ");
 80090cc:	a817      	add	r0, sp, #92	; 0x5c
 80090ce:	f001 fad7 	bl	800a680 <ax25_send_string>
		chsnprintf(temp, sizeof(temp), "%d", ++loss_of_gps_counter);
 80090d2:	4b34      	ldr	r3, [pc, #208]	; (80091a4 <modulePOS+0x754>)
 80090d4:	4a31      	ldr	r2, [pc, #196]	; (800919c <modulePOS+0x74c>)
 80090d6:	881c      	ldrh	r4, [r3, #0]
 80090d8:	3401      	adds	r4, #1
 80090da:	b2a4      	uxth	r4, r4
 80090dc:	2116      	movs	r1, #22
 80090de:	4623      	mov	r3, r4
 80090e0:	a81b      	add	r0, sp, #108	; 0x6c
 80090e2:	802c      	strh	r4, [r5, #0]
 80090e4:	f003 f8a4 	bl	800c230 <chsnprintf>
		ax25_send_string(&packet, temp);
 80090e8:	a91b      	add	r1, sp, #108	; 0x6c
 80090ea:	a817      	add	r0, sp, #92	; 0x5c
 80090ec:	f001 fac8 	bl	800a680 <ax25_send_string>
	} else {
		loss_of_gps_counter = 0;
	}

	temp[2] = 0;
 80090f0:	2300      	movs	r3, #0
 80090f2:	217c      	movs	r1, #124	; 0x7c
 80090f4:	a817      	add	r0, sp, #92	; 0x5c
 80090f6:	f88d 306e 	strb.w	r3, [sp, #110]	; 0x6e
 80090fa:	f001 fa31 	bl	800a560 <send_byte.lto_priv.112>

	ax25_send_byte(&packet, '|');

	// Sequence ID
	uint32_t t = trackPoint->id & 0x1FFF;
 80090fe:	f8d9 3000 	ldr.w	r3, [r9]
	temp[0] = t/91 + 33;
 8009102:	4c24      	ldr	r4, [pc, #144]	; (8009194 <modulePOS+0x744>)
			case TEL_CHARGE:	t = trackPoint->adc_charge;			break;
			case TEL_DISCHARGE:	t = trackPoint->adc_discharge;		break;
			case TEL_IHUM:		t = trackPoint->int_hum;			break;
			case TEL_EHUM:		t = trackPoint->ext_hum;			break;
			case TEL_IPRESS:	t = trackPoint->int_press/125 - 40;	break;
			case TEL_EPRESS:	t = trackPoint->ext_press/125 - 40;	break;
 8009104:	4f28      	ldr	r7, [pc, #160]	; (80091a8 <modulePOS+0x758>)
	temp[2] = 0;

	ax25_send_byte(&packet, '|');

	// Sequence ID
	uint32_t t = trackPoint->id & 0x1FFF;
 8009106:	f3c3 080c 	ubfx	r8, r3, #0, #13
	temp[0] = t/91 + 33;
 800910a:	fba4 2308 	umull	r2, r3, r4, r8
 800910e:	ebc3 0208 	rsb	r2, r3, r8
 8009112:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 8009116:	099b      	lsrs	r3, r3, #6
	temp[1] = t%91 + 33;
 8009118:	225b      	movs	r2, #91	; 0x5b
 800911a:	fb02 8213 	mls	r2, r2, r3, r8
 800911e:	3221      	adds	r2, #33	; 0x21

	ax25_send_byte(&packet, '|');

	// Sequence ID
	uint32_t t = trackPoint->id & 0x1FFF;
	temp[0] = t/91 + 33;
 8009120:	3321      	adds	r3, #33	; 0x21
	temp[1] = t%91 + 33;
	ax25_send_string(&packet, temp);
 8009122:	a91b      	add	r1, sp, #108	; 0x6c
 8009124:	a817      	add	r0, sp, #92	; 0x5c
	ax25_send_byte(&packet, '|');

	// Sequence ID
	uint32_t t = trackPoint->id & 0x1FFF;
	temp[0] = t/91 + 33;
	temp[1] = t%91 + 33;
 8009126:	f88d 206d 	strb.w	r2, [sp, #109]	; 0x6d

	ax25_send_byte(&packet, '|');

	// Sequence ID
	uint32_t t = trackPoint->id & 0x1FFF;
	temp[0] = t/91 + 33;
 800912a:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
	temp[1] = t%91 + 33;
	ax25_send_string(&packet, temp);
 800912e:	f001 faa7 	bl	800a680 <ax25_send_string>
 8009132:	9e12      	ldr	r6, [sp, #72]	; 0x48
 8009134:	9606      	str	r6, [sp, #24]
 8009136:	4635      	mov	r5, r6
 8009138:	9e0f      	ldr	r6, [sp, #60]	; 0x3c

	// Telemetry parameter
	for(uint8_t i=0; i<5; i++) {
		switch(config->tel[i]) {
 800913a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 800913e:	2b0b      	cmp	r3, #11
 8009140:	d836      	bhi.n	80091b0 <modulePOS+0x760>
 8009142:	e8df f013 	tbh	[pc, r3, lsl #1]
 8009146:	00e9      	.short	0x00e9
 8009148:	00e600ec 	.word	0x00e600ec
 800914c:	00fb00fe 	.word	0x00fb00fe
 8009150:	00ef00f8 	.word	0x00ef00f8
 8009154:	00e000e3 	.word	0x00e000e3
 8009158:	00d30101 	.word	0x00d30101
 800915c:	0033      	.short	0x0033
 800915e:	bf00      	nop
 8009160:	00000000 	.word	0x00000000
 8009164:	416312d0 	.word	0x416312d0
 8009168:	00000000 	.word	0x00000000
 800916c:	41173ff8 	.word	0x41173ff8
 8009170:	00000000 	.word	0x00000000
 8009174:	41073ff8 	.word	0x41073ff8
 8009178:	080153f8 	.word	0x080153f8
 800917c:	b21be325 	.word	0xb21be325
 8009180:	000b7fa3 	.word	0x000b7fa3
 8009184:	40568000 	.word	0x40568000
 8009188:	1fa7f4df 	.word	0x1fa7f4df
 800918c:	40668000 	.word	0x40668000
 8009190:	3b02f07e 	.word	0x3b02f07e
 8009194:	68168169 	.word	0x68168169
 8009198:	08015408 	.word	0x08015408
 800919c:	08015410 	.word	0x08015410
 80091a0:	08015414 	.word	0x08015414
 80091a4:	20027878 	.word	0x20027878
 80091a8:	10624dd3 	.word	0x10624dd3
			case TEL_VBAT:		t = trackPoint->adc_battery;		break;
			case TEL_VSOL:		t = trackPoint->adc_solar;			break;
			case TEL_CHARGE:	t = trackPoint->adc_charge;			break;
			case TEL_DISCHARGE:	t = trackPoint->adc_discharge;		break;
			case TEL_IHUM:		t = trackPoint->int_hum;			break;
			case TEL_EHUM:		t = trackPoint->ext_hum;			break;
 80091ac:	f8b9 8034 	ldrh.w	r8, [r9, #52]	; 0x34
			case TEL_EPRESS:	t = trackPoint->ext_press/125 - 40;	break;
			case TEL_ITEMP:		t = trackPoint->int_temp/10 + 1000;	break;
			case TEL_ETEMP:		t = trackPoint->ext_temp/10 + 1000;	break;
		}

		temp[0] = t/91 + 33;
 80091b0:	fba4 2308 	umull	r2, r3, r4, r8
 80091b4:	ebc3 0108 	rsb	r1, r3, r8
 80091b8:	eb03 0351 	add.w	r3, r3, r1, lsr #1
 80091bc:	099b      	lsrs	r3, r3, #6
		temp[1] = t%91 + 33;
 80091be:	205b      	movs	r0, #91	; 0x5b
 80091c0:	fb00 8013 	mls	r0, r0, r3, r8
 80091c4:	3021      	adds	r0, #33	; 0x21
			case TEL_EPRESS:	t = trackPoint->ext_press/125 - 40;	break;
			case TEL_ITEMP:		t = trackPoint->int_temp/10 + 1000;	break;
			case TEL_ETEMP:		t = trackPoint->ext_temp/10 + 1000;	break;
		}

		temp[0] = t/91 + 33;
 80091c6:	3321      	adds	r3, #33	; 0x21
		temp[1] = t%91 + 33;
 80091c8:	f88d 006d 	strb.w	r0, [sp, #109]	; 0x6d
		ax25_send_string(&packet, temp);
 80091cc:	a91b      	add	r1, sp, #108	; 0x6c
 80091ce:	a817      	add	r0, sp, #92	; 0x5c
			case TEL_EPRESS:	t = trackPoint->ext_press/125 - 40;	break;
			case TEL_ITEMP:		t = trackPoint->int_temp/10 + 1000;	break;
			case TEL_ETEMP:		t = trackPoint->ext_temp/10 + 1000;	break;
		}

		temp[0] = t/91 + 33;
 80091d0:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
		temp[1] = t%91 + 33;
		ax25_send_string(&packet, temp);
 80091d4:	f001 fa54 	bl	800a680 <ax25_send_string>
	temp[0] = t/91 + 33;
	temp[1] = t%91 + 33;
	ax25_send_string(&packet, temp);

	// Telemetry parameter
	for(uint8_t i=0; i<5; i++) {
 80091d8:	42ae      	cmp	r6, r5
 80091da:	d1ae      	bne.n	800913a <modulePOS+0x6ea>
 80091dc:	217c      	movs	r1, #124	; 0x7c
 80091de:	a817      	add	r0, sp, #92	; 0x5c
 80091e0:	9d06      	ldr	r5, [sp, #24]
 80091e2:	f001 f9bd 	bl	800a560 <send_byte.lto_priv.112>
		ax25_send_string(&packet, temp);
	}

	ax25_send_byte(&packet, '|');

	ax25_send_footer(&packet);
 80091e6:	a817      	add	r0, sp, #92	; 0x5c
 80091e8:	f001 fa0a 	bl	800a600 <ax25_send_footer>
	scramble(&packet);
 80091ec:	a817      	add	r0, sp, #92	; 0x5c
 80091ee:	f001 f947 	bl	800a480 <scramble>
	nrzi_encode(&packet);
 80091f2:	a817      	add	r0, sp, #92	; 0x5c
 80091f4:	f001 f914 	bl	800a420 <nrzi_encode>

	return packet.size;
 80091f8:	f8bd 3064 	ldrh.w	r3, [sp, #100]	; 0x64
					msg.gfsk_config = &(config->gfsk_config);
					msg.afsk_config = &(config->afsk_config);

					msg.bin_len = aprs_encode_position(msg.msg, msg.mod, &(config->aprs_config), trackPoint); // Encode packet
 80091fc:	93db      	str	r3, [sp, #876]	; 0x36c
					transmitOnRadio(&msg);
 80091fe:	a85b      	add	r0, sp, #364	; 0x16c
 8009200:	f008 f9b6 	bl	8011570 <transmitOnRadio>

					// Telemetry encoding parameter transmission
					if(config->aprs_config.tel_encoding)
 8009204:	9a03      	ldr	r2, [sp, #12]
 8009206:	f892 3083 	ldrb.w	r3, [r2, #131]	; 0x83
 800920a:	2b00      	cmp	r3, #0
 800920c:	f43f ac98 	beq.w	8008b40 <modulePOS+0xf0>
 8009210:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
					{
						// Telemetry encoding parameter transmission trigger
						if(last_config_transmission + S2ST(config->aprs_config.tel_encoding_cycle) < chVTGetSystemTimeX() && current_config_count >= 4)
 8009214:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
 8009218:	9814      	ldr	r0, [sp, #80]	; 0x50
 800921a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800921c:	f644 6420 	movw	r4, #20000	; 0x4e20
 8009220:	fb04 0402 	mla	r4, r4, r2, r0
 8009224:	42a3      	cmp	r3, r4
 8009226:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8009228:	f240 8481 	bls.w	8009b2e <modulePOS+0x10de>
 800922c:	2b03      	cmp	r3, #3
 800922e:	f200 84db 	bhi.w	8009be8 <modulePOS+0x1198>
 8009232:	4604      	mov	r4, r0
						}

						// Actual transmission (each cycle a different config type will be sent)
						if(config->aprs_config.tel_encoding && current_config_count < 4)
						{
							chThdSleepMilliseconds(5000); // Take a litte break between the package transmissions
 8009234:	48c3      	ldr	r0, [pc, #780]	; (8009544 <modulePOS+0xaf4>)
 8009236:	f005 ff2b 	bl	800f090 <chThdSleep>

							const telemetry_config_t tel_config[] = {CONFIG_PARM, CONFIG_UNIT, CONFIG_EQNS, CONFIG_BITS};
 800923a:	4bc3      	ldr	r3, [pc, #780]	; (8009548 <modulePOS+0xaf8>)
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble); // Header
 800923c:	9f03      	ldr	r7, [sp, #12]
 800923e:	6818      	ldr	r0, [r3, #0]
 8009240:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 8009244:	f8b7 307c 	ldrh.w	r3, [r7, #124]	; 0x7c
 8009248:	9016      	str	r0, [sp, #88]	; 0x58
							msg.bin_len = aprs_encode_telemetry_configuration(msg.msg, msg.mod, &(config->aprs_config), tel_config[current_config_count]); // Encode packet
 800924a:	f10d 0e58 	add.w	lr, sp, #88	; 0x58
 800924e:	f89d 0375 	ldrb.w	r0, [sp, #885]	; 0x375
 8009252:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 8009254:	f897 2068 	ldrb.w	r2, [r7, #104]	; 0x68
{
	char temp[4];
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;
 8009258:	f88d 007a 	strb.w	r0, [sp, #122]	; 0x7a
 */
uint32_t aprs_encode_telemetry_configuration(uint8_t* message, mod_t mod, const aprs_config_t *config, const telemetry_config_t type)
{
	char temp[4];
	ax25_t packet;
	packet.data = message;
 800925c:	a95b      	add	r1, sp, #364	; 0x16c
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble); // Header
 800925e:	9300      	str	r3, [sp, #0]
 */
uint32_t aprs_encode_telemetry_configuration(uint8_t* message, mod_t mod, const aprs_config_t *config, const telemetry_config_t type)
{
	char temp[4];
	ax25_t packet;
	packet.data = message;
 8009260:	911c      	str	r1, [sp, #112]	; 0x70
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble); // Header
 8009262:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8009264:	f81e 6006 	ldrb.w	r6, [lr, r6]
uint32_t aprs_encode_telemetry_configuration(uint8_t* message, mod_t mod, const aprs_config_t *config, const telemetry_config_t type)
{
	char temp[4];
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 8009268:	f44f 7700 	mov.w	r7, #512	; 0x200
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble); // Header
 800926c:	4641      	mov	r1, r8
 800926e:	a81b      	add	r0, sp, #108	; 0x6c
uint32_t aprs_encode_telemetry_configuration(uint8_t* message, mod_t mod, const aprs_config_t *config, const telemetry_config_t type)
{
	char temp[4];
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 8009270:	f8ad 7076 	strh.w	r7, [sp, #118]	; 0x76
	packet.mod = mod;

	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble); // Header
 8009274:	f004 fe64 	bl	800df40 <ax25_send_header.constprop.16>
 8009278:	213a      	movs	r1, #58	; 0x3a
 800927a:	a81b      	add	r0, sp, #108	; 0x6c
 800927c:	f001 f970 	bl	800a560 <send_byte.lto_priv.112>
	ax25_send_byte(&packet, ':'); // Message flag

	// Callsign
	ax25_send_string(&packet, config->callsign);
 8009280:	4641      	mov	r1, r8
 8009282:	a81b      	add	r0, sp, #108	; 0x6c
 8009284:	f001 f9fc 	bl	800a680 <ax25_send_string>
 8009288:	212d      	movs	r1, #45	; 0x2d
 800928a:	a81b      	add	r0, sp, #108	; 0x6c
 800928c:	f001 f968 	bl	800a560 <send_byte.lto_priv.112>
	ax25_send_byte(&packet, '-');
	chsnprintf(temp, sizeof(temp), "%d", config->ssid);
 8009290:	9f03      	ldr	r7, [sp, #12]
 8009292:	4aae      	ldr	r2, [pc, #696]	; (800954c <modulePOS+0xafc>)
 8009294:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 8009298:	2104      	movs	r1, #4
 800929a:	a817      	add	r0, sp, #92	; 0x5c
 800929c:	f002 ffc8 	bl	800c230 <chsnprintf>
	ax25_send_string(&packet, temp);
 80092a0:	a917      	add	r1, sp, #92	; 0x5c
 80092a2:	a81b      	add	r0, sp, #108	; 0x6c
 80092a4:	f001 f9ec 	bl	800a680 <ax25_send_string>

	// Padding
	uint8_t length = strlen(config->callsign) + (config->ssid/10);
 80092a8:	4640      	mov	r0, r8
 80092aa:	f7f8 fc01 	bl	8001ab0 <strlen>
 80092ae:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
 80092b2:	4aa7      	ldr	r2, [pc, #668]	; (8009550 <modulePOS+0xb00>)
 80092b4:	fba2 2303 	umull	r2, r3, r2, r3
 80092b8:	eb00 00d3 	add.w	r0, r0, r3, lsr #3
 80092bc:	b2c7      	uxtb	r7, r0
	for(uint8_t i=length; i<7; i++)
 80092be:	2f06      	cmp	r7, #6
 80092c0:	d807      	bhi.n	80092d2 <modulePOS+0x882>
 80092c2:	3701      	adds	r7, #1
		ax25_send_string(&packet, " ");
 80092c4:	49a3      	ldr	r1, [pc, #652]	; (8009554 <modulePOS+0xb04>)
 80092c6:	a81b      	add	r0, sp, #108	; 0x6c
	chsnprintf(temp, sizeof(temp), "%d", config->ssid);
	ax25_send_string(&packet, temp);

	// Padding
	uint8_t length = strlen(config->callsign) + (config->ssid/10);
	for(uint8_t i=length; i<7; i++)
 80092c8:	b2ff      	uxtb	r7, r7
		ax25_send_string(&packet, " ");
 80092ca:	f001 f9d9 	bl	800a680 <ax25_send_string>
	chsnprintf(temp, sizeof(temp), "%d", config->ssid);
	ax25_send_string(&packet, temp);

	// Padding
	uint8_t length = strlen(config->callsign) + (config->ssid/10);
	for(uint8_t i=length; i<7; i++)
 80092ce:	2f07      	cmp	r7, #7
 80092d0:	d1f7      	bne.n	80092c2 <modulePOS+0x872>
		ax25_send_string(&packet, " ");

	ax25_send_string(&packet, ":"); // Message separator
 80092d2:	49a1      	ldr	r1, [pc, #644]	; (8009558 <modulePOS+0xb08>)
 80092d4:	a81b      	add	r0, sp, #108	; 0x6c
 80092d6:	f001 f9d3 	bl	800a680 <ax25_send_string>

	switch(type) {
 80092da:	2e03      	cmp	r6, #3
 80092dc:	f200 8304 	bhi.w	80098e8 <modulePOS+0xe98>
 80092e0:	e8df f016 	tbh	[pc, r6, lsl #1]
 80092e4:	03270338 	.word	0x03270338
 80092e8:	02fa0317 	.word	0x02fa0317
			case TEL_IHUM:		t = trackPoint->int_hum;			break;
			case TEL_EHUM:		t = trackPoint->ext_hum;			break;
			case TEL_IPRESS:	t = trackPoint->int_press/125 - 40;	break;
			case TEL_EPRESS:	t = trackPoint->ext_press/125 - 40;	break;
			case TEL_ITEMP:		t = trackPoint->int_temp/10 + 1000;	break;
			case TEL_ETEMP:		t = trackPoint->ext_temp/10 + 1000;	break;
 80092ec:	f9b9 3036 	ldrsh.w	r3, [r9, #54]	; 0x36
 80092f0:	4a9a      	ldr	r2, [pc, #616]	; (800955c <modulePOS+0xb0c>)
 80092f2:	fb82 2803 	smull	r2, r8, r2, r3
 80092f6:	17db      	asrs	r3, r3, #31
 80092f8:	ebc3 08a8 	rsb	r8, r3, r8, asr #2
 80092fc:	fa0f f888 	sxth.w	r8, r8
 8009300:	f508 787a 	add.w	r8, r8, #1000	; 0x3e8
 8009304:	e754      	b.n	80091b0 <modulePOS+0x760>
			case TEL_TTFF:		t = trackPoint->gps_ttff;			break;
			case TEL_VBAT:		t = trackPoint->adc_battery;		break;
			case TEL_VSOL:		t = trackPoint->adc_solar;			break;
			case TEL_CHARGE:	t = trackPoint->adc_charge;			break;
			case TEL_DISCHARGE:	t = trackPoint->adc_discharge;		break;
			case TEL_IHUM:		t = trackPoint->int_hum;			break;
 8009306:	f8b9 802c 	ldrh.w	r8, [r9, #44]	; 0x2c
 800930a:	e751      	b.n	80091b0 <modulePOS+0x760>
			case TEL_EHUM:		t = trackPoint->ext_hum;			break;
			case TEL_IPRESS:	t = trackPoint->int_press/125 - 40;	break;
			case TEL_EPRESS:	t = trackPoint->ext_press/125 - 40;	break;
			case TEL_ITEMP:		t = trackPoint->int_temp/10 + 1000;	break;
 800930c:	f9b9 302e 	ldrsh.w	r3, [r9, #46]	; 0x2e
 8009310:	e7ee      	b.n	80092f0 <modulePOS+0x8a0>
	// Telemetry parameter
	for(uint8_t i=0; i<5; i++) {
		switch(config->tel[i]) {
			case TEL_SATS:		t = trackPoint->gps_sats;			break;
			case TEL_TTFF:		t = trackPoint->gps_ttff;			break;
			case TEL_VBAT:		t = trackPoint->adc_battery;		break;
 8009312:	f8b9 8020 	ldrh.w	r8, [r9, #32]
 8009316:	e74b      	b.n	80091b0 <modulePOS+0x760>
	ax25_send_string(&packet, temp);

	// Telemetry parameter
	for(uint8_t i=0; i<5; i++) {
		switch(config->tel[i]) {
			case TEL_SATS:		t = trackPoint->gps_sats;			break;
 8009318:	f899 801c 	ldrb.w	r8, [r9, #28]
 800931c:	e748      	b.n	80091b0 <modulePOS+0x760>
			case TEL_TTFF:		t = trackPoint->gps_ttff;			break;
 800931e:	f899 801d 	ldrb.w	r8, [r9, #29]
 8009322:	e745      	b.n	80091b0 <modulePOS+0x760>
			case TEL_VSOL:		t = trackPoint->adc_solar;			break;
			case TEL_CHARGE:	t = trackPoint->adc_charge;			break;
			case TEL_DISCHARGE:	t = trackPoint->adc_discharge;		break;
			case TEL_IHUM:		t = trackPoint->int_hum;			break;
			case TEL_EHUM:		t = trackPoint->ext_hum;			break;
			case TEL_IPRESS:	t = trackPoint->int_press/125 - 40;	break;
 8009324:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
 8009328:	fba7 3803 	umull	r3, r8, r7, r3
 800932c:	ea4f 08d8 	mov.w	r8, r8, lsr #3
 8009330:	f1a8 0828 	sub.w	r8, r8, #40	; 0x28
 8009334:	e73c      	b.n	80091b0 <modulePOS+0x760>
			case TEL_SATS:		t = trackPoint->gps_sats;			break;
			case TEL_TTFF:		t = trackPoint->gps_ttff;			break;
			case TEL_VBAT:		t = trackPoint->adc_battery;		break;
			case TEL_VSOL:		t = trackPoint->adc_solar;			break;
			case TEL_CHARGE:	t = trackPoint->adc_charge;			break;
			case TEL_DISCHARGE:	t = trackPoint->adc_discharge;		break;
 8009336:	f9b9 8024 	ldrsh.w	r8, [r9, #36]	; 0x24
 800933a:	e739      	b.n	80091b0 <modulePOS+0x760>
		switch(config->tel[i]) {
			case TEL_SATS:		t = trackPoint->gps_sats;			break;
			case TEL_TTFF:		t = trackPoint->gps_ttff;			break;
			case TEL_VBAT:		t = trackPoint->adc_battery;		break;
			case TEL_VSOL:		t = trackPoint->adc_solar;			break;
			case TEL_CHARGE:	t = trackPoint->adc_charge;			break;
 800933c:	f9b9 8022 	ldrsh.w	r8, [r9, #34]	; 0x22
 8009340:	e736      	b.n	80091b0 <modulePOS+0x760>
	for(uint8_t i=0; i<5; i++) {
		switch(config->tel[i]) {
			case TEL_SATS:		t = trackPoint->gps_sats;			break;
			case TEL_TTFF:		t = trackPoint->gps_ttff;			break;
			case TEL_VBAT:		t = trackPoint->adc_battery;		break;
			case TEL_VSOL:		t = trackPoint->adc_solar;			break;
 8009342:	f8b9 801e 	ldrh.w	r8, [r9, #30]
 8009346:	e733      	b.n	80091b0 <modulePOS+0x760>
			case TEL_CHARGE:	t = trackPoint->adc_charge;			break;
			case TEL_DISCHARGE:	t = trackPoint->adc_discharge;		break;
			case TEL_IHUM:		t = trackPoint->int_hum;			break;
			case TEL_EHUM:		t = trackPoint->ext_hum;			break;
			case TEL_IPRESS:	t = trackPoint->int_press/125 - 40;	break;
			case TEL_EPRESS:	t = trackPoint->ext_press/125 - 40;	break;
 8009348:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
 800934c:	fba7 3803 	umull	r3, r8, r7, r3
 8009350:	ea4f 08d8 	mov.w	r8, r8, lsr #3
 8009354:	f1a8 0828 	sub.w	r8, r8, #40	; 0x28
 8009358:	e72a      	b.n	80091b0 <modulePOS+0x760>
			dah();
			dit();
			dit();
		break;
		case '9':
			dah();
 800935a:	f001 f831 	bl	800a3c0 <dah>
			dah();
 800935e:	f001 f82f 	bl	800a3c0 <dah>
			dah();
 8009362:	f001 f82d 	bl	800a3c0 <dah>
			dah();
 8009366:	f001 f82b 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800936a:	f8da 3000 	ldr.w	r3, [sl]
 800936e:	4a7c      	ldr	r2, [pc, #496]	; (8009560 <modulePOS+0xb10>)
 8009370:	08d8      	lsrs	r0, r3, #3
 8009372:	6816      	ldr	r6, [r2, #0]
 8009374:	f003 0107 	and.w	r1, r3, #7
 8009378:	5c32      	ldrb	r2, [r6, r0]
 800937a:	fa04 f101 	lsl.w	r1, r4, r1
 800937e:	430a      	orrs	r2, r1
 8009380:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 8009382:	3302      	adds	r3, #2
		data[i] = 0;

	// Encode morse
	buffer = data; // Buffer
	c = 0; // Bitlength
	for(uint32_t i=0; letter[i]!=0; i++)
 8009384:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8009388:	3304      	adds	r3, #4
 800938a:	f8ca 3000 	str.w	r3, [sl]
 800938e:	2900      	cmp	r1, #0
 8009390:	f47f acea 	bne.w	8008d68 <modulePOS+0x318>
					replace_placeholders(morse, sizeof(morse), trackPoint);
					str_replace(morse, sizeof(morse), "<CALL>", config->morse_config.callsign);

					// Transmit message
					msg.bin_len = morse_encode(msg.msg, morse); // Convert message to binary stream
					transmitOnRadio(&msg);
 8009394:	a85b      	add	r0, sp, #364	; 0x16c
					memcpy(morse, config->morse_config.format, sizeof(config->morse_config.format));
					replace_placeholders(morse, sizeof(morse), trackPoint);
					str_replace(morse, sizeof(morse), "<CALL>", config->morse_config.callsign);

					// Transmit message
					msg.bin_len = morse_encode(msg.msg, morse); // Convert message to binary stream
 8009396:	93db      	str	r3, [sp, #876]	; 0x36c
					transmitOnRadio(&msg);
 8009398:	f008 f8ea 	bl	8011570 <transmitOnRadio>
 800939c:	f7ff bbd0 	b.w	8008b40 <modulePOS+0xf0>
			dit();
			dit();
			dah();
		break;
		case 'Y':
			dah();
 80093a0:	f001 f80e 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80093a4:	f8da 3000 	ldr.w	r3, [sl]
 80093a8:	4a6d      	ldr	r2, [pc, #436]	; (8009560 <modulePOS+0xb10>)
 80093aa:	08d8      	lsrs	r0, r3, #3
 80093ac:	6816      	ldr	r6, [r2, #0]
 80093ae:	f003 0107 	and.w	r1, r3, #7
 80093b2:	5c32      	ldrb	r2, [r6, r0]
 80093b4:	fa04 f101 	lsl.w	r1, r4, r1
 80093b8:	430a      	orrs	r2, r1
	ADDB(0);
 80093ba:	3302      	adds	r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80093bc:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 80093be:	f8ca 3000 	str.w	r3, [sl]
			dah();
		break;
		case 'Y':
			dah();
			dit();
			dah();
 80093c2:	f000 fffd 	bl	800a3c0 <dah>
			dah();
 80093c6:	f000 fffb 	bl	800a3c0 <dah>
 80093ca:	f8da 3000 	ldr.w	r3, [sl]
 80093ce:	e7d9      	b.n	8009384 <modulePOS+0x934>
			dit();
			dit();
			dit();
		break;
		case '8':
			dah();
 80093d0:	f000 fff6 	bl	800a3c0 <dah>
			dah();
 80093d4:	f000 fff4 	bl	800a3c0 <dah>
			dah();
 80093d8:	f000 fff2 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80093dc:	f8da 3000 	ldr.w	r3, [sl]
 80093e0:	4a5f      	ldr	r2, [pc, #380]	; (8009560 <modulePOS+0xb10>)
 80093e2:	08de      	lsrs	r6, r3, #3
 80093e4:	6811      	ldr	r1, [r2, #0]
 80093e6:	f003 0007 	and.w	r0, r3, #7
 80093ea:	5d8a      	ldrb	r2, [r1, r6]
 80093ec:	fa04 f000 	lsl.w	r0, r4, r0
 80093f0:	4310      	orrs	r0, r2
	ADDB(0);
 80093f2:	1c9a      	adds	r2, r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80093f4:	5588      	strb	r0, [r1, r6]
 80093f6:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 80093f8:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80093fc:	5d88      	ldrb	r0, [r1, r6]
 80093fe:	f002 0207 	and.w	r2, r2, #7
 8009402:	fa04 f202 	lsl.w	r2, r4, r2
 8009406:	4302      	orrs	r2, r0
	ADDB(0);
 8009408:	3304      	adds	r3, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800940a:	558a      	strb	r2, [r1, r6]
 800940c:	e7ba      	b.n	8009384 <modulePOS+0x934>
			dah();
			dah();
			dit();
		break;
		case 'Q':
			dah();
 800940e:	f000 ffd7 	bl	800a3c0 <dah>
			dah();
 8009412:	f000 ffd5 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009416:	f8da 3000 	ldr.w	r3, [sl]
 800941a:	4a51      	ldr	r2, [pc, #324]	; (8009560 <modulePOS+0xb10>)
 800941c:	08d8      	lsrs	r0, r3, #3
 800941e:	6816      	ldr	r6, [r2, #0]
 8009420:	f003 0107 	and.w	r1, r3, #7
 8009424:	5c32      	ldrb	r2, [r6, r0]
 8009426:	fa04 f101 	lsl.w	r1, r4, r1
 800942a:	430a      	orrs	r2, r1
	ADDB(0);
 800942c:	3302      	adds	r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800942e:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 8009430:	f8ca 3000 	str.w	r3, [sl]
void morse_encode_char(char letter)
{
	switch(letter) {
		case 'A':
			dit();
			dah();
 8009434:	f000 ffc4 	bl	800a3c0 <dah>
 8009438:	f8da 3000 	ldr.w	r3, [sl]
 800943c:	e7a2      	b.n	8009384 <modulePOS+0x934>
			dah();
			dah();
			dit();
		break;
		case '0':
			dah();
 800943e:	f000 ffbf 	bl	800a3c0 <dah>
			dah();
 8009442:	f000 ffbd 	bl	800a3c0 <dah>
			dah();
 8009446:	f000 ffbb 	bl	800a3c0 <dah>
			dah();
		break;
		case 'Y':
			dah();
			dit();
			dah();
 800944a:	f000 ffb9 	bl	800a3c0 <dah>
			dah();
 800944e:	f000 ffb7 	bl	800a3c0 <dah>
 8009452:	f8da 3000 	ldr.w	r3, [sl]
 8009456:	e795      	b.n	8009384 <modulePOS+0x934>
			dit();
			dah();
			dah();
		break;
		case 'X':
			dah();
 8009458:	f000 ffb2 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800945c:	f8da 2000 	ldr.w	r2, [sl]
 8009460:	4b3f      	ldr	r3, [pc, #252]	; (8009560 <modulePOS+0xb10>)
 8009462:	08d6      	lsrs	r6, r2, #3
 8009464:	6819      	ldr	r1, [r3, #0]
 8009466:	f002 0007 	and.w	r0, r2, #7
 800946a:	5d8b      	ldrb	r3, [r1, r6]
 800946c:	fa04 f000 	lsl.w	r0, r4, r0
 8009470:	4318      	orrs	r0, r3
	ADDB(0);
 8009472:	1c93      	adds	r3, r2, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009474:	5588      	strb	r0, [r1, r6]
 8009476:	08de      	lsrs	r6, r3, #3
	ADDB(0);
 8009478:	f8ca 3000 	str.w	r3, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800947c:	5d88      	ldrb	r0, [r1, r6]
 800947e:	f003 0307 	and.w	r3, r3, #7
 8009482:	fa04 f303 	lsl.w	r3, r4, r3
 8009486:	4303      	orrs	r3, r0
 8009488:	558b      	strb	r3, [r1, r6]
	ADDB(0);
 800948a:	3204      	adds	r2, #4
 800948c:	f8ca 2000 	str.w	r2, [sl]
		break;
		case 'X':
			dah();
			dit();
			dit();
			dah();
 8009490:	f000 ff96 	bl	800a3c0 <dah>
 8009494:	f8da 3000 	ldr.w	r3, [sl]
 8009498:	e774      	b.n	8009384 <modulePOS+0x934>
			dit();
			dit();
			dit();
		break;
		case '6':
			dah();
 800949a:	f000 ff91 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800949e:	f8da 3000 	ldr.w	r3, [sl]
 80094a2:	4a2f      	ldr	r2, [pc, #188]	; (8009560 <modulePOS+0xb10>)
 80094a4:	08de      	lsrs	r6, r3, #3
 80094a6:	6812      	ldr	r2, [r2, #0]
 80094a8:	f003 0007 	and.w	r0, r3, #7
 80094ac:	5d91      	ldrb	r1, [r2, r6]
 80094ae:	fa04 f000 	lsl.w	r0, r4, r0
 80094b2:	4308      	orrs	r0, r1
	ADDB(0);
 80094b4:	1c99      	adds	r1, r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80094b6:	5590      	strb	r0, [r2, r6]
 80094b8:	08ce      	lsrs	r6, r1, #3
	ADDB(0);
 80094ba:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80094be:	5d90      	ldrb	r0, [r2, r6]
 80094c0:	f001 0107 	and.w	r1, r1, #7
 80094c4:	fa04 f101 	lsl.w	r1, r4, r1
 80094c8:	4308      	orrs	r0, r1
	ADDB(0);
 80094ca:	1d19      	adds	r1, r3, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80094cc:	5590      	strb	r0, [r2, r6]
 80094ce:	08ce      	lsrs	r6, r1, #3
	ADDB(0);
 80094d0:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80094d4:	5d90      	ldrb	r0, [r2, r6]
 80094d6:	f001 0107 	and.w	r1, r1, #7
 80094da:	fa04 f101 	lsl.w	r1, r4, r1
 80094de:	4308      	orrs	r0, r1
	ADDB(0);
 80094e0:	1d99      	adds	r1, r3, #6
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80094e2:	5590      	strb	r0, [r2, r6]
 80094e4:	08ce      	lsrs	r6, r1, #3
	ADDB(0);
 80094e6:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80094ea:	5d90      	ldrb	r0, [r2, r6]
 80094ec:	f001 0107 	and.w	r1, r1, #7
 80094f0:	fa04 f101 	lsl.w	r1, r4, r1
 80094f4:	4301      	orrs	r1, r0
	ADDB(0);
 80094f6:	3308      	adds	r3, #8
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80094f8:	5591      	strb	r1, [r2, r6]
 80094fa:	e743      	b.n	8009384 <modulePOS+0x934>
 80094fc:	f8da 3000 	ldr.w	r3, [sl]
 8009500:	4a17      	ldr	r2, [pc, #92]	; (8009560 <modulePOS+0xb10>)
 8009502:	08d8      	lsrs	r0, r3, #3
 8009504:	6816      	ldr	r6, [r2, #0]
 8009506:	f003 0107 	and.w	r1, r3, #7
 800950a:	5c32      	ldrb	r2, [r6, r0]
 800950c:	fa04 f101 	lsl.w	r1, r4, r1
 8009510:	430a      	orrs	r2, r1
 8009512:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 8009514:	3302      	adds	r3, #2
 8009516:	f8ca 3000 	str.w	r3, [sl]
		case ' ':
			blank(3);
		break;
		case '.':
			dit();
			dah();
 800951a:	f000 ff51 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800951e:	f8da 3000 	ldr.w	r3, [sl]
 8009522:	4a0f      	ldr	r2, [pc, #60]	; (8009560 <modulePOS+0xb10>)
 8009524:	08d8      	lsrs	r0, r3, #3
 8009526:	6816      	ldr	r6, [r2, #0]
 8009528:	f003 0107 	and.w	r1, r3, #7
 800952c:	5c32      	ldrb	r2, [r6, r0]
 800952e:	fa04 f101 	lsl.w	r1, r4, r1
 8009532:	430a      	orrs	r2, r1
	ADDB(0);
 8009534:	3302      	adds	r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009536:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 8009538:	f8ca 3000 	str.w	r3, [sl]
		break;
		case '.':
			dit();
			dah();
			dit();
			dah();
 800953c:	f000 ff40 	bl	800a3c0 <dah>
 8009540:	e769      	b.n	8009416 <modulePOS+0x9c6>
 8009542:	bf00      	nop
 8009544:	000186a0 	.word	0x000186a0
 8009548:	08013ba0 	.word	0x08013ba0
 800954c:	08015410 	.word	0x08015410
 8009550:	cccccccd 	.word	0xcccccccd
 8009554:	08013d00 	.word	0x08013d00
 8009558:	0801542c 	.word	0x0801542c
 800955c:	66666667 	.word	0x66666667
 8009560:	20027890 	.word	0x20027890
			dit();
			dit();
			dit();
		break;
		case '7':
			dah();
 8009564:	f000 ff2c 	bl	800a3c0 <dah>
			dah();
 8009568:	f000 ff2a 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800956c:	f8da 3000 	ldr.w	r3, [sl]
 8009570:	4ad8      	ldr	r2, [pc, #864]	; (80098d4 <modulePOS+0xe84>)
 8009572:	08de      	lsrs	r6, r3, #3
 8009574:	6811      	ldr	r1, [r2, #0]
 8009576:	f003 0007 	and.w	r0, r3, #7
 800957a:	5d8a      	ldrb	r2, [r1, r6]
 800957c:	fa04 f000 	lsl.w	r0, r4, r0
 8009580:	4310      	orrs	r0, r2
	ADDB(0);
 8009582:	1c9a      	adds	r2, r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009584:	5588      	strb	r0, [r1, r6]
 8009586:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 8009588:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800958c:	5d88      	ldrb	r0, [r1, r6]
 800958e:	f002 0207 	and.w	r2, r2, #7
 8009592:	fa04 f202 	lsl.w	r2, r4, r2
 8009596:	4310      	orrs	r0, r2
	ADDB(0);
 8009598:	1d1a      	adds	r2, r3, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800959a:	5588      	strb	r0, [r1, r6]
 800959c:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 800959e:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80095a2:	5d88      	ldrb	r0, [r1, r6]
 80095a4:	f002 0207 	and.w	r2, r2, #7
 80095a8:	fa04 f202 	lsl.w	r2, r4, r2
 80095ac:	4302      	orrs	r2, r0
	ADDB(0);
 80095ae:	3306      	adds	r3, #6
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80095b0:	558a      	strb	r2, [r1, r6]
 80095b2:	e6e7      	b.n	8009384 <modulePOS+0x934>
			dit();
			dit();
			dit();
		break;
		case 'C':
			dah();
 80095b4:	f000 ff04 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80095b8:	f8da 3000 	ldr.w	r3, [sl]
 80095bc:	4ac5      	ldr	r2, [pc, #788]	; (80098d4 <modulePOS+0xe84>)
 80095be:	08d8      	lsrs	r0, r3, #3
 80095c0:	6816      	ldr	r6, [r2, #0]
 80095c2:	f003 0107 	and.w	r1, r3, #7
 80095c6:	5c32      	ldrb	r2, [r6, r0]
 80095c8:	fa04 f101 	lsl.w	r1, r4, r1
 80095cc:	430a      	orrs	r2, r1
 80095ce:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 80095d0:	3302      	adds	r3, #2
 80095d2:	f8ca 3000 	str.w	r3, [sl]
		break;
		case '9':
			dah();
			dah();
			dah();
			dah();
 80095d6:	f000 fef3 	bl	800a3c0 <dah>
 80095da:	e6c6      	b.n	800936a <modulePOS+0x91a>
 80095dc:	f8da 3000 	ldr.w	r3, [sl]
 80095e0:	3303      	adds	r3, #3
 80095e2:	e6cf      	b.n	8009384 <modulePOS+0x934>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80095e4:	f8da 3000 	ldr.w	r3, [sl]
 80095e8:	4aba      	ldr	r2, [pc, #744]	; (80098d4 <modulePOS+0xe84>)
 80095ea:	08de      	lsrs	r6, r3, #3
 80095ec:	6811      	ldr	r1, [r2, #0]
 80095ee:	f003 0007 	and.w	r0, r3, #7
 80095f2:	5d8a      	ldrb	r2, [r1, r6]
 80095f4:	fa04 f000 	lsl.w	r0, r4, r0
 80095f8:	4310      	orrs	r0, r2
	ADDB(0);
 80095fa:	1c9a      	adds	r2, r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80095fc:	5588      	strb	r0, [r1, r6]
 80095fe:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 8009600:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009604:	5d88      	ldrb	r0, [r1, r6]
 8009606:	f002 0207 	and.w	r2, r2, #7
 800960a:	fa04 f202 	lsl.w	r2, r4, r2
 800960e:	4310      	orrs	r0, r2
	ADDB(0);
 8009610:	1d1a      	adds	r2, r3, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009612:	5588      	strb	r0, [r1, r6]
 8009614:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 8009616:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800961a:	5d88      	ldrb	r0, [r1, r6]
 800961c:	f002 0207 	and.w	r2, r2, #7
 8009620:	fa04 f202 	lsl.w	r2, r4, r2
 8009624:	4302      	orrs	r2, r0
	ADDB(0);
 8009626:	3306      	adds	r3, #6
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009628:	558a      	strb	r2, [r1, r6]
	ADDB(0);
 800962a:	f8ca 3000 	str.w	r3, [sl]
		break;
		case 'V':
			dit();
			dit();
			dit();
			dah();
 800962e:	f000 fec7 	bl	800a3c0 <dah>
 8009632:	f8da 3000 	ldr.w	r3, [sl]
 8009636:	e6a5      	b.n	8009384 <modulePOS+0x934>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009638:	f8da 2000 	ldr.w	r2, [sl]
 800963c:	4ba5      	ldr	r3, [pc, #660]	; (80098d4 <modulePOS+0xe84>)
 800963e:	08d6      	lsrs	r6, r2, #3
 8009640:	6819      	ldr	r1, [r3, #0]
 8009642:	f002 0007 	and.w	r0, r2, #7
 8009646:	5d8b      	ldrb	r3, [r1, r6]
 8009648:	fa04 f000 	lsl.w	r0, r4, r0
 800964c:	4318      	orrs	r0, r3
	ADDB(0);
 800964e:	1c93      	adds	r3, r2, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009650:	5588      	strb	r0, [r1, r6]
 8009652:	08de      	lsrs	r6, r3, #3
	ADDB(0);
 8009654:	f8ca 3000 	str.w	r3, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009658:	5d88      	ldrb	r0, [r1, r6]
 800965a:	f003 0307 	and.w	r3, r3, #7
 800965e:	fa04 f303 	lsl.w	r3, r4, r3
 8009662:	4303      	orrs	r3, r0
	ADDB(0);
 8009664:	3204      	adds	r2, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009666:	558b      	strb	r3, [r1, r6]
	ADDB(0);
 8009668:	f8ca 2000 	str.w	r2, [sl]
		break;
		case '9':
			dah();
			dah();
			dah();
			dah();
 800966c:	f000 fea8 	bl	800a3c0 <dah>
 8009670:	e67b      	b.n	800936a <modulePOS+0x91a>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009672:	f8da 3000 	ldr.w	r3, [sl]
 8009676:	4a97      	ldr	r2, [pc, #604]	; (80098d4 <modulePOS+0xe84>)
 8009678:	08d8      	lsrs	r0, r3, #3
 800967a:	6816      	ldr	r6, [r2, #0]
 800967c:	f003 0107 	and.w	r1, r3, #7
 8009680:	5c32      	ldrb	r2, [r6, r0]
 8009682:	fa04 f101 	lsl.w	r1, r4, r1
 8009686:	430a      	orrs	r2, r1
 8009688:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 800968a:	3302      	adds	r3, #2
 800968c:	f8ca 3000 	str.w	r3, [sl]
			dit();
		break;
		case '8':
			dah();
			dah();
			dah();
 8009690:	f000 fe96 	bl	800a3c0 <dah>
 8009694:	e6a2      	b.n	80093dc <modulePOS+0x98c>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009696:	f8da 3000 	ldr.w	r3, [sl]
 800969a:	4a8e      	ldr	r2, [pc, #568]	; (80098d4 <modulePOS+0xe84>)
 800969c:	08d8      	lsrs	r0, r3, #3
 800969e:	6816      	ldr	r6, [r2, #0]
 80096a0:	f003 0107 	and.w	r1, r3, #7
 80096a4:	5c32      	ldrb	r2, [r6, r0]
 80096a6:	fa04 f101 	lsl.w	r1, r4, r1
 80096aa:	430a      	orrs	r2, r1
	ADDB(0);
 80096ac:	3302      	adds	r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80096ae:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 80096b0:	f8ca 3000 	str.w	r3, [sl]
			dit();
			dit();
		break;
		case 'J':
			dit();
			dah();
 80096b4:	f000 fe84 	bl	800a3c0 <dah>
			dah();
 80096b8:	f000 fe82 	bl	800a3c0 <dah>
			dah();
 80096bc:	f000 fe80 	bl	800a3c0 <dah>
 80096c0:	f8da 3000 	ldr.w	r3, [sl]
 80096c4:	e65e      	b.n	8009384 <modulePOS+0x934>
		case 'A':
			dit();
			dah();
		break;
		case 'B':
			dah();
 80096c6:	f000 fe7b 	bl	800a3c0 <dah>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80096ca:	f8da 3000 	ldr.w	r3, [sl]
 80096ce:	4a81      	ldr	r2, [pc, #516]	; (80098d4 <modulePOS+0xe84>)
 80096d0:	08de      	lsrs	r6, r3, #3
 80096d2:	6811      	ldr	r1, [r2, #0]
 80096d4:	f003 0007 	and.w	r0, r3, #7
 80096d8:	5d8a      	ldrb	r2, [r1, r6]
 80096da:	fa04 f000 	lsl.w	r0, r4, r0
 80096de:	4310      	orrs	r0, r2
	ADDB(0);
 80096e0:	1c9a      	adds	r2, r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80096e2:	5588      	strb	r0, [r1, r6]
 80096e4:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 80096e6:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80096ea:	5d88      	ldrb	r0, [r1, r6]
 80096ec:	f002 0207 	and.w	r2, r2, #7
 80096f0:	fa04 f202 	lsl.w	r2, r4, r2
 80096f4:	4310      	orrs	r0, r2
	ADDB(0);
 80096f6:	1d1a      	adds	r2, r3, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80096f8:	5588      	strb	r0, [r1, r6]
 80096fa:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 80096fc:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009700:	5d88      	ldrb	r0, [r1, r6]
 8009702:	f002 0207 	and.w	r2, r2, #7
 8009706:	fa04 f202 	lsl.w	r2, r4, r2
 800970a:	4302      	orrs	r2, r0
 800970c:	558a      	strb	r2, [r1, r6]
	ADDB(0);
 800970e:	3306      	adds	r3, #6
 8009710:	e638      	b.n	8009384 <modulePOS+0x934>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009712:	f8da 3000 	ldr.w	r3, [sl]
 8009716:	4a6f      	ldr	r2, [pc, #444]	; (80098d4 <modulePOS+0xe84>)
 8009718:	08d8      	lsrs	r0, r3, #3
 800971a:	6816      	ldr	r6, [r2, #0]
 800971c:	f003 0107 	and.w	r1, r3, #7
 8009720:	5c32      	ldrb	r2, [r6, r0]
 8009722:	fa04 f101 	lsl.w	r1, r4, r1
 8009726:	430a      	orrs	r2, r1
 8009728:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 800972a:	3302      	adds	r3, #2
 800972c:	f8ca 3000 	str.w	r3, [sl]
			dit();
		break;
		case '9':
			dah();
			dah();
			dah();
 8009730:	f000 fe46 	bl	800a3c0 <dah>
 8009734:	e617      	b.n	8009366 <modulePOS+0x916>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009736:	f8da 3000 	ldr.w	r3, [sl]
 800973a:	4a66      	ldr	r2, [pc, #408]	; (80098d4 <modulePOS+0xe84>)
 800973c:	08df      	lsrs	r7, r3, #3
 800973e:	6812      	ldr	r2, [r2, #0]
 8009740:	f003 0007 	and.w	r0, r3, #7
 8009744:	5dd6      	ldrb	r6, [r2, r7]
 8009746:	fa04 f000 	lsl.w	r0, r4, r0
 800974a:	b240      	sxtb	r0, r0
	ADDB(0);
 800974c:	1c99      	adds	r1, r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800974e:	4306      	orrs	r6, r0
 8009750:	55d6      	strb	r6, [r2, r7]
 8009752:	08cf      	lsrs	r7, r1, #3
	ADDB(0);
 8009754:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009758:	5dd6      	ldrb	r6, [r2, r7]
 800975a:	f001 0107 	and.w	r1, r1, #7
 800975e:	fa04 f101 	lsl.w	r1, r4, r1
 8009762:	430e      	orrs	r6, r1
	ADDB(0);
 8009764:	1d19      	adds	r1, r3, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009766:	55d6      	strb	r6, [r2, r7]
 8009768:	08cf      	lsrs	r7, r1, #3
	ADDB(0);
 800976a:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800976e:	5dd6      	ldrb	r6, [r2, r7]
 8009770:	f001 0107 	and.w	r1, r1, #7
 8009774:	fa04 f101 	lsl.w	r1, r4, r1
 8009778:	430e      	orrs	r6, r1
	ADDB(0);
 800977a:	1d99      	adds	r1, r3, #6
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800977c:	55d6      	strb	r6, [r2, r7]
 800977e:	ea4f 0ed1 	mov.w	lr, r1, lsr #3
	ADDB(0);
 8009782:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009786:	f812 600e 	ldrb.w	r6, [r2, lr]
 800978a:	f001 0107 	and.w	r1, r1, #7
 800978e:	fa04 f101 	lsl.w	r1, r4, r1
 8009792:	4331      	orrs	r1, r6
	ADDB(0);
 8009794:	f103 0708 	add.w	r7, r3, #8
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009798:	f802 100e 	strb.w	r1, [r2, lr]
 800979c:	08fe      	lsrs	r6, r7, #3
	ADDB(0);
 800979e:	f8ca 7000 	str.w	r7, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80097a2:	5d91      	ldrb	r1, [r2, r6]
 80097a4:	4308      	orrs	r0, r1
	ADDB(0);
 80097a6:	330a      	adds	r3, #10
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80097a8:	5590      	strb	r0, [r2, r6]
 80097aa:	e5eb      	b.n	8009384 <modulePOS+0x934>
 80097ac:	f8da 3000 	ldr.w	r3, [sl]
 80097b0:	4a48      	ldr	r2, [pc, #288]	; (80098d4 <modulePOS+0xe84>)
 80097b2:	08de      	lsrs	r6, r3, #3
 80097b4:	6812      	ldr	r2, [r2, #0]
 80097b6:	f003 0007 	and.w	r0, r3, #7
 80097ba:	5d91      	ldrb	r1, [r2, r6]
 80097bc:	fa04 f000 	lsl.w	r0, r4, r0
 80097c0:	4308      	orrs	r0, r1
	ADDB(0);
 80097c2:	1c99      	adds	r1, r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80097c4:	5590      	strb	r0, [r2, r6]
 80097c6:	08ce      	lsrs	r6, r1, #3
	ADDB(0);
 80097c8:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80097cc:	5d90      	ldrb	r0, [r2, r6]
 80097ce:	f001 0107 	and.w	r1, r1, #7
 80097d2:	fa04 f101 	lsl.w	r1, r4, r1
 80097d6:	4308      	orrs	r0, r1
	ADDB(0);
 80097d8:	1d19      	adds	r1, r3, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80097da:	5590      	strb	r0, [r2, r6]
 80097dc:	08ce      	lsrs	r6, r1, #3
	ADDB(0);
 80097de:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80097e2:	5d90      	ldrb	r0, [r2, r6]
 80097e4:	f001 0107 	and.w	r1, r1, #7
 80097e8:	fa04 f101 	lsl.w	r1, r4, r1
 80097ec:	4308      	orrs	r0, r1
	ADDB(0);
 80097ee:	1d99      	adds	r1, r3, #6
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80097f0:	5590      	strb	r0, [r2, r6]
 80097f2:	08ce      	lsrs	r6, r1, #3
	ADDB(0);
 80097f4:	f8ca 1000 	str.w	r1, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80097f8:	5d90      	ldrb	r0, [r2, r6]
 80097fa:	f001 0107 	and.w	r1, r1, #7
 80097fe:	fa04 f101 	lsl.w	r1, r4, r1
 8009802:	4301      	orrs	r1, r0
	ADDB(0);
 8009804:	3308      	adds	r3, #8
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009806:	5591      	strb	r1, [r2, r6]
	ADDB(0);
 8009808:	f8ca 3000 	str.w	r3, [sl]
		case '4':
			dit();
			dit();
			dit();
			dit();
			dah();
 800980c:	f000 fdd8 	bl	800a3c0 <dah>
 8009810:	f8da 3000 	ldr.w	r3, [sl]
 8009814:	e5b6      	b.n	8009384 <modulePOS+0x934>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009816:	f8da 3000 	ldr.w	r3, [sl]
 800981a:	4a2e      	ldr	r2, [pc, #184]	; (80098d4 <modulePOS+0xe84>)
 800981c:	08de      	lsrs	r6, r3, #3
 800981e:	6811      	ldr	r1, [r2, #0]
 8009820:	f003 0007 	and.w	r0, r3, #7
 8009824:	5d8a      	ldrb	r2, [r1, r6]
 8009826:	fa04 f000 	lsl.w	r0, r4, r0
 800982a:	4310      	orrs	r0, r2
	ADDB(0);
 800982c:	1c9a      	adds	r2, r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800982e:	5588      	strb	r0, [r1, r6]
 8009830:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 8009832:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009836:	5d88      	ldrb	r0, [r1, r6]
 8009838:	f002 0207 	and.w	r2, r2, #7
 800983c:	fa04 f202 	lsl.w	r2, r4, r2
 8009840:	4310      	orrs	r0, r2
	ADDB(0);
 8009842:	1d1a      	adds	r2, r3, #4
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009844:	5588      	strb	r0, [r1, r6]
 8009846:	08d6      	lsrs	r6, r2, #3
	ADDB(0);
 8009848:	f8ca 2000 	str.w	r2, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800984c:	5d88      	ldrb	r0, [r1, r6]
 800984e:	f002 0207 	and.w	r2, r2, #7
 8009852:	fa04 f202 	lsl.w	r2, r4, r2
 8009856:	4302      	orrs	r2, r0
	ADDB(0);
 8009858:	3306      	adds	r3, #6
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800985a:	558a      	strb	r2, [r1, r6]
	ADDB(0);
 800985c:	f8ca 3000 	str.w	r3, [sl]
		break;
		case '3':
			dit();
			dit();
			dit();
			dah();
 8009860:	f000 fdae 	bl	800a3c0 <dah>
			dah();
 8009864:	f000 fdac 	bl	800a3c0 <dah>
 8009868:	f8da 3000 	ldr.w	r3, [sl]
 800986c:	e58a      	b.n	8009384 <modulePOS+0x934>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800986e:	f8da 2000 	ldr.w	r2, [sl]
 8009872:	4b18      	ldr	r3, [pc, #96]	; (80098d4 <modulePOS+0xe84>)
 8009874:	08d6      	lsrs	r6, r2, #3
 8009876:	6819      	ldr	r1, [r3, #0]
 8009878:	f002 0007 	and.w	r0, r2, #7
 800987c:	5d8b      	ldrb	r3, [r1, r6]
 800987e:	fa04 f000 	lsl.w	r0, r4, r0
 8009882:	4318      	orrs	r0, r3
	ADDB(0);
 8009884:	1c93      	adds	r3, r2, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 8009886:	5588      	strb	r0, [r1, r6]
 8009888:	08de      	lsrs	r6, r3, #3
	ADDB(0);
 800988a:	f8ca 3000 	str.w	r3, [sl]
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 800988e:	5d88      	ldrb	r0, [r1, r6]
 8009890:	f003 0307 	and.w	r3, r3, #7
 8009894:	fa04 f303 	lsl.w	r3, r4, r3
 8009898:	4303      	orrs	r3, r0
 800989a:	558b      	strb	r3, [r1, r6]
	ADDB(0);
 800989c:	3204      	adds	r2, #4
 800989e:	f8ca 2000 	str.w	r2, [sl]
			dah();
		break;
		case '2':
			dit();
			dit();
			dah();
 80098a2:	f000 fd8d 	bl	800a3c0 <dah>
			dah();
 80098a6:	f000 fd8b 	bl	800a3c0 <dah>
			dah();
 80098aa:	f000 fd89 	bl	800a3c0 <dah>
 80098ae:	f8da 3000 	ldr.w	r3, [sl]
 80098b2:	e567      	b.n	8009384 <modulePOS+0x934>
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80098b4:	f8da 3000 	ldr.w	r3, [sl]
 80098b8:	4a06      	ldr	r2, [pc, #24]	; (80098d4 <modulePOS+0xe84>)
 80098ba:	08d8      	lsrs	r0, r3, #3
 80098bc:	6816      	ldr	r6, [r2, #0]
 80098be:	f003 0107 	and.w	r1, r3, #7
 80098c2:	5c32      	ldrb	r2, [r6, r0]
 80098c4:	fa04 f101 	lsl.w	r1, r4, r1
 80098c8:	430a      	orrs	r2, r1
	ADDB(0);
 80098ca:	3302      	adds	r3, #2
	ADDB(1);
	ADDB(0);
}
void dit(void)
{
	ADDB(1);
 80098cc:	5432      	strb	r2, [r6, r0]
	ADDB(0);
 80098ce:	f8ca 3000 	str.w	r3, [sl]
 80098d2:	e5b6      	b.n	8009442 <modulePOS+0x9f2>
 80098d4:	20027890 	.word	0x20027890
			}

			break;

		case CONFIG_BITS:
			ax25_send_string(&packet, "BITS.11111111,");
 80098d8:	4998      	ldr	r1, [pc, #608]	; (8009b3c <modulePOS+0x10ec>)
 80098da:	a81b      	add	r0, sp, #108	; 0x6c
 80098dc:	f000 fed0 	bl	800a680 <ax25_send_string>
			ax25_send_string(&packet, config->tel_comment);
 80098e0:	9915      	ldr	r1, [sp, #84]	; 0x54
 80098e2:	a81b      	add	r0, sp, #108	; 0x6c
 80098e4:	f000 fecc 	bl	800a680 <ax25_send_string>
			break;
	}

	ax25_send_footer(&packet); // Footer
 80098e8:	a81b      	add	r0, sp, #108	; 0x6c
 80098ea:	f000 fe89 	bl	800a600 <ax25_send_footer>
	scramble(&packet);
 80098ee:	a81b      	add	r0, sp, #108	; 0x6c
 80098f0:	f000 fdc6 	bl	800a480 <scramble>
	nrzi_encode(&packet);
 80098f4:	a81b      	add	r0, sp, #108	; 0x6c
 80098f6:	f000 fd93 	bl	800a420 <nrzi_encode>
	
	return packet.size;
 80098fa:	f8bd 3074 	ldrh.w	r3, [sp, #116]	; 0x74
						if(config->aprs_config.tel_encoding && current_config_count < 4)
						{
							chThdSleepMilliseconds(5000); // Take a litte break between the package transmissions

							const telemetry_config_t tel_config[] = {CONFIG_PARM, CONFIG_UNIT, CONFIG_EQNS, CONFIG_BITS};
							msg.bin_len = aprs_encode_telemetry_configuration(msg.msg, msg.mod, &(config->aprs_config), tel_config[current_config_count]); // Encode packet
 80098fe:	93db      	str	r3, [sp, #876]	; 0x36c
							transmitOnRadio(&msg);

							current_config_count++;
 8009900:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8009902:	9414      	str	r4, [sp, #80]	; 0x50
 8009904:	3301      	adds	r3, #1
						{
							chThdSleepMilliseconds(5000); // Take a litte break between the package transmissions

							const telemetry_config_t tel_config[] = {CONFIG_PARM, CONFIG_UNIT, CONFIG_EQNS, CONFIG_BITS};
							msg.bin_len = aprs_encode_telemetry_configuration(msg.msg, msg.mod, &(config->aprs_config), tel_config[current_config_count]); // Encode packet
							transmitOnRadio(&msg);
 8009906:	a85b      	add	r0, sp, #364	; 0x16c

							current_config_count++;
 8009908:	9313      	str	r3, [sp, #76]	; 0x4c
						{
							chThdSleepMilliseconds(5000); // Take a litte break between the package transmissions

							const telemetry_config_t tel_config[] = {CONFIG_PARM, CONFIG_UNIT, CONFIG_EQNS, CONFIG_BITS};
							msg.bin_len = aprs_encode_telemetry_configuration(msg.msg, msg.mod, &(config->aprs_config), tel_config[current_config_count]); // Encode packet
							transmitOnRadio(&msg);
 800990a:	f007 fe31 	bl	8011570 <transmitOnRadio>
 800990e:	f7ff b917 	b.w	8008b40 <modulePOS+0xf0>

			break;

		case CONFIG_EQNS: // Telemetry conversion parameters

			ax25_send_string(&packet, "EQNS.");
 8009912:	498b      	ldr	r1, [pc, #556]	; (8009b40 <modulePOS+0x10f0>)
 8009914:	a81b      	add	r0, sp, #108	; 0x6c
 8009916:	f000 feb3 	bl	800a680 <ax25_send_string>

			for(uint8_t i=0; i<5; i++) {
				switch(config->tel[i]) {
 800991a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 800991e:	2b0b      	cmp	r3, #11
 8009920:	d879      	bhi.n	8009a16 <modulePOS+0xfc6>
 8009922:	e8df f003 	tbb	[pc, r3]
 8009926:	8989      	.short	0x8989
 8009928:	8e8e8e8e 	.word	0x8e8e8e8e
 800992c:	84747f84 	.word	0x84747f84
 8009930:	747f      	.short	0x747f

			break;

		case CONFIG_UNIT: // Telemetry units

			ax25_send_string(&packet, "UNIT.");
 8009932:	4984      	ldr	r1, [pc, #528]	; (8009b44 <modulePOS+0x10f4>)
 8009934:	a81b      	add	r0, sp, #108	; 0x6c
 8009936:	f000 fea3 	bl	800a680 <ax25_send_string>

			for(uint8_t i=0; i<5; i++) {
				switch(config->tel[i]) {
 800993a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 800993e:	3b01      	subs	r3, #1
 8009940:	2b0a      	cmp	r3, #10
 8009942:	d854      	bhi.n	80099ee <modulePOS+0xf9e>
 8009944:	e8df f003 	tbb	[pc, r3]
 8009948:	878c8c96 	.word	0x878c8c96
 800994c:	914f8287 	.word	0x914f8287
 8009950:	4f82      	.short	0x4f82
 8009952:	91          	.byte	0x91
 8009953:	00          	.byte	0x00
	ax25_send_string(&packet, ":"); // Message separator

	switch(type) {
		case CONFIG_PARM: // Telemetry parameter names

			ax25_send_string(&packet, "PARM.");
 8009954:	497c      	ldr	r1, [pc, #496]	; (8009b48 <modulePOS+0x10f8>)
 8009956:	a81b      	add	r0, sp, #108	; 0x6c
 8009958:	f000 fe92 	bl	800a680 <ax25_send_string>

			for(uint8_t i=0; i<5; i++) {
				switch(config->tel[i]) {
 800995c:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8009960:	2b0b      	cmp	r3, #11
 8009962:	d80b      	bhi.n	800997c <modulePOS+0xf2c>
 8009964:	e8df f003 	tbb	[pc, r3]
 8009968:	353a494e 	.word	0x353a494e
 800996c:	21262b30 	.word	0x21262b30
 8009970:	0612171c 	.word	0x0612171c
					case TEL_VBAT:		ax25_send_string(&packet, "Battery");			break;
					case TEL_VSOL:		ax25_send_string(&packet, "Solar");				break;
					case TEL_CHARGE:	ax25_send_string(&packet, "Charge");			break;
					case TEL_DISCHARGE:	ax25_send_string(&packet, "Discharge");			break;
					case TEL_IHUM:		ax25_send_string(&packet, "Humidity int");		break;
					case TEL_EHUM:		ax25_send_string(&packet, "Humidity ext");		break;
 8009974:	4975      	ldr	r1, [pc, #468]	; (8009b4c <modulePOS+0x10fc>)
 8009976:	a81b      	add	r0, sp, #108	; 0x6c
 8009978:	f000 fe82 	bl	800a680 <ax25_send_string>
					case TEL_IPRESS:	ax25_send_string(&packet, "Airpressure int");	break;
					case TEL_EPRESS:	ax25_send_string(&packet, "Airpressure ext");	break;
					case TEL_ITEMP:		ax25_send_string(&packet, "Temperature int");	break;
					case TEL_ETEMP:		ax25_send_string(&packet, "Temperature ext");	break;
				}
				if(i < 4)
 800997c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800997e:	42ab      	cmp	r3, r5
 8009980:	d0b2      	beq.n	80098e8 <modulePOS+0xe98>
					ax25_send_string(&packet, ",");
 8009982:	4973      	ldr	r1, [pc, #460]	; (8009b50 <modulePOS+0x1100>)
 8009984:	a81b      	add	r0, sp, #108	; 0x6c
 8009986:	f000 fe7b 	bl	800a680 <ax25_send_string>
 800998a:	e7e7      	b.n	800995c <modulePOS+0xf0c>
					case TEL_IHUM:		ax25_send_string(&packet, "Humidity int");		break;
					case TEL_EHUM:		ax25_send_string(&packet, "Humidity ext");		break;
					case TEL_IPRESS:	ax25_send_string(&packet, "Airpressure int");	break;
					case TEL_EPRESS:	ax25_send_string(&packet, "Airpressure ext");	break;
					case TEL_ITEMP:		ax25_send_string(&packet, "Temperature int");	break;
					case TEL_ETEMP:		ax25_send_string(&packet, "Temperature ext");	break;
 800998c:	4971      	ldr	r1, [pc, #452]	; (8009b54 <modulePOS+0x1104>)
 800998e:	a81b      	add	r0, sp, #108	; 0x6c
 8009990:	f000 fe76 	bl	800a680 <ax25_send_string>
 8009994:	e7f2      	b.n	800997c <modulePOS+0xf2c>
					case TEL_CHARGE:	ax25_send_string(&packet, "Charge");			break;
					case TEL_DISCHARGE:	ax25_send_string(&packet, "Discharge");			break;
					case TEL_IHUM:		ax25_send_string(&packet, "Humidity int");		break;
					case TEL_EHUM:		ax25_send_string(&packet, "Humidity ext");		break;
					case TEL_IPRESS:	ax25_send_string(&packet, "Airpressure int");	break;
					case TEL_EPRESS:	ax25_send_string(&packet, "Airpressure ext");	break;
 8009996:	4970      	ldr	r1, [pc, #448]	; (8009b58 <modulePOS+0x1108>)
 8009998:	a81b      	add	r0, sp, #108	; 0x6c
 800999a:	f000 fe71 	bl	800a680 <ax25_send_string>
 800999e:	e7ed      	b.n	800997c <modulePOS+0xf2c>
					case TEL_TTFF:		ax25_send_string(&packet, "TTFF");				break;
					case TEL_VBAT:		ax25_send_string(&packet, "Battery");			break;
					case TEL_VSOL:		ax25_send_string(&packet, "Solar");				break;
					case TEL_CHARGE:	ax25_send_string(&packet, "Charge");			break;
					case TEL_DISCHARGE:	ax25_send_string(&packet, "Discharge");			break;
					case TEL_IHUM:		ax25_send_string(&packet, "Humidity int");		break;
 80099a0:	496e      	ldr	r1, [pc, #440]	; (8009b5c <modulePOS+0x110c>)
 80099a2:	a81b      	add	r0, sp, #108	; 0x6c
 80099a4:	f000 fe6c 	bl	800a680 <ax25_send_string>
 80099a8:	e7e8      	b.n	800997c <modulePOS+0xf2c>
					case TEL_EHUM:		ax25_send_string(&packet, "Humidity ext");		break;
					case TEL_IPRESS:	ax25_send_string(&packet, "Airpressure int");	break;
					case TEL_EPRESS:	ax25_send_string(&packet, "Airpressure ext");	break;
					case TEL_ITEMP:		ax25_send_string(&packet, "Temperature int");	break;
 80099aa:	496d      	ldr	r1, [pc, #436]	; (8009b60 <modulePOS+0x1110>)
 80099ac:	a81b      	add	r0, sp, #108	; 0x6c
 80099ae:	f000 fe67 	bl	800a680 <ax25_send_string>
 80099b2:	e7e3      	b.n	800997c <modulePOS+0xf2c>
					case TEL_VSOL:		ax25_send_string(&packet, "Solar");				break;
					case TEL_CHARGE:	ax25_send_string(&packet, "Charge");			break;
					case TEL_DISCHARGE:	ax25_send_string(&packet, "Discharge");			break;
					case TEL_IHUM:		ax25_send_string(&packet, "Humidity int");		break;
					case TEL_EHUM:		ax25_send_string(&packet, "Humidity ext");		break;
					case TEL_IPRESS:	ax25_send_string(&packet, "Airpressure int");	break;
 80099b4:	496b      	ldr	r1, [pc, #428]	; (8009b64 <modulePOS+0x1114>)
 80099b6:	a81b      	add	r0, sp, #108	; 0x6c
 80099b8:	f000 fe62 	bl	800a680 <ax25_send_string>
 80099bc:	e7de      	b.n	800997c <modulePOS+0xf2c>
					case TEL_SATS:		ax25_send_string(&packet, "Sats");				break;
					case TEL_TTFF:		ax25_send_string(&packet, "TTFF");				break;
					case TEL_VBAT:		ax25_send_string(&packet, "Battery");			break;
					case TEL_VSOL:		ax25_send_string(&packet, "Solar");				break;
					case TEL_CHARGE:	ax25_send_string(&packet, "Charge");			break;
					case TEL_DISCHARGE:	ax25_send_string(&packet, "Discharge");			break;
 80099be:	496a      	ldr	r1, [pc, #424]	; (8009b68 <modulePOS+0x1118>)
 80099c0:	a81b      	add	r0, sp, #108	; 0x6c
 80099c2:	f000 fe5d 	bl	800a680 <ax25_send_string>
 80099c6:	e7d9      	b.n	800997c <modulePOS+0xf2c>
				switch(config->tel[i]) {
					case TEL_SATS:		ax25_send_string(&packet, "Sats");				break;
					case TEL_TTFF:		ax25_send_string(&packet, "TTFF");				break;
					case TEL_VBAT:		ax25_send_string(&packet, "Battery");			break;
					case TEL_VSOL:		ax25_send_string(&packet, "Solar");				break;
					case TEL_CHARGE:	ax25_send_string(&packet, "Charge");			break;
 80099c8:	4968      	ldr	r1, [pc, #416]	; (8009b6c <modulePOS+0x111c>)
 80099ca:	a81b      	add	r0, sp, #108	; 0x6c
 80099cc:	f000 fe58 	bl	800a680 <ax25_send_string>
 80099d0:	e7d4      	b.n	800997c <modulePOS+0xf2c>
			for(uint8_t i=0; i<5; i++) {
				switch(config->tel[i]) {
					case TEL_SATS:		ax25_send_string(&packet, "Sats");				break;
					case TEL_TTFF:		ax25_send_string(&packet, "TTFF");				break;
					case TEL_VBAT:		ax25_send_string(&packet, "Battery");			break;
					case TEL_VSOL:		ax25_send_string(&packet, "Solar");				break;
 80099d2:	4967      	ldr	r1, [pc, #412]	; (8009b70 <modulePOS+0x1120>)
 80099d4:	a81b      	add	r0, sp, #108	; 0x6c
 80099d6:	f000 fe53 	bl	800a680 <ax25_send_string>
 80099da:	e7cf      	b.n	800997c <modulePOS+0xf2c>

			for(uint8_t i=0; i<5; i++) {
				switch(config->tel[i]) {
					case TEL_SATS:		ax25_send_string(&packet, "Sats");				break;
					case TEL_TTFF:		ax25_send_string(&packet, "TTFF");				break;
					case TEL_VBAT:		ax25_send_string(&packet, "Battery");			break;
 80099dc:	4965      	ldr	r1, [pc, #404]	; (8009b74 <modulePOS+0x1124>)
 80099de:	a81b      	add	r0, sp, #108	; 0x6c
 80099e0:	f000 fe4e 	bl	800a680 <ax25_send_string>
 80099e4:	e7ca      	b.n	800997c <modulePOS+0xf2c>
						ax25_send_string(&packet, "Pa");
						break;
						
					case TEL_ITEMP:
					case TEL_ETEMP:
						ax25_send_string(&packet, "degC");
 80099e6:	4964      	ldr	r1, [pc, #400]	; (8009b78 <modulePOS+0x1128>)
 80099e8:	a81b      	add	r0, sp, #108	; 0x6c
 80099ea:	f000 fe49 	bl	800a680 <ax25_send_string>
						break;
				}
				if(i < 4)
 80099ee:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
					ax25_send_string(&packet, ",");
 80099f0:	4957      	ldr	r1, [pc, #348]	; (8009b50 <modulePOS+0x1100>)
					case TEL_ITEMP:
					case TEL_ETEMP:
						ax25_send_string(&packet, "degC");
						break;
				}
				if(i < 4)
 80099f2:	42ab      	cmp	r3, r5
					ax25_send_string(&packet, ",");
 80099f4:	a81b      	add	r0, sp, #108	; 0x6c
					case TEL_ITEMP:
					case TEL_ETEMP:
						ax25_send_string(&packet, "degC");
						break;
				}
				if(i < 4)
 80099f6:	d19e      	bne.n	8009936 <modulePOS+0xee6>
 80099f8:	e776      	b.n	80098e8 <modulePOS+0xe98>
			ax25_send_string(&packet, "PARM.");

			for(uint8_t i=0; i<5; i++) {
				switch(config->tel[i]) {
					case TEL_SATS:		ax25_send_string(&packet, "Sats");				break;
					case TEL_TTFF:		ax25_send_string(&packet, "TTFF");				break;
 80099fa:	4960      	ldr	r1, [pc, #384]	; (8009b7c <modulePOS+0x112c>)
 80099fc:	a81b      	add	r0, sp, #108	; 0x6c
 80099fe:	f000 fe3f 	bl	800a680 <ax25_send_string>
 8009a02:	e7bb      	b.n	800997c <modulePOS+0xf2c>

			ax25_send_string(&packet, "PARM.");

			for(uint8_t i=0; i<5; i++) {
				switch(config->tel[i]) {
					case TEL_SATS:		ax25_send_string(&packet, "Sats");				break;
 8009a04:	495e      	ldr	r1, [pc, #376]	; (8009b80 <modulePOS+0x1130>)
 8009a06:	a81b      	add	r0, sp, #108	; 0x6c
 8009a08:	f000 fe3a 	bl	800a680 <ax25_send_string>
 8009a0c:	e7b6      	b.n	800997c <modulePOS+0xf2c>
						ax25_send_string(&packet, "0,.001,0");
						break;

					case TEL_IHUM:
					case TEL_EHUM:
						ax25_send_string(&packet, "0,.1,0");
 8009a0e:	495d      	ldr	r1, [pc, #372]	; (8009b84 <modulePOS+0x1134>)
 8009a10:	a81b      	add	r0, sp, #108	; 0x6c
 8009a12:	f000 fe35 	bl	800a680 <ax25_send_string>
					case TEL_ITEMP:
					case TEL_ETEMP:
						ax25_send_string(&packet, "0,.1,-100");
						break;
				}
				if(i < 4)
 8009a16:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
					ax25_send_string(&packet, ",");
 8009a18:	494d      	ldr	r1, [pc, #308]	; (8009b50 <modulePOS+0x1100>)
					case TEL_ITEMP:
					case TEL_ETEMP:
						ax25_send_string(&packet, "0,.1,-100");
						break;
				}
				if(i < 4)
 8009a1a:	42ab      	cmp	r3, r5
					ax25_send_string(&packet, ",");
 8009a1c:	a81b      	add	r0, sp, #108	; 0x6c
					case TEL_ITEMP:
					case TEL_ETEMP:
						ax25_send_string(&packet, "0,.1,-100");
						break;
				}
				if(i < 4)
 8009a1e:	f47f af7a 	bne.w	8009916 <modulePOS+0xec6>
 8009a22:	e761      	b.n	80098e8 <modulePOS+0xe98>
						ax25_send_string(&packet, "0,12.5,500");
						break;
						
					case TEL_ITEMP:
					case TEL_ETEMP:
						ax25_send_string(&packet, "0,.1,-100");
 8009a24:	4958      	ldr	r1, [pc, #352]	; (8009b88 <modulePOS+0x1138>)
 8009a26:	a81b      	add	r0, sp, #108	; 0x6c
 8009a28:	f000 fe2a 	bl	800a680 <ax25_send_string>
 8009a2c:	e7f3      	b.n	8009a16 <modulePOS+0xfc6>
						ax25_send_string(&packet, "0,.1,0");
						break;

					case TEL_IPRESS:
					case TEL_EPRESS:
						ax25_send_string(&packet, "0,12.5,500");
 8009a2e:	4957      	ldr	r1, [pc, #348]	; (8009b8c <modulePOS+0x113c>)
 8009a30:	a81b      	add	r0, sp, #108	; 0x6c
 8009a32:	f000 fe25 	bl	800a680 <ax25_send_string>
 8009a36:	e7ee      	b.n	8009a16 <modulePOS+0xfc6>

			for(uint8_t i=0; i<5; i++) {
				switch(config->tel[i]) {
					case TEL_SATS:
					case TEL_TTFF:
						ax25_send_string(&packet, "0,1,0");
 8009a38:	4955      	ldr	r1, [pc, #340]	; (8009b90 <modulePOS+0x1140>)
 8009a3a:	a81b      	add	r0, sp, #108	; 0x6c
 8009a3c:	f000 fe20 	bl	800a680 <ax25_send_string>
 8009a40:	e7e9      	b.n	8009a16 <modulePOS+0xfc6>

					case TEL_CHARGE:
					case TEL_DISCHARGE:
					case TEL_VBAT:
					case TEL_VSOL:
						ax25_send_string(&packet, "0,.001,0");
 8009a42:	4954      	ldr	r1, [pc, #336]	; (8009b94 <modulePOS+0x1144>)
 8009a44:	a81b      	add	r0, sp, #108	; 0x6c
 8009a46:	f000 fe1b 	bl	800a680 <ax25_send_string>
 8009a4a:	e7e4      	b.n	8009a16 <modulePOS+0xfc6>
						ax25_send_string(&packet, "%");
						break;

					case TEL_IPRESS:
					case TEL_EPRESS:
						ax25_send_string(&packet, "Pa");
 8009a4c:	4952      	ldr	r1, [pc, #328]	; (8009b98 <modulePOS+0x1148>)
 8009a4e:	a81b      	add	r0, sp, #108	; 0x6c
 8009a50:	f000 fe16 	bl	800a680 <ax25_send_string>
 8009a54:	e7cb      	b.n	80099ee <modulePOS+0xf9e>
						ax25_send_string(&packet, "V");
						break;

					case TEL_CHARGE:
					case TEL_DISCHARGE:
						ax25_send_string(&packet, "W");
 8009a56:	4951      	ldr	r1, [pc, #324]	; (8009b9c <modulePOS+0x114c>)
 8009a58:	a81b      	add	r0, sp, #108	; 0x6c
 8009a5a:	f000 fe11 	bl	800a680 <ax25_send_string>
 8009a5e:	e7c6      	b.n	80099ee <modulePOS+0xf9e>
						ax25_send_string(&packet, "sec");
						break;

					case TEL_VBAT:
					case TEL_VSOL:
						ax25_send_string(&packet, "V");
 8009a60:	494f      	ldr	r1, [pc, #316]	; (8009ba0 <modulePOS+0x1150>)
 8009a62:	a81b      	add	r0, sp, #108	; 0x6c
 8009a64:	f000 fe0c 	bl	800a680 <ax25_send_string>
 8009a68:	e7c1      	b.n	80099ee <modulePOS+0xf9e>
						ax25_send_string(&packet, "W");
						break;

					case TEL_IHUM:
					case TEL_EHUM:
						ax25_send_string(&packet, "%");
 8009a6a:	494e      	ldr	r1, [pc, #312]	; (8009ba4 <modulePOS+0x1154>)
 8009a6c:	a81b      	add	r0, sp, #108	; 0x6c
 8009a6e:	f000 fe07 	bl	800a680 <ax25_send_string>
 8009a72:	e7bc      	b.n	80099ee <modulePOS+0xf9e>
				switch(config->tel[i]) {
					case TEL_SATS:
						break; // No unit

					case TEL_TTFF:
						ax25_send_string(&packet, "sec");
 8009a74:	494c      	ldr	r1, [pc, #304]	; (8009ba8 <modulePOS+0x1158>)
 8009a76:	a81b      	add	r0, sp, #108	; 0x6c
 8009a78:	f000 fe02 	bl	800a680 <ax25_send_string>
 8009a7c:	e7b7      	b.n	80099ee <modulePOS+0xf9e>
					msg.bin_len = morse_encode(msg.msg, morse); // Convert message to binary stream
					transmitOnRadio(&msg);
					break;

				default:
					TRACE_ERROR("POS  > Unsupported modulation/protocol selected for module POSITION");
 8009a7e:	484b      	ldr	r0, [pc, #300]	; (8009bac <modulePOS+0x115c>)
 8009a80:	4c4b      	ldr	r4, [pc, #300]	; (8009bb0 <modulePOS+0x1160>)
 8009a82:	f005 fa35 	bl	800eef0 <chMtxLock>
 8009a86:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009a8a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8009a8e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009a90:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8009a92:	4b48      	ldr	r3, [pc, #288]	; (8009bb4 <modulePOS+0x1164>)
 8009a94:	fb00 f101 	mul.w	r1, r0, r1
 8009a98:	fba4 5101 	umull	r5, r1, r4, r1
 8009a9c:	0b89      	lsrs	r1, r1, #14
 8009a9e:	fba3 5301 	umull	r5, r3, r3, r1
 8009aa2:	fba4 4202 	umull	r4, r2, r4, r2
 8009aa6:	099b      	lsrs	r3, r3, #6
 8009aa8:	fb00 1313 	mls	r3, r0, r3, r1
 8009aac:	0b92      	lsrs	r2, r2, #14
 8009aae:	4942      	ldr	r1, [pc, #264]	; (8009bb8 <modulePOS+0x1168>)
 8009ab0:	4842      	ldr	r0, [pc, #264]	; (8009bbc <modulePOS+0x116c>)
 8009ab2:	f008 fe15 	bl	80126e0 <chprintf.constprop.35>
 8009ab6:	4a42      	ldr	r2, [pc, #264]	; (8009bc0 <modulePOS+0x1170>)
 8009ab8:	4942      	ldr	r1, [pc, #264]	; (8009bc4 <modulePOS+0x1174>)
 8009aba:	4840      	ldr	r0, [pc, #256]	; (8009bbc <modulePOS+0x116c>)
 8009abc:	f008 fe10 	bl	80126e0 <chprintf.constprop.35>
 8009ac0:	23d6      	movs	r3, #214	; 0xd6
 8009ac2:	4a41      	ldr	r2, [pc, #260]	; (8009bc8 <modulePOS+0x1178>)
 8009ac4:	4941      	ldr	r1, [pc, #260]	; (8009bcc <modulePOS+0x117c>)
 8009ac6:	483d      	ldr	r0, [pc, #244]	; (8009bbc <modulePOS+0x116c>)
 8009ac8:	f008 fe0a 	bl	80126e0 <chprintf.constprop.35>
 8009acc:	4940      	ldr	r1, [pc, #256]	; (8009bd0 <modulePOS+0x1180>)
 8009ace:	483b      	ldr	r0, [pc, #236]	; (8009bbc <modulePOS+0x116c>)
 8009ad0:	f008 fe06 	bl	80126e0 <chprintf.constprop.35>
 8009ad4:	493f      	ldr	r1, [pc, #252]	; (8009bd4 <modulePOS+0x1184>)
 8009ad6:	4839      	ldr	r0, [pc, #228]	; (8009bbc <modulePOS+0x116c>)
 8009ad8:	f008 fe02 	bl	80126e0 <chprintf.constprop.35>
 8009adc:	493e      	ldr	r1, [pc, #248]	; (8009bd8 <modulePOS+0x1188>)
 8009ade:	4837      	ldr	r0, [pc, #220]	; (8009bbc <modulePOS+0x116c>)
 8009ae0:	f008 fdfe 	bl	80126e0 <chprintf.constprop.35>
 8009ae4:	4831      	ldr	r0, [pc, #196]	; (8009bac <modulePOS+0x115c>)
 8009ae6:	f005 f9a3 	bl	800ee30 <chMtxUnlock>
 8009aea:	21d6      	movs	r1, #214	; 0xd6
 8009aec:	4836      	ldr	r0, [pc, #216]	; (8009bc8 <modulePOS+0x1178>)
 8009aee:	f006 fa37 	bl	800ff60 <log_error>
 8009af2:	f7ff b825 	b.w	8008b40 <modulePOS+0xf0>
	ax25_send_string(&packet, temp);

	if(trackPoint->gps_lock)
	{
		// TTFF (Time to first fix)
		ax25_send_string(&packet, " TTFF ");
 8009af6:	4939      	ldr	r1, [pc, #228]	; (8009bdc <modulePOS+0x118c>)
 8009af8:	a817      	add	r0, sp, #92	; 0x5c
 8009afa:	f000 fdc1 	bl	800a680 <ax25_send_string>
		chsnprintf(temp, sizeof(temp), "%d", trackPoint->gps_ttff);
 8009afe:	f899 301d 	ldrb.w	r3, [r9, #29]
 8009b02:	4a37      	ldr	r2, [pc, #220]	; (8009be0 <modulePOS+0x1190>)
 8009b04:	2116      	movs	r1, #22
 8009b06:	a81b      	add	r0, sp, #108	; 0x6c
 8009b08:	f002 fb92 	bl	800c230 <chsnprintf>
		ax25_send_string(&packet, temp);
 8009b0c:	a91b      	add	r1, sp, #108	; 0x6c
 8009b0e:	a817      	add	r0, sp, #92	; 0x5c
 8009b10:	f000 fdb6 	bl	800a680 <ax25_send_string>
		ax25_send_string(&packet, "sec");
 8009b14:	4924      	ldr	r1, [pc, #144]	; (8009ba8 <modulePOS+0x1158>)
 8009b16:	a817      	add	r0, sp, #92	; 0x5c
 8009b18:	f000 fdb2 	bl	800a680 <ax25_send_string>
	}

	// GPS Loss counter
	if(!trackPoint->gps_lock)
 8009b1c:	f899 300e 	ldrb.w	r3, [r9, #14]
 8009b20:	2b00      	cmp	r3, #0
 8009b22:	f43f aad1 	beq.w	80090c8 <modulePOS+0x678>
	{
		ax25_send_string(&packet, " GPS LOSS ");
		chsnprintf(temp, sizeof(temp), "%d", ++loss_of_gps_counter);
		ax25_send_string(&packet, temp);
	} else {
		loss_of_gps_counter = 0;
 8009b26:	4b2f      	ldr	r3, [pc, #188]	; (8009be4 <modulePOS+0x1194>)
 8009b28:	801c      	strh	r4, [r3, #0]
 8009b2a:	f7ff bae1 	b.w	80090f0 <modulePOS+0x6a0>
							last_config_transmission += S2ST(config->aprs_config.tel_encoding_cycle);
							current_config_count = 0;
						}

						// Actual transmission (each cycle a different config type will be sent)
						if(config->aprs_config.tel_encoding && current_config_count < 4)
 8009b2e:	2b03      	cmp	r3, #3
 8009b30:	f63f a806 	bhi.w	8008b40 <modulePOS+0xf0>
 8009b34:	9c14      	ldr	r4, [sp, #80]	; 0x50
 8009b36:	f7ff bb7d 	b.w	8009234 <modulePOS+0x7e4>
 8009b3a:	bf00      	nop
 8009b3c:	08015528 	.word	0x08015528
 8009b40:	080154ec 	.word	0x080154ec
 8009b44:	080154d0 	.word	0x080154d0
 8009b48:	08015430 	.word	0x08015430
 8009b4c:	0801547c 	.word	0x0801547c
 8009b50:	080154cc 	.word	0x080154cc
 8009b54:	080154bc 	.word	0x080154bc
 8009b58:	0801549c 	.word	0x0801549c
 8009b5c:	0801546c 	.word	0x0801546c
 8009b60:	080154ac 	.word	0x080154ac
 8009b64:	0801548c 	.word	0x0801548c
 8009b68:	08015460 	.word	0x08015460
 8009b6c:	08015458 	.word	0x08015458
 8009b70:	08015450 	.word	0x08015450
 8009b74:	08015448 	.word	0x08015448
 8009b78:	080154e4 	.word	0x080154e4
 8009b7c:	08015440 	.word	0x08015440
 8009b80:	08015438 	.word	0x08015438
 8009b84:	08015508 	.word	0x08015508
 8009b88:	0801551c 	.word	0x0801551c
 8009b8c:	08015510 	.word	0x08015510
 8009b90:	080154f4 	.word	0x080154f4
 8009b94:	080154fc 	.word	0x080154fc
 8009b98:	080154e0 	.word	0x080154e0
 8009b9c:	080154dc 	.word	0x080154dc
 8009ba0:	080154d8 	.word	0x080154d8
 8009ba4:	080142b8 	.word	0x080142b8
 8009ba8:	08015428 	.word	0x08015428
 8009bac:	20027b2c 	.word	0x20027b2c
 8009bb0:	d1b71759 	.word	0xd1b71759
 8009bb4:	10624dd3 	.word	0x10624dd3
 8009bb8:	08013c50 	.word	0x08013c50
 8009bbc:	20027e60 	.word	0x20027e60
 8009bc0:	08013d9c 	.word	0x08013d9c
 8009bc4:	08013c5c 	.word	0x08013c5c
 8009bc8:	08015374 	.word	0x08015374
 8009bcc:	08013c78 	.word	0x08013c78
 8009bd0:	08013d00 	.word	0x08013d00
 8009bd4:	08015550 	.word	0x08015550
 8009bd8:	08013cac 	.word	0x08013cac
 8009bdc:	08015420 	.word	0x08015420
 8009be0:	08015410 	.word	0x08015410
 8009be4:	20027878 	.word	0x20027878
					{
						// Telemetry encoding parameter transmission trigger
						if(last_config_transmission + S2ST(config->aprs_config.tel_encoding_cycle) < chVTGetSystemTimeX() && current_config_count >= 4)
						{
							last_config_transmission += S2ST(config->aprs_config.tel_encoding_cycle);
							current_config_count = 0;
 8009be8:	2300      	movs	r3, #0
 8009bea:	9313      	str	r3, [sp, #76]	; 0x4c
 8009bec:	f7ff bb22 	b.w	8009234 <modulePOS+0x7e4>
		data[i] = 0;

	// Encode morse
	buffer = data; // Buffer
	c = 0; // Bitlength
	for(uint32_t i=0; letter[i]!=0; i++)
 8009bf0:	460b      	mov	r3, r1
					replace_placeholders(morse, sizeof(morse), trackPoint);
					str_replace(morse, sizeof(morse), "<CALL>", config->morse_config.callsign);

					// Transmit message
					msg.bin_len = morse_encode(msg.msg, morse); // Convert message to binary stream
					transmitOnRadio(&msg);
 8009bf2:	a85b      	add	r0, sp, #364	; 0x16c
					memcpy(morse, config->morse_config.format, sizeof(config->morse_config.format));
					replace_placeholders(morse, sizeof(morse), trackPoint);
					str_replace(morse, sizeof(morse), "<CALL>", config->morse_config.callsign);

					// Transmit message
					msg.bin_len = morse_encode(msg.msg, morse); // Convert message to binary stream
 8009bf4:	93db      	str	r3, [sp, #876]	; 0x36c
					transmitOnRadio(&msg);
 8009bf6:	f007 fcbb 	bl	8011570 <transmitOnRadio>
 8009bfa:	f7fe bfa1 	b.w	8008b40 <modulePOS+0xf0>
 8009bfe:	bf00      	nop

08009c00 <adccb>:
#define DIVIDER_VSOL			2/1		/* VSol --- 1kOhm -- ADC --- 1kOhm -- GND */
#define DIVIDER_VBAT			200/64	/* VBat -- 33KOhm -- ADC -- 10kOhm -- GND */

static adcsample_t samples[ADC_GRP1_NUM_CHANNELS*2]; // ADC sample buffer

void adccb(ADCDriver *adcp, adcsample_t *buffer, size_t n) {
 8009c00:	4770      	bx	lr
 8009c02:	bf00      	nop
	...

08009c10 <Si4464_Init>:
/**
 * Initializes Si4464 transceiver chip. Adjustes the frequency which is shifted by variable
 * oscillator voltage.
 * @param mv Oscillator voltage in mv
 */
void Si4464_Init(radio_t radio, mod_t modulation) {
 8009c10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009c14:	b099      	sub	sp, #100	; 0x64
 8009c16:	4606      	mov	r6, r0
 8009c18:	af00      	add	r7, sp, #0
	// Initialize SPI
	palSetPadMode(PORT(SPI_SCK), PIN(SPI_SCK), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// SCK
 8009c1a:	f240 229a 	movw	r2, #666	; 0x29a
 8009c1e:	48b5      	ldr	r0, [pc, #724]	; (8009ef4 <Si4464_Init+0x2e4>)
	palSetPadMode(PORT(SPI_MISO), PIN(SPI_MISO), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MISO
	palSetPadMode(PORT(SPI_MOSI), PIN(SPI_MOSI), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MOSI
	palSetPadMode(PORT(RADIO1_CS), PIN(RADIO1_CS), PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO1 CS
 8009c20:	4cb5      	ldr	r4, [pc, #724]	; (8009ef8 <Si4464_Init+0x2e8>)
	palSetPad(PORT(RADIO1_CS), PIN(RADIO1_CS));
	palSetPadMode(PORT(RADIO2_CS), PIN(RADIO2_CS), PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO2 CS
 8009c22:	4db6      	ldr	r5, [pc, #728]	; (8009efc <Si4464_Init+0x2ec>)
/**
 * Initializes Si4464 transceiver chip. Adjustes the frequency which is shifted by variable
 * oscillator voltage.
 * @param mv Oscillator voltage in mv
 */
void Si4464_Init(radio_t radio, mod_t modulation) {
 8009c24:	4688      	mov	r8, r1
	// Initialize SPI
	palSetPadMode(PORT(SPI_SCK), PIN(SPI_SCK), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// SCK
 8009c26:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8009c2a:	f002 fba9 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(SPI_MISO), PIN(SPI_MISO), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MISO
 8009c2e:	f240 229a 	movw	r2, #666	; 0x29a
 8009c32:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8009c36:	48af      	ldr	r0, [pc, #700]	; (8009ef4 <Si4464_Init+0x2e4>)
 8009c38:	f002 fba2 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(SPI_MOSI), PIN(SPI_MOSI), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MOSI
 8009c3c:	f240 229a 	movw	r2, #666	; 0x29a
 8009c40:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8009c44:	48ab      	ldr	r0, [pc, #684]	; (8009ef4 <Si4464_Init+0x2e4>)
 8009c46:	f002 fb9b 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(RADIO1_CS), PIN(RADIO1_CS), PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO1 CS
 8009c4a:	4620      	mov	r0, r4
 8009c4c:	2219      	movs	r2, #25
 8009c4e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8009c52:	f002 fb95 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPad(PORT(RADIO1_CS), PIN(RADIO1_CS));
 8009c56:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009c5a:	8323      	strh	r3, [r4, #24]
	palSetPadMode(PORT(RADIO2_CS), PIN(RADIO2_CS), PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO2 CS
 8009c5c:	4628      	mov	r0, r5
 8009c5e:	2219      	movs	r2, #25
 8009c60:	2104      	movs	r1, #4
 8009c62:	f002 fb8d 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPad(PORT(RADIO2_CS), PIN(RADIO2_CS));
 8009c66:	2304      	movs	r3, #4

	if(radio == RADIO_2M) {
 8009c68:	2e01      	cmp	r6, #1
	palSetPadMode(PORT(SPI_MISO), PIN(SPI_MISO), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MISO
	palSetPadMode(PORT(SPI_MOSI), PIN(SPI_MOSI), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MOSI
	palSetPadMode(PORT(RADIO1_CS), PIN(RADIO1_CS), PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO1 CS
	palSetPad(PORT(RADIO1_CS), PIN(RADIO1_CS));
	palSetPadMode(PORT(RADIO2_CS), PIN(RADIO2_CS), PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO2 CS
	palSetPad(PORT(RADIO2_CS), PIN(RADIO2_CS));
 8009c6a:	832b      	strh	r3, [r5, #24]

	if(radio == RADIO_2M) {
 8009c6c:	d038      	beq.n	8009ce0 <Si4464_Init+0xd0>
		// Configure pins
		palSetPadMode(PORT(RADIO1_SDN), PIN(RADIO1_SDN), PAL_MODE_OUTPUT_PUSHPULL);		// RADIO1 SDN
		palSetPadMode(PORT(RADIO1_GPIO0), PIN(RADIO1_GPIO0), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO1 GPIO0
		palSetPadMode(PORT(RADIO1_GPIO1), PIN(RADIO1_GPIO1), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO1 GPIO1

	} else if (radio == RADIO_70CM) {
 8009c6e:	2e02      	cmp	r6, #2
 8009c70:	f000 824c 	beq.w	800a10c <Si4464_Init+0x4fc>
		palSetPadMode(PORT(RADIO2_GPIO1), PIN(RADIO2_GPIO1), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO2 GPIO1

	}

	// Power up transmitter
	RADIO_SDN_SET(radio, false);	// Radio SDN low (power up transmitter)
 8009c74:	4ba1      	ldr	r3, [pc, #644]	; (8009efc <Si4464_Init+0x2ec>)
 8009c76:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8009c7a:	619a      	str	r2, [r3, #24]
	chThdSleepMilliseconds(10);		// Wait for transmitter to power up
 8009c7c:	20c8      	movs	r0, #200	; 0xc8
 8009c7e:	f005 fa07 	bl	800f090 <chThdSleep>
	// Power up (transmits oscillator type)
	uint8_t x3 = (OSC_FREQ >> 24) & 0x0FF;
	uint8_t x2 = (OSC_FREQ >> 16) & 0x0FF;
	uint8_t x1 = (OSC_FREQ >>  8) & 0x0FF;
	uint8_t x0 = (OSC_FREQ >>  0) & 0x0FF;
	uint8_t init_command[] = {0x02, 0x01, 0x01, x3, x2, x1, x0};
 8009c82:	2002      	movs	r0, #2
 8009c84:	2301      	movs	r3, #1
 8009c86:	248c      	movs	r4, #140	; 0x8c
	Si4464_write(radio, init_command, 7);
 8009c88:	2207      	movs	r2, #7
 8009c8a:	f107 0130 	add.w	r1, r7, #48	; 0x30
	// Power up (transmits oscillator type)
	uint8_t x3 = (OSC_FREQ >> 24) & 0x0FF;
	uint8_t x2 = (OSC_FREQ >> 16) & 0x0FF;
	uint8_t x1 = (OSC_FREQ >>  8) & 0x0FF;
	uint8_t x0 = (OSC_FREQ >>  0) & 0x0FF;
	uint8_t init_command[] = {0x02, 0x01, 0x01, x3, x2, x1, x0};
 8009c8e:	f887 0030 	strb.w	r0, [r7, #48]	; 0x30
 8009c92:	25b8      	movs	r5, #184	; 0xb8
	Si4464_write(radio, init_command, 7);
 8009c94:	4630      	mov	r0, r6
	// Power up (transmits oscillator type)
	uint8_t x3 = (OSC_FREQ >> 24) & 0x0FF;
	uint8_t x2 = (OSC_FREQ >> 16) & 0x0FF;
	uint8_t x1 = (OSC_FREQ >>  8) & 0x0FF;
	uint8_t x0 = (OSC_FREQ >>  0) & 0x0FF;
	uint8_t init_command[] = {0x02, 0x01, 0x01, x3, x2, x1, x0};
 8009c96:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
 8009c9a:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 8009c9e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009ca2:	f887 4034 	strb.w	r4, [r7, #52]	; 0x34
 8009ca6:	f887 4036 	strb.w	r4, [r7, #54]	; 0x36
 8009caa:	f887 5035 	strb.w	r5, [r7, #53]	; 0x35
	Si4464_write(radio, init_command, 7);
 8009cae:	f006 f897 	bl	800fde0 <Si4464_write>

	// Set transmitter GPIOs
	uint8_t gpio_pin_cfg_command[] = {
 8009cb2:	4b93      	ldr	r3, [pc, #588]	; (8009f00 <Si4464_Init+0x2f0>)
 8009cb4:	6818      	ldr	r0, [r3, #0]
 8009cb6:	6859      	ldr	r1, [r3, #4]
 8009cb8:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8009cbc:	c303      	stmia	r3!, {r0, r1}
		0x00,	// GPIO3        0 - PULL_CTL[1bit] - GPIO_MODE[6bit]
		0x00,	// NIRQ
		0x00,	// SDO
		0x00	// GEN_CONFIG
	};
	Si4464_write(radio, gpio_pin_cfg_command, 8);
 8009cbe:	2208      	movs	r2, #8
 8009cc0:	f107 0140 	add.w	r1, r7, #64	; 0x40
 8009cc4:	4630      	mov	r0, r6
 8009cc6:	f006 f88b 	bl	800fde0 <Si4464_write>

	// Set modem
	switch(modulation)
 8009cca:	f1b8 0f04 	cmp.w	r8, #4
 8009cce:	f200 8210 	bhi.w	800a0f2 <Si4464_Init+0x4e2>
 8009cd2:	e8df f018 	tbh	[pc, r8, lsl #1]
 8009cd6:	00a4      	.short	0x00a4
 8009cd8:	017d0217 	.word	0x017d0217
 8009cdc:	001d01d4 	.word	0x001d01d4
	palSetPad(PORT(RADIO2_CS), PIN(RADIO2_CS));

	if(radio == RADIO_2M) {

		// Configure pins
		palSetPadMode(PORT(RADIO1_SDN), PIN(RADIO1_SDN), PAL_MODE_OUTPUT_PUSHPULL);		// RADIO1 SDN
 8009ce0:	f5a5 6500 	sub.w	r5, r5, #2048	; 0x800
 8009ce4:	4632      	mov	r2, r6
 8009ce6:	4628      	mov	r0, r5
 8009ce8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8009cec:	f002 fb48 	bl	800c380 <_pal_lld_setgroupmode>
		palSetPadMode(PORT(RADIO1_GPIO0), PIN(RADIO1_GPIO0), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO1 GPIO0
 8009cf0:	4632      	mov	r2, r6
 8009cf2:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8009cf6:	4620      	mov	r0, r4
 8009cf8:	f002 fb42 	bl	800c380 <_pal_lld_setgroupmode>
		palSetPadMode(PORT(RADIO1_GPIO1), PIN(RADIO1_GPIO1), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO1 GPIO1
 8009cfc:	4632      	mov	r2, r6
 8009cfe:	4620      	mov	r0, r4
 8009d00:	f44f 7180 	mov.w	r1, #256	; 0x100
 8009d04:	f002 fb3c 	bl	800c380 <_pal_lld_setgroupmode>
		palSetPadMode(PORT(RADIO2_GPIO1), PIN(RADIO2_GPIO1), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO2 GPIO1

	}

	// Power up transmitter
	RADIO_SDN_SET(radio, false);	// Radio SDN low (power up transmitter)
 8009d08:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8009d0c:	61ab      	str	r3, [r5, #24]
 8009d0e:	e7b5      	b.n	8009c7c <Si4464_Init+0x6c>
	Si4464_write(radio, set_modem_freq_dev_command, 7);
}

void setModemAFSK(radio_t radio) {
	// Disable preamble
	uint8_t disable_preamble[] = {0x11, 0x10, 0x01, 0x00, 0x00};
 8009d10:	4c7c      	ldr	r4, [pc, #496]	; (8009f04 <Si4464_Init+0x2f4>)
 8009d12:	6820      	ldr	r0, [r4, #0]
 8009d14:	7923      	ldrb	r3, [r4, #4]
 8009d16:	6138      	str	r0, [r7, #16]
	Si4464_write(radio, disable_preamble, 5);
 8009d18:	f107 0110 	add.w	r1, r7, #16
 8009d1c:	2205      	movs	r2, #5
 8009d1e:	4630      	mov	r0, r6
	Si4464_write(radio, set_modem_freq_dev_command, 7);
}

void setModemAFSK(radio_t radio) {
	// Disable preamble
	uint8_t disable_preamble[] = {0x11, 0x10, 0x01, 0x00, 0x00};
 8009d20:	753b      	strb	r3, [r7, #20]
	Si4464_write(radio, disable_preamble, 5);
 8009d22:	f006 f85d 	bl	800fde0 <Si4464_write>

	// Do not transmit sync word
	uint8_t no_sync_word[] = {0x11, 0x11, 0x01, 0x00, (0x01 << 7)};
 8009d26:	4623      	mov	r3, r4
	Si4464_write(radio, no_sync_word, 5);
 8009d28:	f107 0118 	add.w	r1, r7, #24
	// Disable preamble
	uint8_t disable_preamble[] = {0x11, 0x10, 0x01, 0x00, 0x00};
	Si4464_write(radio, disable_preamble, 5);

	// Do not transmit sync word
	uint8_t no_sync_word[] = {0x11, 0x11, 0x01, 0x00, (0x01 << 7)};
 8009d2c:	f853 0f08 	ldr.w	r0, [r3, #8]!
 8009d30:	61b8      	str	r0, [r7, #24]
 8009d32:	791b      	ldrb	r3, [r3, #4]
 8009d34:	773b      	strb	r3, [r7, #28]
	Si4464_write(radio, no_sync_word, 5);
 8009d36:	2205      	movs	r2, #5
 8009d38:	4630      	mov	r0, r6
 8009d3a:	f006 f851 	bl	800fde0 <Si4464_write>
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
	Si4464_write(radio, setup_oversampling, 8);
 8009d3e:	f107 0548 	add.w	r5, r7, #72	; 0x48
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 8009d42:	2304      	movs	r3, #4
 8009d44:	2206      	movs	r2, #6
 8009d46:	2000      	movs	r0, #0
 8009d48:	f04f 0e27 	mov.w	lr, #39	; 0x27
 8009d4c:	f04f 0a20 	mov.w	sl, #32
	Si4464_write(radio, setup_oversampling, 8);
 8009d50:	4629      	mov	r1, r5
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 8009d52:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
 8009d56:	f887 204b 	strb.w	r2, [r7, #75]	; 0x4b
 8009d5a:	230e      	movs	r3, #14
	Si4464_write(radio, setup_oversampling, 8);
 8009d5c:	2208      	movs	r2, #8
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 8009d5e:	f887 004c 	strb.w	r0, [r7, #76]	; 0x4c
 8009d62:	f887 e04d 	strb.w	lr, [r7, #77]	; 0x4d
	Si4464_write(radio, setup_oversampling, 8);
 8009d66:	4630      	mov	r0, r6
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 8009d68:	f06f 0e53 	mvn.w	lr, #83	; 0x53
 8009d6c:	f04f 0b11 	mov.w	fp, #17
 8009d70:	f887 e04e 	strb.w	lr, [r7, #78]	; 0x4e
 8009d74:	f887 a049 	strb.w	sl, [r7, #73]	; 0x49
 8009d78:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
 8009d7c:	f887 b048 	strb.w	fp, [r7, #72]	; 0x48
	Si4464_write(radio, setup_oversampling, 8);
 8009d80:	f006 f82e 	bl	800fde0 <Si4464_write>

	// Setup the NCO data rate for APRS
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x11, 0x30};
 8009d84:	4623      	mov	r3, r4
 8009d86:	f107 0938 	add.w	r9, r7, #56	; 0x38
 8009d8a:	f853 0f10 	ldr.w	r0, [r3, #16]!
 8009d8e:	63b8      	str	r0, [r7, #56]	; 0x38
 8009d90:	889a      	ldrh	r2, [r3, #4]
 8009d92:	f8a9 2004 	strh.w	r2, [r9, #4]
 8009d96:	799b      	ldrb	r3, [r3, #6]
 8009d98:	f889 3006 	strb.w	r3, [r9, #6]
	Si4464_write(radio, setup_data_rate, 7);
 8009d9c:	4649      	mov	r1, r9
 8009d9e:	2207      	movs	r2, #7
 8009da0:	4630      	mov	r0, r6
 8009da2:	f006 f81d 	bl	800fde0 <Si4464_write>

	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
 8009da6:	4623      	mov	r3, r4
	Si4464_write(radio, use_2gfsk, 5);
 8009da8:	eb07 010a 	add.w	r1, r7, sl
	// Setup the NCO data rate for APRS
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x11, 0x30};
	Si4464_write(radio, setup_data_rate, 7);

	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
 8009dac:	f853 0f18 	ldr.w	r0, [r3, #24]!
 8009db0:	6238      	str	r0, [r7, #32]
 8009db2:	791b      	ldrb	r3, [r3, #4]
 8009db4:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	Si4464_write(radio, use_2gfsk, 5);
 8009db8:	2205      	movs	r2, #5
 8009dba:	4630      	mov	r0, r6
 8009dbc:	f006 f810 	bl	800fde0 <Si4464_write>

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
 8009dc0:	f854 0f20 	ldr.w	r0, [r4, #32]!
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
		uint8_t msg[] = {0x11, 0x20, 0x01, 0x17-i, coeff[i]};
 8009dc4:	f8c7 a008 	str.w	sl, [r7, #8]
	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
	Si4464_write(radio, use_2gfsk, 5);

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
 8009dc8:	6861      	ldr	r1, [r4, #4]
 8009dca:	7a22      	ldrb	r2, [r4, #8]
 8009dcc:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8009dd0:	c303      	stmia	r3!, {r0, r1}
 8009dd2:	f107 0450 	add.w	r4, r7, #80	; 0x50
 8009dd6:	701a      	strb	r2, [r3, #0]
 8009dd8:	2317      	movs	r3, #23
 8009dda:	46a2      	mov	sl, r4
 8009ddc:	f107 0828 	add.w	r8, r7, #40	; 0x28
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
		uint8_t msg[] = {0x11, 0x20, 0x01, 0x17-i, coeff[i]};
 8009de0:	60fb      	str	r3, [r7, #12]
 8009de2:	607c      	str	r4, [r7, #4]
 8009de4:	7a3c      	ldrb	r4, [r7, #8]
 8009de6:	f887 4029 	strb.w	r4, [r7, #41]	; 0x29
 8009dea:	f04f 0401 	mov.w	r4, #1
 8009dee:	f81a 3b01 	ldrb.w	r3, [sl], #1
 8009df2:	f887 402a 	strb.w	r4, [r7, #42]	; 0x2a
		Si4464_write(radio, msg, 5);
 8009df6:	2205      	movs	r2, #5

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
		uint8_t msg[] = {0x11, 0x20, 0x01, 0x17-i, coeff[i]};
 8009df8:	7b3c      	ldrb	r4, [r7, #12]
 8009dfa:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
		Si4464_write(radio, msg, 5);
 8009dfe:	4641      	mov	r1, r8
 8009e00:	4630      	mov	r0, r6

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
		uint8_t msg[] = {0x11, 0x20, 0x01, 0x17-i, coeff[i]};
 8009e02:	f887 b028 	strb.w	fp, [r7, #40]	; 0x28
 8009e06:	f887 402b 	strb.w	r4, [r7, #43]	; 0x2b
		Si4464_write(radio, msg, 5);
 8009e0a:	f005 ffe9 	bl	800fde0 <Si4464_write>
 8009e0e:	68fb      	ldr	r3, [r7, #12]
 8009e10:	3b01      	subs	r3, #1
 8009e12:	b2db      	uxtb	r3, r3
	Si4464_write(radio, use_2gfsk, 5);

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
 8009e14:	2b0e      	cmp	r3, #14
 8009e16:	60fb      	str	r3, [r7, #12]
 8009e18:	d1e4      	bne.n	8009de4 <Si4464_Init+0x1d4>
 8009e1a:	687c      	ldr	r4, [r7, #4]
 8009e1c:	e011      	b.n	8009e42 <Si4464_Init+0x232>
	}
}

void setModemOOK(radio_t radio) {
	// Use OOK from async GPIO0
	uint8_t use_ook[] = {0x11, 0x20, 0x01, 0x00, 0x89};
 8009e1e:	4b3a      	ldr	r3, [pc, #232]	; (8009f08 <Si4464_Init+0x2f8>)
	Si4464_write(radio, use_ook, 5);
}

void setModem2FSK(radio_t radio) {
	// use 2FSK from async GPIO0
	uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x8A};
 8009e20:	6818      	ldr	r0, [r3, #0]
 8009e22:	791b      	ldrb	r3, [r3, #4]
 8009e24:	6538      	str	r0, [r7, #80]	; 0x50
 8009e26:	f107 0450 	add.w	r4, r7, #80	; 0x50
	Si4464_write(radio, use_2fsk, 5);
 8009e2a:	4621      	mov	r1, r4
	Si4464_write(radio, use_ook, 5);
}

void setModem2FSK(radio_t radio) {
	// use 2FSK from async GPIO0
	uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x8A};
 8009e2c:	7123      	strb	r3, [r4, #4]
	Si4464_write(radio, use_2fsk, 5);
 8009e2e:	2205      	movs	r2, #5
 8009e30:	4630      	mov	r0, r6
 8009e32:	f005 ffd5 	bl	800fde0 <Si4464_write>
 8009e36:	f107 0548 	add.w	r5, r7, #72	; 0x48
 8009e3a:	f107 0938 	add.w	r9, r7, #56	; 0x38
 8009e3e:	f107 0828 	add.w	r8, r7, #40	; 0x28
		case MOD_DOMINOEX16:
			TRACE_WARN("SI %d > Unimplemented modulation %s", radio, VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
	}

	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
 8009e42:	4832      	ldr	r0, [pc, #200]	; (8009f0c <Si4464_Init+0x2fc>)
 8009e44:	f005 f854 	bl	800eef0 <chMtxLock>
 8009e48:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009e4c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8009e50:	f8d3 e024 	ldr.w	lr, [r3, #36]	; 0x24
 8009e54:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8009e56:	4a2e      	ldr	r2, [pc, #184]	; (8009f10 <Si4464_Init+0x300>)
 8009e58:	4b2e      	ldr	r3, [pc, #184]	; (8009f14 <Si4464_Init+0x304>)
 8009e5a:	fb00 f101 	mul.w	r1, r0, r1
 8009e5e:	fba2 2101 	umull	r2, r1, r2, r1
 8009e62:	0b89      	lsrs	r1, r1, #14
 8009e64:	fba3 2301 	umull	r2, r3, r3, r1
 8009e68:	4a29      	ldr	r2, [pc, #164]	; (8009f10 <Si4464_Init+0x300>)
 8009e6a:	099b      	lsrs	r3, r3, #6
 8009e6c:	fba2 e20e 	umull	lr, r2, r2, lr
 8009e70:	fb00 1313 	mls	r3, r0, r3, r1
 8009e74:	0b92      	lsrs	r2, r2, #14
 8009e76:	4928      	ldr	r1, [pc, #160]	; (8009f18 <Si4464_Init+0x308>)
 8009e78:	4828      	ldr	r0, [pc, #160]	; (8009f1c <Si4464_Init+0x30c>)
 8009e7a:	f008 fc31 	bl	80126e0 <chprintf.constprop.35>
 8009e7e:	4a28      	ldr	r2, [pc, #160]	; (8009f20 <Si4464_Init+0x310>)
 8009e80:	4928      	ldr	r1, [pc, #160]	; (8009f24 <Si4464_Init+0x314>)
 8009e82:	4826      	ldr	r0, [pc, #152]	; (8009f1c <Si4464_Init+0x30c>)
 8009e84:	f008 fc2c 	bl	80126e0 <chprintf.constprop.35>
 8009e88:	236a      	movs	r3, #106	; 0x6a
 8009e8a:	4a27      	ldr	r2, [pc, #156]	; (8009f28 <Si4464_Init+0x318>)
 8009e8c:	4927      	ldr	r1, [pc, #156]	; (8009f2c <Si4464_Init+0x31c>)
 8009e8e:	4823      	ldr	r0, [pc, #140]	; (8009f1c <Si4464_Init+0x30c>)
 8009e90:	f008 fc26 	bl	80126e0 <chprintf.constprop.35>
 8009e94:	4926      	ldr	r1, [pc, #152]	; (8009f30 <Si4464_Init+0x320>)
 8009e96:	4821      	ldr	r0, [pc, #132]	; (8009f1c <Si4464_Init+0x30c>)
 8009e98:	f008 fc22 	bl	80126e0 <chprintf.constprop.35>
	Si4464_read(radio, fifo_info, 1, rxData, 4);
	return rxData[2];
}

int8_t Si4464_getTemperature(radio_t radio) {
	uint8_t txData[2] = {0x14, 0x10};
 8009e9c:	4b25      	ldr	r3, [pc, #148]	; (8009f34 <Si4464_Init+0x324>)
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8009e9e:	4826      	ldr	r0, [pc, #152]	; (8009f38 <Si4464_Init+0x328>)
 8009ea0:	881b      	ldrh	r3, [r3, #0]
 8009ea2:	853b      	strh	r3, [r7, #40]	; 0x28
 8009ea4:	f005 f824 	bl	800eef0 <chMtxLock>
void Si4464_read(radio_t radio, uint8_t* txData, uint32_t txlen, uint8_t* rxData, uint32_t rxlen) {
	// Transmit data by SPI
	uint8_t null_spi[txlen];
	// SPI transfer
	spiAcquireBus(&SPID2);
	spiStart(&SPID2, getSPIDriver(radio));
 8009ea8:	2e01      	cmp	r6, #1
}

/**
 * Read register from Si4464. First Register CTS is included.
 */
void Si4464_read(radio_t radio, uint8_t* txData, uint32_t txlen, uint8_t* rxData, uint32_t rxlen) {
 8009eaa:	46ea      	mov	sl, sp
	// Transmit data by SPI
	uint8_t null_spi[txlen];
	// SPI transfer
	spiAcquireBus(&SPID2);
	spiStart(&SPID2, getSPIDriver(radio));
 8009eac:	f000 812c 	beq.w	800a108 <Si4464_Init+0x4f8>
 8009eb0:	4922      	ldr	r1, [pc, #136]	; (8009f3c <Si4464_Init+0x32c>)
 8009eb2:	4823      	ldr	r0, [pc, #140]	; (8009f40 <Si4464_Init+0x330>)
 8009eb4:	f003 f8b4 	bl	800d020 <spiStart>
	spiSelect(&SPID2);
 8009eb8:	4821      	ldr	r0, [pc, #132]	; (8009f40 <Si4464_Init+0x330>)
 8009eba:	f003 f839 	bl	800cf30 <spiSelect>
	spiExchange(&SPID2, txlen, txData, null_spi);
 8009ebe:	464a      	mov	r2, r9
 8009ec0:	4641      	mov	r1, r8
 8009ec2:	2002      	movs	r0, #2
 8009ec4:	f008 fe34 	bl	8012b30 <spiExchange.constprop.47>
	spiUnselect(&SPID2);
 8009ec8:	481d      	ldr	r0, [pc, #116]	; (8009f40 <Si4464_Init+0x330>)
 8009eca:	f003 f801 	bl	800ced0 <spiUnselect>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8009ece:	481a      	ldr	r0, [pc, #104]	; (8009f38 <Si4464_Init+0x328>)
 8009ed0:	f004 ffae 	bl	800ee30 <chMtxUnlock>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
 8009ed4:	2300      	movs	r3, #0
 8009ed6:	f887 3049 	strb.w	r3, [r7, #73]	; 0x49
 8009eda:	4a18      	ldr	r2, [pc, #96]	; (8009f3c <Si4464_Init+0x32c>)
 8009edc:	4b19      	ldr	r3, [pc, #100]	; (8009f44 <Si4464_Init+0x334>)
	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
	Si4464_write(radio, use_2gfsk, 5);

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
 8009ede:	f240 71cf 	movw	r1, #1999	; 0x7cf
 8009ee2:	2e01      	cmp	r6, #1
 8009ee4:	bf0c      	ite	eq
 8009ee6:	4698      	moveq	r8, r3
 8009ee8:	4690      	movne	r8, r2
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {

		// Request ACK by Si4464
		uint16_t rx_ready[rxlen];
		rx_ready[0] = 0x44;
 8009eea:	f04f 0944 	mov.w	r9, #68	; 0x44
 8009eee:	468b      	mov	fp, r1
 8009ef0:	e02e      	b.n	8009f50 <Si4464_Init+0x340>
 8009ef2:	bf00      	nop
 8009ef4:	40020400 	.word	0x40020400
 8009ef8:	40020c00 	.word	0x40020c00
 8009efc:	40021800 	.word	0x40021800
 8009f00:	08013ba4 	.word	0x08013ba4
 8009f04:	08013bac 	.word	0x08013bac
 8009f08:	08013bd8 	.word	0x08013bd8
 8009f0c:	20027b2c 	.word	0x20027b2c
 8009f10:	d1b71759 	.word	0xd1b71759
 8009f14:	10624dd3 	.word	0x10624dd3
 8009f18:	08013c50 	.word	0x08013c50
 8009f1c:	20027e60 	.word	0x20027e60
 8009f20:	08013cfc 	.word	0x08013cfc
 8009f24:	08013c5c 	.word	0x08013c5c
 8009f28:	080155e4 	.word	0x080155e4
 8009f2c:	08013c78 	.word	0x08013c78
 8009f30:	08013d00 	.word	0x08013d00
 8009f34:	08013bf0 	.word	0x08013bf0
 8009f38:	200287a8 	.word	0x200287a8
 8009f3c:	08016030 	.word	0x08016030
 8009f40:	2002879c 	.word	0x2002879c
 8009f44:	08015d98 	.word	0x08015d98
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {
 8009f48:	465b      	mov	r3, fp
 8009f4a:	3b01      	subs	r3, #1
 8009f4c:	469b      	mov	fp, r3
 8009f4e:	d01a      	beq.n	8009f86 <Si4464_Init+0x376>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8009f50:	4876      	ldr	r0, [pc, #472]	; (800a12c <Si4464_Init+0x51c>)

		// Request ACK by Si4464
		uint16_t rx_ready[rxlen];
		rx_ready[0] = 0x44;
 8009f52:	f8a7 9050 	strh.w	r9, [r7, #80]	; 0x50
 8009f56:	f004 ffcb 	bl	800eef0 <chMtxLock>

		// SPI transfer
		spiAcquireBus(&SPID2);
		spiStart(&SPID2, getSPIDriver(radio));
 8009f5a:	4641      	mov	r1, r8
 8009f5c:	4874      	ldr	r0, [pc, #464]	; (800a130 <Si4464_Init+0x520>)
 8009f5e:	f003 f85f 	bl	800d020 <spiStart>
		spiSelect(&SPID2);
 8009f62:	4873      	ldr	r0, [pc, #460]	; (800a130 <Si4464_Init+0x520>)
 8009f64:	f002 ffe4 	bl	800cf30 <spiSelect>
		spiExchange(&SPID2, rxlen, rx_ready, rxData);
 8009f68:	462a      	mov	r2, r5
 8009f6a:	4621      	mov	r1, r4
 8009f6c:	2008      	movs	r0, #8
 8009f6e:	f008 fddf 	bl	8012b30 <spiExchange.constprop.47>
		spiUnselect(&SPID2);
 8009f72:	486f      	ldr	r0, [pc, #444]	; (800a130 <Si4464_Init+0x520>)
 8009f74:	f002 ffac 	bl	800ced0 <spiUnselect>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8009f78:	486c      	ldr	r0, [pc, #432]	; (800a12c <Si4464_Init+0x51c>)
 8009f7a:	f004 ff59 	bl	800ee30 <chMtxUnlock>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {
 8009f7e:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
 8009f82:	2bff      	cmp	r3, #255	; 0xff
 8009f84:	d1e0      	bne.n	8009f48 <Si4464_Init+0x338>

int8_t Si4464_getTemperature(radio_t radio) {
	uint8_t txData[2] = {0x14, 0x10};
	uint8_t rxData[8];
	Si4464_read(radio, txData, 2, rxData, 8);
	uint16_t adc = rxData[7] | ((rxData[6] & 0x7) << 8);
 8009f86:	f897 304e 	ldrb.w	r3, [r7, #78]	; 0x4e
 8009f8a:	f897 204f 	ldrb.w	r2, [r7, #79]	; 0x4f
		case MOD_DOMINOEX16:
			TRACE_WARN("SI %d > Unimplemented modulation %s", radio, VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
	}

	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
 8009f8e:	4969      	ldr	r1, [pc, #420]	; (800a134 <Si4464_Init+0x524>)
 8009f90:	4869      	ldr	r0, [pc, #420]	; (800a138 <Si4464_Init+0x528>)

int8_t Si4464_getTemperature(radio_t radio) {
	uint8_t txData[2] = {0x14, 0x10};
	uint8_t rxData[8];
	Si4464_read(radio, txData, 2, rxData, 8);
	uint16_t adc = rxData[7] | ((rxData[6] & 0x7) << 8);
 8009f92:	021b      	lsls	r3, r3, #8
 8009f94:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8009f98:	4313      	orrs	r3, r2
		case MOD_DOMINOEX16:
			TRACE_WARN("SI %d > Unimplemented modulation %s", radio, VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
	}

	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
 8009f9a:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 8009f9e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8009fa2:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8009fa6:	131b      	asrs	r3, r3, #12
 8009fa8:	3b25      	subs	r3, #37	; 0x25
 8009faa:	4632      	mov	r2, r6
 8009fac:	46d5      	mov	sp, sl
 8009fae:	b25b      	sxtb	r3, r3
 8009fb0:	f008 fb96 	bl	80126e0 <chprintf.constprop.35>
 8009fb4:	4961      	ldr	r1, [pc, #388]	; (800a13c <Si4464_Init+0x52c>)
 8009fb6:	4860      	ldr	r0, [pc, #384]	; (800a138 <Si4464_Init+0x528>)
 8009fb8:	f008 fb92 	bl	80126e0 <chprintf.constprop.35>
 8009fbc:	4860      	ldr	r0, [pc, #384]	; (800a140 <Si4464_Init+0x530>)
 8009fbe:	f004 ff37 	bl	800ee30 <chMtxUnlock>
	initialized[radio] = true;
 8009fc2:	4b60      	ldr	r3, [pc, #384]	; (800a144 <Si4464_Init+0x534>)
 8009fc4:	2201      	movs	r2, #1
}
 8009fc6:	3764      	adds	r7, #100	; 0x64
			TRACE_WARN("SI %d > Unimplemented modulation %s", radio, VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
	}

	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
	initialized[radio] = true;
 8009fc8:	559a      	strb	r2, [r3, r6]
}
 8009fca:	46bd      	mov	sp, r7
 8009fcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	Si4464_write(radio, use_2fsk, 5);
}

void setModem2GFSK(radio_t radio) {
	// Disable preamble
	uint8_t disable_preamble[] = {0x11, 0x10, 0x01, 0x00, 0x00};
 8009fd0:	4b5d      	ldr	r3, [pc, #372]	; (800a148 <Si4464_Init+0x538>)
 8009fd2:	6818      	ldr	r0, [r3, #0]
 8009fd4:	6238      	str	r0, [r7, #32]
 8009fd6:	791b      	ldrb	r3, [r3, #4]
 8009fd8:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	Si4464_write(radio, disable_preamble, 5);
 8009fdc:	f107 0120 	add.w	r1, r7, #32
 8009fe0:	4630      	mov	r0, r6
 8009fe2:	2205      	movs	r2, #5
 8009fe4:	f005 fefc 	bl	800fde0 <Si4464_write>

	// Do not transmit sync word
	uint8_t no_sync_word[] = {0x11, 0x11, 0x01, 0x00, (0x01 << 7)};
 8009fe8:	4b57      	ldr	r3, [pc, #348]	; (800a148 <Si4464_Init+0x538>)
 8009fea:	f853 0f08 	ldr.w	r0, [r3, #8]!
 8009fee:	62b8      	str	r0, [r7, #40]	; 0x28
 8009ff0:	f107 0828 	add.w	r8, r7, #40	; 0x28
 8009ff4:	791b      	ldrb	r3, [r3, #4]
 8009ff6:	f888 3004 	strb.w	r3, [r8, #4]
	Si4464_write(radio, no_sync_word, 5);
 8009ffa:	4641      	mov	r1, r8
 8009ffc:	4630      	mov	r0, r6
 8009ffe:	2205      	movs	r2, #5
 800a000:	f005 feee 	bl	800fde0 <Si4464_write>
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 800a004:	2211      	movs	r2, #17
 800a006:	2020      	movs	r0, #32
 800a008:	f887 2050 	strb.w	r2, [r7, #80]	; 0x50
 800a00c:	f887 0051 	strb.w	r0, [r7, #81]	; 0x51
	Si4464_write(radio, setup_oversampling, 8);
 800a010:	f107 0450 	add.w	r4, r7, #80	; 0x50
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 800a014:	2504      	movs	r5, #4
 800a016:	2306      	movs	r3, #6
 800a018:	2200      	movs	r2, #0
 800a01a:	2027      	movs	r0, #39	; 0x27
	Si4464_write(radio, setup_oversampling, 8);
 800a01c:	4621      	mov	r1, r4
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 800a01e:	f887 5052 	strb.w	r5, [r7, #82]	; 0x52
 800a022:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
 800a026:	25ac      	movs	r5, #172	; 0xac
 800a028:	230e      	movs	r3, #14
 800a02a:	f887 2054 	strb.w	r2, [r7, #84]	; 0x54
 800a02e:	f887 0055 	strb.w	r0, [r7, #85]	; 0x55
	Si4464_write(radio, setup_oversampling, 8);
 800a032:	2208      	movs	r2, #8
 800a034:	4630      	mov	r0, r6
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 800a036:	f887 5056 	strb.w	r5, [r7, #86]	; 0x56
 800a03a:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	Si4464_write(radio, setup_oversampling, 8);
 800a03e:	f005 fecf 	bl	800fde0 <Si4464_write>

	// Setup the NCO data rate for 2GFSK
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x25, 0x80};
 800a042:	4b41      	ldr	r3, [pc, #260]	; (800a148 <Si4464_Init+0x538>)
 800a044:	f853 0f3c 	ldr.w	r0, [r3, #60]!
 800a048:	64b8      	str	r0, [r7, #72]	; 0x48
 800a04a:	f107 0548 	add.w	r5, r7, #72	; 0x48
 800a04e:	889a      	ldrh	r2, [r3, #4]
 800a050:	80aa      	strh	r2, [r5, #4]
 800a052:	799b      	ldrb	r3, [r3, #6]
 800a054:	71ab      	strb	r3, [r5, #6]
	Si4464_write(radio, setup_data_rate, 7);
 800a056:	4629      	mov	r1, r5
 800a058:	4630      	mov	r0, r6
 800a05a:	2207      	movs	r2, #7
 800a05c:	f005 fec0 	bl	800fde0 <Si4464_write>

	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
 800a060:	4b39      	ldr	r3, [pc, #228]	; (800a148 <Si4464_Init+0x538>)
 800a062:	f853 0f18 	ldr.w	r0, [r3, #24]!
 800a066:	63b8      	str	r0, [r7, #56]	; 0x38
 800a068:	f107 0938 	add.w	r9, r7, #56	; 0x38
 800a06c:	791b      	ldrb	r3, [r3, #4]
 800a06e:	f889 3004 	strb.w	r3, [r9, #4]
	Si4464_write(radio, use_2gfsk, 5);
 800a072:	4649      	mov	r1, r9
 800a074:	2205      	movs	r2, #5
 800a076:	4630      	mov	r0, r6
 800a078:	f005 feb2 	bl	800fde0 <Si4464_write>
 800a07c:	e6e1      	b.n	8009e42 <Si4464_Init+0x232>
			break;
		case MOD_2GFSK:
			setModem2GFSK(radio);
			break;
		case MOD_DOMINOEX16:
			TRACE_WARN("SI %d > Unimplemented modulation %s", radio, VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
 800a07e:	4830      	ldr	r0, [pc, #192]	; (800a140 <Si4464_Init+0x530>)
 800a080:	f004 ff36 	bl	800eef0 <chMtxLock>
 800a084:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800a088:	4a30      	ldr	r2, [pc, #192]	; (800a14c <Si4464_Init+0x53c>)
 800a08a:	f8d3 e024 	ldr.w	lr, [r3, #36]	; 0x24
 800a08e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800a090:	4b2f      	ldr	r3, [pc, #188]	; (800a150 <Si4464_Init+0x540>)
 800a092:	4930      	ldr	r1, [pc, #192]	; (800a154 <Si4464_Init+0x544>)
 800a094:	4828      	ldr	r0, [pc, #160]	; (800a138 <Si4464_Init+0x528>)
 800a096:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800a09a:	fb05 f404 	mul.w	r4, r5, r4
 800a09e:	fba2 2404 	umull	r2, r4, r2, r4
 800a0a2:	0ba4      	lsrs	r4, r4, #14
 800a0a4:	fba3 2304 	umull	r2, r3, r3, r4
 800a0a8:	4a28      	ldr	r2, [pc, #160]	; (800a14c <Si4464_Init+0x53c>)
 800a0aa:	099b      	lsrs	r3, r3, #6
 800a0ac:	fba2 e20e 	umull	lr, r2, r2, lr
 800a0b0:	fb05 4313 	mls	r3, r5, r3, r4
 800a0b4:	0b92      	lsrs	r2, r2, #14
 800a0b6:	f008 fb13 	bl	80126e0 <chprintf.constprop.35>
 800a0ba:	4a27      	ldr	r2, [pc, #156]	; (800a158 <Si4464_Init+0x548>)
 800a0bc:	4927      	ldr	r1, [pc, #156]	; (800a15c <Si4464_Init+0x54c>)
 800a0be:	481e      	ldr	r0, [pc, #120]	; (800a138 <Si4464_Init+0x528>)
 800a0c0:	f008 fb0e 	bl	80126e0 <chprintf.constprop.35>
 800a0c4:	2366      	movs	r3, #102	; 0x66
 800a0c6:	4a26      	ldr	r2, [pc, #152]	; (800a160 <Si4464_Init+0x550>)
 800a0c8:	4926      	ldr	r1, [pc, #152]	; (800a164 <Si4464_Init+0x554>)
 800a0ca:	481b      	ldr	r0, [pc, #108]	; (800a138 <Si4464_Init+0x528>)
 800a0cc:	f008 fb08 	bl	80126e0 <chprintf.constprop.35>
 800a0d0:	4925      	ldr	r1, [pc, #148]	; (800a168 <Si4464_Init+0x558>)
 800a0d2:	4819      	ldr	r0, [pc, #100]	; (800a138 <Si4464_Init+0x528>)
 800a0d4:	f008 fb04 	bl	80126e0 <chprintf.constprop.35>
 800a0d8:	4b24      	ldr	r3, [pc, #144]	; (800a16c <Si4464_Init+0x55c>)
 800a0da:	4925      	ldr	r1, [pc, #148]	; (800a170 <Si4464_Init+0x560>)
 800a0dc:	4816      	ldr	r0, [pc, #88]	; (800a138 <Si4464_Init+0x528>)
 800a0de:	4632      	mov	r2, r6
 800a0e0:	f008 fafe 	bl	80126e0 <chprintf.constprop.35>
 800a0e4:	4915      	ldr	r1, [pc, #84]	; (800a13c <Si4464_Init+0x52c>)
 800a0e6:	4814      	ldr	r0, [pc, #80]	; (800a138 <Si4464_Init+0x528>)
 800a0e8:	f008 fafa 	bl	80126e0 <chprintf.constprop.35>
 800a0ec:	4814      	ldr	r0, [pc, #80]	; (800a140 <Si4464_Init+0x530>)
 800a0ee:	f004 fe9f 	bl	800ee30 <chMtxUnlock>
 800a0f2:	f107 0548 	add.w	r5, r7, #72	; 0x48
 800a0f6:	f107 0938 	add.w	r9, r7, #56	; 0x38
 800a0fa:	f107 0450 	add.w	r4, r7, #80	; 0x50
 800a0fe:	f107 0828 	add.w	r8, r7, #40	; 0x28
 800a102:	e69e      	b.n	8009e42 <Si4464_Init+0x232>
	Si4464_write(radio, use_ook, 5);
}

void setModem2FSK(radio_t radio) {
	// use 2FSK from async GPIO0
	uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x8A};
 800a104:	4b1b      	ldr	r3, [pc, #108]	; (800a174 <Si4464_Init+0x564>)
 800a106:	e68b      	b.n	8009e20 <Si4464_Init+0x210>
void Si4464_read(radio_t radio, uint8_t* txData, uint32_t txlen, uint8_t* rxData, uint32_t rxlen) {
	// Transmit data by SPI
	uint8_t null_spi[txlen];
	// SPI transfer
	spiAcquireBus(&SPID2);
	spiStart(&SPID2, getSPIDriver(radio));
 800a108:	491b      	ldr	r1, [pc, #108]	; (800a178 <Si4464_Init+0x568>)
 800a10a:	e6d2      	b.n	8009eb2 <Si4464_Init+0x2a2>
		palSetPadMode(PORT(RADIO1_GPIO1), PIN(RADIO1_GPIO1), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO1 GPIO1

	} else if (radio == RADIO_70CM) {

		// Configure pins
		palSetPadMode(PORT(RADIO2_SDN), PIN(RADIO2_SDN), PAL_MODE_OUTPUT_PUSHPULL);		// RADIO2 SDN
 800a10c:	4628      	mov	r0, r5
 800a10e:	2201      	movs	r2, #1
 800a110:	2140      	movs	r1, #64	; 0x40
 800a112:	f002 f935 	bl	800c380 <_pal_lld_setgroupmode>
		palSetPadMode(PORT(RADIO2_GPIO0), PIN(RADIO2_GPIO0), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO2 GPIO0
 800a116:	4628      	mov	r0, r5
 800a118:	2201      	movs	r2, #1
 800a11a:	2108      	movs	r1, #8
 800a11c:	f002 f930 	bl	800c380 <_pal_lld_setgroupmode>
		palSetPadMode(PORT(RADIO2_GPIO1), PIN(RADIO2_GPIO1), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO2 GPIO1
 800a120:	4620      	mov	r0, r4
 800a122:	2201      	movs	r2, #1
 800a124:	2120      	movs	r1, #32
 800a126:	f002 f92b 	bl	800c380 <_pal_lld_setgroupmode>
 800a12a:	e5a3      	b.n	8009c74 <Si4464_Init+0x64>
 800a12c:	200287a8 	.word	0x200287a8
 800a130:	2002879c 	.word	0x2002879c
 800a134:	08015620 	.word	0x08015620
 800a138:	20027e60 	.word	0x20027e60
 800a13c:	08013cac 	.word	0x08013cac
 800a140:	20027b2c 	.word	0x20027b2c
 800a144:	20027e18 	.word	0x20027e18
 800a148:	08013bac 	.word	0x08013bac
 800a14c:	d1b71759 	.word	0xd1b71759
 800a150:	10624dd3 	.word	0x10624dd3
 800a154:	08013c50 	.word	0x08013c50
 800a158:	08013cb0 	.word	0x08013cb0
 800a15c:	08013c5c 	.word	0x08013c5c
 800a160:	080155e4 	.word	0x080155e4
 800a164:	08013c78 	.word	0x08013c78
 800a168:	08013d00 	.word	0x08013d00
 800a16c:	080155f0 	.word	0x080155f0
 800a170:	080155fc 	.word	0x080155fc
 800a174:	08013be0 	.word	0x08013be0
 800a178:	08015d98 	.word	0x08015d98
 800a17c:	00000000 	.word	0x00000000

0800a180 <GPS_Deinit>:

	return status;
}

void GPS_Deinit(void)
{
 800a180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// Switch MOSFET
	TRACE_INFO("GPS  > Switch off");
 800a182:	4d1e      	ldr	r5, [pc, #120]	; (800a1fc <GPS_Deinit+0x7c>)
 800a184:	4f1e      	ldr	r7, [pc, #120]	; (800a200 <GPS_Deinit+0x80>)
 800a186:	4c1f      	ldr	r4, [pc, #124]	; (800a204 <GPS_Deinit+0x84>)
 800a188:	4628      	mov	r0, r5
 800a18a:	f004 feb1 	bl	800eef0 <chMtxLock>
 800a18e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800a192:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800a196:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a198:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800a19a:	4b1b      	ldr	r3, [pc, #108]	; (800a208 <GPS_Deinit+0x88>)
 800a19c:	491b      	ldr	r1, [pc, #108]	; (800a20c <GPS_Deinit+0x8c>)
 800a19e:	fb06 f000 	mul.w	r0, r6, r0
 800a1a2:	fba7 e000 	umull	lr, r0, r7, r0
 800a1a6:	0b80      	lsrs	r0, r0, #14
 800a1a8:	fba3 e300 	umull	lr, r3, r3, r0
 800a1ac:	fba7 7202 	umull	r7, r2, r7, r2
 800a1b0:	099b      	lsrs	r3, r3, #6
 800a1b2:	fb06 0313 	mls	r3, r6, r3, r0
 800a1b6:	0b92      	lsrs	r2, r2, #14
 800a1b8:	4620      	mov	r0, r4
 800a1ba:	f008 fa91 	bl	80126e0 <chprintf.constprop.35>
 800a1be:	4a14      	ldr	r2, [pc, #80]	; (800a210 <GPS_Deinit+0x90>)
 800a1c0:	4914      	ldr	r1, [pc, #80]	; (800a214 <GPS_Deinit+0x94>)
 800a1c2:	4620      	mov	r0, r4
 800a1c4:	f008 fa8c 	bl	80126e0 <chprintf.constprop.35>
 800a1c8:	f240 2307 	movw	r3, #519	; 0x207
 800a1cc:	4a12      	ldr	r2, [pc, #72]	; (800a218 <GPS_Deinit+0x98>)
 800a1ce:	4913      	ldr	r1, [pc, #76]	; (800a21c <GPS_Deinit+0x9c>)
 800a1d0:	4620      	mov	r0, r4
 800a1d2:	f008 fa85 	bl	80126e0 <chprintf.constprop.35>
 800a1d6:	4912      	ldr	r1, [pc, #72]	; (800a220 <GPS_Deinit+0xa0>)
 800a1d8:	4620      	mov	r0, r4
 800a1da:	f008 fa81 	bl	80126e0 <chprintf.constprop.35>
 800a1de:	4911      	ldr	r1, [pc, #68]	; (800a224 <GPS_Deinit+0xa4>)
 800a1e0:	4620      	mov	r0, r4
 800a1e2:	f008 fa7d 	bl	80126e0 <chprintf.constprop.35>
 800a1e6:	4910      	ldr	r1, [pc, #64]	; (800a228 <GPS_Deinit+0xa8>)
 800a1e8:	4620      	mov	r0, r4
 800a1ea:	f008 fa79 	bl	80126e0 <chprintf.constprop.35>
 800a1ee:	4628      	mov	r0, r5
 800a1f0:	f004 fe1e 	bl	800ee30 <chMtxUnlock>
	palClearPad(PORT(GPS_EN), PIN(GPS_EN));
 800a1f4:	4b0d      	ldr	r3, [pc, #52]	; (800a22c <GPS_Deinit+0xac>)
 800a1f6:	2204      	movs	r2, #4
 800a1f8:	835a      	strh	r2, [r3, #26]
 800a1fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a1fc:	20027b2c 	.word	0x20027b2c
 800a200:	d1b71759 	.word	0xd1b71759
 800a204:	20027e60 	.word	0x20027e60
 800a208:	10624dd3 	.word	0x10624dd3
 800a20c:	08013c50 	.word	0x08013c50
 800a210:	08013cfc 	.word	0x08013cfc
 800a214:	08013c5c 	.word	0x08013c5c
 800a218:	08013e24 	.word	0x08013e24
 800a21c:	08013c78 	.word	0x08013c78
 800a220:	08013d00 	.word	0x08013d00
 800a224:	08015648 	.word	0x08015648
 800a228:	08013cac 	.word	0x08013cac
 800a22c:	40020000 	.word	0x40020000

0800a230 <getTime>:

/**
  * Reads the time from the STM32 internal RTC
  * @return Date in Julian calendar format
  */
void getTime(ptime_t *date) {
 800a230:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a232:	b083      	sub	sp, #12
 800a234:	4604      	mov	r4, r0
 */
void rtcGetTime(RTCDriver *rtcp, RTCDateTime *timespec) {

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_get_time(rtcp, timespec);
 800a236:	4668      	mov	r0, sp
 800a238:	f008 f9d2 	bl	80125e0 <rtc_lld_get_time.constprop.54>
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800a23c:	9d01      	ldr	r5, [sp, #4]
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800a23e:	4b1b      	ldr	r3, [pc, #108]	; (800a2ac <getTime+0x7c>)
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800a240:	481b      	ldr	r0, [pc, #108]	; (800a2b0 <getTime+0x80>)
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800a242:	4e1c      	ldr	r6, [pc, #112]	; (800a2b4 <getTime+0x84>)

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
 800a244:	491c      	ldr	r1, [pc, #112]	; (800a2b8 <getTime+0x88>)
 800a246:	f8df c074 	ldr.w	ip, [pc, #116]	; 800a2bc <getTime+0x8c>
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800a24a:	f89d e000 	ldrb.w	lr, [sp]
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800a24e:	f3c5 051a 	ubfx	r5, r5, #0, #27
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800a252:	fb83 2305 	smull	r2, r3, r3, r5
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800a256:	fb80 2005 	smull	r2, r0, r0, r5
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800a25a:	099b      	lsrs	r3, r3, #6
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800a25c:	0d00      	lsrs	r0, r0, #20
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800a25e:	fb83 6706 	smull	r6, r7, r3, r6

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
 800a262:	fb01 5110 	mls	r1, r1, r0, r5
	date->second = (timespec.millisecond / 1000) % 60;
 800a266:	19da      	adds	r2, r3, r7

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
 800a268:	fb8c 7601 	smull	r7, r6, ip, r1
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800a26c:	f89d 7001 	ldrb.w	r7, [sp, #1]
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800a270:	7120      	strb	r0, [r4, #4]
	date->minute = (timespec.millisecond%3600000) / 60000;
 800a272:	17c9      	asrs	r1, r1, #31
 800a274:	ebc1 31a6 	rsb	r1, r1, r6, asr #14
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800a278:	f3c7 0703 	ubfx	r7, r7, #0, #4
	date->day = timespec.day;
 800a27c:	f89d 6002 	ldrb.w	r6, [sp, #2]
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800a280:	70a7      	strb	r7, [r4, #2]
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800a282:	1152      	asrs	r2, r2, #5
	date->millisecond = timespec.millisecond % 1000;
 800a284:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800a288:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
 800a28c:	eba3 0282 	sub.w	r2, r3, r2, lsl #2
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800a290:	f50e 6efa 	add.w	lr, lr, #2000	; 0x7d0
	date->month = timespec.month;
	date->day = timespec.day;
 800a294:	f3c6 0604 	ubfx	r6, r6, #0, #5
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
	date->millisecond = timespec.millisecond % 1000;
 800a298:	fb07 5313 	mls	r3, r7, r3, r5
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800a29c:	f8a4 e000 	strh.w	lr, [r4]
	date->month = timespec.month;
	date->day = timespec.day;
 800a2a0:	70e6      	strb	r6, [r4, #3]
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
 800a2a2:	7161      	strb	r1, [r4, #5]
	date->second = (timespec.millisecond / 1000) % 60;
 800a2a4:	71a2      	strb	r2, [r4, #6]
	date->millisecond = timespec.millisecond % 1000;
 800a2a6:	8123      	strh	r3, [r4, #8]
}
 800a2a8:	b003      	add	sp, #12
 800a2aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a2ac:	10624dd3 	.word	0x10624dd3
 800a2b0:	4a90be59 	.word	0x4a90be59
 800a2b4:	88888889 	.word	0x88888889
 800a2b8:	0036ee80 	.word	0x0036ee80
 800a2bc:	45e7b273 	.word	0x45e7b273

0800a2c0 <I2C_read8>:
	I2C_unlock();
	return ret;
}

bool I2C_read8(uint8_t address, uint8_t reg, uint8_t *val)
{
 800a2c0:	b5f0      	push	{r4, r5, r6, r7, lr}
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800a2c2:	4c0d      	ldr	r4, [pc, #52]	; (800a2f8 <I2C_read8+0x38>)
	I2C_unlock();
	return ret;
}

bool I2C_read8(uint8_t address, uint8_t reg, uint8_t *val)
{
 800a2c4:	b085      	sub	sp, #20
 800a2c6:	4607      	mov	r7, r0
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800a2c8:	4620      	mov	r0, r4
	I2C_unlock();
	return ret;
}

bool I2C_read8(uint8_t address, uint8_t reg, uint8_t *val)
{
 800a2ca:	460d      	mov	r5, r1
 800a2cc:	4616      	mov	r6, r2
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800a2ce:	f004 fe0f 	bl	800eef0 <chMtxLock>
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800a2d2:	2201      	movs	r2, #1
 800a2d4:	9200      	str	r2, [sp, #0]
 800a2d6:	ab02      	add	r3, sp, #8
 800a2d8:	a903      	add	r1, sp, #12
 800a2da:	4638      	mov	r0, r7
	return I2C_send(address, txbuf, length, NULL, 0, MS2ST(100));
}

bool I2C_read8_locked(uint8_t address, uint8_t reg, uint8_t *val)
{
	uint8_t txbuf[] = {reg};
 800a2dc:	f88d 500c 	strb.w	r5, [sp, #12]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800a2e0:	f003 ff6e 	bl	800e1c0 <i2cSendDriver.constprop.25>
bool I2C_read8_locked(uint8_t address, uint8_t reg, uint8_t *val)
{
	uint8_t txbuf[] = {reg};
	uint8_t rxbuf[1];
	bool ret = I2C_send(address, txbuf, 1, rxbuf, 1, MS2ST(100));
	*val = rxbuf[0];
 800a2e4:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800a2e8:	7033      	strb	r3, [r6, #0]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800a2ea:	4605      	mov	r5, r0
/**
  * Unlocks all other I2C threads to access I2C
  */
void I2C_unlock(void)
{
	chMtxUnlock(&pi2c_mtx);
 800a2ec:	4620      	mov	r0, r4
 800a2ee:	f004 fd9f 	bl	800ee30 <chMtxUnlock>
{
	I2C_lock();
	bool ret = I2C_read8_locked(address, reg, val);
	I2C_unlock();
	return ret;
}
 800a2f2:	4628      	mov	r0, r5
 800a2f4:	b005      	add	sp, #20
 800a2f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a2f8:	200278f8 	.word	0x200278f8
 800a2fc:	00000000 	.word	0x00000000

0800a300 <I2C_write8>:
}

// I2C Mutex unlocked access functions

bool I2C_write8(uint8_t address, uint8_t reg, uint8_t value)
{
 800a300:	b5f0      	push	{r4, r5, r6, r7, lr}
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800a302:	4c0d      	ldr	r4, [pc, #52]	; (800a338 <I2C_write8+0x38>)
}

// I2C Mutex unlocked access functions

bool I2C_write8(uint8_t address, uint8_t reg, uint8_t value)
{
 800a304:	b085      	sub	sp, #20
 800a306:	4607      	mov	r7, r0
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800a308:	4620      	mov	r0, r4
}

// I2C Mutex unlocked access functions

bool I2C_write8(uint8_t address, uint8_t reg, uint8_t value)
{
 800a30a:	460e      	mov	r6, r1
 800a30c:	4615      	mov	r5, r2
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800a30e:	f004 fdef 	bl	800eef0 <chMtxLock>
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800a312:	2300      	movs	r3, #0
 800a314:	9300      	str	r3, [sp, #0]
 800a316:	2202      	movs	r2, #2
 800a318:	a903      	add	r1, sp, #12
 800a31a:	4638      	mov	r0, r7

// I2C Mutex locked access functions

bool I2C_write8_locked(uint8_t address, uint8_t reg, uint8_t value)
{
	uint8_t txbuf[] = {reg, value};
 800a31c:	f88d 500d 	strb.w	r5, [sp, #13]
 800a320:	f88d 600c 	strb.w	r6, [sp, #12]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800a324:	f003 ff4c 	bl	800e1c0 <i2cSendDriver.constprop.25>
 800a328:	4605      	mov	r5, r0

bool I2C_write8(uint8_t address, uint8_t reg, uint8_t value)
{
	I2C_lock();
	bool ret = I2C_write8_locked(address, reg, value);
	chMtxUnlock(&pi2c_mtx);
 800a32a:	4620      	mov	r0, r4
 800a32c:	f004 fd80 	bl	800ee30 <chMtxUnlock>
	return ret;
}
 800a330:	4628      	mov	r0, r5
 800a332:	b005      	add	sp, #20
 800a334:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a336:	bf00      	nop
 800a338:	200278f8 	.word	0x200278f8
 800a33c:	00000000 	.word	0x00000000

0800a340 <I2C_read16_locked>:
	*val = rxbuf[0];
	return ret;
}

bool I2C_read16_locked(uint8_t address, uint8_t reg, uint16_t *val)
{
 800a340:	b510      	push	{r4, lr}
 800a342:	b084      	sub	sp, #16
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800a344:	2302      	movs	r3, #2
	*val = rxbuf[0];
	return ret;
}

bool I2C_read16_locked(uint8_t address, uint8_t reg, uint16_t *val)
{
 800a346:	4614      	mov	r4, r2
	uint8_t txbuf[] = {reg};
 800a348:	f88d 1008 	strb.w	r1, [sp, #8]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800a34c:	9300      	str	r3, [sp, #0]
 800a34e:	2201      	movs	r2, #1
 800a350:	ab03      	add	r3, sp, #12
 800a352:	a902      	add	r1, sp, #8
 800a354:	f003 ff34 	bl	800e1c0 <i2cSendDriver.constprop.25>
bool I2C_read16_locked(uint8_t address, uint8_t reg, uint16_t *val)
{
	uint8_t txbuf[] = {reg};
	uint8_t rxbuf[2];
	bool ret = I2C_send(address, txbuf, 1, rxbuf, 2, MS2ST(100));
	*val =  (rxbuf[0] << 8) | rxbuf[1];
 800a358:	f89d 200c 	ldrb.w	r2, [sp, #12]
 800a35c:	f89d 300d 	ldrb.w	r3, [sp, #13]
 800a360:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800a364:	8023      	strh	r3, [r4, #0]
	return ret;
}
 800a366:	b004      	add	sp, #16
 800a368:	bd10      	pop	{r4, pc}
 800a36a:	bf00      	nop
 800a36c:	0000      	movs	r0, r0
	...

0800a370 <I2C_read16_LE>:
	bool ret = I2C_read16_locked(address, reg, val);
	I2C_unlock();
	return ret;
}

bool I2C_read16_LE(uint8_t address, uint8_t reg, uint16_t *val) {
 800a370:	b510      	push	{r4, lr}
 800a372:	4614      	mov	r4, r2
	bool ret = I2C_read16_locked(address, reg, val);
 800a374:	f7ff ffe4 	bl	800a340 <I2C_read16_locked>
	*val = (*val >> 8) | (*val << 8);
 800a378:	8822      	ldrh	r2, [r4, #0]
 800a37a:	0213      	lsls	r3, r2, #8
 800a37c:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800a380:	8023      	strh	r3, [r4, #0]
	return ret;
}
 800a382:	bd10      	pop	{r4, pc}
	...

0800a390 <I2C_read16>:
	I2C_unlock();
	return ret;
}

bool I2C_read16(uint8_t address, uint8_t reg, uint16_t *val)
{
 800a390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800a392:	4c09      	ldr	r4, [pc, #36]	; (800a3b8 <I2C_read16+0x28>)
	I2C_unlock();
	return ret;
}

bool I2C_read16(uint8_t address, uint8_t reg, uint16_t *val)
{
 800a394:	4605      	mov	r5, r0
 800a396:	460e      	mov	r6, r1
 800a398:	4617      	mov	r7, r2
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800a39a:	4620      	mov	r0, r4
 800a39c:	f004 fda8 	bl	800eef0 <chMtxLock>
}

bool I2C_read16(uint8_t address, uint8_t reg, uint16_t *val)
{
	I2C_lock();
	bool ret = I2C_read16_locked(address, reg, val);
 800a3a0:	463a      	mov	r2, r7
 800a3a2:	4631      	mov	r1, r6
 800a3a4:	4628      	mov	r0, r5
 800a3a6:	f7ff ffcb 	bl	800a340 <I2C_read16_locked>
 800a3aa:	4605      	mov	r5, r0
/**
  * Unlocks all other I2C threads to access I2C
  */
void I2C_unlock(void)
{
	chMtxUnlock(&pi2c_mtx);
 800a3ac:	4620      	mov	r0, r4
 800a3ae:	f004 fd3f 	bl	800ee30 <chMtxUnlock>
{
	I2C_lock();
	bool ret = I2C_read16_locked(address, reg, val);
	I2C_unlock();
	return ret;
}
 800a3b2:	4628      	mov	r0, r5
 800a3b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a3b6:	bf00      	nop
 800a3b8:	200278f8 	.word	0x200278f8
 800a3bc:	00000000 	.word	0x00000000

0800a3c0 <dah>:
	buffer[c/8] |= ((bit & 0x1) << (c % 8)); \
	c++; \
}

void dah(void)
{
 800a3c0:	b470      	push	{r4, r5, r6}
	ADDB(1);
 800a3c2:	4d12      	ldr	r5, [pc, #72]	; (800a40c <dah+0x4c>)
 800a3c4:	4a12      	ldr	r2, [pc, #72]	; (800a410 <dah+0x50>)
 800a3c6:	682b      	ldr	r3, [r5, #0]
 800a3c8:	6811      	ldr	r1, [r2, #0]
 800a3ca:	08de      	lsrs	r6, r3, #3
 800a3cc:	2001      	movs	r0, #1
 800a3ce:	5d8a      	ldrb	r2, [r1, r6]
 800a3d0:	f003 0407 	and.w	r4, r3, #7
 800a3d4:	fa00 f404 	lsl.w	r4, r0, r4
 800a3d8:	4314      	orrs	r4, r2
 800a3da:	181a      	adds	r2, r3, r0
 800a3dc:	558c      	strb	r4, [r1, r6]
	ADDB(1);
 800a3de:	08d6      	lsrs	r6, r2, #3
	c++; \
}

void dah(void)
{
	ADDB(1);
 800a3e0:	602a      	str	r2, [r5, #0]
	ADDB(1);
 800a3e2:	5d8c      	ldrb	r4, [r1, r6]
 800a3e4:	f002 0207 	and.w	r2, r2, #7
 800a3e8:	fa00 f202 	lsl.w	r2, r0, r2
 800a3ec:	4322      	orrs	r2, r4
 800a3ee:	1c9c      	adds	r4, r3, #2
 800a3f0:	558a      	strb	r2, [r1, r6]
	ADDB(1);
 800a3f2:	08e6      	lsrs	r6, r4, #3
}

void dah(void)
{
	ADDB(1);
	ADDB(1);
 800a3f4:	602c      	str	r4, [r5, #0]
	ADDB(1);
 800a3f6:	5d8a      	ldrb	r2, [r1, r6]
 800a3f8:	f004 0407 	and.w	r4, r4, #7
 800a3fc:	40a0      	lsls	r0, r4
 800a3fe:	4310      	orrs	r0, r2
 800a400:	5588      	strb	r0, [r1, r6]
	ADDB(0);
 800a402:	3304      	adds	r3, #4
 800a404:	602b      	str	r3, [r5, #0]
}
 800a406:	bc70      	pop	{r4, r5, r6}
 800a408:	4770      	bx	lr
 800a40a:	bf00      	nop
 800a40c:	20027880 	.word	0x20027880
 800a410:	20027890 	.word	0x20027890
	...

0800a420 <nrzi_encode>:
/**
  * NRZ-I tone encoding (0: bit change, 1: no bit change)
  */
void nrzi_encode(ax25_t *packet) {
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 800a420:	8903      	ldrh	r3, [r0, #8]
 800a422:	b32b      	cbz	r3, 800a470 <nrzi_encode+0x50>
 800a424:	2200      	movs	r2, #0
}

/**
  * NRZ-I tone encoding (0: bit change, 1: no bit change)
  */
void nrzi_encode(ax25_t *packet) {
 800a426:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 800a428:	4696      	mov	lr, r2
		if(((packet->data[i >> 3] >> (i & 0x7)) & 0x1) == 0)
			ctone = !ctone;
		if(ctone) {
			AX25_WRITE_BIT(packet->data, i);
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 800a42a:	2701      	movs	r7, #1
 800a42c:	e004      	b.n	800a438 <nrzi_encode+0x18>
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		if(((packet->data[i >> 3] >> (i & 0x7)) & 0x1) == 0)
			ctone = !ctone;
		if(ctone) {
			AX25_WRITE_BIT(packet->data, i);
 800a42e:	5574      	strb	r4, [r6, r5]
/**
  * NRZ-I tone encoding (0: bit change, 1: no bit change)
  */
void nrzi_encode(ax25_t *packet) {
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 800a430:	8903      	ldrh	r3, [r0, #8]
 800a432:	3201      	adds	r2, #1
 800a434:	4293      	cmp	r3, r2
 800a436:	d91a      	bls.n	800a46e <nrzi_encode+0x4e>
		if(((packet->data[i >> 3] >> (i & 0x7)) & 0x1) == 0)
 800a438:	08d5      	lsrs	r5, r2, #3
 800a43a:	6846      	ldr	r6, [r0, #4]
 800a43c:	5d71      	ldrb	r1, [r6, r5]
 800a43e:	f002 0307 	and.w	r3, r2, #7
 800a442:	fa41 fc03 	asr.w	ip, r1, r3
 800a446:	f01c 0f01 	tst.w	ip, #1
			ctone = !ctone;
		if(ctone) {
			AX25_WRITE_BIT(packet->data, i);
 800a44a:	fa07 f403 	lsl.w	r4, r7, r3
 800a44e:	bf08      	it	eq
 800a450:	f08e 0e01 	eoreq.w	lr, lr, #1
 800a454:	430c      	orrs	r4, r1
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 800a456:	fa07 f303 	lsl.w	r3, r7, r3
void nrzi_encode(ax25_t *packet) {
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		if(((packet->data[i >> 3] >> (i & 0x7)) & 0x1) == 0)
			ctone = !ctone;
		if(ctone) {
 800a45a:	f1be 0f00 	cmp.w	lr, #0
 800a45e:	d1e6      	bne.n	800a42e <nrzi_encode+0xe>
			AX25_WRITE_BIT(packet->data, i);
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 800a460:	ea21 0303 	bic.w	r3, r1, r3
 800a464:	5573      	strb	r3, [r6, r5]
/**
  * NRZ-I tone encoding (0: bit change, 1: no bit change)
  */
void nrzi_encode(ax25_t *packet) {
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 800a466:	8903      	ldrh	r3, [r0, #8]
 800a468:	3201      	adds	r2, #1
 800a46a:	4293      	cmp	r3, r2
 800a46c:	d8e4      	bhi.n	800a438 <nrzi_encode+0x18>
 800a46e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a470:	4770      	bx	lr
 800a472:	bf00      	nop
	...

0800a480 <scramble>:

/**
  * Scrambling for 2GFSK
  */
void scramble(ax25_t *packet) {
	if(packet->mod != MOD_2GFSK)
 800a480:	7b83      	ldrb	r3, [r0, #14]
 800a482:	2b02      	cmp	r3, #2
 800a484:	d000      	beq.n	800a488 <scramble+0x8>
 800a486:	4770      	bx	lr
}

/**
  * Scrambling for 2GFSK
  */
void scramble(ax25_t *packet) {
 800a488:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if(packet->mod != MOD_2GFSK)
		return; // Scrambling not necessary

	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 800a48c:	8903      	ldrh	r3, [r0, #8]
void scramble(ax25_t *packet) {
	if(packet->mod != MOD_2GFSK)
		return; // Scrambling not necessary

	// Scramble
	lfsr = 0;
 800a48e:	f8df 8068 	ldr.w	r8, [pc, #104]	; 800a4f8 <scramble+0x78>
 800a492:	2500      	movs	r5, #0
 800a494:	4686      	mov	lr, r0
 800a496:	f8c8 5000 	str.w	r5, [r8]
	for(uint32_t i=0; i<packet->size; i++) {
 800a49a:	b353      	cbz	r3, 800a4f2 <scramble+0x72>
 800a49c:	462c      	mov	r4, r5
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
		if(bit) {
			AX25_WRITE_BIT(packet->data, i);
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 800a49e:	f04f 0c01 	mov.w	ip, #1
 800a4a2:	e005      	b.n	800a4b0 <scramble+0x30>
	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
		if(bit) {
			AX25_WRITE_BIT(packet->data, i);
 800a4a4:	55c2      	strb	r2, [r0, r7]
	if(packet->mod != MOD_2GFSK)
		return; // Scrambling not necessary

	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 800a4a6:	f8be 3008 	ldrh.w	r3, [lr, #8]
 800a4aa:	3401      	adds	r4, #1
 800a4ac:	429c      	cmp	r4, r3
 800a4ae:	d21e      	bcs.n	800a4ee <scramble+0x6e>
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
 800a4b0:	08e7      	lsrs	r7, r4, #3
 800a4b2:	f8de 0004 	ldr.w	r0, [lr, #4]
 800a4b6:	5dc6      	ldrb	r6, [r0, r7]
 800a4b8:	f004 0107 	and.w	r1, r4, #7
		packet->crc = packet->crc >> 1;
}

uint32_t lfsr;
uint8_t scramble_bit(uint8_t _in) {
	uint8_t x = (_in ^ (lfsr >> 16) ^ (lfsr >> 11)) & 1;
 800a4bc:	0aeb      	lsrs	r3, r5, #11
 800a4be:	fa46 f201 	asr.w	r2, r6, r1
 800a4c2:	ea83 4315 	eor.w	r3, r3, r5, lsr #16
 800a4c6:	4053      	eors	r3, r2
 800a4c8:	f003 0301 	and.w	r3, r3, #1
	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
		if(bit) {
			AX25_WRITE_BIT(packet->data, i);
 800a4cc:	fa0c f201 	lsl.w	r2, ip, r1
 800a4d0:	4332      	orrs	r2, r6
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 800a4d2:	fa0c f101 	lsl.w	r1, ip, r1
}

uint32_t lfsr;
uint8_t scramble_bit(uint8_t _in) {
	uint8_t x = (_in ^ (lfsr >> 16) ^ (lfsr >> 11)) & 1;
	lfsr = (lfsr << 1) | (x & 1);
 800a4d6:	ea43 0545 	orr.w	r5, r3, r5, lsl #1

	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
		if(bit) {
 800a4da:	2b00      	cmp	r3, #0
 800a4dc:	d1e2      	bne.n	800a4a4 <scramble+0x24>
			AX25_WRITE_BIT(packet->data, i);
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 800a4de:	ea26 0101 	bic.w	r1, r6, r1
 800a4e2:	55c1      	strb	r1, [r0, r7]
	if(packet->mod != MOD_2GFSK)
		return; // Scrambling not necessary

	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 800a4e4:	f8be 3008 	ldrh.w	r3, [lr, #8]
 800a4e8:	3401      	adds	r4, #1
 800a4ea:	429c      	cmp	r4, r3
 800a4ec:	d3e0      	bcc.n	800a4b0 <scramble+0x30>
 800a4ee:	f8c8 5000 	str.w	r5, [r8]
 800a4f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a4f6:	bf00      	nop
 800a4f8:	2002787c 	.word	0x2002787c
 800a4fc:	00000000 	.word	0x00000000

0800a500 <ax25_send_flag>:
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
	}
}

void ax25_send_flag(ax25_t *packet)
{
 800a500:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
 800a504:	2200      	movs	r2, #0
 800a506:	8903      	ldrh	r3, [r0, #8]
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
      return;
    if((byte >> i) & 1)
 800a508:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
    else
      packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800a50c:	2501      	movs	r5, #1
 800a50e:	e00c      	b.n	800a52a <ax25_send_flag+0x2a>
  int i;
  for(i=0; i<8; i++, packet->size++) {
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
      return;
    if((byte >> i) & 1)
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
 800a510:	6843      	ldr	r3, [r0, #4]
 800a512:	f813 100e 	ldrb.w	r1, [r3, lr]
 800a516:	4321      	orrs	r1, r4
 800a518:	f803 100e 	strb.w	r1, [r3, lr]

void ax25_send_flag(ax25_t *packet)
{
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
 800a51c:	8903      	ldrh	r3, [r0, #8]
 800a51e:	3201      	adds	r2, #1
 800a520:	3301      	adds	r3, #1
 800a522:	b29b      	uxth	r3, r3
 800a524:	2a08      	cmp	r2, #8
 800a526:	8103      	strh	r3, [r0, #8]
 800a528:	d017      	beq.n	800a55a <ax25_send_flag+0x5a>
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800a52a:	8946      	ldrh	r6, [r0, #10]
      return;
    if((byte >> i) & 1)
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
 800a52c:	f003 0107 	and.w	r1, r3, #7
 800a530:	fa05 f401 	lsl.w	r4, r5, r1
void ax25_send_flag(ax25_t *packet)
{
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800a534:	ebb3 0fc6 	cmp.w	r3, r6, lsl #3
      return;
    if((byte >> i) & 1)
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
 800a538:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
      return;
    if((byte >> i) & 1)
 800a53c:	fa4c f802 	asr.w	r8, ip, r2
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
    else
      packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800a540:	4621      	mov	r1, r4
void ax25_send_flag(ax25_t *packet)
{
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800a542:	da0a      	bge.n	800a55a <ax25_send_flag+0x5a>
      return;
    if((byte >> i) & 1)
 800a544:	f018 0f01 	tst.w	r8, #1
 800a548:	d1e2      	bne.n	800a510 <ax25_send_flag+0x10>
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
    else
      packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800a54a:	6844      	ldr	r4, [r0, #4]
 800a54c:	f814 300e 	ldrb.w	r3, [r4, lr]
 800a550:	ea23 0101 	bic.w	r1, r3, r1
 800a554:	f804 100e 	strb.w	r1, [r4, lr]
 800a558:	e7e0      	b.n	800a51c <ax25_send_flag+0x1c>
 800a55a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a55e:	bf00      	nop

0800a560 <send_byte.lto_priv.112>:
	lfsr = (lfsr << 1) | (x & 1);
	return x;
}

static void send_byte(ax25_t *packet, char byte)
{
 800a560:	b5f0      	push	{r4, r5, r6, r7, lr}
	int i;
	for(i=0; i<8; i++) {
 800a562:	2400      	movs	r4, #0
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);

		packet->size++;
		packet->ones_in_a_row = 0;
 800a564:	4626      	mov	r6, r4
		}
		// Next bit is a '0' or a zero padding after 5 ones in a row
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);
 800a566:	2501      	movs	r5, #1
	data[size >> 3] &= ~(1 << (size & 7)); \
}

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
 800a568:	8983      	ldrh	r3, [r0, #12]

static void send_byte(ax25_t *packet, char byte)
{
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
 800a56a:	fa41 f204 	asr.w	r2, r1, r4
	data[size >> 3] &= ~(1 << (size & 7)); \
}

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
 800a56e:	f002 0201 	and.w	r2, r2, #1
 800a572:	4053      	eors	r3, r2
	if(packet->crc & 1)
		packet->crc = (packet->crc >> 1) ^ 0x8408;  // X-modem CRC poly
 800a574:	085f      	lsrs	r7, r3, #1
}

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
	if(packet->crc & 1)
 800a576:	f013 0f01 	tst.w	r3, #1
		packet->crc = (packet->crc >> 1) ^ 0x8408;  // X-modem CRC poly
 800a57a:	f487 4704 	eor.w	r7, r7, #33792	; 0x8400
	data[size >> 3] &= ~(1 << (size & 7)); \
}

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
 800a57e:	8183      	strh	r3, [r0, #12]
	if(packet->crc & 1)
		packet->crc = (packet->crc >> 1) ^ 0x8408;  // X-modem CRC poly
 800a580:	f087 0708 	eor.w	r7, r7, #8
	else
		packet->crc = packet->crc >> 1;
 800a584:	bf06      	itte	eq
 800a586:	085b      	lsreq	r3, r3, #1
 800a588:	8183      	strheq	r3, [r0, #12]

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
	if(packet->crc & 1)
		packet->crc = (packet->crc >> 1) ^ 0x8408;  // X-modem CRC poly
 800a58a:	8187      	strhne	r7, [r0, #12]
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
		if((byte >> i) & 1) {
			// Next bit is a '1'
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800a58c:	8903      	ldrh	r3, [r0, #8]
static void send_byte(ax25_t *packet, char byte)
{
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
		if((byte >> i) & 1) {
 800a58e:	b1da      	cbz	r2, 800a5c8 <send_byte.lto_priv.112+0x68>
			// Next bit is a '1'
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800a590:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
				return;

			AX25_WRITE_BIT(packet->data, packet->size);
 800a594:	f003 0207 	and.w	r2, r3, #7
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
		if((byte >> i) & 1) {
			// Next bit is a '1'
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800a598:	ebb3 0fce 	cmp.w	r3, lr, lsl #3
				return;

			AX25_WRITE_BIT(packet->data, packet->size);
 800a59c:	ea4f 07d3 	mov.w	r7, r3, lsr #3
 800a5a0:	fa05 f202 	lsl.w	r2, r5, r2
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
		if((byte >> i) & 1) {
			// Next bit is a '1'
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800a5a4:	da2a      	bge.n	800a5fc <send_byte.lto_priv.112+0x9c>
				return;

			AX25_WRITE_BIT(packet->data, packet->size);
 800a5a6:	f8d0 e004 	ldr.w	lr, [r0, #4]
 800a5aa:	f81e 3007 	ldrb.w	r3, [lr, r7]
 800a5ae:	431a      	orrs	r2, r3
 800a5b0:	f80e 2007 	strb.w	r2, [lr, r7]

			packet->size++;
			packet->ones_in_a_row++;
 800a5b4:	7802      	ldrb	r2, [r0, #0]
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
				return;

			AX25_WRITE_BIT(packet->data, packet->size);

			packet->size++;
 800a5b6:	8903      	ldrh	r3, [r0, #8]
			packet->ones_in_a_row++;
 800a5b8:	3201      	adds	r2, #1
 800a5ba:	b2d2      	uxtb	r2, r2
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
				return;

			AX25_WRITE_BIT(packet->data, packet->size);

			packet->size++;
 800a5bc:	3301      	adds	r3, #1
 800a5be:	b29b      	uxth	r3, r3
			packet->ones_in_a_row++;
			if(packet->ones_in_a_row < 5)
 800a5c0:	2a04      	cmp	r2, #4
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
				return;

			AX25_WRITE_BIT(packet->data, packet->size);

			packet->size++;
 800a5c2:	8103      	strh	r3, [r0, #8]
			packet->ones_in_a_row++;
 800a5c4:	7002      	strb	r2, [r0, #0]
			if(packet->ones_in_a_row < 5)
 800a5c6:	d916      	bls.n	800a5f6 <send_byte.lto_priv.112+0x96>
				continue;
		}
		// Next bit is a '0' or a zero padding after 5 ones in a row
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
 800a5c8:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);
 800a5cc:	f003 0207 	and.w	r2, r3, #7
			packet->ones_in_a_row++;
			if(packet->ones_in_a_row < 5)
				continue;
		}
		// Next bit is a '0' or a zero padding after 5 ones in a row
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
 800a5d0:	ebb3 0fce 	cmp.w	r3, lr, lsl #3
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);
 800a5d4:	ea4f 07d3 	mov.w	r7, r3, lsr #3
 800a5d8:	fa05 f202 	lsl.w	r2, r5, r2
			packet->ones_in_a_row++;
			if(packet->ones_in_a_row < 5)
				continue;
		}
		// Next bit is a '0' or a zero padding after 5 ones in a row
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
 800a5dc:	da0e      	bge.n	800a5fc <send_byte.lto_priv.112+0x9c>
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);
 800a5de:	f8d0 e004 	ldr.w	lr, [r0, #4]
 800a5e2:	f81e 3007 	ldrb.w	r3, [lr, r7]
 800a5e6:	ea23 0202 	bic.w	r2, r3, r2
 800a5ea:	f80e 2007 	strb.w	r2, [lr, r7]

		packet->size++;
 800a5ee:	8903      	ldrh	r3, [r0, #8]
		packet->ones_in_a_row = 0;
 800a5f0:	7006      	strb	r6, [r0, #0]
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);

		packet->size++;
 800a5f2:	3301      	adds	r3, #1
 800a5f4:	8103      	strh	r3, [r0, #8]
}

static void send_byte(ax25_t *packet, char byte)
{
	int i;
	for(i=0; i<8; i++) {
 800a5f6:	3401      	adds	r4, #1
 800a5f8:	2c08      	cmp	r4, #8
 800a5fa:	d1b5      	bne.n	800a568 <send_byte.lto_priv.112+0x8>
 800a5fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a5fe:	bf00      	nop

0800a600 <ax25_send_footer>:
	// Transmit SSID. Termination signaled with last bit = 1
	send_byte(packet, ('0' + ssid) << 1 | (last & 0x1));
}

void ax25_send_footer(ax25_t *packet)
{
 800a600:	b538      	push	{r3, r4, r5, lr}
	// Save the crc so that it can be treated it atomically
	uint16_t final_crc = packet->crc;
 800a602:	8984      	ldrh	r4, [r0, #12]

	// Send CRC
	send_byte(packet, ~(final_crc & 0xff));
 800a604:	43e1      	mvns	r1, r4
 800a606:	b2c9      	uxtb	r1, r1
	final_crc >>= 8;
 800a608:	0a24      	lsrs	r4, r4, #8
{
	// Save the crc so that it can be treated it atomically
	uint16_t final_crc = packet->crc;

	// Send CRC
	send_byte(packet, ~(final_crc & 0xff));
 800a60a:	f7ff ffa9 	bl	800a560 <send_byte.lto_priv.112>
	final_crc >>= 8;
	send_byte(packet, ~(final_crc & 0xff));
 800a60e:	43e1      	mvns	r1, r4
 800a610:	b2c9      	uxtb	r1, r1
 800a612:	f7ff ffa5 	bl	800a560 <send_byte.lto_priv.112>

	packet->crc = final_crc;
 800a616:	8184      	strh	r4, [r0, #12]

	// Signal the end of frame
	ax25_send_flag(packet);
}
 800a618:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	send_byte(packet, ~(final_crc & 0xff));

	packet->crc = final_crc;

	// Signal the end of frame
	ax25_send_flag(packet);
 800a61c:	f7ff bf70 	b.w	800a500 <ax25_send_flag>

0800a620 <ax25_send_path>:
	// Protocol ID: 0xf0 = no layer 3 data
	send_byte(packet, 0xf0);
}

void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
 800a620:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a624:	4688      	mov	r8, r1
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800a626:	7809      	ldrb	r1, [r1, #0]
	// Protocol ID: 0xf0 = no layer 3 data
	send_byte(packet, 0xf0);
}

void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
 800a628:	4605      	mov	r5, r0
 800a62a:	4616      	mov	r6, r2
 800a62c:	461f      	mov	r7, r3
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800a62e:	b301      	cbz	r1, 800a672 <ax25_send_path+0x52>
 800a630:	2400      	movs	r4, #0
 800a632:	3401      	adds	r4, #1
		send_byte(packet, callsign[j] << 1);
 800a634:	0049      	lsls	r1, r1, #1
void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800a636:	b2e4      	uxtb	r4, r4
		send_byte(packet, callsign[j] << 1);
 800a638:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 800a63c:	4628      	mov	r0, r5
 800a63e:	f7ff ff8f 	bl	800a560 <send_byte.lto_priv.112>
void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800a642:	f818 1004 	ldrb.w	r1, [r8, r4]
 800a646:	2900      	cmp	r1, #0
 800a648:	d1f3      	bne.n	800a632 <ax25_send_path+0x12>
		send_byte(packet, callsign[j] << 1);
	}

	// Transmit pad
	for( ; j < 6; j++)
 800a64a:	2c05      	cmp	r4, #5
 800a64c:	d807      	bhi.n	800a65e <ax25_send_path+0x3e>
 800a64e:	3401      	adds	r4, #1
		send_byte(packet, ' ' << 1);
 800a650:	2140      	movs	r1, #64	; 0x40
 800a652:	4628      	mov	r0, r5
	for(j = 0; callsign[j]; j++) {
		send_byte(packet, callsign[j] << 1);
	}

	// Transmit pad
	for( ; j < 6; j++)
 800a654:	b2e4      	uxtb	r4, r4
		send_byte(packet, ' ' << 1);
 800a656:	f7ff ff83 	bl	800a560 <send_byte.lto_priv.112>
	for(j = 0; callsign[j]; j++) {
		send_byte(packet, callsign[j] << 1);
	}

	// Transmit pad
	for( ; j < 6; j++)
 800a65a:	2c06      	cmp	r4, #6
 800a65c:	d1f7      	bne.n	800a64e <ax25_send_path+0x2e>
		send_byte(packet, ' ' << 1);

	// Transmit SSID. Termination signaled with last bit = 1
	send_byte(packet, ('0' + ssid) << 1 | (last & 0x1));
 800a65e:	f106 0130 	add.w	r1, r6, #48	; 0x30
 800a662:	ea47 0141 	orr.w	r1, r7, r1, lsl #1
 800a666:	4628      	mov	r0, r5
 800a668:	b2c9      	uxtb	r1, r1
}
 800a66a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	// Transmit pad
	for( ; j < 6; j++)
		send_byte(packet, ' ' << 1);

	// Transmit SSID. Termination signaled with last bit = 1
	send_byte(packet, ('0' + ssid) << 1 | (last & 0x1));
 800a66e:	f7ff bf77 	b.w	800a560 <send_byte.lto_priv.112>
void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800a672:	460c      	mov	r4, r1
 800a674:	e7eb      	b.n	800a64e <ax25_send_path+0x2e>
 800a676:	bf00      	nop
	...

0800a680 <ax25_send_string>:
      packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
  }
}

void ax25_send_string(ax25_t *packet, const char *string)
{
 800a680:	b538      	push	{r3, r4, r5, lr}
 800a682:	460c      	mov	r4, r1
	int i;
	for(i=0; string[i]; i++) {
 800a684:	7809      	ldrb	r1, [r1, #0]
 800a686:	b139      	cbz	r1, 800a698 <ax25_send_string+0x18>
 800a688:	4605      	mov	r5, r0
	}
}

void ax25_send_byte(ax25_t *packet, char byte)
{
	send_byte(packet, byte);
 800a68a:	4628      	mov	r0, r5
 800a68c:	f7ff ff68 	bl	800a560 <send_byte.lto_priv.112>
}

void ax25_send_string(ax25_t *packet, const char *string)
{
	int i;
	for(i=0; string[i]; i++) {
 800a690:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 800a694:	2900      	cmp	r1, #0
 800a696:	d1f8      	bne.n	800a68a <ax25_send_string+0xa>
 800a698:	bd38      	pop	{r3, r4, r5, pc}
 800a69a:	bf00      	nop
 800a69c:	0000      	movs	r0, r0
	...

0800a6a0 <aprs_encode_experimental>:

/**
 * Transmit custom experimental packet
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
 800a6a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a6a2:	461c      	mov	r4, r3
 800a6a4:	b087      	sub	sp, #28
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 800a6a6:	7c1b      	ldrb	r3, [r3, #16]
 800a6a8:	8ca5      	ldrh	r5, [r4, #36]	; 0x24
 * Transmit custom experimental packet
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
	ax25_t packet;
	packet.data = message;
 800a6aa:	9103      	str	r1, [sp, #12]

/**
 * Transmit custom experimental packet
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
 800a6ac:	4607      	mov	r7, r0
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 800a6ae:	4621      	mov	r1, r4
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;
 800a6b0:	f88d 2016 	strb.w	r2, [sp, #22]

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 800a6b4:	9500      	str	r5, [sp, #0]
 800a6b6:	461a      	mov	r2, r3
 800a6b8:	a802      	add	r0, sp, #8
 800a6ba:	f104 0314 	add.w	r3, r4, #20
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 800a6be:	f44f 7400 	mov.w	r4, #512	; 0x200

/**
 * Transmit custom experimental packet
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
 800a6c2:	9d0d      	ldr	r5, [sp, #52]	; 0x34
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 800a6c4:	f8ad 4012 	strh.w	r4, [sp, #18]

/**
 * Transmit custom experimental packet
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
 800a6c8:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 800a6ca:	f003 fc39 	bl	800df40 <ax25_send_header.constprop.16>
	ax25_send_string(&packet, "{{");
 800a6ce:	a802      	add	r0, sp, #8
 800a6d0:	490f      	ldr	r1, [pc, #60]	; (800a710 <aprs_encode_experimental+0x70>)
 800a6d2:	f7ff ffd5 	bl	800a680 <ax25_send_string>
	}
}

void ax25_send_byte(ax25_t *packet, char byte)
{
	send_byte(packet, byte);
 800a6d6:	4639      	mov	r1, r7
 800a6d8:	a802      	add	r0, sp, #8
 800a6da:	f7ff ff41 	bl	800a560 <send_byte.lto_priv.112>
	ax25_send_byte(&packet, packetType);

	// Encode message
	for(uint16_t i=0; i<size; i++)
 800a6de:	b155      	cbz	r5, 800a6f6 <aprs_encode_experimental+0x56>
 800a6e0:	2300      	movs	r3, #0
 800a6e2:	461c      	mov	r4, r3
 800a6e4:	3401      	adds	r4, #1
 800a6e6:	5cf1      	ldrb	r1, [r6, r3]
 800a6e8:	b2a4      	uxth	r4, r4
 800a6ea:	a802      	add	r0, sp, #8
 800a6ec:	f7ff ff38 	bl	800a560 <send_byte.lto_priv.112>
 800a6f0:	42ac      	cmp	r4, r5
 800a6f2:	4623      	mov	r3, r4
 800a6f4:	d3f6      	bcc.n	800a6e4 <aprs_encode_experimental+0x44>
		ax25_send_byte(&packet, data[i]);

	// Send footer
	ax25_send_footer(&packet);
 800a6f6:	a802      	add	r0, sp, #8
 800a6f8:	f7ff ff82 	bl	800a600 <ax25_send_footer>
	scramble(&packet);
 800a6fc:	a802      	add	r0, sp, #8
 800a6fe:	f7ff febf 	bl	800a480 <scramble>
	nrzi_encode(&packet);
 800a702:	a802      	add	r0, sp, #8
 800a704:	f7ff fe8c 	bl	800a420 <nrzi_encode>

	return packet.size;
 800a708:	f8bd 0010 	ldrh.w	r0, [sp, #16]
}
 800a70c:	b007      	add	sp, #28
 800a70e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a710:	0801565c 	.word	0x0801565c
	...

0800a720 <ssdv_have_marker.lto_priv.157>:
	for(; n > 0; n--) *(s++) = (l = l * 245 + 45);
}

static char ssdv_have_marker(ssdv_t *s)
{
	switch(s->marker)
 800a720:	f8b0 304a 	ldrh.w	r3, [r0, #74]	; 0x4a
 800a724:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
 800a728:	3bc0      	subs	r3, #192	; 0xc0
	uint8_t l = 0x00;
	for(; n > 0; n--) *(s++) = (l = l * 245 + 45);
}

static char ssdv_have_marker(ssdv_t *s)
{
 800a72a:	4602      	mov	r2, r0
	switch(s->marker)
 800a72c:	2b1d      	cmp	r3, #29
 800a72e:	d874      	bhi.n	800a81a <ssdv_have_marker.lto_priv.157+0xfa>
 800a730:	e8df f003 	tbb	[pc, r3]
 800a734:	73297368 	.word	0x73297368
 800a738:	73737368 	.word	0x73737368
 800a73c:	73737373 	.word	0x73737373
 800a740:	73737373 	.word	0x73737373
 800a744:	14141414 	.word	0x14141414
 800a748:	14141414 	.word	0x14141414
 800a74c:	68680f73 	.word	0x68680f73
 800a750:	6873      	.short	0x6873
		/* Don't do progressive images! */
		TRACE_ERROR("SSDV > Progressive images not supported");
		return(SSDV_ERROR);
	
	case J_EOI:
		s->state = S_EOI;
 800a752:	2305      	movs	r3, #5
 800a754:	f880 3049 	strb.w	r3, [r0, #73]	; 0x49
		s->in_skip = s->marker_len;
		s->state   = S_MARKER;
		break;
	}
	
	return(SSDV_OK);
 800a758:	2000      	movs	r0, #0
 800a75a:	4770      	bx	lr
	case J_RST3:
	case J_RST4:
	case J_RST5:
	case J_RST6:
	case J_RST7:
		s->dc[0]  = s->dc[1]  = s->dc[2]  = 0;
 800a75c:	2000      	movs	r0, #0
		s->mcupart = s->acpart = s->component = 0;
		s->acrle = s->accrle = 0;
		s->workbits = s->worklen = 0;
		s->state = S_HUFF;
 800a75e:	2303      	movs	r3, #3
	case J_RST3:
	case J_RST4:
	case J_RST5:
	case J_RST6:
	case J_RST7:
		s->dc[0]  = s->dc[1]  = s->dc[2]  = 0;
 800a760:	6650      	str	r0, [r2, #100]	; 0x64
 800a762:	6610      	str	r0, [r2, #96]	; 0x60
 800a764:	65d0      	str	r0, [r2, #92]	; 0x5c
		s->mcupart = s->acpart = s->component = 0;
 800a766:	f882 0056 	strb.w	r0, [r2, #86]	; 0x56
 800a76a:	f882 0059 	strb.w	r0, [r2, #89]	; 0x59
 800a76e:	f882 0058 	strb.w	r0, [r2, #88]	; 0x58
		s->acrle = s->accrle = 0;
 800a772:	f882 0075 	strb.w	r0, [r2, #117]	; 0x75
 800a776:	f882 0074 	strb.w	r0, [r2, #116]	; 0x74
		s->workbits = s->worklen = 0;
 800a77a:	f882 0030 	strb.w	r0, [r2, #48]	; 0x30
 800a77e:	62d0      	str	r0, [r2, #44]	; 0x2c
		s->state = S_HUFF;
 800a780:	f882 3049 	strb.w	r3, [r2, #73]	; 0x49
 800a784:	4770      	bx	lr
	uint8_t l = 0x00;
	for(; n > 0; n--) *(s++) = (l = l * 245 + 45);
}

static char ssdv_have_marker(ssdv_t *s)
{
 800a786:	b570      	push	{r4, r5, r6, lr}
		s->state           = S_MARKER_DATA;
		break;
	
	case J_SOF2:
		/* Don't do progressive images! */
		TRACE_ERROR("SSDV > Progressive images not supported");
 800a788:	482c      	ldr	r0, [pc, #176]	; (800a83c <ssdv_have_marker.lto_priv.157+0x11c>)
 800a78a:	4e2d      	ldr	r6, [pc, #180]	; (800a840 <ssdv_have_marker.lto_priv.157+0x120>)
 800a78c:	f004 fbb0 	bl	800eef0 <chMtxLock>
 800a790:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800a794:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800a798:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a79a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800a79c:	4b29      	ldr	r3, [pc, #164]	; (800a844 <ssdv_have_marker.lto_priv.157+0x124>)
 800a79e:	492a      	ldr	r1, [pc, #168]	; (800a848 <ssdv_have_marker.lto_priv.157+0x128>)
 800a7a0:	482a      	ldr	r0, [pc, #168]	; (800a84c <ssdv_have_marker.lto_priv.157+0x12c>)
 800a7a2:	fb05 f404 	mul.w	r4, r5, r4
 800a7a6:	fba6 e404 	umull	lr, r4, r6, r4
 800a7aa:	0ba4      	lsrs	r4, r4, #14
 800a7ac:	fba3 e304 	umull	lr, r3, r3, r4
 800a7b0:	fba6 6202 	umull	r6, r2, r6, r2
 800a7b4:	099b      	lsrs	r3, r3, #6
 800a7b6:	fb05 4313 	mls	r3, r5, r3, r4
 800a7ba:	0b92      	lsrs	r2, r2, #14
 800a7bc:	f007 ff90 	bl	80126e0 <chprintf.constprop.35>
 800a7c0:	4a23      	ldr	r2, [pc, #140]	; (800a850 <ssdv_have_marker.lto_priv.157+0x130>)
 800a7c2:	4924      	ldr	r1, [pc, #144]	; (800a854 <ssdv_have_marker.lto_priv.157+0x134>)
 800a7c4:	4821      	ldr	r0, [pc, #132]	; (800a84c <ssdv_have_marker.lto_priv.157+0x12c>)
 800a7c6:	f007 ff8b 	bl	80126e0 <chprintf.constprop.35>
 800a7ca:	f240 2362 	movw	r3, #610	; 0x262
 800a7ce:	4a22      	ldr	r2, [pc, #136]	; (800a858 <ssdv_have_marker.lto_priv.157+0x138>)
 800a7d0:	4922      	ldr	r1, [pc, #136]	; (800a85c <ssdv_have_marker.lto_priv.157+0x13c>)
 800a7d2:	481e      	ldr	r0, [pc, #120]	; (800a84c <ssdv_have_marker.lto_priv.157+0x12c>)
 800a7d4:	f007 ff84 	bl	80126e0 <chprintf.constprop.35>
 800a7d8:	4921      	ldr	r1, [pc, #132]	; (800a860 <ssdv_have_marker.lto_priv.157+0x140>)
 800a7da:	481c      	ldr	r0, [pc, #112]	; (800a84c <ssdv_have_marker.lto_priv.157+0x12c>)
 800a7dc:	f007 ff80 	bl	80126e0 <chprintf.constprop.35>
 800a7e0:	4920      	ldr	r1, [pc, #128]	; (800a864 <ssdv_have_marker.lto_priv.157+0x144>)
 800a7e2:	481a      	ldr	r0, [pc, #104]	; (800a84c <ssdv_have_marker.lto_priv.157+0x12c>)
 800a7e4:	f007 ff7c 	bl	80126e0 <chprintf.constprop.35>
 800a7e8:	491f      	ldr	r1, [pc, #124]	; (800a868 <ssdv_have_marker.lto_priv.157+0x148>)
 800a7ea:	4818      	ldr	r0, [pc, #96]	; (800a84c <ssdv_have_marker.lto_priv.157+0x12c>)
 800a7ec:	f007 ff78 	bl	80126e0 <chprintf.constprop.35>
 800a7f0:	4812      	ldr	r0, [pc, #72]	; (800a83c <ssdv_have_marker.lto_priv.157+0x11c>)
 800a7f2:	f004 fb1d 	bl	800ee30 <chMtxUnlock>
 800a7f6:	f240 2162 	movw	r1, #610	; 0x262
 800a7fa:	4817      	ldr	r0, [pc, #92]	; (800a858 <ssdv_have_marker.lto_priv.157+0x138>)
 800a7fc:	f005 fbb0 	bl	800ff60 <log_error>
		return(SSDV_ERROR);
 800a800:	20ff      	movs	r0, #255	; 0xff
 800a802:	bd70      	pop	{r4, r5, r6, pc}
	case J_SOS:
	case J_DRI:
	case J_DHT:
	case J_DQT:
		/* Copy the data before processing */
		if(s->marker_len > TBL_LEN + HBUFF_LEN - s->stbl_len)
 800a804:	f8b0 12cc 	ldrh.w	r1, [r0, #716]	; 0x2cc
 800a808:	f8b0 004c 	ldrh.w	r0, [r0, #76]	; 0x4c
 800a80c:	f5c1 730c 	rsb	r3, r1, #560	; 0x230
 800a810:	3302      	adds	r3, #2
 800a812:	4298      	cmp	r0, r3
 800a814:	dd08      	ble.n	800a828 <ssdv_have_marker.lto_priv.157+0x108>
		{
			/* Not enough memory ... shouldn't happen! */
			return(SSDV_ERROR);
 800a816:	20ff      	movs	r0, #255	; 0xff
 800a818:	4770      	bx	lr
		s->state = S_HUFF;
		break;
	
	default:
		/* Ignore other marks, skipping any associated data */
		s->in_skip = s->marker_len;
 800a81a:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
 800a81e:	6283      	str	r3, [r0, #40]	; 0x28
		s->state   = S_MARKER;
 800a820:	2000      	movs	r0, #0
 800a822:	f882 0049 	strb.w	r0, [r2, #73]	; 0x49
 800a826:	4770      	bx	lr
		{
			/* Not enough memory ... shouldn't happen! */
			return(SSDV_ERROR);
		}
		
		s->marker_data     = &s->stbls[s->stbl_len];
 800a828:	4411      	add	r1, r2
 800a82a:	3181      	adds	r1, #129	; 0x81
		s->marker_data_len = 0;
 800a82c:	2000      	movs	r0, #0
		s->state           = S_MARKER_DATA;
 800a82e:	2302      	movs	r3, #2
		{
			/* Not enough memory ... shouldn't happen! */
			return(SSDV_ERROR);
		}
		
		s->marker_data     = &s->stbls[s->stbl_len];
 800a830:	6511      	str	r1, [r2, #80]	; 0x50
		s->marker_data_len = 0;
 800a832:	f8a2 0054 	strh.w	r0, [r2, #84]	; 0x54
		s->state           = S_MARKER_DATA;
 800a836:	f882 3049 	strb.w	r3, [r2, #73]	; 0x49
 800a83a:	4770      	bx	lr
 800a83c:	20027b2c 	.word	0x20027b2c
 800a840:	d1b71759 	.word	0xd1b71759
 800a844:	10624dd3 	.word	0x10624dd3
 800a848:	08013c50 	.word	0x08013c50
 800a84c:	20027e60 	.word	0x20027e60
 800a850:	08013d9c 	.word	0x08013d9c
 800a854:	08013c5c 	.word	0x08013c5c
 800a858:	0801491f 	.word	0x0801491f
 800a85c:	08013c78 	.word	0x08013c78
 800a860:	08013d00 	.word	0x08013d00
 800a864:	08015660 	.word	0x08015660
 800a868:	08013cac 	.word	0x08013cac
 800a86c:	00000000 	.word	0x00000000

0800a870 <doConversion>:
{
	adcStop(&ADCD1);
}

void doConversion(void)
{
 800a870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a872:	2320      	movs	r3, #32
 800a874:	f383 8811 	msr	BASEPRI, r3
void adcStart(ADCDriver *adcp, const ADCConfig *config) {

  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 800a878:	4c62      	ldr	r4, [pc, #392]	; (800aa04 <doConversion+0x194>)
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a87a:	f004 fa81 	bl	800ed80 <_dbg_check_lock>
 800a87e:	7825      	ldrb	r5, [r4, #0]
 800a880:	1e6b      	subs	r3, r5, #1
 800a882:	2b01      	cmp	r3, #1
 800a884:	d902      	bls.n	800a88c <doConversion+0x1c>
 800a886:	4860      	ldr	r0, [pc, #384]	; (800aa08 <doConversion+0x198>)
 800a888:	f003 ff6a 	bl	800e760 <chSysHalt>
                "invalid state");
  adcp->config = config;
 800a88c:	2300      	movs	r3, #0
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 800a88e:	2d01      	cmp	r5, #1
 800a890:	6063      	str	r3, [r4, #4]
 800a892:	d076      	beq.n	800a982 <doConversion+0x112>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a894:	4d5d      	ldr	r5, [pc, #372]	; (800aa0c <doConversion+0x19c>)
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 800a896:	2302      	movs	r3, #2
 800a898:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800a89a:	f004 fa61 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a89e:	682b      	ldr	r3, [r5, #0]
 800a8a0:	42ab      	cmp	r3, r5
 800a8a2:	d004      	beq.n	800a8ae <doConversion+0x3e>
 800a8a4:	69aa      	ldr	r2, [r5, #24]
 800a8a6:	689b      	ldr	r3, [r3, #8]
 800a8a8:	6892      	ldr	r2, [r2, #8]
 800a8aa:	429a      	cmp	r2, r3
 800a8ac:	d321      	bcc.n	800a8f2 <doConversion+0x82>
 800a8ae:	2300      	movs	r3, #0
 800a8b0:	f383 8811 	msr	BASEPRI, r3
 *          temperature sensor and internal reference voltage.
 * @note    This is an STM32-only functionality.
 */
void adcSTM32EnableTSVREFE(void) {

  ADC->CCR |= ADC_CCR_TSVREFE;
 800a8b4:	4a56      	ldr	r2, [pc, #344]	; (800aa10 <doConversion+0x1a0>)
 
void initADC(void)
{
	adcStart(&ADCD1, NULL);
	adcSTM32EnableTSVREFE();
	palSetPadMode(PORT(ADC_VSOLAR), PIN(ADC_VSOLAR), PAL_MODE_INPUT_ANALOG);			// Solar panels
 800a8b6:	4857      	ldr	r0, [pc, #348]	; (800aa14 <doConversion+0x1a4>)
 800a8b8:	6853      	ldr	r3, [r2, #4]
 800a8ba:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800a8be:	6053      	str	r3, [r2, #4]
 800a8c0:	2110      	movs	r1, #16
 800a8c2:	2203      	movs	r2, #3
 800a8c4:	f001 fd5c 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(ADC_VBAT), PIN(ADC_VBAT), PAL_MODE_INPUT_ANALOG);		// Battery voltage divider
 800a8c8:	2203      	movs	r2, #3
 800a8ca:	2120      	movs	r1, #32
 800a8cc:	4851      	ldr	r0, [pc, #324]	; (800aa14 <doConversion+0x1a4>)
 800a8ce:	f001 fd57 	bl	800c380 <_pal_lld_setgroupmode>
 800a8d2:	2320      	movs	r3, #32
 800a8d4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a8d8:	f004 fa52 	bl	800ed80 <_dbg_check_lock>
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {

  osalDbgCheckClassI();
 800a8dc:	f003 ffb8 	bl	800e850 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
 800a8e0:	7823      	ldrb	r3, [r4, #0]
 800a8e2:	2b02      	cmp	r3, #2
 800a8e4:	d008      	beq.n	800a8f8 <doConversion+0x88>
 800a8e6:	3b04      	subs	r3, #4
 800a8e8:	2b01      	cmp	r3, #1
 800a8ea:	d905      	bls.n	800a8f8 <doConversion+0x88>
 800a8ec:	484a      	ldr	r0, [pc, #296]	; (800aa18 <doConversion+0x1a8>)
 800a8ee:	f003 ff37 	bl	800e760 <chSysHalt>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a8f2:	484a      	ldr	r0, [pc, #296]	; (800aa1c <doConversion+0x1ac>)
 800a8f4:	f003 ff34 	bl	800e760 <chSysHalt>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800a8f8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
 800a8fa:	4b49      	ldr	r3, [pc, #292]	; (800aa20 <doConversion+0x1b0>)
 800a8fc:	6812      	ldr	r2, [r2, #0]
  uint32_t mode;
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
 800a8fe:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800a900:	6123      	str	r3, [r4, #16]
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 800a902:	4948      	ldr	r1, [pc, #288]	; (800aa24 <doConversion+0x1b4>)
 800a904:	60a1      	str	r1, [r4, #8]
  adcp->depth    = depth;
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 800a906:	2303      	movs	r3, #3
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
 800a908:	2601      	movs	r6, #1
 800a90a:	60e6      	str	r6, [r4, #12]
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 800a90c:	7023      	strb	r3, [r4, #0]
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800a90e:	60d1      	str	r1, [r2, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800a910:	6053      	str	r3, [r2, #4]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
 800a912:	6010      	str	r0, [r2, #0]
  dmaStreamEnable(adcp->dmastp);
 800a914:	6811      	ldr	r1, [r2, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800a916:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  adcp->adc->SMPR1 = grpp->smpr1;
 800a918:	4f43      	ldr	r7, [pc, #268]	; (800aa28 <doConversion+0x1b8>)
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800a91a:	4844      	ldr	r0, [pc, #272]	; (800aa2c <doConversion+0x1bc>)
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800a91c:	4e44      	ldr	r6, [pc, #272]	; (800aa30 <doConversion+0x1c0>)
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);
 800a91e:	f041 0101 	orr.w	r1, r1, #1
 800a922:	6011      	str	r1, [r2, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800a924:	2200      	movs	r2, #0
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1;
 800a926:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800a92a:	601a      	str	r2, [r3, #0]
  adcp->adc->SMPR1 = grpp->smpr1;
 800a92c:	60df      	str	r7, [r3, #12]
  adcp->adc->SMPR2 = grpp->smpr2;
 800a92e:	611a      	str	r2, [r3, #16]
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;
 800a930:	f244 17cf 	movw	r7, #16847	; 0x41cf

  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1;
 800a934:	62d9      	str	r1, [r3, #44]	; 0x2c

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800a936:	f240 3103 	movw	r1, #771	; 0x303
  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
 800a93a:	631a      	str	r2, [r3, #48]	; 0x30
  adcp->adc->SQR3  = grpp->sqr3;
 800a93c:	635f      	str	r7, [r3, #52]	; 0x34

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800a93e:	605e      	str	r6, [r3, #4]

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800a940:	6099      	str	r1, [r3, #8]

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800a942:	6098      	str	r0, [r3, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800a944:	f004 fa0c 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a948:	682b      	ldr	r3, [r5, #0]
 800a94a:	4a30      	ldr	r2, [pc, #192]	; (800aa0c <doConversion+0x19c>)
 800a94c:	42ab      	cmp	r3, r5
 800a94e:	d004      	beq.n	800a95a <doConversion+0xea>
 800a950:	6992      	ldr	r2, [r2, #24]
 800a952:	689b      	ldr	r3, [r3, #8]
 800a954:	6892      	ldr	r2, [r2, #8]
 800a956:	429a      	cmp	r2, r3
 800a958:	d3cb      	bcc.n	800a8f2 <doConversion+0x82>
 800a95a:	2600      	movs	r6, #0
 800a95c:	f386 8811 	msr	BASEPRI, r6

void doConversion(void)
{
	initADC();
	adcStartConversion(&ADCD1, &adcgrpcfg, samples, 1);
	chThdSleepMilliseconds(35); // Wait until conversion is finished
 800a960:	f44f 702f 	mov.w	r0, #700	; 0x2bc
 800a964:	f004 fb94 	bl	800f090 <chThdSleep>
 800a968:	2320      	movs	r3, #32
 800a96a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a96e:	f004 fa07 	bl	800ed80 <_dbg_check_lock>

  osalDbgCheck(adcp != NULL);

  osalSysLock();

  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 800a972:	7823      	ldrb	r3, [r4, #0]
 800a974:	4f23      	ldr	r7, [pc, #140]	; (800aa04 <doConversion+0x194>)
 800a976:	1e5a      	subs	r2, r3, #1
 800a978:	2a01      	cmp	r2, #1
 800a97a:	d921      	bls.n	800a9c0 <doConversion+0x150>
 800a97c:	482d      	ldr	r0, [pc, #180]	; (800aa34 <doConversion+0x1c4>)
 800a97e:	f003 feef 	bl	800e760 <chSysHalt>
  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
 800a982:	4623      	mov	r3, r4
 800a984:	4a2c      	ldr	r2, [pc, #176]	; (800aa38 <doConversion+0x1c8>)
 800a986:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800a988:	2106      	movs	r1, #6
 800a98a:	f002 f951 	bl	800cc30 <dmaStreamAllocate>
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
 800a98e:	b9a0      	cbnz	r0, 800a9ba <doConversion+0x14a>
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800a990:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800a992:	4a2a      	ldr	r2, [pc, #168]	; (800aa3c <doConversion+0x1cc>)
 800a994:	681b      	ldr	r3, [r3, #0]
      rccEnableADC1(FALSE);
 800a996:	4e2a      	ldr	r6, [pc, #168]	; (800aa40 <doConversion+0x1d0>)
      b = dmaStreamAllocate(adcp->dmastp,
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800a998:	609a      	str	r2, [r3, #8]
      rccEnableADC1(FALSE);
 800a99a:	6c73      	ldr	r3, [r6, #68]	; 0x44
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800a99c:	491c      	ldr	r1, [pc, #112]	; (800aa10 <doConversion+0x1a0>)
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 800a99e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(FALSE);
 800a9a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a9a4:	6473      	str	r3, [r6, #68]	; 0x44
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800a9a6:	684b      	ldr	r3, [r1, #4]
 800a9a8:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 800a9ac:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800a9b0:	604b      	str	r3, [r1, #4]
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 800a9b2:	6050      	str	r0, [r2, #4]
    adcp->adc->CR2 = 0;
 800a9b4:	6090      	str	r0, [r2, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
 800a9b6:	6095      	str	r5, [r2, #8]
 800a9b8:	e76c      	b.n	800a894 <doConversion+0x24>
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
 800a9ba:	4822      	ldr	r0, [pc, #136]	; (800aa44 <doConversion+0x1d4>)
 800a9bc:	f003 fed0 	bl	800e760 <chSysHalt>
 * @notapi
 */
void adc_lld_stop(ADCDriver *adcp) {

  /* If in ready state then disables the ADC clock.*/
  if (adcp->state == ADC_READY) {
 800a9c0:	2b02      	cmp	r3, #2
 800a9c2:	d012      	beq.n	800a9ea <doConversion+0x17a>
                "invalid state");

  adc_lld_stop(adcp);
  adcp->config = NULL;
 800a9c4:	2200      	movs	r2, #0
  adcp->state  = ADC_STOP;
 800a9c6:	2301      	movs	r3, #1

  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");

  adc_lld_stop(adcp);
  adcp->config = NULL;
 800a9c8:	6062      	str	r2, [r4, #4]
  adcp->state  = ADC_STOP;
 800a9ca:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800a9cc:	f004 f9c8 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a9d0:	682b      	ldr	r3, [r5, #0]
 800a9d2:	4a0e      	ldr	r2, [pc, #56]	; (800aa0c <doConversion+0x19c>)
 800a9d4:	42ab      	cmp	r3, r5
 800a9d6:	d004      	beq.n	800a9e2 <doConversion+0x172>
 800a9d8:	6992      	ldr	r2, [r2, #24]
 800a9da:	689b      	ldr	r3, [r3, #8]
 800a9dc:	6892      	ldr	r2, [r2, #8]
 800a9de:	429a      	cmp	r2, r3
 800a9e0:	d387      	bcc.n	800a8f2 <doConversion+0x82>
 800a9e2:	2300      	movs	r3, #0
 800a9e4:	f383 8811 	msr	BASEPRI, r3
 800a9e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dmaStreamRelease(adcp->dmastp);
 800a9ea:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800a9ec:	f002 f8e0 	bl	800cbb0 <dmaStreamRelease>
    adcp->adc->CR1 = 0;
 800a9f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
    adcp->adc->CR2 = 0;

#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp)
      rccDisableADC1(FALSE);
 800a9f2:	4a13      	ldr	r2, [pc, #76]	; (800aa40 <doConversion+0x1d0>)
void adc_lld_stop(ADCDriver *adcp) {

  /* If in ready state then disables the ADC clock.*/
  if (adcp->state == ADC_READY) {
    dmaStreamRelease(adcp->dmastp);
    adcp->adc->CR1 = 0;
 800a9f4:	605e      	str	r6, [r3, #4]
    adcp->adc->CR2 = 0;
 800a9f6:	609e      	str	r6, [r3, #8]

#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp)
      rccDisableADC1(FALSE);
 800a9f8:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800a9fa:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a9fe:	6453      	str	r3, [r2, #68]	; 0x44
 800aa00:	e7e0      	b.n	800a9c4 <doConversion+0x154>
 800aa02:	bf00      	nop
 800aa04:	2002773c 	.word	0x2002773c
 800aa08:	080155d0 	.word	0x080155d0
 800aa0c:	20027edc 	.word	0x20027edc
 800aa10:	40012300 	.word	0x40012300
 800aa14:	40020800 	.word	0x40020800
 800aa18:	08015698 	.word	0x08015698
 800aa1c:	08015594 	.word	0x08015594
 800aa20:	080155a0 	.word	0x080155a0
 800aa24:	20027884 	.word	0x20027884
 800aa28:	0019b000 	.word	0x0019b000
 800aa2c:	40000303 	.word	0x40000303
 800aa30:	04000100 	.word	0x04000100
 800aa34:	080155c8 	.word	0x080155c8
 800aa38:	0800c451 	.word	0x0800c451
 800aa3c:	4001204c 	.word	0x4001204c
 800aa40:	40023800 	.word	0x40023800
 800aa44:	08015688 	.word	0x08015688
	...

0800aa50 <getSolarVoltageMV>:
	}

	return vbat;
}
uint16_t getSolarVoltageMV(void)
{
 800aa50:	b508      	push	{r3, lr}
	doConversion();
 800aa52:	f7ff ff0d 	bl	800a870 <doConversion>
	return samples[1] * VCC_REF * DIVIDER_VSOL / 4096;
 800aa56:	4b04      	ldr	r3, [pc, #16]	; (800aa68 <getSolarVoltageMV+0x18>)
 800aa58:	8858      	ldrh	r0, [r3, #2]
 800aa5a:	f640 6358 	movw	r3, #3672	; 0xe58
 800aa5e:	fb03 f000 	mul.w	r0, r3, r0
}
 800aa62:	f3c0 300f 	ubfx	r0, r0, #12, #16
 800aa66:	bd08      	pop	{r3, pc}
 800aa68:	20027884 	.word	0x20027884
 800aa6c:	00000000 	.word	0x00000000

0800aa70 <getBatteryVoltageMV>:
	chThdSleepMilliseconds(35); // Wait until conversion is finished
	deinitADC();
}

uint16_t getBatteryVoltageMV(void)
{
 800aa70:	b510      	push	{r4, lr}
 800aa72:	b082      	sub	sp, #8
	doConversion();
 800aa74:	f7ff fefc 	bl	800a870 <doConversion>
	uint16_t vbat = samples[0] * VCC_REF * DIVIDER_VBAT / 4096;
 800aa78:	4a11      	ldr	r2, [pc, #68]	; (800aac0 <getBatteryVoltageMV+0x50>)
 800aa7a:	4b12      	ldr	r3, [pc, #72]	; (800aac4 <getBatteryVoltageMV+0x54>)
 800aa7c:	8814      	ldrh	r4, [r2, #0]
 800aa7e:	fb03 f404 	mul.w	r4, r3, r4
 800aa82:	14a4      	asrs	r4, r4, #18
 800aa84:	b2a4      	uxth	r4, r4

	// Get voltage from PAC1720 (PAC1720 returns false redings below 2.35V)
	if(vbat >= 2400)
 800aa86:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
 800aa8a:	d202      	bcs.n	800aa92 <getBatteryVoltageMV+0x22>
		if(vbat_pac) // Apply it if valid
			vbat = vbat_pac;
	}

	return vbat;
}
 800aa8c:	4620      	mov	r0, r4
 800aa8e:	b002      	add	sp, #8
 800aa90:	bd10      	pop	{r4, pc}
	return ret;
}

uint16_t pac1720_getBatteryVoltage(void) {
	uint16_t val;
	if(!I2C_read16(PAC1720_ADDRESS, PAC1720_CH2_VSOURCE_HIGH, &val))
 800aa92:	f10d 0206 	add.w	r2, sp, #6
 800aa96:	2113      	movs	r1, #19
 800aa98:	204c      	movs	r0, #76	; 0x4c
 800aa9a:	f7ff fc79 	bl	800a390 <I2C_read16>
 800aa9e:	2800      	cmp	r0, #0
 800aaa0:	d0f4      	beq.n	800aa8c <getBatteryVoltageMV+0x1c>
		return 0; // PAC1720 not available (maybe Vcc too low)

	return (val >> 5) * 20000 / 0x400;
 800aaa2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800aaa6:	f644 6220 	movw	r2, #20000	; 0x4e20
 800aaaa:	095b      	lsrs	r3, r3, #5
 800aaac:	fb02 f303 	mul.w	r3, r2, r3
 800aab0:	129b      	asrs	r3, r3, #10
 800aab2:	b29a      	uxth	r2, r3

	// Get voltage from PAC1720 (PAC1720 returns false redings below 2.35V)
	if(vbat >= 2400)
	{
		uint16_t vbat_pac = pac1720_getBatteryVoltage(); // Get value from PAC1720
		if(vbat_pac) // Apply it if valid
 800aab4:	2b00      	cmp	r3, #0
 800aab6:	bf18      	it	ne
 800aab8:	4614      	movne	r4, r2
			vbat = vbat_pac;
	}

	return vbat;
}
 800aaba:	4620      	mov	r0, r4
 800aabc:	b002      	add	sp, #8
 800aabe:	bd10      	pop	{r4, pc}
 800aac0:	20027884 	.word	0x20027884
 800aac4:	00059a60 	.word	0x00059a60
	...

0800aad0 <recvr1.isra.0>:
 * @return              The response as an @p uint8_t value.
 * @retval 0xFF         timed out.
 *
 * @notapi
 */
static uint8_t recvr1(MMCDriver *mmcp) {
 800aad0:	b530      	push	{r4, r5, lr}
 800aad2:	4605      	mov	r5, r0
 800aad4:	b083      	sub	sp, #12
 800aad6:	2409      	movs	r4, #9
  int i;
  uint8_t r1[1];

  for (i = 0; i < 9; i++) {
    spiReceive(mmcp->config->spip, 1, r1);
 800aad8:	682b      	ldr	r3, [r5, #0]
 800aada:	aa01      	add	r2, sp, #4
 800aadc:	6818      	ldr	r0, [r3, #0]
 800aade:	2101      	movs	r1, #1
 800aae0:	f002 f906 	bl	800ccf0 <spiReceive>
    if (r1[0] != 0xFFU) {
 800aae4:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800aae8:	28ff      	cmp	r0, #255	; 0xff
 800aaea:	d101      	bne.n	800aaf0 <recvr1.isra.0+0x20>
 */
static uint8_t recvr1(MMCDriver *mmcp) {
  int i;
  uint8_t r1[1];

  for (i = 0; i < 9; i++) {
 800aaec:	3c01      	subs	r4, #1
 800aaee:	d1f3      	bne.n	800aad8 <recvr1.isra.0+0x8>
    if (r1[0] != 0xFFU) {
      return r1[0];
    }
  }
  return 0xFFU;
}
 800aaf0:	b003      	add	sp, #12
 800aaf2:	bd30      	pop	{r4, r5, pc}
	...

0800ab00 <wait.isra.1>:
 *
 * @param[in] mmcp      pointer to the @p MMCDriver object
 *
 * @notapi
 */
static void wait(MMCDriver *mmcp) {
 800ab00:	b530      	push	{r4, r5, lr}
 800ab02:	4605      	mov	r5, r0
 800ab04:	b083      	sub	sp, #12
 800ab06:	2410      	movs	r4, #16
  int i;
  uint8_t buf[4];

  for (i = 0; i < 16; i++) {
    spiReceive(mmcp->config->spip, 1, buf);
 800ab08:	682b      	ldr	r3, [r5, #0]
 800ab0a:	aa01      	add	r2, sp, #4
 800ab0c:	6818      	ldr	r0, [r3, #0]
 800ab0e:	2101      	movs	r1, #1
 800ab10:	f002 f8ee 	bl	800ccf0 <spiReceive>
    if (buf[0] == 0xFFU) {
 800ab14:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800ab18:	2bff      	cmp	r3, #255	; 0xff
 800ab1a:	d010      	beq.n	800ab3e <wait.isra.1+0x3e>
 */
static void wait(MMCDriver *mmcp) {
  int i;
  uint8_t buf[4];

  for (i = 0; i < 16; i++) {
 800ab1c:	3c01      	subs	r4, #1
 800ab1e:	d1f3      	bne.n	800ab08 <wait.isra.1+0x8>
 800ab20:	e001      	b.n	800ab26 <wait.isra.1+0x26>
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
 800ab22:	f004 fab5 	bl	800f090 <chThdSleep>
      return;
    }
  }
  /* Looks like it is a long wait.*/
  while (true) {
    spiReceive(mmcp->config->spip, 1, buf);
 800ab26:	682b      	ldr	r3, [r5, #0]
 800ab28:	aa01      	add	r2, sp, #4
 800ab2a:	6818      	ldr	r0, [r3, #0]
 800ab2c:	2101      	movs	r1, #1
 800ab2e:	f002 f8df 	bl	800ccf0 <spiReceive>
    if (buf[0] == 0xFFU) {
 800ab32:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800ab36:	2bff      	cmp	r3, #255	; 0xff
 800ab38:	f04f 0014 	mov.w	r0, #20
 800ab3c:	d1f1      	bne.n	800ab22 <wait.isra.1+0x22>
#if MMC_NICE_WAITING == TRUE
    /* Trying to be nice with the other threads.*/
    osalThreadSleepMilliseconds(1);
#endif
  }
}
 800ab3e:	b003      	add	sp, #12
 800ab40:	bd30      	pop	{r4, r5, pc}
 800ab42:	bf00      	nop
	...

0800ab50 <send_hdr>:
 * @param[in] cmd       the command id
 * @param[in] arg       the command argument
 *
 * @notapi
 */
static void send_hdr(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
 800ab50:	b570      	push	{r4, r5, r6, lr}
 800ab52:	4616      	mov	r6, r2
 800ab54:	b082      	sub	sp, #8
 800ab56:	4605      	mov	r5, r0
  uint8_t buf[6];

  /* Wait for the bus to become idle if a write operation was in progress.*/
  wait(mmcp);
 800ab58:	302c      	adds	r0, #44	; 0x2c
 * @param[in] cmd       the command id
 * @param[in] arg       the command argument
 *
 * @notapi
 */
static void send_hdr(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
 800ab5a:	460c      	mov	r4, r1
  uint8_t buf[6];

  /* Wait for the bus to become idle if a write operation was in progress.*/
  wait(mmcp);
 800ab5c:	f7ff ffd0 	bl	800ab00 <wait.isra.1>

  buf[0] = (uint8_t)0x40U | cmd;
  buf[1] = (uint8_t)(arg >> 24U);
  buf[2] = (uint8_t)(arg >> 16U);
  buf[3] = (uint8_t)(arg >> 8U);
 800ab60:	0a33      	lsrs	r3, r6, #8
  uint8_t buf[6];

  /* Wait for the bus to become idle if a write operation was in progress.*/
  wait(mmcp);

  buf[0] = (uint8_t)0x40U | cmd;
 800ab62:	f044 0140 	orr.w	r1, r4, #64	; 0x40
  buf[1] = (uint8_t)(arg >> 24U);
 800ab66:	0e30      	lsrs	r0, r6, #24
  buf[2] = (uint8_t)(arg >> 16U);
 800ab68:	0c32      	lsrs	r2, r6, #16
  buf[3] = (uint8_t)(arg >> 8U);
 800ab6a:	f88d 3003 	strb.w	r3, [sp, #3]
  buf[4] = (uint8_t)arg;
 800ab6e:	2300      	movs	r3, #0
 800ab70:	4c11      	ldr	r4, [pc, #68]	; (800abb8 <send_hdr+0x68>)
  uint8_t buf[6];

  /* Wait for the bus to become idle if a write operation was in progress.*/
  wait(mmcp);

  buf[0] = (uint8_t)0x40U | cmd;
 800ab72:	f88d 1000 	strb.w	r1, [sp]
  buf[1] = (uint8_t)(arg >> 24U);
 800ab76:	f88d 0001 	strb.w	r0, [sp, #1]
  buf[2] = (uint8_t)(arg >> 16U);
 800ab7a:	f88d 2002 	strb.w	r2, [sp, #2]
 800ab7e:	a801      	add	r0, sp, #4
 800ab80:	466a      	mov	r2, sp
 * @return              Calculated CRC
 */
static uint8_t crc7(uint8_t crc, const uint8_t *buffer, size_t len) {

  while (len > 0U) {
    crc = crc7_lookup_table[(crc << 1) ^ (*buffer++)];
 800ab82:	ea81 0143 	eor.w	r1, r1, r3, lsl #1
 * @param[in] len       length of data
 * @return              Calculated CRC
 */
static uint8_t crc7(uint8_t crc, const uint8_t *buffer, size_t len) {

  while (len > 0U) {
 800ab86:	4290      	cmp	r0, r2

  buf[0] = (uint8_t)0x40U | cmd;
  buf[1] = (uint8_t)(arg >> 24U);
  buf[2] = (uint8_t)(arg >> 16U);
  buf[3] = (uint8_t)(arg >> 8U);
  buf[4] = (uint8_t)arg;
 800ab88:	f88d 6004 	strb.w	r6, [sp, #4]
 * @return              Calculated CRC
 */
static uint8_t crc7(uint8_t crc, const uint8_t *buffer, size_t len) {

  while (len > 0U) {
    crc = crc7_lookup_table[(crc << 1) ^ (*buffer++)];
 800ab8c:	5c63      	ldrb	r3, [r4, r1]
 * @param[in] len       length of data
 * @return              Calculated CRC
 */
static uint8_t crc7(uint8_t crc, const uint8_t *buffer, size_t len) {

  while (len > 0U) {
 800ab8e:	d006      	beq.n	800ab9e <send_hdr+0x4e>
 800ab90:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    crc = crc7_lookup_table[(crc << 1) ^ (*buffer++)];
 800ab94:	ea81 0143 	eor.w	r1, r1, r3, lsl #1
 * @param[in] len       length of data
 * @return              Calculated CRC
 */
static uint8_t crc7(uint8_t crc, const uint8_t *buffer, size_t len) {

  while (len > 0U) {
 800ab98:	4290      	cmp	r0, r2
    crc = crc7_lookup_table[(crc << 1) ^ (*buffer++)];
 800ab9a:	5c63      	ldrb	r3, [r4, r1]
 * @param[in] len       length of data
 * @return              Calculated CRC
 */
static uint8_t crc7(uint8_t crc, const uint8_t *buffer, size_t len) {

  while (len > 0U) {
 800ab9c:	d1f8      	bne.n	800ab90 <send_hdr+0x40>
  buf[1] = (uint8_t)(arg >> 24U);
  buf[2] = (uint8_t)(arg >> 16U);
  buf[3] = (uint8_t)(arg >> 8U);
  buf[4] = (uint8_t)arg;
  /* Calculate CRC for command header, shift to right position, add stop bit.*/
  buf[5] = ((crc7(0, buf, 5U) & 0x7FU) << 1U) | 0x01U;
 800ab9e:	0059      	lsls	r1, r3, #1
 800aba0:	f041 0101 	orr.w	r1, r1, #1

  spiSend(mmcp->config->spip, 6, buf);
 800aba4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  buf[1] = (uint8_t)(arg >> 24U);
  buf[2] = (uint8_t)(arg >> 16U);
  buf[3] = (uint8_t)(arg >> 8U);
  buf[4] = (uint8_t)arg;
  /* Calculate CRC for command header, shift to right position, add stop bit.*/
  buf[5] = ((crc7(0, buf, 5U) & 0x7FU) << 1U) | 0x01U;
 800aba6:	f88d 1005 	strb.w	r1, [sp, #5]

  spiSend(mmcp->config->spip, 6, buf);
 800abaa:	6818      	ldr	r0, [r3, #0]
 800abac:	466a      	mov	r2, sp
 800abae:	2106      	movs	r1, #6
 800abb0:	f002 f8ee 	bl	800cd90 <spiSend>
}
 800abb4:	b002      	add	sp, #8
 800abb6:	bd70      	pop	{r4, r5, r6, pc}
 800abb8:	08015700 	.word	0x08015700
 800abbc:	00000000 	.word	0x00000000

0800abc0 <sync.isra.2>:
 *
 * @param[in] mmcp      pointer to the @p MMCDriver object
 *
 * @notapi
 */
static void sync(MMCDriver *mmcp) {
 800abc0:	b510      	push	{r4, lr}
  uint8_t buf[1];

  spiSelect(mmcp->config->spip);
 800abc2:	6803      	ldr	r3, [r0, #0]
 *
 * @param[in] mmcp      pointer to the @p MMCDriver object
 *
 * @notapi
 */
static void sync(MMCDriver *mmcp) {
 800abc4:	4604      	mov	r4, r0
 800abc6:	b082      	sub	sp, #8
  uint8_t buf[1];

  spiSelect(mmcp->config->spip);
 800abc8:	6818      	ldr	r0, [r3, #0]
 800abca:	f002 f9b1 	bl	800cf30 <spiSelect>
 800abce:	e001      	b.n	800abd4 <sync.isra.2+0x14>
 800abd0:	f004 fa5e 	bl	800f090 <chThdSleep>
  while (true) {
    spiReceive(mmcp->config->spip, 1, buf);
 800abd4:	6823      	ldr	r3, [r4, #0]
 800abd6:	aa01      	add	r2, sp, #4
 800abd8:	6818      	ldr	r0, [r3, #0]
 800abda:	2101      	movs	r1, #1
 800abdc:	f002 f888 	bl	800ccf0 <spiReceive>
    if (buf[0] == 0xFFU) {
 800abe0:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800abe4:	2bff      	cmp	r3, #255	; 0xff
 800abe6:	f04f 0014 	mov.w	r0, #20
 800abea:	d1f1      	bne.n	800abd0 <sync.isra.2+0x10>
#if MMC_NICE_WAITING == TRUE
    /* Trying to be nice with the other threads.*/
    osalThreadSleepMilliseconds(1);
#endif
  }
  spiUnselect(mmcp->config->spip);
 800abec:	6823      	ldr	r3, [r4, #0]
 800abee:	6818      	ldr	r0, [r3, #0]
 800abf0:	f002 f96e 	bl	800ced0 <spiUnselect>
}
 800abf4:	b002      	add	sp, #8
 800abf6:	bd10      	pop	{r4, pc}
	...

0800ac00 <read_CxD>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @notapi
 */
static bool read_CxD(MMCDriver *mmcp, uint8_t cmd, uint32_t cxd[4]) {
 800ac00:	b570      	push	{r4, r5, r6, lr}
  unsigned i;
  uint8_t *bp, buf[16];

  spiSelect(mmcp->config->spip);
 800ac02:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @notapi
 */
static bool read_CxD(MMCDriver *mmcp, uint8_t cmd, uint32_t cxd[4]) {
 800ac04:	b084      	sub	sp, #16
 800ac06:	4605      	mov	r5, r0
 800ac08:	460c      	mov	r4, r1
  unsigned i;
  uint8_t *bp, buf[16];

  spiSelect(mmcp->config->spip);
 800ac0a:	6818      	ldr	r0, [r3, #0]
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @notapi
 */
static bool read_CxD(MMCDriver *mmcp, uint8_t cmd, uint32_t cxd[4]) {
 800ac0c:	4616      	mov	r6, r2
  unsigned i;
  uint8_t *bp, buf[16];

  spiSelect(mmcp->config->spip);
 800ac0e:	f002 f98f 	bl	800cf30 <spiSelect>
  send_hdr(mmcp, cmd, 0);
 800ac12:	4628      	mov	r0, r5
 800ac14:	4621      	mov	r1, r4
 800ac16:	2200      	movs	r2, #0
 800ac18:	f7ff ff9a 	bl	800ab50 <send_hdr>
  if (recvr1(mmcp) != 0x00U) {
 800ac1c:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 800ac20:	f7ff ff56 	bl	800aad0 <recvr1.isra.0>
 800ac24:	bb58      	cbnz	r0, 800ac7e <read_CxD+0x7e>
 800ac26:	f242 7410 	movw	r4, #10000	; 0x2710
 800ac2a:	e001      	b.n	800ac30 <read_CxD+0x30>
    spiUnselect(mmcp->config->spip);
    return HAL_FAILED;
  }

  /* Wait for data availability.*/
  for (i = 0U; i < MMC_WAIT_DATA; i++) {
 800ac2c:	3c01      	subs	r4, #1
 800ac2e:	d02d      	beq.n	800ac8c <read_CxD+0x8c>
    spiReceive(mmcp->config->spip, 1, buf);
 800ac30:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ac32:	466a      	mov	r2, sp
 800ac34:	6818      	ldr	r0, [r3, #0]
 800ac36:	2101      	movs	r1, #1
 800ac38:	f002 f85a 	bl	800ccf0 <spiReceive>
    if (buf[0] == 0xFEU) {
 800ac3c:	f89d 3000 	ldrb.w	r3, [sp]
 800ac40:	2bfe      	cmp	r3, #254	; 0xfe
 800ac42:	d1f3      	bne.n	800ac2c <read_CxD+0x2c>
      uint32_t *wp;

      spiReceive(mmcp->config->spip, 16, buf);
 800ac44:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ac46:	466a      	mov	r2, sp
 800ac48:	6818      	ldr	r0, [r3, #0]
 800ac4a:	2110      	movs	r1, #16
 800ac4c:	f002 f850 	bl	800ccf0 <spiReceive>
 800ac50:	466b      	mov	r3, sp
      bp = buf;
      for (wp = &cxd[3]; wp >= cxd; wp--) {
 800ac52:	f106 000c 	add.w	r0, r6, #12
 800ac56:	1f32      	subs	r2, r6, #4
 800ac58:	f853 1b04 	ldr.w	r1, [r3], #4
 800ac5c:	ba09      	rev	r1, r1
        *wp = ((uint32_t)bp[0] << 24U) | ((uint32_t)bp[1] << 16U) |
 800ac5e:	f840 1904 	str.w	r1, [r0], #-4
    if (buf[0] == 0xFEU) {
      uint32_t *wp;

      spiReceive(mmcp->config->spip, 16, buf);
      bp = buf;
      for (wp = &cxd[3]; wp >= cxd; wp--) {
 800ac62:	4282      	cmp	r2, r0
 800ac64:	d1f8      	bne.n	800ac58 <read_CxD+0x58>
              ((uint32_t)bp[2] << 8U)  | (uint32_t)bp[3];
        bp += 4;
      }

      /* CRC ignored then end of transaction. */
      spiIgnore(mmcp->config->spip, 2);
 800ac66:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ac68:	2102      	movs	r1, #2
 800ac6a:	6818      	ldr	r0, [r3, #0]
 800ac6c:	f002 f8e0 	bl	800ce30 <spiIgnore>
      spiUnselect(mmcp->config->spip);
 800ac70:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ac72:	6818      	ldr	r0, [r3, #0]
 800ac74:	f002 f92c 	bl	800ced0 <spiUnselect>

      return HAL_SUCCESS;
 800ac78:	2000      	movs	r0, #0
    }
  }
  return HAL_FAILED;
}
 800ac7a:	b004      	add	sp, #16
 800ac7c:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t *bp, buf[16];

  spiSelect(mmcp->config->spip);
  send_hdr(mmcp, cmd, 0);
  if (recvr1(mmcp) != 0x00U) {
    spiUnselect(mmcp->config->spip);
 800ac7e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ac80:	6818      	ldr	r0, [r3, #0]
 800ac82:	f002 f925 	bl	800ced0 <spiUnselect>
    return HAL_FAILED;
 800ac86:	2001      	movs	r0, #1

      return HAL_SUCCESS;
    }
  }
  return HAL_FAILED;
}
 800ac88:	b004      	add	sp, #16
 800ac8a:	bd70      	pop	{r4, r5, r6, pc}
      spiUnselect(mmcp->config->spip);

      return HAL_SUCCESS;
    }
  }
  return HAL_FAILED;
 800ac8c:	2001      	movs	r0, #1
}
 800ac8e:	b004      	add	sp, #16
 800ac90:	bd70      	pop	{r4, r5, r6, pc}
 800ac92:	bf00      	nop
	...

0800aca0 <send_command_R3>:
 * @retval 0xFF         timed out.
 *
 * @notapi
 */
static uint8_t send_command_R3(MMCDriver *mmcp, uint8_t cmd, uint32_t arg,
                               uint8_t *response) {
 800aca0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800aca2:	460d      	mov	r5, r1
  uint8_t r1;

  spiSelect(mmcp->config->spip);
 800aca4:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 * @retval 0xFF         timed out.
 *
 * @notapi
 */
static uint8_t send_command_R3(MMCDriver *mmcp, uint8_t cmd, uint32_t arg,
                               uint8_t *response) {
 800aca6:	4604      	mov	r4, r0
 800aca8:	4617      	mov	r7, r2
  uint8_t r1;

  spiSelect(mmcp->config->spip);
 800acaa:	6808      	ldr	r0, [r1, #0]
 * @retval 0xFF         timed out.
 *
 * @notapi
 */
static uint8_t send_command_R3(MMCDriver *mmcp, uint8_t cmd, uint32_t arg,
                               uint8_t *response) {
 800acac:	461e      	mov	r6, r3
  uint8_t r1;

  spiSelect(mmcp->config->spip);
 800acae:	f002 f93f 	bl	800cf30 <spiSelect>
  send_hdr(mmcp, cmd, arg);
 800acb2:	463a      	mov	r2, r7
 800acb4:	4629      	mov	r1, r5
 800acb6:	4620      	mov	r0, r4
 800acb8:	f7ff ff4a 	bl	800ab50 <send_hdr>
 * @notapi
 */
static uint8_t recvr3(MMCDriver *mmcp, uint8_t* buffer) {
  uint8_t r1;

  r1 = recvr1(mmcp);
 800acbc:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800acc0:	f7ff ff06 	bl	800aad0 <recvr1.isra.0>
  spiReceive(mmcp->config->spip, 4, buffer);
 800acc4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 * @notapi
 */
static uint8_t recvr3(MMCDriver *mmcp, uint8_t* buffer) {
  uint8_t r1;

  r1 = recvr1(mmcp);
 800acc6:	4605      	mov	r5, r0
  spiReceive(mmcp->config->spip, 4, buffer);
 800acc8:	4632      	mov	r2, r6
 800acca:	6808      	ldr	r0, [r1, #0]
 800accc:	2104      	movs	r1, #4
 800acce:	f002 f80f 	bl	800ccf0 <spiReceive>
  uint8_t r1;

  spiSelect(mmcp->config->spip);
  send_hdr(mmcp, cmd, arg);
  r1 = recvr3(mmcp, response);
  spiUnselect(mmcp->config->spip);
 800acd2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800acd4:	6818      	ldr	r0, [r3, #0]
 800acd6:	f002 f8fb 	bl	800ced0 <spiUnselect>
  return r1;
}
 800acda:	4628      	mov	r0, r5
 800acdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800acde:	bf00      	nop

0800ace0 <send_command_R1>:
 * @notapi
 */
static uint8_t send_command_R1(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
  uint8_t r1;

  spiSelect(mmcp->config->spip);
 800ace0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 * @return              The response as an @p uint8_t value.
 * @retval 0xFF         timed out.
 *
 * @notapi
 */
static uint8_t send_command_R1(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
 800ace2:	b570      	push	{r4, r5, r6, lr}
 800ace4:	4604      	mov	r4, r0
 800ace6:	460d      	mov	r5, r1
  uint8_t r1;

  spiSelect(mmcp->config->spip);
 800ace8:	6818      	ldr	r0, [r3, #0]
 * @return              The response as an @p uint8_t value.
 * @retval 0xFF         timed out.
 *
 * @notapi
 */
static uint8_t send_command_R1(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
 800acea:	4616      	mov	r6, r2
  uint8_t r1;

  spiSelect(mmcp->config->spip);
 800acec:	f002 f920 	bl	800cf30 <spiSelect>
  send_hdr(mmcp, cmd, arg);
 800acf0:	4629      	mov	r1, r5
 800acf2:	4632      	mov	r2, r6
 800acf4:	4620      	mov	r0, r4
 800acf6:	f7ff ff2b 	bl	800ab50 <send_hdr>
  r1 = recvr1(mmcp);
 800acfa:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800acfe:	f7ff fee7 	bl	800aad0 <recvr1.isra.0>
  spiUnselect(mmcp->config->spip);
 800ad02:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
static uint8_t send_command_R1(MMCDriver *mmcp, uint8_t cmd, uint32_t arg) {
  uint8_t r1;

  spiSelect(mmcp->config->spip);
  send_hdr(mmcp, cmd, arg);
  r1 = recvr1(mmcp);
 800ad04:	4605      	mov	r5, r0
  spiUnselect(mmcp->config->spip);
 800ad06:	6818      	ldr	r0, [r3, #0]
 800ad08:	f002 f8e2 	bl	800ced0 <spiUnselect>
  return r1;
}
 800ad0c:	4628      	mov	r0, r5
 800ad0e:	bd70      	pop	{r4, r5, r6, pc}

0800ad10 <mmcGetInfo>:
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcGetInfo(MMCDriver *mmcp, BlockDeviceInfo *bdip) {
 800ad10:	b508      	push	{r3, lr}

  osalDbgCheck((mmcp != NULL) && (bdip != NULL));
 800ad12:	b160      	cbz	r0, 800ad2e <mmcGetInfo+0x1e>
 800ad14:	b159      	cbz	r1, 800ad2e <mmcGetInfo+0x1e>

  if (mmcp->state != BLK_READY) {
 800ad16:	7903      	ldrb	r3, [r0, #4]
 800ad18:	2b05      	cmp	r3, #5
 800ad1a:	d001      	beq.n	800ad20 <mmcGetInfo+0x10>
    return HAL_FAILED;
 800ad1c:	2001      	movs	r0, #1

  bdip->blk_num  = mmcp->capacity;
  bdip->blk_size = MMCSD_BLOCK_SIZE;

  return HAL_SUCCESS;
}
 800ad1e:	bd08      	pop	{r3, pc}

  if (mmcp->state != BLK_READY) {
    return HAL_FAILED;
  }

  bdip->blk_num  = mmcp->capacity;
 800ad20:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800ad22:	604b      	str	r3, [r1, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 800ad24:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ad28:	600b      	str	r3, [r1, #0]

  return HAL_SUCCESS;
 800ad2a:	2000      	movs	r0, #0
 800ad2c:	bd08      	pop	{r3, pc}
 *
 * @api
 */
bool mmcGetInfo(MMCDriver *mmcp, BlockDeviceInfo *bdip) {

  osalDbgCheck((mmcp != NULL) && (bdip != NULL));
 800ad2e:	4801      	ldr	r0, [pc, #4]	; (800ad34 <mmcGetInfo+0x24>)
 800ad30:	f003 fd16 	bl	800e760 <chSysHalt>
 800ad34:	0801580c 	.word	0x0801580c
	...

0800ad40 <_mmcsd_get_slice>:
                          uint32_t end,
                          uint32_t start) {
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));
 800ad40:	4291      	cmp	r1, r2
 *
 * @notapi
 */
uint32_t _mmcsd_get_slice(const uint32_t *data,
                          uint32_t end,
                          uint32_t start) {
 800ad42:	b510      	push	{r4, lr}
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));
 800ad44:	d316      	bcc.n	800ad74 <_mmcsd_get_slice+0x34>
 800ad46:	1a8b      	subs	r3, r1, r2
 800ad48:	2b1f      	cmp	r3, #31
 800ad4a:	d813      	bhi.n	800ad74 <_mmcsd_get_slice+0x34>

  startidx = start / 32U;
  startoff = start % 32U;
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 800ad4c:	f001 041f 	and.w	r4, r1, #31
 800ad50:	2301      	movs	r3, #1
 800ad52:	3401      	adds	r4, #1
 800ad54:	fa03 f404 	lsl.w	r4, r3, r4

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
  endidx   = end / 32U;
 800ad58:	0949      	lsrs	r1, r1, #5
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
 800ad5a:	0953      	lsrs	r3, r2, #5
  startoff = start % 32U;
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
 800ad5c:	428b      	cmp	r3, r1
  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 800ad5e:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
 800ad62:	f002 021f 	and.w	r2, r2, #31
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
 800ad66:	d308      	bcc.n	800ad7a <_mmcsd_get_slice+0x3a>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 800ad68:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800ad6c:	ea04 0003 	and.w	r0, r4, r3
 800ad70:	40d0      	lsrs	r0, r2
}
 800ad72:	bd10      	pop	{r4, pc}
                          uint32_t end,
                          uint32_t start) {
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));
 800ad74:	4807      	ldr	r0, [pc, #28]	; (800ad94 <_mmcsd_get_slice+0x54>)
 800ad76:	f003 fcf3 	bl	800e760 <chSysHalt>
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800ad7a:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 800ad7e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800ad82:	ea04 0001 	and.w	r0, r4, r1
 800ad86:	f1c2 0420 	rsb	r4, r2, #32
 800ad8a:	40a0      	lsls	r0, r4
 800ad8c:	fa23 f202 	lsr.w	r2, r3, r2
 800ad90:	4310      	orrs	r0, r2
 800ad92:	bd10      	pop	{r4, pc}
 800ad94:	08015818 	.word	0x08015818
	...

0800ada0 <mmcSync>:
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcSync(MMCDriver *mmcp) {
 800ada0:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheck(mmcp != NULL);
 800ada2:	b1a0      	cbz	r0, 800adce <mmcSync+0x2e>

  if (mmcp->state != BLK_READY) {
 800ada4:	7905      	ldrb	r5, [r0, #4]
 800ada6:	2d05      	cmp	r5, #5
 800ada8:	4604      	mov	r4, r0
 800adaa:	d001      	beq.n	800adb0 <mmcSync+0x10>
    return HAL_FAILED;
 800adac:	2001      	movs	r0, #1
  sync(mmcp);

  /* Synchronization operation finished.*/
  mmcp->state = BLK_READY;
  return HAL_SUCCESS;
}
 800adae:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* Synchronization operation in progress.*/
  mmcp->state = BLK_SYNCING;

  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800adb0:	4606      	mov	r6, r0
  if (mmcp->state != BLK_READY) {
    return HAL_FAILED;
  }

  /* Synchronization operation in progress.*/
  mmcp->state = BLK_SYNCING;
 800adb2:	2208      	movs	r2, #8

  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800adb4:	f856 3f2c 	ldr.w	r3, [r6, #44]!
  if (mmcp->state != BLK_READY) {
    return HAL_FAILED;
  }

  /* Synchronization operation in progress.*/
  mmcp->state = BLK_SYNCING;
 800adb8:	7102      	strb	r2, [r0, #4]

  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800adba:	6899      	ldr	r1, [r3, #8]
 800adbc:	6818      	ldr	r0, [r3, #0]
 800adbe:	f002 f92f 	bl	800d020 <spiStart>
  sync(mmcp);
 800adc2:	4630      	mov	r0, r6
 800adc4:	f7ff fefc 	bl	800abc0 <sync.isra.2>

  /* Synchronization operation finished.*/
  mmcp->state = BLK_READY;
 800adc8:	7125      	strb	r5, [r4, #4]
 800adca:	2000      	movs	r0, #0
 800adcc:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @api
 */
bool mmcSync(MMCDriver *mmcp) {

  osalDbgCheck(mmcp != NULL);
 800adce:	4801      	ldr	r0, [pc, #4]	; (800add4 <mmcSync+0x34>)
 800add0:	f003 fcc6 	bl	800e760 <chSysHalt>
 800add4:	080156f8 	.word	0x080156f8
	...

0800ade0 <mmcConnect>:
 *                      in the @p MMC_READY state.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcConnect(MMCDriver *mmcp) {
 800ade0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ade2:	b083      	sub	sp, #12
  unsigned i;
  uint8_t r3[4];

  osalDbgCheck(mmcp != NULL);
 800ade4:	b128      	cbz	r0, 800adf2 <mmcConnect+0x12>

  osalDbgAssert((mmcp->state == BLK_ACTIVE) || (mmcp->state == BLK_READY),
 800ade6:	7903      	ldrb	r3, [r0, #4]
 800ade8:	2b02      	cmp	r3, #2
 800adea:	4605      	mov	r5, r0
 800adec:	d004      	beq.n	800adf8 <mmcConnect+0x18>
 800adee:	2b05      	cmp	r3, #5
 800adf0:	d002      	beq.n	800adf8 <mmcConnect+0x18>
 */
bool mmcConnect(MMCDriver *mmcp) {
  unsigned i;
  uint8_t r3[4];

  osalDbgCheck(mmcp != NULL);
 800adf2:	4859      	ldr	r0, [pc, #356]	; (800af58 <mmcConnect+0x178>)
 800adf4:	f003 fcb4 	bl	800e760 <chSysHalt>
  /* Connection procedure in progress.*/
  mmcp->state = BLK_CONNECTING;
  mmcp->block_addresses = false;

  /* Slow clock mode and 128 clock pulses.*/
  spiStart(mmcp->config->spip, mmcp->config->lscfg);
 800adf8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  osalDbgAssert((mmcp->state == BLK_ACTIVE) || (mmcp->state == BLK_READY),
                "invalid state");

  /* Connection procedure in progress.*/
  mmcp->state = BLK_CONNECTING;
  mmcp->block_addresses = false;
 800adfa:	2200      	movs	r2, #0

  osalDbgAssert((mmcp->state == BLK_ACTIVE) || (mmcp->state == BLK_READY),
                "invalid state");

  /* Connection procedure in progress.*/
  mmcp->state = BLK_CONNECTING;
 800adfc:	2403      	movs	r4, #3
  mmcp->block_addresses = false;

  /* Slow clock mode and 128 clock pulses.*/
  spiStart(mmcp->config->spip, mmcp->config->lscfg);
 800adfe:	e893 0003 	ldmia.w	r3, {r0, r1}

  osalDbgAssert((mmcp->state == BLK_ACTIVE) || (mmcp->state == BLK_READY),
                "invalid state");

  /* Connection procedure in progress.*/
  mmcp->state = BLK_CONNECTING;
 800ae02:	712c      	strb	r4, [r5, #4]
  mmcp->block_addresses = false;
 800ae04:	f885 2030 	strb.w	r2, [r5, #48]	; 0x30

  /* Slow clock mode and 128 clock pulses.*/
  spiStart(mmcp->config->spip, mmcp->config->lscfg);
 800ae08:	f002 f90a 	bl	800d020 <spiStart>
  spiIgnore(mmcp->config->spip, 16);
 800ae0c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ae0e:	2110      	movs	r1, #16
 800ae10:	6818      	ldr	r0, [r3, #0]
 800ae12:	f002 f80d 	bl	800ce30 <spiIgnore>
 800ae16:	240a      	movs	r4, #10
 800ae18:	e002      	b.n	800ae20 <mmcConnect+0x40>
 800ae1a:	20c8      	movs	r0, #200	; 0xc8
 800ae1c:	f004 f938 	bl	800f090 <chThdSleep>

  /* SPI mode selection.*/
  i = 0;
  while (true) {
    if (send_command_R1(mmcp, MMCSD_CMD_GO_IDLE_STATE, 0) == 0x01U) {
 800ae20:	2200      	movs	r2, #0
 800ae22:	4611      	mov	r1, r2
 800ae24:	4628      	mov	r0, r5
 800ae26:	f7ff ff5b 	bl	800ace0 <send_command_R1>
 800ae2a:	2801      	cmp	r0, #1
 800ae2c:	d00a      	beq.n	800ae44 <mmcConnect+0x64>
      break;
    }
    if (++i >= MMC_CMD0_RETRY) {
 800ae2e:	3c01      	subs	r4, #1
 800ae30:	d1f3      	bne.n	800ae1a <mmcConnect+0x3a>
  mmcp->state = BLK_READY;
  return HAL_SUCCESS;

  /* Connection failed, state reset to BLK_ACTIVE.*/
failed:
  spiStop(mmcp->config->spip);
 800ae32:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800ae34:	6818      	ldr	r0, [r3, #0]
 800ae36:	f002 f8ab 	bl	800cf90 <spiStop>
  mmcp->state = BLK_ACTIVE;
 800ae3a:	2302      	movs	r3, #2
 800ae3c:	712b      	strb	r3, [r5, #4]
  return HAL_FAILED;
 800ae3e:	2001      	movs	r0, #1
}
 800ae40:	b003      	add	sp, #12
 800ae42:	bdf0      	pop	{r4, r5, r6, r7, pc}

  /* Try to detect if this is a high capacity card and switch to block
     addresses if possible.
     This method is based on "How to support SDC Ver2 and high capacity cards"
     by ElmChan.*/
  if (send_command_R3(mmcp, MMCSD_CMD_SEND_IF_COND,
 800ae44:	ab01      	add	r3, sp, #4
 800ae46:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 800ae4a:	2108      	movs	r1, #8
 800ae4c:	4628      	mov	r0, r5
 800ae4e:	f7ff ff27 	bl	800aca0 <send_command_R3>
 800ae52:	2805      	cmp	r0, #5
 800ae54:	d022      	beq.n	800ae9c <mmcConnect+0xbc>
 800ae56:	2464      	movs	r4, #100	; 0x64
 800ae58:	e004      	b.n	800ae64 <mmcConnect+0x84>
          (send_command_R3(mmcp, MMCSD_CMD_APP_OP_COND, 0x400001AAU, r3) == 0x00U)) {
      /*lint -restore*/
        break;
      }

      if (++i >= MMC_ACMD41_RETRY) {
 800ae5a:	3c01      	subs	r4, #1
 800ae5c:	d0e9      	beq.n	800ae32 <mmcConnect+0x52>
 800ae5e:	20c8      	movs	r0, #200	; 0xc8
 800ae60:	f004 f916 	bl	800f090 <chThdSleep>

    /* Switch to SDHC mode.*/
    i = 0;
    while (true) {
      /*lint -save -e9007 [13.5] Side effect unimportant.*/
      if ((send_command_R1(mmcp, MMCSD_CMD_APP_CMD, 0) == 0x01U) &&
 800ae64:	2200      	movs	r2, #0
 800ae66:	2137      	movs	r1, #55	; 0x37
 800ae68:	4628      	mov	r0, r5
 800ae6a:	f7ff ff39 	bl	800ace0 <send_command_R1>
 800ae6e:	2801      	cmp	r0, #1
 800ae70:	4606      	mov	r6, r0
 800ae72:	d1f2      	bne.n	800ae5a <mmcConnect+0x7a>
          (send_command_R3(mmcp, MMCSD_CMD_APP_OP_COND, 0x400001AAU, r3) == 0x00U)) {
 800ae74:	ab01      	add	r3, sp, #4
 800ae76:	4a39      	ldr	r2, [pc, #228]	; (800af5c <mmcConnect+0x17c>)
 800ae78:	2129      	movs	r1, #41	; 0x29
 800ae7a:	4628      	mov	r0, r5
 800ae7c:	f7ff ff10 	bl	800aca0 <send_command_R3>

    /* Switch to SDHC mode.*/
    i = 0;
    while (true) {
      /*lint -save -e9007 [13.5] Side effect unimportant.*/
      if ((send_command_R1(mmcp, MMCSD_CMD_APP_CMD, 0) == 0x01U) &&
 800ae80:	2800      	cmp	r0, #0
 800ae82:	d1ea      	bne.n	800ae5a <mmcConnect+0x7a>
      }
      osalThreadSleepMilliseconds(10);
    }

    /* Execute dedicated read on OCR register */
    (void) send_command_R3(mmcp, MMCSD_CMD_READ_OCR, 0, r3);
 800ae84:	ab01      	add	r3, sp, #4
 800ae86:	4602      	mov	r2, r0
 800ae88:	213a      	movs	r1, #58	; 0x3a
 800ae8a:	4628      	mov	r0, r5
 800ae8c:	f7ff ff08 	bl	800aca0 <send_command_R3>

    /* Check if CCS is set in response. Card operates in block mode if set.*/
    if ((r3[0] & 0x40U) != 0U) {
 800ae90:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800ae94:	065b      	lsls	r3, r3, #25
      mmcp->block_addresses = true;
 800ae96:	bf48      	it	mi
 800ae98:	f885 6030 	strbmi.w	r6, [r5, #48]	; 0x30

  /* Try to detect if this is a high capacity card and switch to block
     addresses if possible.
     This method is based on "How to support SDC Ver2 and high capacity cards"
     by ElmChan.*/
  if (send_command_R3(mmcp, MMCSD_CMD_SEND_IF_COND,
 800ae9c:	2464      	movs	r4, #100	; 0x64
 800ae9e:	e006      	b.n	800aeae <mmcConnect+0xce>
  while (true) {
    uint8_t b = send_command_R1(mmcp, MMCSD_CMD_INIT, 0);
    if (b == 0x00U) {
      break;
    }
    if (b != 0x01U) {
 800aea0:	2801      	cmp	r0, #1
 800aea2:	d1c6      	bne.n	800ae32 <mmcConnect+0x52>
      goto failed;
    }
    if (++i >= MMC_CMD1_RETRY) {
 800aea4:	3c01      	subs	r4, #1
 800aea6:	d0c4      	beq.n	800ae32 <mmcConnect+0x52>
 800aea8:	20c8      	movs	r0, #200	; 0xc8
 800aeaa:	f004 f8f1 	bl	800f090 <chThdSleep>
  }

  /* Initialization.*/
  i = 0;
  while (true) {
    uint8_t b = send_command_R1(mmcp, MMCSD_CMD_INIT, 0);
 800aeae:	2200      	movs	r2, #0
 800aeb0:	2101      	movs	r1, #1
 800aeb2:	4628      	mov	r0, r5
 800aeb4:	f7ff ff14 	bl	800ace0 <send_command_R1>
    if (b == 0x00U) {
 800aeb8:	2800      	cmp	r0, #0
 800aeba:	d1f1      	bne.n	800aea0 <mmcConnect+0xc0>
    }
    osalThreadSleepMilliseconds(10);
  }

  /* Initialization complete, full speed.*/
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800aebc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800aebe:	6899      	ldr	r1, [r3, #8]
 800aec0:	6818      	ldr	r0, [r3, #0]
 800aec2:	f002 f8ad 	bl	800d020 <spiStart>

  /* Setting block size.*/
  if (send_command_R1(mmcp, MMCSD_CMD_SET_BLOCKLEN,
 800aec6:	f44f 7200 	mov.w	r2, #512	; 0x200
 800aeca:	2110      	movs	r1, #16
 800aecc:	4628      	mov	r0, r5
 800aece:	f7ff ff07 	bl	800ace0 <send_command_R1>
 800aed2:	2800      	cmp	r0, #0
 800aed4:	d1ad      	bne.n	800ae32 <mmcConnect+0x52>
                      MMCSD_BLOCK_SIZE) != 0x00U) {
    goto failed;
  }

  /* Determine capacity.*/
  if (read_CxD(mmcp, MMCSD_CMD_SEND_CSD, mmcp->csd)) {
 800aed6:	f105 0618 	add.w	r6, r5, #24
 800aeda:	4632      	mov	r2, r6
 800aedc:	2109      	movs	r1, #9
 800aede:	4628      	mov	r0, r5
 800aee0:	f7ff fe8e 	bl	800ac00 <read_CxD>
 800aee4:	4604      	mov	r4, r0
 800aee6:	2800      	cmp	r0, #0
 800aee8:	d1a3      	bne.n	800ae32 <mmcConnect+0x52>
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 800aeea:	227e      	movs	r2, #126	; 0x7e
 800aeec:	217f      	movs	r1, #127	; 0x7f
 800aeee:	4630      	mov	r0, r6
 800aef0:	f7ff ff26 	bl	800ad40 <_mmcsd_get_slice>
 800aef4:	b1b0      	cbz	r0, 800af24 <mmcConnect+0x144>
 800aef6:	2801      	cmp	r0, #1
 800aef8:	d12c      	bne.n	800af54 <mmcConnect+0x174>
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 800aefa:	4630      	mov	r0, r6
 800aefc:	2230      	movs	r2, #48	; 0x30
 800aefe:	2145      	movs	r1, #69	; 0x45
 800af00:	f7ff ff1e 	bl	800ad40 <_mmcsd_get_slice>
 800af04:	3001      	adds	r0, #1
 800af06:	0283      	lsls	r3, r0, #10
    goto failed;
  }

  mmcp->capacity = _mmcsd_get_capacity(mmcp->csd);
 800af08:	62ab      	str	r3, [r5, #40]	; 0x28
  if (mmcp->capacity == 0U) {
 800af0a:	2b00      	cmp	r3, #0
 800af0c:	d091      	beq.n	800ae32 <mmcConnect+0x52>
    goto failed;
  }

  if (read_CxD(mmcp, MMCSD_CMD_SEND_CID, mmcp->cid)) {
 800af0e:	f105 0208 	add.w	r2, r5, #8
 800af12:	210a      	movs	r1, #10
 800af14:	4628      	mov	r0, r5
 800af16:	f7ff fe73 	bl	800ac00 <read_CxD>
 800af1a:	2800      	cmp	r0, #0
 800af1c:	d189      	bne.n	800ae32 <mmcConnect+0x52>
    goto failed;
  }

  mmcp->state = BLK_READY;
 800af1e:	2305      	movs	r3, #5
 800af20:	712b      	strb	r3, [r5, #4]
 800af22:	e78d      	b.n	800ae40 <mmcConnect+0x60>
  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 800af24:	223e      	movs	r2, #62	; 0x3e
 800af26:	2149      	movs	r1, #73	; 0x49
 800af28:	4630      	mov	r0, r6
 800af2a:	f7ff ff09 	bl	800ad40 <_mmcsd_get_slice>
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800af2e:	222f      	movs	r2, #47	; 0x2f
  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 800af30:	4604      	mov	r4, r0
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800af32:	2131      	movs	r1, #49	; 0x31
 800af34:	4630      	mov	r0, r6
 800af36:	f7ff ff03 	bl	800ad40 <_mmcsd_get_slice>
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 800af3a:	2250      	movs	r2, #80	; 0x50

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800af3c:	4607      	mov	r7, r0
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 800af3e:	2153      	movs	r1, #83	; 0x53
 800af40:	4630      	mov	r0, r6
 800af42:	f7ff fefd 	bl	800ad40 <_mmcsd_get_slice>
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 800af46:	3401      	adds	r4, #1
 800af48:	3702      	adds	r7, #2
 800af4a:	3809      	subs	r0, #9
 800af4c:	40bc      	lsls	r4, r7
 800af4e:	fa04 f300 	lsl.w	r3, r4, r0
 800af52:	e7d9      	b.n	800af08 <mmcConnect+0x128>
  /* Determine capacity.*/
  if (read_CxD(mmcp, MMCSD_CMD_SEND_CSD, mmcp->csd)) {
    goto failed;
  }

  mmcp->capacity = _mmcsd_get_capacity(mmcp->csd);
 800af54:	62ac      	str	r4, [r5, #40]	; 0x28
 800af56:	e76c      	b.n	800ae32 <mmcConnect+0x52>
 800af58:	08015800 	.word	0x08015800
 800af5c:	400001aa 	.word	0x400001aa

0800af60 <mmcSequentialWrite.part.7.lto_priv.170>:
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
 800af60:	b530      	push	{r4, r5, lr}

  if (mmcp->state != BLK_WRITING) {
    return HAL_FAILED;
  }

  spiSend(mmcp->config->spip, sizeof(start), start);    /* Data prologue.   */
 800af62:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800af64:	4a19      	ldr	r2, [pc, #100]	; (800afcc <mmcSequentialWrite.part.7.lto_priv.170+0x6c>)
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
 800af66:	4604      	mov	r4, r0
 800af68:	b083      	sub	sp, #12

  if (mmcp->state != BLK_WRITING) {
    return HAL_FAILED;
  }

  spiSend(mmcp->config->spip, sizeof(start), start);    /* Data prologue.   */
 800af6a:	6818      	ldr	r0, [r3, #0]
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
 800af6c:	460d      	mov	r5, r1

  if (mmcp->state != BLK_WRITING) {
    return HAL_FAILED;
  }

  spiSend(mmcp->config->spip, sizeof(start), start);    /* Data prologue.   */
 800af6e:	2102      	movs	r1, #2
 800af70:	f001 ff0e 	bl	800cd90 <spiSend>
  spiSend(mmcp->config->spip, MMCSD_BLOCK_SIZE, buffer);/* Data.            */
 800af74:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800af76:	462a      	mov	r2, r5
 800af78:	6818      	ldr	r0, [r3, #0]
 800af7a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800af7e:	f001 ff07 	bl	800cd90 <spiSend>
  spiIgnore(mmcp->config->spip, 2);                     /* CRC ignored.     */
 800af82:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800af84:	2102      	movs	r1, #2
 800af86:	6818      	ldr	r0, [r3, #0]
 800af88:	f001 ff52 	bl	800ce30 <spiIgnore>
  spiReceive(mmcp->config->spip, 1, b);
 800af8c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800af8e:	aa01      	add	r2, sp, #4
 800af90:	6818      	ldr	r0, [r3, #0]
 800af92:	2101      	movs	r1, #1
 800af94:	f001 feac 	bl	800ccf0 <spiReceive>
  if ((b[0] & 0x1FU) == 0x05U) {
 800af98:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800af9c:	f003 031f 	and.w	r3, r3, #31
 800afa0:	2b05      	cmp	r3, #5
 800afa2:	d00c      	beq.n	800afbe <mmcSequentialWrite.part.7.lto_priv.170+0x5e>
    wait(mmcp);
    return HAL_SUCCESS;
  }

  /* Error.*/
  spiUnselect(mmcp->config->spip);
 800afa4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800afa6:	6818      	ldr	r0, [r3, #0]
 800afa8:	f001 ff92 	bl	800ced0 <spiUnselect>
  spiStop(mmcp->config->spip);
 800afac:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800afae:	6818      	ldr	r0, [r3, #0]
 800afb0:	f001 ffee 	bl	800cf90 <spiStop>
  mmcp->state = BLK_READY;
 800afb4:	2305      	movs	r3, #5
  return HAL_FAILED;
 800afb6:	2001      	movs	r0, #1
  }

  /* Error.*/
  spiUnselect(mmcp->config->spip);
  spiStop(mmcp->config->spip);
  mmcp->state = BLK_READY;
 800afb8:	7123      	strb	r3, [r4, #4]
  return HAL_FAILED;
}
 800afba:	b003      	add	sp, #12
 800afbc:	bd30      	pop	{r4, r5, pc}
  spiSend(mmcp->config->spip, sizeof(start), start);    /* Data prologue.   */
  spiSend(mmcp->config->spip, MMCSD_BLOCK_SIZE, buffer);/* Data.            */
  spiIgnore(mmcp->config->spip, 2);                     /* CRC ignored.     */
  spiReceive(mmcp->config->spip, 1, b);
  if ((b[0] & 0x1FU) == 0x05U) {
    wait(mmcp);
 800afbe:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800afc2:	f7ff fd9d 	bl	800ab00 <wait.isra.1>
    return HAL_SUCCESS;
 800afc6:	2000      	movs	r0, #0
  /* Error.*/
  spiUnselect(mmcp->config->spip);
  spiStop(mmcp->config->spip);
  mmcp->state = BLK_READY;
  return HAL_FAILED;
}
 800afc8:	b003      	add	sp, #12
 800afca:	bd30      	pop	{r4, r5, pc}
 800afcc:	08015880 	.word	0x08015880

0800afd0 <mmcStopSequentialRead.part.5.lto_priv.111>:
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcStopSequentialRead(MMCDriver *mmcp) {
 800afd0:	b538      	push	{r3, r4, r5, lr}

  if (mmcp->state != BLK_READING) {
    return HAL_FAILED;
  }

  spiSend(mmcp->config->spip, sizeof(stopcmd), stopcmd);
 800afd2:	4605      	mov	r5, r0
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcStopSequentialRead(MMCDriver *mmcp) {
 800afd4:	4604      	mov	r4, r0

  if (mmcp->state != BLK_READING) {
    return HAL_FAILED;
  }

  spiSend(mmcp->config->spip, sizeof(stopcmd), stopcmd);
 800afd6:	f855 3f2c 	ldr.w	r3, [r5, #44]!
 800afda:	4a08      	ldr	r2, [pc, #32]	; (800affc <mmcStopSequentialRead.part.5.lto_priv.111+0x2c>)
 800afdc:	6818      	ldr	r0, [r3, #0]
 800afde:	2107      	movs	r1, #7
 800afe0:	f001 fed6 	bl	800cd90 <spiSend>
/*  result = recvr1(mmcp) != 0x00U;*/
  /* Note, ignored r1 response, it can be not zero, unknown issue.*/
  (void) recvr1(mmcp);
 800afe4:	4628      	mov	r0, r5
 800afe6:	f7ff fd73 	bl	800aad0 <recvr1.isra.0>

  /* Read operation finished.*/
  spiUnselect(mmcp->config->spip);
 800afea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800afec:	6818      	ldr	r0, [r3, #0]
 800afee:	f001 ff6f 	bl	800ced0 <spiUnselect>
  mmcp->state = BLK_READY;
 800aff2:	2305      	movs	r3, #5
 800aff4:	7123      	strb	r3, [r4, #4]
  return HAL_SUCCESS;
}
 800aff6:	2000      	movs	r0, #0
 800aff8:	bd38      	pop	{r3, r4, r5, pc}
 800affa:	bf00      	nop
 800affc:	080156e4 	.word	0x080156e4

0800b000 <mmcStartSequentialWrite>:
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcStartSequentialWrite(MMCDriver *mmcp, uint32_t startblk) {
 800b000:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheck(mmcp != NULL);
 800b002:	b118      	cbz	r0, 800b00c <mmcStartSequentialWrite+0xc>
  osalDbgAssert(mmcp->state == BLK_READY, "invalid state");
 800b004:	7903      	ldrb	r3, [r0, #4]
 800b006:	2b05      	cmp	r3, #5
 800b008:	4604      	mov	r4, r0
 800b00a:	d002      	beq.n	800b012 <mmcStartSequentialWrite+0x12>
 *
 * @api
 */
bool mmcStartSequentialWrite(MMCDriver *mmcp, uint32_t startblk) {

  osalDbgCheck(mmcp != NULL);
 800b00c:	4814      	ldr	r0, [pc, #80]	; (800b060 <mmcStartSequentialWrite+0x60>)
 800b00e:	f003 fba7 	bl	800e760 <chSysHalt>
  osalDbgAssert(mmcp->state == BLK_READY, "invalid state");

  /* Write operation in progress.*/
  mmcp->state = BLK_WRITING;

  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b012:	6ac3      	ldr	r3, [r0, #44]	; 0x2c

  osalDbgCheck(mmcp != NULL);
  osalDbgAssert(mmcp->state == BLK_READY, "invalid state");

  /* Write operation in progress.*/
  mmcp->state = BLK_WRITING;
 800b014:	2207      	movs	r2, #7

  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b016:	6818      	ldr	r0, [r3, #0]
 800b018:	460d      	mov	r5, r1
 800b01a:	6899      	ldr	r1, [r3, #8]

  osalDbgCheck(mmcp != NULL);
  osalDbgAssert(mmcp->state == BLK_READY, "invalid state");

  /* Write operation in progress.*/
  mmcp->state = BLK_WRITING;
 800b01c:	7122      	strb	r2, [r4, #4]

  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b01e:	f001 ffff 	bl	800d020 <spiStart>
  spiSelect(mmcp->config->spip);
 800b022:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b024:	6818      	ldr	r0, [r3, #0]
 800b026:	f001 ff83 	bl	800cf30 <spiSelect>
  if (mmcp->block_addresses) {
 800b02a:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800b02e:	b18b      	cbz	r3, 800b054 <mmcStartSequentialWrite+0x54>
    send_hdr(mmcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK, startblk);
 800b030:	462a      	mov	r2, r5
 800b032:	2119      	movs	r1, #25
 800b034:	4620      	mov	r0, r4
 800b036:	f7ff fd8b 	bl	800ab50 <send_hdr>
  else {
    send_hdr(mmcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
             startblk * MMCSD_BLOCK_SIZE);
  }

  if (recvr1(mmcp) != 0x00U) {
 800b03a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800b03e:	f7ff fd47 	bl	800aad0 <recvr1.isra.0>
 800b042:	b130      	cbz	r0, 800b052 <mmcStartSequentialWrite+0x52>
    spiStop(mmcp->config->spip);
 800b044:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b046:	6818      	ldr	r0, [r3, #0]
 800b048:	f001 ffa2 	bl	800cf90 <spiStop>
    mmcp->state = BLK_READY;
 800b04c:	2305      	movs	r3, #5
 800b04e:	7123      	strb	r3, [r4, #4]
    return HAL_FAILED;
 800b050:	2001      	movs	r0, #1
  }
  return HAL_SUCCESS;
}
 800b052:	bd38      	pop	{r3, r4, r5, pc}
  spiSelect(mmcp->config->spip);
  if (mmcp->block_addresses) {
    send_hdr(mmcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK, startblk);
  }
  else {
    send_hdr(mmcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 800b054:	026a      	lsls	r2, r5, #9
 800b056:	2119      	movs	r1, #25
 800b058:	4620      	mov	r0, r4
 800b05a:	f7ff fd79 	bl	800ab50 <send_hdr>
 800b05e:	e7ec      	b.n	800b03a <mmcStartSequentialWrite+0x3a>
 800b060:	080156ac 	.word	0x080156ac
	...

0800b070 <mmc_write.lto_priv.128>:
  }
  return HAL_SUCCESS;
}

static bool mmc_write(void *instance, uint32_t startblk,
                 const uint8_t *buffer, uint32_t n) {
 800b070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b072:	4614      	mov	r4, r2
 800b074:	461d      	mov	r5, r3
 800b076:	4607      	mov	r7, r0

  if (mmcStartSequentialWrite((MMCDriver *)instance, startblk)) {
 800b078:	f7ff ffc2 	bl	800b000 <mmcStartSequentialWrite>
 800b07c:	b930      	cbnz	r0, 800b08c <mmc_write.lto_priv.128+0x1c>
 800b07e:	4606      	mov	r6, r0
    return HAL_FAILED;
  }

  while (n > 0U) {
 800b080:	b325      	cbz	r5, 800b0cc <mmc_write.lto_priv.128+0x5c>
 */
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
  static const uint8_t start[] = {0xFF, 0xFC};
  uint8_t b[1];

  osalDbgCheck((mmcp != NULL) && (buffer != NULL));
 800b082:	b137      	cbz	r7, 800b092 <mmc_write.lto_priv.128+0x22>
 800b084:	b12c      	cbz	r4, 800b092 <mmc_write.lto_priv.128+0x22>

  if (mmcp->state != BLK_WRITING) {
 800b086:	793b      	ldrb	r3, [r7, #4]
 800b088:	2b07      	cmp	r3, #7
 800b08a:	d005      	beq.n	800b098 <mmc_write.lto_priv.128+0x28>

static bool mmc_write(void *instance, uint32_t startblk,
                 const uint8_t *buffer, uint32_t n) {

  if (mmcStartSequentialWrite((MMCDriver *)instance, startblk)) {
    return HAL_FAILED;
 800b08c:	2601      	movs	r6, #1

  if (mmcStopSequentialWrite((MMCDriver *)instance)) {
    return HAL_FAILED;
  }
  return HAL_SUCCESS;
}
 800b08e:	4630      	mov	r0, r6
 800b090:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
  static const uint8_t start[] = {0xFF, 0xFC};
  uint8_t b[1];

  osalDbgCheck((mmcp != NULL) && (buffer != NULL));
 800b092:	4811      	ldr	r0, [pc, #68]	; (800b0d8 <mmc_write.lto_priv.128+0x68>)
 800b094:	f003 fb64 	bl	800e760 <chSysHalt>
 800b098:	4621      	mov	r1, r4
 800b09a:	4638      	mov	r0, r7
 800b09c:	f7ff ff60 	bl	800af60 <mmcSequentialWrite.part.7.lto_priv.170>
  if (mmcStartSequentialWrite((MMCDriver *)instance, startblk)) {
    return HAL_FAILED;
  }

  while (n > 0U) {
    if (mmcSequentialWrite((MMCDriver *)instance, buffer)) {
 800b0a0:	2800      	cmp	r0, #0
 800b0a2:	d1f3      	bne.n	800b08c <mmc_write.lto_priv.128+0x1c>

  if (mmcStartSequentialWrite((MMCDriver *)instance, startblk)) {
    return HAL_FAILED;
  }

  while (n > 0U) {
 800b0a4:	3d01      	subs	r5, #1
    if (mmcSequentialWrite((MMCDriver *)instance, buffer)) {
      return HAL_FAILED;
    }
    buffer += MMCSD_BLOCK_SIZE;
 800b0a6:	f504 7400 	add.w	r4, r4, #512	; 0x200

  if (mmcStartSequentialWrite((MMCDriver *)instance, startblk)) {
    return HAL_FAILED;
  }

  while (n > 0U) {
 800b0aa:	d1eb      	bne.n	800b084 <mmc_write.lto_priv.128+0x14>
bool mmcStopSequentialWrite(MMCDriver *mmcp) {
  static const uint8_t stop[] = {0xFD, 0xFF};

  osalDbgCheck(mmcp != NULL);

  if (mmcp->state != BLK_WRITING) {
 800b0ac:	793b      	ldrb	r3, [r7, #4]
 800b0ae:	2b07      	cmp	r3, #7
 800b0b0:	d1ec      	bne.n	800b08c <mmc_write.lto_priv.128+0x1c>
    return HAL_FAILED;
  }

  spiSend(mmcp->config->spip, sizeof(stop), stop);
 800b0b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0b4:	4a09      	ldr	r2, [pc, #36]	; (800b0dc <mmc_write.lto_priv.128+0x6c>)
 800b0b6:	6818      	ldr	r0, [r3, #0]
 800b0b8:	2102      	movs	r1, #2
 800b0ba:	f001 fe69 	bl	800cd90 <spiSend>
  spiUnselect(mmcp->config->spip);
 800b0be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0c0:	6818      	ldr	r0, [r3, #0]
 800b0c2:	f001 ff05 	bl	800ced0 <spiUnselect>

  /* Write operation finished.*/
  mmcp->state = BLK_READY;
 800b0c6:	2305      	movs	r3, #5
 800b0c8:	713b      	strb	r3, [r7, #4]
 800b0ca:	e7e0      	b.n	800b08e <mmc_write.lto_priv.128+0x1e>
 * @api
 */
bool mmcStopSequentialWrite(MMCDriver *mmcp) {
  static const uint8_t stop[] = {0xFD, 0xFF};

  osalDbgCheck(mmcp != NULL);
 800b0cc:	2f00      	cmp	r7, #0
 800b0ce:	d1ed      	bne.n	800b0ac <mmc_write.lto_priv.128+0x3c>
 800b0d0:	4803      	ldr	r0, [pc, #12]	; (800b0e0 <mmc_write.lto_priv.128+0x70>)
 800b0d2:	f003 fb45 	bl	800e760 <chSysHalt>
 800b0d6:	bf00      	nop
 800b0d8:	08015884 	.word	0x08015884
 800b0dc:	08015898 	.word	0x08015898
 800b0e0:	080158cc 	.word	0x080158cc
	...

0800b0f0 <mmcSequentialRead>:
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcSequentialRead(MMCDriver *mmcp, uint8_t *buffer) {
 800b0f0:	b570      	push	{r4, r5, r6, lr}
  unsigned i;

  osalDbgCheck((mmcp != NULL) && (buffer != NULL));
 800b0f2:	b318      	cbz	r0, 800b13c <mmcSequentialRead+0x4c>
 800b0f4:	460d      	mov	r5, r1
 800b0f6:	b309      	cbz	r1, 800b13c <mmcSequentialRead+0x4c>

  if (mmcp->state != BLK_READING) {
 800b0f8:	7903      	ldrb	r3, [r0, #4]
 800b0fa:	2b06      	cmp	r3, #6
 800b0fc:	4606      	mov	r6, r0
 800b0fe:	d001      	beq.n	800b104 <mmcSequentialRead+0x14>
    return HAL_FAILED;
 800b100:	2001      	movs	r0, #1
  /* Timeout.*/
  spiUnselect(mmcp->config->spip);
  spiStop(mmcp->config->spip);
  mmcp->state = BLK_READY;
  return HAL_FAILED;
}
 800b102:	bd70      	pop	{r4, r5, r6, pc}
bool mmcSequentialRead(MMCDriver *mmcp, uint8_t *buffer) {
  unsigned i;

  osalDbgCheck((mmcp != NULL) && (buffer != NULL));

  if (mmcp->state != BLK_READING) {
 800b104:	f242 7410 	movw	r4, #10000	; 0x2710
 800b108:	e001      	b.n	800b10e <mmcSequentialRead+0x1e>
    return HAL_FAILED;
  }

  for (i = 0; i < MMC_WAIT_DATA; i++) {
 800b10a:	3c01      	subs	r4, #1
 800b10c:	d019      	beq.n	800b142 <mmcSequentialRead+0x52>
    spiReceive(mmcp->config->spip, 1, buffer);
 800b10e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b110:	462a      	mov	r2, r5
 800b112:	6818      	ldr	r0, [r3, #0]
 800b114:	2101      	movs	r1, #1
 800b116:	f001 fdeb 	bl	800ccf0 <spiReceive>
    if (buffer[0] == 0xFEU) {
 800b11a:	782b      	ldrb	r3, [r5, #0]
 800b11c:	2bfe      	cmp	r3, #254	; 0xfe
 800b11e:	d1f4      	bne.n	800b10a <mmcSequentialRead+0x1a>
      spiReceive(mmcp->config->spip, MMCSD_BLOCK_SIZE, buffer);
 800b120:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b122:	462a      	mov	r2, r5
 800b124:	6818      	ldr	r0, [r3, #0]
 800b126:	f44f 7100 	mov.w	r1, #512	; 0x200
 800b12a:	f001 fde1 	bl	800ccf0 <spiReceive>
      /* CRC ignored. */
      spiIgnore(mmcp->config->spip, 2);
 800b12e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b130:	2102      	movs	r1, #2
 800b132:	6818      	ldr	r0, [r3, #0]
 800b134:	f001 fe7c 	bl	800ce30 <spiIgnore>
      return HAL_SUCCESS;
 800b138:	2000      	movs	r0, #0
 800b13a:	bd70      	pop	{r4, r5, r6, pc}
 * @api
 */
bool mmcSequentialRead(MMCDriver *mmcp, uint8_t *buffer) {
  unsigned i;

  osalDbgCheck((mmcp != NULL) && (buffer != NULL));
 800b13c:	4807      	ldr	r0, [pc, #28]	; (800b15c <mmcSequentialRead+0x6c>)
 800b13e:	f003 fb0f 	bl	800e760 <chSysHalt>
      spiIgnore(mmcp->config->spip, 2);
      return HAL_SUCCESS;
    }
  }
  /* Timeout.*/
  spiUnselect(mmcp->config->spip);
 800b142:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b144:	6818      	ldr	r0, [r3, #0]
 800b146:	f001 fec3 	bl	800ced0 <spiUnselect>
  spiStop(mmcp->config->spip);
 800b14a:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800b14c:	6818      	ldr	r0, [r3, #0]
 800b14e:	f001 ff1f 	bl	800cf90 <spiStop>
  mmcp->state = BLK_READY;
 800b152:	2305      	movs	r3, #5
 800b154:	7133      	strb	r3, [r6, #4]
 800b156:	2001      	movs	r0, #1
 800b158:	bd70      	pop	{r4, r5, r6, pc}
 800b15a:	bf00      	nop
 800b15c:	08015860 	.word	0x08015860

0800b160 <mmcStartSequentialRead>:
 * @retval HAL_SUCCESS   the operation succeeded.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcStartSequentialRead(MMCDriver *mmcp, uint32_t startblk) {
 800b160:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheck(mmcp != NULL);
 800b162:	b118      	cbz	r0, 800b16c <mmcStartSequentialRead+0xc>
  osalDbgAssert(mmcp->state == BLK_READY, "invalid state");
 800b164:	7903      	ldrb	r3, [r0, #4]
 800b166:	2b05      	cmp	r3, #5
 800b168:	4604      	mov	r4, r0
 800b16a:	d002      	beq.n	800b172 <mmcStartSequentialRead+0x12>
 *
 * @api
 */
bool mmcStartSequentialRead(MMCDriver *mmcp, uint32_t startblk) {

  osalDbgCheck(mmcp != NULL);
 800b16c:	4814      	ldr	r0, [pc, #80]	; (800b1c0 <mmcStartSequentialRead+0x60>)
 800b16e:	f003 faf7 	bl	800e760 <chSysHalt>
  /* Read operation in progress.*/
  mmcp->state = BLK_READING;

  /* (Re)starting the SPI in case it has been reprogrammed externally, it can
     happen if the SPI bus is shared among multiple peripherals.*/
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b172:	6ac3      	ldr	r3, [r0, #44]	; 0x2c

  osalDbgCheck(mmcp != NULL);
  osalDbgAssert(mmcp->state == BLK_READY, "invalid state");

  /* Read operation in progress.*/
  mmcp->state = BLK_READING;
 800b174:	2206      	movs	r2, #6

  /* (Re)starting the SPI in case it has been reprogrammed externally, it can
     happen if the SPI bus is shared among multiple peripherals.*/
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b176:	6818      	ldr	r0, [r3, #0]
 800b178:	460d      	mov	r5, r1
 800b17a:	6899      	ldr	r1, [r3, #8]

  osalDbgCheck(mmcp != NULL);
  osalDbgAssert(mmcp->state == BLK_READY, "invalid state");

  /* Read operation in progress.*/
  mmcp->state = BLK_READING;
 800b17c:	7122      	strb	r2, [r4, #4]

  /* (Re)starting the SPI in case it has been reprogrammed externally, it can
     happen if the SPI bus is shared among multiple peripherals.*/
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b17e:	f001 ff4f 	bl	800d020 <spiStart>
  spiSelect(mmcp->config->spip);
 800b182:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b184:	6818      	ldr	r0, [r3, #0]
 800b186:	f001 fed3 	bl	800cf30 <spiSelect>

  if (mmcp->block_addresses) {
 800b18a:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800b18e:	b18b      	cbz	r3, 800b1b4 <mmcStartSequentialRead+0x54>
    send_hdr(mmcp, MMCSD_CMD_READ_MULTIPLE_BLOCK, startblk);
 800b190:	462a      	mov	r2, r5
 800b192:	2112      	movs	r1, #18
 800b194:	4620      	mov	r0, r4
 800b196:	f7ff fcdb 	bl	800ab50 <send_hdr>
  }
  else {
    send_hdr(mmcp, MMCSD_CMD_READ_MULTIPLE_BLOCK, startblk * MMCSD_BLOCK_SIZE);
  }

  if (recvr1(mmcp) != 0x00U) {
 800b19a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 800b19e:	f7ff fc97 	bl	800aad0 <recvr1.isra.0>
 800b1a2:	b130      	cbz	r0, 800b1b2 <mmcStartSequentialRead+0x52>
    spiStop(mmcp->config->spip);
 800b1a4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b1a6:	6818      	ldr	r0, [r3, #0]
 800b1a8:	f001 fef2 	bl	800cf90 <spiStop>
    mmcp->state = BLK_READY;
 800b1ac:	2305      	movs	r3, #5
 800b1ae:	7123      	strb	r3, [r4, #4]
    return HAL_FAILED;
 800b1b0:	2001      	movs	r0, #1
  }
  return HAL_SUCCESS;
}
 800b1b2:	bd38      	pop	{r3, r4, r5, pc}

  if (mmcp->block_addresses) {
    send_hdr(mmcp, MMCSD_CMD_READ_MULTIPLE_BLOCK, startblk);
  }
  else {
    send_hdr(mmcp, MMCSD_CMD_READ_MULTIPLE_BLOCK, startblk * MMCSD_BLOCK_SIZE);
 800b1b4:	026a      	lsls	r2, r5, #9
 800b1b6:	2112      	movs	r1, #18
 800b1b8:	4620      	mov	r0, r4
 800b1ba:	f7ff fcc9 	bl	800ab50 <send_hdr>
 800b1be:	e7ec      	b.n	800b19a <mmcStartSequentialRead+0x3a>
 800b1c0:	08015848 	.word	0x08015848
	...

0800b1d0 <mmc_read.lto_priv.127>:
/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static bool mmc_read(void *instance, uint32_t startblk,
                uint8_t *buffer, uint32_t n) {
 800b1d0:	b570      	push	{r4, r5, r6, lr}
 800b1d2:	4615      	mov	r5, r2
 800b1d4:	461c      	mov	r4, r3
 800b1d6:	4606      	mov	r6, r0

  if (mmcStartSequentialRead((MMCDriver *)instance, startblk)) {
 800b1d8:	f7ff ffc2 	bl	800b160 <mmcStartSequentialRead>
 800b1dc:	b958      	cbnz	r0, 800b1f6 <mmc_read.lto_priv.127+0x26>
    return HAL_FAILED;
  }

  while (n > 0U) {
 800b1de:	b924      	cbnz	r4, 800b1ea <mmc_read.lto_priv.127+0x1a>
 800b1e0:	e00b      	b.n	800b1fa <mmc_read.lto_priv.127+0x2a>
 800b1e2:	3c01      	subs	r4, #1
    if (mmcSequentialRead((MMCDriver *)instance, buffer)) {
      return HAL_FAILED;
    }
    buffer += MMCSD_BLOCK_SIZE;
 800b1e4:	f505 7500 	add.w	r5, r5, #512	; 0x200

  if (mmcStartSequentialRead((MMCDriver *)instance, startblk)) {
    return HAL_FAILED;
  }

  while (n > 0U) {
 800b1e8:	d007      	beq.n	800b1fa <mmc_read.lto_priv.127+0x2a>
    if (mmcSequentialRead((MMCDriver *)instance, buffer)) {
 800b1ea:	4629      	mov	r1, r5
 800b1ec:	4630      	mov	r0, r6
 800b1ee:	f7ff ff7f 	bl	800b0f0 <mmcSequentialRead>
 800b1f2:	2800      	cmp	r0, #0
 800b1f4:	d0f5      	beq.n	800b1e2 <mmc_read.lto_priv.127+0x12>

  if (mmcStopSequentialRead((MMCDriver *)instance)) {
    return HAL_FAILED;
  }
  return HAL_SUCCESS;
}
 800b1f6:	2001      	movs	r0, #1
 800b1f8:	bd70      	pop	{r4, r5, r6, pc}
bool mmcStopSequentialRead(MMCDriver *mmcp) {
  static const uint8_t stopcmd[] = {
    (uint8_t)(0x40U | MMCSD_CMD_STOP_TRANSMISSION), 0, 0, 0, 0, 1, 0xFF
  };

  osalDbgCheck(mmcp != NULL);
 800b1fa:	b13e      	cbz	r6, 800b20c <mmc_read.lto_priv.127+0x3c>

  if (mmcp->state != BLK_READING) {
 800b1fc:	7933      	ldrb	r3, [r6, #4]
 800b1fe:	2b06      	cmp	r3, #6
 800b200:	d1f9      	bne.n	800b1f6 <mmc_read.lto_priv.127+0x26>
 800b202:	4630      	mov	r0, r6

  if (mmcStopSequentialRead((MMCDriver *)instance)) {
    return HAL_FAILED;
  }
  return HAL_SUCCESS;
}
 800b204:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800b208:	f7ff bee2 	b.w	800afd0 <mmcStopSequentialRead.part.5.lto_priv.111>
bool mmcStopSequentialRead(MMCDriver *mmcp) {
  static const uint8_t stopcmd[] = {
    (uint8_t)(0x40U | MMCSD_CMD_STOP_TRANSMISSION), 0, 0, 0, 0, 1, 0xFF
  };

  osalDbgCheck(mmcp != NULL);
 800b20c:	4801      	ldr	r0, [pc, #4]	; (800b214 <mmc_read.lto_priv.127+0x44>)
 800b20e:	f003 faa7 	bl	800e760 <chSysHalt>
 800b212:	bf00      	nop
 800b214:	08017568 	.word	0x08017568
	...

0800b220 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 800b220:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800b222:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b226:	68da      	ldr	r2, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800b228:	0792      	lsls	r2, r2, #30
 800b22a:	d501      	bpl.n	800b230 <stSetAlarm+0x10>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800b22c:	6358      	str	r0, [r3, #52]	; 0x34
 800b22e:	bd08      	pop	{r3, pc}
 800b230:	4801      	ldr	r0, [pc, #4]	; (800b238 <stSetAlarm+0x18>)
 800b232:	f003 fa95 	bl	800e760 <chSysHalt>
 800b236:	bf00      	nop
 800b238:	0801583c 	.word	0x0801583c
 800b23c:	00000000 	.word	0x00000000

0800b240 <_port_irq_epilogue>:
 800b240:	2320      	movs	r3, #32
 800b242:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 800b246:	4b0f      	ldr	r3, [pc, #60]	; (800b284 <_port_irq_epilogue+0x44>)
 800b248:	685b      	ldr	r3, [r3, #4]
 800b24a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800b24e:	d102      	bne.n	800b256 <_port_irq_epilogue+0x16>
 800b250:	f383 8811 	msr	BASEPRI, r3
 800b254:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800b256:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800b25a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800b25e:	f843 2c04 	str.w	r2, [r3, #-4]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800b262:	f1a3 0220 	sub.w	r2, r3, #32
 800b266:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800b26a:	4a07      	ldr	r2, [pc, #28]	; (800b288 <_port_irq_epilogue+0x48>)
 800b26c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 800b26e:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800b270:	6889      	ldr	r1, [r1, #8]
 800b272:	6892      	ldr	r2, [r2, #8]
 800b274:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800b276:	bf8c      	ite	hi
 800b278:	4a04      	ldrhi	r2, [pc, #16]	; (800b28c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800b27a:	4a05      	ldrls	r2, [pc, #20]	; (800b290 <_port_irq_epilogue+0x50>)
 800b27c:	f843 2c08 	str.w	r2, [r3, #-8]
 800b280:	4770      	bx	lr
 800b282:	bf00      	nop
 800b284:	e000ed00 	.word	0xe000ed00
 800b288:	20027edc 	.word	0x20027edc
 800b28c:	080002c5 	.word	0x080002c5
 800b290:	080002d0 	.word	0x080002d0
	...

0800b2a0 <mmcDisconnect>:
 *                      in the @p MMC_INSERTED state.
 * @retval HAL_FAILED    the operation failed.
 *
 * @api
 */
bool mmcDisconnect(MMCDriver *mmcp) {
 800b2a0:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheck(mmcp != NULL);
 800b2a2:	b150      	cbz	r0, 800b2ba <mmcDisconnect+0x1a>
 800b2a4:	4604      	mov	r4, r0
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800b2a6:	2320      	movs	r3, #32
 800b2a8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b2ac:	f003 fd68 	bl	800ed80 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((mmcp->state == BLK_ACTIVE) || (mmcp->state == BLK_READY),
 800b2b0:	7923      	ldrb	r3, [r4, #4]
 800b2b2:	2b02      	cmp	r3, #2
 800b2b4:	d029      	beq.n	800b30a <mmcDisconnect+0x6a>
 800b2b6:	2b05      	cmp	r3, #5
 800b2b8:	d002      	beq.n	800b2c0 <mmcDisconnect+0x20>
 *
 * @api
 */
bool mmcDisconnect(MMCDriver *mmcp) {

  osalDbgCheck(mmcp != NULL);
 800b2ba:	481b      	ldr	r0, [pc, #108]	; (800b328 <mmcDisconnect+0x88>)
 800b2bc:	f003 fa50 	bl	800e760 <chSysHalt>
                "invalid state");
  if (mmcp->state == BLK_ACTIVE) {
    osalSysUnlock();
    return HAL_SUCCESS;
  }
  mmcp->state = BLK_DISCONNECTING;
 800b2c0:	2304      	movs	r3, #4
 800b2c2:	7123      	strb	r3, [r4, #4]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b2c4:	f003 fd4c 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b2c8:	4b18      	ldr	r3, [pc, #96]	; (800b32c <mmcDisconnect+0x8c>)
 800b2ca:	681a      	ldr	r2, [r3, #0]
 800b2cc:	429a      	cmp	r2, r3
 800b2ce:	d004      	beq.n	800b2da <mmcDisconnect+0x3a>
 800b2d0:	6999      	ldr	r1, [r3, #24]
 800b2d2:	6893      	ldr	r3, [r2, #8]
 800b2d4:	688a      	ldr	r2, [r1, #8]
 800b2d6:	429a      	cmp	r2, r3
 800b2d8:	d314      	bcc.n	800b304 <mmcDisconnect+0x64>
 800b2da:	2300      	movs	r3, #0
 800b2dc:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();

  /* Wait for the pending write operations to complete.*/
  spiStart(mmcp->config->spip, mmcp->config->hscfg);
 800b2e0:	4625      	mov	r5, r4
 800b2e2:	f855 3f2c 	ldr.w	r3, [r5, #44]!
 800b2e6:	6899      	ldr	r1, [r3, #8]
 800b2e8:	6818      	ldr	r0, [r3, #0]
 800b2ea:	f001 fe99 	bl	800d020 <spiStart>
  sync(mmcp);
 800b2ee:	4628      	mov	r0, r5
 800b2f0:	f7ff fc66 	bl	800abc0 <sync.isra.2>

  spiStop(mmcp->config->spip);
 800b2f4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b2f6:	6818      	ldr	r0, [r3, #0]
 800b2f8:	f001 fe4a 	bl	800cf90 <spiStop>
  mmcp->state = BLK_ACTIVE;
 800b2fc:	2302      	movs	r3, #2
 800b2fe:	7123      	strb	r3, [r4, #4]
  return HAL_SUCCESS;
}
 800b300:	2000      	movs	r0, #0
 800b302:	bd38      	pop	{r3, r4, r5, pc}
 800b304:	480a      	ldr	r0, [pc, #40]	; (800b330 <mmcDisconnect+0x90>)
 800b306:	f003 fa2b 	bl	800e760 <chSysHalt>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b30a:	f003 fd29 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b30e:	4b07      	ldr	r3, [pc, #28]	; (800b32c <mmcDisconnect+0x8c>)
 800b310:	681a      	ldr	r2, [r3, #0]
 800b312:	429a      	cmp	r2, r3
 800b314:	d004      	beq.n	800b320 <mmcDisconnect+0x80>
 800b316:	6999      	ldr	r1, [r3, #24]
 800b318:	6893      	ldr	r3, [r2, #8]
 800b31a:	688a      	ldr	r2, [r1, #8]
 800b31c:	429a      	cmp	r2, r3
 800b31e:	d3f1      	bcc.n	800b304 <mmcDisconnect+0x64>
 800b320:	2300      	movs	r3, #0
 800b322:	f383 8811 	msr	BASEPRI, r3
 800b326:	e7eb      	b.n	800b300 <mmcDisconnect+0x60>
 800b328:	0801582c 	.word	0x0801582c
 800b32c:	20027edc 	.word	0x20027edc
 800b330:	08015874 	.word	0x08015874
	...

0800b340 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 800b340:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b344:	b083      	sub	sp, #12
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);
 800b346:	2a00      	cmp	r2, #0
 800b348:	d074      	beq.n	800b434 <oqWriteTimeout+0xf4>
 800b34a:	4604      	mov	r4, r0
 800b34c:	4688      	mov	r8, r1
 800b34e:	461e      	mov	r6, r3
 800b350:	4615      	mov	r5, r2
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 800b352:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 800b356:	f04f 0b20 	mov.w	fp, #32
 800b35a:	f38b 8811 	msr	BASEPRI, fp
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b35e:	f003 fd0f 	bl	800ed80 <_dbg_check_lock>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800b362:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b366:	4f35      	ldr	r7, [pc, #212]	; (800b43c <oqWriteTimeout+0xfc>)
 800b368:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b36a:	f8cd b004 	str.w	fp, [sp, #4]
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800b36e:	18f3      	adds	r3, r6, r3
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 800b370:	f04f 0900 	mov.w	r9, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800b374:	9300      	str	r3, [sp, #0]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b376:	46bb      	mov	fp, r7

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 800b378:	68a3      	ldr	r3, [r4, #8]
 800b37a:	2b00      	cmp	r3, #0
 800b37c:	d02f      	beq.n	800b3de <oqWriteTimeout+0x9e>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800b37e:	6962      	ldr	r2, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 800b380:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800b382:	1c51      	adds	r1, r2, #1
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 800b384:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 800b386:	6161      	str	r1, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 800b388:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800b38a:	f898 3000 	ldrb.w	r3, [r8]
 800b38e:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800b390:	6923      	ldr	r3, [r4, #16]
 800b392:	6962      	ldr	r2, [r4, #20]
 800b394:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 800b396:	bf24      	itt	cs
 800b398:	68e3      	ldrcs	r3, [r4, #12]
 800b39a:	6163      	strcs	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 800b39c:	f1ba 0f00 	cmp.w	sl, #0
 800b3a0:	d001      	beq.n	800b3a6 <oqWriteTimeout+0x66>
      nfy(oqp);
 800b3a2:	4620      	mov	r0, r4
 800b3a4:	47d0      	blx	sl
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b3a6:	f003 fcdb 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b3aa:	683b      	ldr	r3, [r7, #0]
 800b3ac:	42bb      	cmp	r3, r7
 800b3ae:	d005      	beq.n	800b3bc <oqWriteTimeout+0x7c>
 800b3b0:	f8db 2018 	ldr.w	r2, [fp, #24]
 800b3b4:	689b      	ldr	r3, [r3, #8]
 800b3b6:	6892      	ldr	r2, [r2, #8]
 800b3b8:	429a      	cmp	r2, r3
 800b3ba:	d331      	bcc.n	800b420 <oqWriteTimeout+0xe0>
 800b3bc:	2300      	movs	r3, #0
 800b3be:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 800b3c2:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 800b3c4:	f109 0901 	add.w	r9, r9, #1
    if (--n == 0U) {
 800b3c8:	d026      	beq.n	800b418 <oqWriteTimeout+0xd8>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800b3ca:	f108 0801 	add.w	r8, r8, #1
 800b3ce:	9b01      	ldr	r3, [sp, #4]
 800b3d0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b3d4:	f003 fcd4 	bl	800ed80 <_dbg_check_lock>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 800b3d8:	68a3      	ldr	r3, [r4, #8]
 800b3da:	2b00      	cmp	r3, #0
 800b3dc:	d1cf      	bne.n	800b37e <oqWriteTimeout+0x3e>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800b3de:	1e73      	subs	r3, r6, #1
 800b3e0:	3303      	adds	r3, #3
 800b3e2:	d820      	bhi.n	800b426 <oqWriteTimeout+0xe6>
 800b3e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b3e8:	6a59      	ldr	r1, [r3, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800b3ea:	9b00      	ldr	r3, [sp, #0]
 800b3ec:	1a59      	subs	r1, r3, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 800b3ee:	428e      	cmp	r6, r1
 800b3f0:	d304      	bcc.n	800b3fc <oqWriteTimeout+0xbc>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 800b3f2:	4620      	mov	r0, r4
 800b3f4:	f003 fc04 	bl	800ec00 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800b3f8:	2800      	cmp	r0, #0
 800b3fa:	d0bd      	beq.n	800b378 <oqWriteTimeout+0x38>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b3fc:	f003 fcb0 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b400:	683b      	ldr	r3, [r7, #0]
 800b402:	4a0e      	ldr	r2, [pc, #56]	; (800b43c <oqWriteTimeout+0xfc>)
 800b404:	42bb      	cmp	r3, r7
 800b406:	d004      	beq.n	800b412 <oqWriteTimeout+0xd2>
 800b408:	6992      	ldr	r2, [r2, #24]
 800b40a:	689b      	ldr	r3, [r3, #8]
 800b40c:	6892      	ldr	r2, [r2, #8]
 800b40e:	429a      	cmp	r2, r3
 800b410:	d306      	bcc.n	800b420 <oqWriteTimeout+0xe0>
 800b412:	2300      	movs	r3, #0
 800b414:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
 800b418:	4648      	mov	r0, r9
 800b41a:	b003      	add	sp, #12
 800b41c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b420:	4807      	ldr	r0, [pc, #28]	; (800b440 <oqWriteTimeout+0x100>)
 800b422:	f003 f99d 	bl	800e760 <chSysHalt>
 800b426:	4631      	mov	r1, r6
 800b428:	4620      	mov	r0, r4
 800b42a:	f003 fbe9 	bl	800ec00 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800b42e:	2800      	cmp	r0, #0
 800b430:	d0a2      	beq.n	800b378 <oqWriteTimeout+0x38>
 800b432:	e7e3      	b.n	800b3fc <oqWriteTimeout+0xbc>
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);
 800b434:	4803      	ldr	r0, [pc, #12]	; (800b444 <oqWriteTimeout+0x104>)
 800b436:	f003 f993 	bl	800e760 <chSysHalt>
 800b43a:	bf00      	nop
 800b43c:	20027edc 	.word	0x20027edc
 800b440:	080156ec 	.word	0x080156ec
 800b444:	080156c4 	.word	0x080156c4
	...

0800b450 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 800b450:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b452:	4604      	mov	r4, r0
 800b454:	460f      	mov	r7, r1
 800b456:	4616      	mov	r6, r2
 800b458:	2320      	movs	r3, #32
 800b45a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b45e:	f003 fc8f 	bl	800ed80 <_dbg_check_lock>
 800b462:	e005      	b.n	800b470 <oqPutTimeout+0x20>
 800b464:	4631      	mov	r1, r6
 800b466:	4620      	mov	r0, r4
 800b468:	f003 fbca 	bl	800ec00 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 800b46c:	1e05      	subs	r5, r0, #0
 800b46e:	db23      	blt.n	800b4b8 <oqPutTimeout+0x68>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 800b470:	68a3      	ldr	r3, [r4, #8]
 800b472:	2b00      	cmp	r3, #0
 800b474:	d0f6      	beq.n	800b464 <oqPutTimeout+0x14>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 800b476:	6962      	ldr	r2, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 800b478:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800b47a:	1c51      	adds	r1, r2, #1
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 800b47c:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 800b47e:	6161      	str	r1, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 800b480:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800b482:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800b484:	6923      	ldr	r3, [r4, #16]
 800b486:	6962      	ldr	r2, [r4, #20]
 800b488:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 800b48a:	bf24      	itt	cs
 800b48c:	68e3      	ldrcs	r3, [r4, #12]
 800b48e:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 800b490:	69e3      	ldr	r3, [r4, #28]
 800b492:	b10b      	cbz	r3, 800b498 <oqPutTimeout+0x48>
    oqp->q_notify(oqp);
 800b494:	4620      	mov	r0, r4
 800b496:	4798      	blx	r3
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b498:	f003 fc62 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b49c:	4b10      	ldr	r3, [pc, #64]	; (800b4e0 <oqPutTimeout+0x90>)
 800b49e:	681a      	ldr	r2, [r3, #0]
 800b4a0:	429a      	cmp	r2, r3
 800b4a2:	d004      	beq.n	800b4ae <oqPutTimeout+0x5e>
 800b4a4:	6999      	ldr	r1, [r3, #24]
 800b4a6:	6893      	ldr	r3, [r2, #8]
 800b4a8:	688a      	ldr	r2, [r1, #8]
 800b4aa:	429a      	cmp	r2, r3
 800b4ac:	d314      	bcc.n	800b4d8 <oqPutTimeout+0x88>
 800b4ae:	2500      	movs	r5, #0
 800b4b0:	f385 8811 	msr	BASEPRI, r5
  }

  osalSysUnlock();

  return MSG_OK;
}
 800b4b4:	4628      	mov	r0, r5
 800b4b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b4b8:	f003 fc52 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b4bc:	4b08      	ldr	r3, [pc, #32]	; (800b4e0 <oqPutTimeout+0x90>)
 800b4be:	681a      	ldr	r2, [r3, #0]
 800b4c0:	429a      	cmp	r2, r3
 800b4c2:	d004      	beq.n	800b4ce <oqPutTimeout+0x7e>
 800b4c4:	6999      	ldr	r1, [r3, #24]
 800b4c6:	6893      	ldr	r3, [r2, #8]
 800b4c8:	688a      	ldr	r2, [r1, #8]
 800b4ca:	429a      	cmp	r2, r3
 800b4cc:	d304      	bcc.n	800b4d8 <oqPutTimeout+0x88>
 800b4ce:	2300      	movs	r3, #0
 800b4d0:	f383 8811 	msr	BASEPRI, r3
 800b4d4:	4628      	mov	r0, r5
 800b4d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b4d8:	4802      	ldr	r0, [pc, #8]	; (800b4e4 <oqPutTimeout+0x94>)
 800b4da:	f003 f941 	bl	800e760 <chSysHalt>
 800b4de:	bf00      	nop
 800b4e0:	20027edc 	.word	0x20027edc
 800b4e4:	080156ec 	.word	0x080156ec
	...

0800b4f0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 800b4f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b4f4:	b083      	sub	sp, #12
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  osalDbgCheck(n > 0U);
 800b4f6:	2a00      	cmp	r2, #0
 800b4f8:	d074      	beq.n	800b5e4 <iqReadTimeout+0xf4>
 800b4fa:	4604      	mov	r4, r0
 800b4fc:	4688      	mov	r8, r1
 800b4fe:	461e      	mov	r6, r3
 800b500:	4615      	mov	r5, r2
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 800b502:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 800b506:	f04f 0b20 	mov.w	fp, #32
 800b50a:	f38b 8811 	msr	BASEPRI, fp
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b50e:	f003 fc37 	bl	800ed80 <_dbg_check_lock>
 800b512:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b516:	4f35      	ldr	r7, [pc, #212]	; (800b5ec <iqReadTimeout+0xfc>)
 800b518:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b51a:	f8cd b004 	str.w	fp, [sp, #4]
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800b51e:	18f3      	adds	r3, r6, r3
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 800b520:	f04f 0900 	mov.w	r9, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800b524:	9300      	str	r3, [sp, #0]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b526:	46bb      	mov	fp, r7

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 800b528:	68a3      	ldr	r3, [r4, #8]
 800b52a:	2b00      	cmp	r3, #0
 800b52c:	d02f      	beq.n	800b58e <iqReadTimeout+0x9e>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800b52e:	69a2      	ldr	r2, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800b530:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800b532:	1c51      	adds	r1, r2, #1
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800b534:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 800b536:	61a1      	str	r1, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800b538:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800b53a:	7813      	ldrb	r3, [r2, #0]
 800b53c:	f888 3000 	strb.w	r3, [r8]
    if (iqp->q_rdptr >= iqp->q_top) {
 800b540:	6923      	ldr	r3, [r4, #16]
 800b542:	69a2      	ldr	r2, [r4, #24]
 800b544:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 800b546:	bf24      	itt	cs
 800b548:	68e3      	ldrcs	r3, [r4, #12]
 800b54a:	61a3      	strcs	r3, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 800b54c:	f1ba 0f00 	cmp.w	sl, #0
 800b550:	d001      	beq.n	800b556 <iqReadTimeout+0x66>
      nfy(iqp);
 800b552:	4620      	mov	r0, r4
 800b554:	47d0      	blx	sl
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b556:	f003 fc03 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b55a:	683b      	ldr	r3, [r7, #0]
 800b55c:	42bb      	cmp	r3, r7
 800b55e:	d005      	beq.n	800b56c <iqReadTimeout+0x7c>
 800b560:	f8db 2018 	ldr.w	r2, [fp, #24]
 800b564:	689b      	ldr	r3, [r3, #8]
 800b566:	6892      	ldr	r2, [r2, #8]
 800b568:	429a      	cmp	r2, r3
 800b56a:	d331      	bcc.n	800b5d0 <iqReadTimeout+0xe0>
 800b56c:	2300      	movs	r3, #0
 800b56e:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 800b572:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 800b574:	f109 0901 	add.w	r9, r9, #1
    if (--n == 0U) {
 800b578:	d026      	beq.n	800b5c8 <iqReadTimeout+0xd8>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800b57a:	f108 0801 	add.w	r8, r8, #1
 800b57e:	9b01      	ldr	r3, [sp, #4]
 800b580:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b584:	f003 fbfc 	bl	800ed80 <_dbg_check_lock>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 800b588:	68a3      	ldr	r3, [r4, #8]
 800b58a:	2b00      	cmp	r3, #0
 800b58c:	d1cf      	bne.n	800b52e <iqReadTimeout+0x3e>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800b58e:	1e73      	subs	r3, r6, #1
 800b590:	3303      	adds	r3, #3
 800b592:	d820      	bhi.n	800b5d6 <iqReadTimeout+0xe6>
 800b594:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b598:	6a59      	ldr	r1, [r3, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800b59a:	9b00      	ldr	r3, [sp, #0]
 800b59c:	1a59      	subs	r1, r3, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 800b59e:	428e      	cmp	r6, r1
 800b5a0:	d304      	bcc.n	800b5ac <iqReadTimeout+0xbc>
 800b5a2:	4620      	mov	r0, r4
 800b5a4:	f003 fb2c 	bl	800ec00 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800b5a8:	2800      	cmp	r0, #0
 800b5aa:	d0bd      	beq.n	800b528 <iqReadTimeout+0x38>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b5ac:	f003 fbd8 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b5b0:	683b      	ldr	r3, [r7, #0]
 800b5b2:	4a0e      	ldr	r2, [pc, #56]	; (800b5ec <iqReadTimeout+0xfc>)
 800b5b4:	42bb      	cmp	r3, r7
 800b5b6:	d004      	beq.n	800b5c2 <iqReadTimeout+0xd2>
 800b5b8:	6992      	ldr	r2, [r2, #24]
 800b5ba:	689b      	ldr	r3, [r3, #8]
 800b5bc:	6892      	ldr	r2, [r2, #8]
 800b5be:	429a      	cmp	r2, r3
 800b5c0:	d306      	bcc.n	800b5d0 <iqReadTimeout+0xe0>
 800b5c2:	2300      	movs	r3, #0
 800b5c4:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    osalSysLock();
  }
}
 800b5c8:	4648      	mov	r0, r9
 800b5ca:	b003      	add	sp, #12
 800b5cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b5d0:	4807      	ldr	r0, [pc, #28]	; (800b5f0 <iqReadTimeout+0x100>)
 800b5d2:	f003 f8c5 	bl	800e760 <chSysHalt>
 800b5d6:	4631      	mov	r1, r6
 800b5d8:	4620      	mov	r0, r4
 800b5da:	f003 fb11 	bl	800ec00 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800b5de:	2800      	cmp	r0, #0
 800b5e0:	d0a2      	beq.n	800b528 <iqReadTimeout+0x38>
 800b5e2:	e7e3      	b.n	800b5ac <iqReadTimeout+0xbc>
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  osalDbgCheck(n > 0U);
 800b5e4:	4803      	ldr	r0, [pc, #12]	; (800b5f4 <iqReadTimeout+0x104>)
 800b5e6:	f003 f8bb 	bl	800e760 <chSysHalt>
 800b5ea:	bf00      	nop
 800b5ec:	20027edc 	.word	0x20027edc
 800b5f0:	080156ec 	.word	0x080156ec
 800b5f4:	080156d4 	.word	0x080156d4
	...

0800b600 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 800b600:	b570      	push	{r4, r5, r6, lr}
 800b602:	2320      	movs	r3, #32
 800b604:	4604      	mov	r4, r0
 800b606:	460e      	mov	r6, r1
 800b608:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800b60c:	f003 fbb8 	bl	800ed80 <_dbg_check_lock>
 800b610:	e005      	b.n	800b61e <iqGetTimeout+0x1e>
 800b612:	4631      	mov	r1, r6
 800b614:	4620      	mov	r0, r4
 800b616:	f003 faf3 	bl	800ec00 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 800b61a:	1e05      	subs	r5, r0, #0
 800b61c:	db13      	blt.n	800b646 <iqGetTimeout+0x46>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 800b61e:	68a3      	ldr	r3, [r4, #8]
 800b620:	2b00      	cmp	r3, #0
 800b622:	d0f6      	beq.n	800b612 <iqGetTimeout+0x12>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800b624:	69a1      	ldr	r1, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800b626:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800b628:	6920      	ldr	r0, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800b62a:	1c4a      	adds	r2, r1, #1
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800b62c:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800b62e:	4282      	cmp	r2, r0
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800b630:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800b632:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800b634:	bf28      	it	cs
 800b636:	68e3      	ldrcs	r3, [r4, #12]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800b638:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800b63a:	bf28      	it	cs
 800b63c:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 800b63e:	69e3      	ldr	r3, [r4, #28]
 800b640:	b10b      	cbz	r3, 800b646 <iqGetTimeout+0x46>
    iqp->q_notify(iqp);
 800b642:	4620      	mov	r0, r4
 800b644:	4798      	blx	r3
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800b646:	f003 fb8b 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800b64a:	4b08      	ldr	r3, [pc, #32]	; (800b66c <iqGetTimeout+0x6c>)
 800b64c:	681a      	ldr	r2, [r3, #0]
 800b64e:	429a      	cmp	r2, r3
 800b650:	d004      	beq.n	800b65c <iqGetTimeout+0x5c>
 800b652:	6999      	ldr	r1, [r3, #24]
 800b654:	6893      	ldr	r3, [r2, #8]
 800b656:	688a      	ldr	r2, [r1, #8]
 800b658:	429a      	cmp	r2, r3
 800b65a:	d304      	bcc.n	800b666 <iqGetTimeout+0x66>
 800b65c:	2300      	movs	r3, #0
 800b65e:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
}
 800b662:	4628      	mov	r0, r5
 800b664:	bd70      	pop	{r4, r5, r6, pc}
 800b666:	4802      	ldr	r0, [pc, #8]	; (800b670 <iqGetTimeout+0x70>)
 800b668:	f003 f87a 	bl	800e760 <chSysHalt>
 800b66c:	20027edc 	.word	0x20027edc
 800b670:	080156ec 	.word	0x080156ec
	...

0800b680 <mmc_lld_is_write_protected>:
bool mmc_lld_is_write_protected(MMCDriver *mmcp) {

  (void)mmcp;
  /* TODO: Fill the implementation.*/
  return false;
}
 800b680:	2000      	movs	r0, #0
 800b682:	4770      	bx	lr
	...

0800b690 <ch_ltoa>:
  while (--i);

  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {
 800b690:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 800b692:	f100 070b 	add.w	r7, r0, #11
 800b696:	463c      	mov	r4, r7
 800b698:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 800b69a:	fbb1 f6f2 	udiv	r6, r1, r2
 800b69e:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 800b6a2:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 800b6a6:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 800b6a8:	bfc8      	it	gt
 800b6aa:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 800b6ae:	b2db      	uxtb	r3, r3
 800b6b0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 800b6b4:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 800b6b8:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 800b6ba:	2d00      	cmp	r5, #0
 800b6bc:	d1ed      	bne.n	800b69a <ch_ltoa+0xa>
 800b6be:	1b3a      	subs	r2, r7, r4
 800b6c0:	4402      	add	r2, r0
 800b6c2:	e001      	b.n	800b6c8 <ch_ltoa+0x38>
 800b6c4:	f814 3f01 	ldrb.w	r3, [r4, #1]!

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 800b6c8:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 800b6cc:	4290      	cmp	r0, r2
 800b6ce:	d1f9      	bne.n	800b6c4 <ch_ltoa+0x34>
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
}
 800b6d0:	bcf0      	pop	{r4, r5, r6, r7}
 800b6d2:	4770      	bx	lr
	...

0800b6e0 <get>:

static msg_t get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 800b6e0:	6903      	ldr	r3, [r0, #16]
 800b6e2:	68c1      	ldr	r1, [r0, #12]
 800b6e4:	4299      	cmp	r1, r3
  *(msp->buffer + msp->eos) = b;
  msp->eos += 1;
  return MSG_OK;
}

static msg_t get(void *ip) {
 800b6e6:	4602      	mov	r2, r0
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 800b6e8:	d004      	beq.n	800b6f4 <get+0x14>
    return MSG_RESET;
  b = *(msp->buffer + msp->offset);
 800b6ea:	6841      	ldr	r1, [r0, #4]
 800b6ec:	5cc8      	ldrb	r0, [r1, r3]
  msp->offset += 1;
 800b6ee:	3301      	adds	r3, #1
 800b6f0:	6113      	str	r3, [r2, #16]
 800b6f2:	4770      	bx	lr
static msg_t get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
    return MSG_RESET;
 800b6f4:	f06f 0001 	mvn.w	r0, #1
  b = *(msp->buffer + msp->offset);
  msp->offset += 1;
  return b;
}
 800b6f8:	4770      	bx	lr
 800b6fa:	bf00      	nop
 800b6fc:	0000      	movs	r0, r0
	...

0800b700 <put>:
}

static msg_t put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
 800b700:	68c3      	ldr	r3, [r0, #12]
 800b702:	6882      	ldr	r2, [r0, #8]
 800b704:	429a      	cmp	r2, r3
 800b706:	d006      	beq.n	800b716 <put+0x16>
    return MSG_RESET;
  *(msp->buffer + msp->eos) = b;
 800b708:	6842      	ldr	r2, [r0, #4]
 800b70a:	54d1      	strb	r1, [r2, r3]
  msp->eos += 1;
 800b70c:	68c3      	ldr	r3, [r0, #12]
 800b70e:	3301      	adds	r3, #1
 800b710:	60c3      	str	r3, [r0, #12]
  return MSG_OK;
 800b712:	2000      	movs	r0, #0
 800b714:	4770      	bx	lr

static msg_t put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
    return MSG_RESET;
 800b716:	f06f 0001 	mvn.w	r0, #1
  *(msp->buffer + msp->eos) = b;
  msp->eos += 1;
  return MSG_OK;
}
 800b71a:	4770      	bx	lr
 800b71c:	0000      	movs	r0, r0
	...

0800b720 <mmc_lld_is_card_inserted>:
bool mmc_lld_is_card_inserted(MMCDriver *mmcp) {

  (void)mmcp;
  /* TODO: Fill the implementation.*/
  return true;
}
 800b720:	2001      	movs	r0, #1
 800b722:	4770      	bx	lr
	...

0800b730 <notify4.lto_priv.126>:

#if STM32_SERIAL_USE_UART4 || defined(__DOXYGEN__)
static void notify4(io_queue_t *qp) {

  (void)qp;
  UART4->CR1 |= USART_CR1_TXEIE;
 800b730:	4a02      	ldr	r2, [pc, #8]	; (800b73c <notify4.lto_priv.126+0xc>)
 800b732:	68d3      	ldr	r3, [r2, #12]
 800b734:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b738:	60d3      	str	r3, [r2, #12]
 800b73a:	4770      	bx	lr
 800b73c:	40004c00 	.word	0x40004c00

0800b740 <spi_lld_serve_tx_interrupt.lto_priv.176>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800b740:	f011 0f0c 	tst.w	r1, #12
 800b744:	d100      	bne.n	800b748 <spi_lld_serve_tx_interrupt.lto_priv.176+0x8>
 800b746:	4770      	bx	lr
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 800b748:	b508      	push	{r3, lr}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 800b74a:	4801      	ldr	r0, [pc, #4]	; (800b750 <spi_lld_serve_tx_interrupt.lto_priv.176+0x10>)
 800b74c:	f003 f808 	bl	800e760 <chSysHalt>
 800b750:	080158e4 	.word	0x080158e4
	...

0800b760 <i2c_lld_serve_tx_end_irq.lto_priv.107>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800b760:	f011 0f0c 	tst.w	r1, #12
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 800b764:	b510      	push	{r4, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 800b766:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800b768:	d112      	bne.n	800b790 <i2c_lld_serve_tx_end_irq.lto_priv.107+0x30>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 800b76a:	6b01      	ldr	r1, [r0, #48]	; 0x30
 800b76c:	680a      	ldr	r2, [r1, #0]
 800b76e:	6813      	ldr	r3, [r2, #0]
 800b770:	f023 031f 	bic.w	r3, r3, #31
 800b774:	6013      	str	r3, [r2, #0]
 800b776:	6813      	ldr	r3, [r2, #0]
 800b778:	07db      	lsls	r3, r3, #31
 800b77a:	d4fc      	bmi.n	800b776 <i2c_lld_serve_tx_end_irq.lto_priv.107+0x16>
 800b77c:	7a08      	ldrb	r0, [r1, #8]
 800b77e:	684a      	ldr	r2, [r1, #4]
 800b780:	233d      	movs	r3, #61	; 0x3d
 800b782:	4083      	lsls	r3, r0
 800b784:	6013      	str	r3, [r2, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800b786:	6863      	ldr	r3, [r4, #4]
 800b788:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800b78c:	6063      	str	r3, [r4, #4]
 800b78e:	bd10      	pop	{r4, pc}
 800b790:	4801      	ldr	r0, [pc, #4]	; (800b798 <i2c_lld_serve_tx_end_irq.lto_priv.107+0x38>)
 800b792:	f002 ffe5 	bl	800e760 <chSysHalt>
 800b796:	bf00      	nop
 800b798:	080158e4 	.word	0x080158e4
 800b79c:	00000000 	.word	0x00000000

0800b7a0 <reads>:
  memcpy(msp->buffer + msp->eos, bp, n);
  msp->eos += n;
  return n;
}

static size_t reads(void *ip, uint8_t *bp, size_t n) {
 800b7a0:	b570      	push	{r4, r5, r6, lr}
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
 800b7a2:	6903      	ldr	r3, [r0, #16]
 800b7a4:	68c4      	ldr	r4, [r0, #12]
    n = msp->eos - msp->offset;
  memcpy(bp, msp->buffer + msp->offset, n);
 800b7a6:	6846      	ldr	r6, [r0, #4]
}

static size_t reads(void *ip, uint8_t *bp, size_t n) {
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
 800b7a8:	1ae4      	subs	r4, r4, r3
 800b7aa:	4294      	cmp	r4, r2
 800b7ac:	bf28      	it	cs
 800b7ae:	4614      	movcs	r4, r2
  memcpy(msp->buffer + msp->eos, bp, n);
  msp->eos += n;
  return n;
}

static size_t reads(void *ip, uint8_t *bp, size_t n) {
 800b7b0:	4605      	mov	r5, r0
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
    n = msp->eos - msp->offset;
  memcpy(bp, msp->buffer + msp->offset, n);
 800b7b2:	4622      	mov	r2, r4
 800b7b4:	4608      	mov	r0, r1
 800b7b6:	18f1      	adds	r1, r6, r3
 800b7b8:	f7f5 ff6a 	bl	8001690 <memcpy>
  msp->offset += n;
 800b7bc:	692b      	ldr	r3, [r5, #16]
 800b7be:	4423      	add	r3, r4
 800b7c0:	612b      	str	r3, [r5, #16]
  return n;
}
 800b7c2:	4620      	mov	r0, r4
 800b7c4:	bd70      	pop	{r4, r5, r6, pc}
 800b7c6:	bf00      	nop
	...

0800b7d0 <writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 800b7d0:	b538      	push	{r3, r4, r5, lr}
  MemoryStream *msp = ip;

  if (msp->size - msp->eos < n)
 800b7d2:	68c3      	ldr	r3, [r0, #12]
 800b7d4:	6884      	ldr	r4, [r0, #8]
 800b7d6:	1ae4      	subs	r4, r4, r3

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 800b7d8:	4605      	mov	r5, r0
 800b7da:	4294      	cmp	r4, r2
  MemoryStream *msp = ip;

  if (msp->size - msp->eos < n)
    n = msp->size - msp->eos;
  memcpy(msp->buffer + msp->eos, bp, n);
 800b7dc:	6840      	ldr	r0, [r0, #4]
 800b7de:	bf28      	it	cs
 800b7e0:	4614      	movcs	r4, r2
 800b7e2:	4418      	add	r0, r3
 800b7e4:	4622      	mov	r2, r4
 800b7e6:	f7f5 ff53 	bl	8001690 <memcpy>
  msp->eos += n;
 800b7ea:	68eb      	ldr	r3, [r5, #12]
 800b7ec:	4423      	add	r3, r4
 800b7ee:	60eb      	str	r3, [r5, #12]
  return n;
}
 800b7f0:	4620      	mov	r0, r4
 800b7f2:	bd38      	pop	{r3, r4, r5, pc}
	...

0800b800 <Vector110>:
/**
 * @brief   UART4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART4_HANDLER) {
 800b800:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 800b804:	4d71      	ldr	r5, [pc, #452]	; (800b9cc <Vector110+0x1cc>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART4_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800b806:	4872      	ldr	r0, [pc, #456]	; (800b9d0 <Vector110+0x1d0>)
 800b808:	f002 ff8a 	bl	800e720 <_trace_isr_enter>
 800b80c:	f003 fa28 	bl	800ec60 <_dbg_check_enter_isr>
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 800b810:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 800b812:	f8d6 900c 	ldr.w	r9, [r6, #12]
  uint16_t sr = u->SR;
 800b816:	6833      	ldr	r3, [r6, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800b818:	05d8      	lsls	r0, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 800b81a:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800b81c:	f100 808c 	bmi.w	800b938 <Vector110+0x138>
 800b820:	2320      	movs	r3, #32
 800b822:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800b826:	f003 fa4b 	bl	800ecc0 <_dbg_check_lock_from_isr>
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800b82a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800b82e:	d045      	beq.n	800b8bc <Vector110+0xbc>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 800b830:	f8df 8198 	ldr.w	r8, [pc, #408]	; 800b9cc <Vector110+0x1cc>
 800b834:	e007      	b.n	800b846 <Vector110+0x46>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
 800b836:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 800b838:	6877      	ldr	r7, [r6, #4]
    if (sr & USART_SR_RXNE)
 800b83a:	d41c      	bmi.n	800b876 <Vector110+0x76>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 800b83c:	6834      	ldr	r4, [r6, #0]
 800b83e:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800b840:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800b844:	d03a      	beq.n	800b8bc <Vector110+0xbc>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 800b846:	0721      	lsls	r1, r4, #28
 800b848:	d0f5      	beq.n	800b836 <Vector110+0x36>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 800b84a:	f014 0f08 	tst.w	r4, #8
 800b84e:	bf0c      	ite	eq
 800b850:	2000      	moveq	r0, #0
 800b852:	2080      	movne	r0, #128	; 0x80
  if (sr & USART_SR_PE)
 800b854:	07e2      	lsls	r2, r4, #31
    sts |= SD_PARITY_ERROR;
 800b856:	bf48      	it	mi
 800b858:	f040 0020 	orrmi.w	r0, r0, #32
  if (sr & USART_SR_FE)
 800b85c:	07a3      	lsls	r3, r4, #30
    sts |= SD_FRAMING_ERROR;
 800b85e:	bf48      	it	mi
 800b860:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (sr & USART_SR_NE)
 800b864:	0767      	lsls	r7, r4, #29
    sts |= SD_NOISE_ERROR;
 800b866:	bf48      	it	mi
 800b868:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800b86c:	f006 fe70 	bl	8012550 <chEvtBroadcastFlagsI.constprop.89>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
 800b870:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 800b872:	6877      	ldr	r7, [r6, #4]
    if (sr & USART_SR_RXNE)
 800b874:	d5e2      	bpl.n	800b83c <Vector110+0x3c>
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 800b876:	f002 ffeb 	bl	800e850 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800b87a:	696b      	ldr	r3, [r5, #20]
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 800b87c:	f895 4078 	ldrb.w	r4, [r5, #120]	; 0x78
 800b880:	b38b      	cbz	r3, 800b8e6 <Vector110+0xe6>
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();
 800b882:	f002 ffe5 	bl	800e850 <chDbgCheckClassI>

  if (iqIsFullI(iqp)) {
 800b886:	6a2b      	ldr	r3, [r5, #32]
 800b888:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800b88a:	4293      	cmp	r3, r2
 800b88c:	d034      	beq.n	800b8f8 <Vector110+0xf8>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 800b88e:	696a      	ldr	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 800b890:	1c59      	adds	r1, r3, #1

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 800b892:	3201      	adds	r2, #1
  *iqp->q_wrptr++ = b;
 800b894:	4027      	ands	r7, r4

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 800b896:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 800b898:	6229      	str	r1, [r5, #32]
 800b89a:	701f      	strb	r7, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 800b89c:	6a2a      	ldr	r2, [r5, #32]
 800b89e:	69eb      	ldr	r3, [r5, #28]
 800b8a0:	429a      	cmp	r2, r3
 800b8a2:	d303      	bcc.n	800b8ac <Vector110+0xac>
    iqp->q_wrptr = iqp->q_buffer;
 800b8a4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800b8a8:	f8c8 3020 	str.w	r3, [r8, #32]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 800b8ac:	4849      	ldr	r0, [pc, #292]	; (800b9d4 <Vector110+0x1d4>)
 800b8ae:	f006 fe37 	bl	8012520 <chThdDequeueNextI.constprop.90>
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 800b8b2:	6834      	ldr	r4, [r6, #0]
 800b8b4:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800b8b6:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800b8ba:	d1c4      	bne.n	800b846 <Vector110+0x46>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800b8bc:	f003 f9e8 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800b8c0:	2300      	movs	r3, #0
 800b8c2:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800b8c6:	f019 0f80 	tst.w	r9, #128	; 0x80
 800b8ca:	d001      	beq.n	800b8d0 <Vector110+0xd0>
 800b8cc:	0622      	lsls	r2, r4, #24
 800b8ce:	d445      	bmi.n	800b95c <Vector110+0x15c>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 800b8d0:	0663      	lsls	r3, r4, #25
 800b8d2:	d419      	bmi.n	800b908 <Vector110+0x108>

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD4);

  OSAL_IRQ_EPILOGUE();
 800b8d4:	f003 f9ac 	bl	800ec30 <_dbg_check_leave_isr>
 800b8d8:	483d      	ldr	r0, [pc, #244]	; (800b9d0 <Vector110+0x1d0>)
 800b8da:	f002 ff01 	bl	800e6e0 <_trace_isr_leave>
}
 800b8de:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD4);

  OSAL_IRQ_EPILOGUE();
 800b8e2:	f7ff bcad 	b.w	800b240 <_port_irq_epilogue>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800b8e6:	2004      	movs	r0, #4
 800b8e8:	f006 fe32 	bl	8012550 <chEvtBroadcastFlagsI.constprop.89>
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();
 800b8ec:	f002 ffb0 	bl	800e850 <chDbgCheckClassI>

  if (iqIsFullI(iqp)) {
 800b8f0:	6a2b      	ldr	r3, [r5, #32]
 800b8f2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800b8f4:	4293      	cmp	r3, r2
 800b8f6:	d1ca      	bne.n	800b88e <Vector110+0x8e>
 800b8f8:	f8d8 2014 	ldr.w	r2, [r8, #20]
 800b8fc:	2a00      	cmp	r2, #0
 800b8fe:	d0c6      	beq.n	800b88e <Vector110+0x8e>
 800b900:	2080      	movs	r0, #128	; 0x80
 800b902:	f006 fe25 	bl	8012550 <chEvtBroadcastFlagsI.constprop.89>
 800b906:	e799      	b.n	800b83c <Vector110+0x3c>
 800b908:	2320      	movs	r3, #32
 800b90a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800b90e:	f003 f9d7 	bl	800ecc0 <_dbg_check_lock_from_isr>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 800b912:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 800b914:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800b916:	492d      	ldr	r1, [pc, #180]	; (800b9cc <Vector110+0x1cc>)
 800b918:	429a      	cmp	r2, r3
 800b91a:	d041      	beq.n	800b9a0 <Vector110+0x1a0>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800b91c:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 800b920:	ea09 0303 	and.w	r3, r9, r3
    u->SR = ~USART_SR_TC;
 800b924:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800b928:	60f3      	str	r3, [r6, #12]
    u->SR = ~USART_SR_TC;
 800b92a:	6032      	str	r2, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800b92c:	f003 f9b0 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800b930:	2300      	movs	r3, #0
 800b932:	f383 8811 	msr	BASEPRI, r3
 800b936:	e7cd      	b.n	800b8d4 <Vector110+0xd4>
 800b938:	2320      	movs	r3, #32
 800b93a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800b93e:	f003 f9bf 	bl	800ecc0 <_dbg_check_lock_from_isr>
 800b942:	f44f 7000 	mov.w	r0, #512	; 0x200
 800b946:	f006 fe03 	bl	8012550 <chEvtBroadcastFlagsI.constprop.89>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 800b94a:	f46f 7380 	mvn.w	r3, #256	; 0x100
 800b94e:	6033      	str	r3, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800b950:	f003 f99e 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800b954:	2300      	movs	r3, #0
 800b956:	f383 8811 	msr	BASEPRI, r3
 800b95a:	e761      	b.n	800b820 <Vector110+0x20>
 800b95c:	2320      	movs	r3, #32
 800b95e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800b962:	f003 f9ad 	bl	800ecc0 <_dbg_check_lock_from_isr>
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();
 800b966:	f002 ff73 	bl	800e850 <chDbgCheckClassI>

  if (oqIsEmptyI(oqp)) {
 800b96a:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800b96c:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 800b96e:	4917      	ldr	r1, [pc, #92]	; (800b9cc <Vector110+0x1cc>)
 800b970:	429a      	cmp	r2, r3
 800b972:	d01c      	beq.n	800b9ae <Vector110+0x1ae>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 800b974:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800b976:	4915      	ldr	r1, [pc, #84]	; (800b9cc <Vector110+0x1cc>)
  b = *oqp->q_rdptr++;
 800b978:	1c58      	adds	r0, r3, #1

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 800b97a:	3201      	adds	r2, #1
 800b97c:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 800b97e:	64a8      	str	r0, [r5, #72]	; 0x48
 800b980:	781f      	ldrb	r7, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 800b982:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800b984:	4298      	cmp	r0, r3
 800b986:	d301      	bcc.n	800b98c <Vector110+0x18c>
    oqp->q_rdptr = oqp->q_buffer;
 800b988:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 800b98a:	648b      	str	r3, [r1, #72]	; 0x48
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 800b98c:	4812      	ldr	r0, [pc, #72]	; (800b9d8 <Vector110+0x1d8>)
 800b98e:	f006 fdc7 	bl	8012520 <chThdDequeueNextI.constprop.90>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 800b992:	6077      	str	r7, [r6, #4]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800b994:	f003 f97c 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800b998:	2300      	movs	r3, #0
 800b99a:	f383 8811 	msr	BASEPRI, r3
 800b99e:	e797      	b.n	800b8d0 <Vector110+0xd0>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 800b9a0:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 800b9a2:	2b00      	cmp	r3, #0
 800b9a4:	d0ba      	beq.n	800b91c <Vector110+0x11c>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800b9a6:	2010      	movs	r0, #16
 800b9a8:	f006 fdd2 	bl	8012550 <chEvtBroadcastFlagsI.constprop.89>
 800b9ac:	e7b6      	b.n	800b91c <Vector110+0x11c>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 800b9ae:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 800b9b0:	2a00      	cmp	r2, #0
 800b9b2:	d0df      	beq.n	800b974 <Vector110+0x174>
 800b9b4:	2008      	movs	r0, #8
 800b9b6:	f006 fdcb 	bl	8012550 <chEvtBroadcastFlagsI.constprop.89>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800b9ba:	f64f 733f 	movw	r3, #65343	; 0xff3f
 800b9be:	ea09 0303 	and.w	r3, r9, r3
 800b9c2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b9c6:	60f3      	str	r3, [r6, #12]
 800b9c8:	e7e4      	b.n	800b994 <Vector110+0x194>
 800b9ca:	bf00      	nop
 800b9cc:	20027e60 	.word	0x20027e60
 800b9d0:	0801589c 	.word	0x0801589c
 800b9d4:	20027e6c 	.word	0x20027e6c
 800b9d8:	20027e90 	.word	0x20027e90
 800b9dc:	00000000 	.word	0x00000000

0800b9e0 <spi_lld_serve_rx_interrupt.lto_priv.175>:
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800b9e0:	f011 0f0c 	tst.w	r1, #12
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 800b9e4:	b538      	push	{r3, r4, r5, lr}

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800b9e6:	d139      	bne.n	800ba5c <spi_lld_serve_rx_interrupt.lto_priv.175+0x7c>
 800b9e8:	4604      	mov	r4, r0
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 800b9ea:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800b9ec:	6802      	ldr	r2, [r0, #0]
 800b9ee:	6813      	ldr	r3, [r2, #0]
 800b9f0:	f023 031f 	bic.w	r3, r3, #31
 800b9f4:	6013      	str	r3, [r2, #0]
 800b9f6:	6813      	ldr	r3, [r2, #0]
 800b9f8:	07d9      	lsls	r1, r3, #31
 800b9fa:	d4fc      	bmi.n	800b9f6 <spi_lld_serve_rx_interrupt.lto_priv.175+0x16>
 800b9fc:	7a05      	ldrb	r5, [r0, #8]
  dmaStreamDisable(spip->dmarx);
 800b9fe:	6a21      	ldr	r1, [r4, #32]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 800ba00:	6840      	ldr	r0, [r0, #4]
  dmaStreamDisable(spip->dmarx);
 800ba02:	680a      	ldr	r2, [r1, #0]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 800ba04:	233d      	movs	r3, #61	; 0x3d
 800ba06:	40ab      	lsls	r3, r5
 800ba08:	6003      	str	r3, [r0, #0]
  dmaStreamDisable(spip->dmarx);
 800ba0a:	6813      	ldr	r3, [r2, #0]
 800ba0c:	f023 031f 	bic.w	r3, r3, #31
 800ba10:	6013      	str	r3, [r2, #0]
 800ba12:	6813      	ldr	r3, [r2, #0]
 800ba14:	07db      	lsls	r3, r3, #31
 800ba16:	d4fc      	bmi.n	800ba12 <spi_lld_serve_rx_interrupt.lto_priv.175+0x32>

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800ba18:	6863      	ldr	r3, [r4, #4]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 800ba1a:	7a08      	ldrb	r0, [r1, #8]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800ba1c:	681a      	ldr	r2, [r3, #0]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 800ba1e:	6849      	ldr	r1, [r1, #4]
 800ba20:	233d      	movs	r3, #61	; 0x3d
 800ba22:	4083      	lsls	r3, r0
 800ba24:	600b      	str	r3, [r1, #0]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800ba26:	b1b2      	cbz	r2, 800ba56 <spi_lld_serve_rx_interrupt.lto_priv.175+0x76>
 800ba28:	2304      	movs	r3, #4
 800ba2a:	7023      	strb	r3, [r4, #0]
 800ba2c:	4620      	mov	r0, r4
 800ba2e:	4790      	blx	r2
 800ba30:	7823      	ldrb	r3, [r4, #0]
 800ba32:	2b04      	cmp	r3, #4
 800ba34:	d00f      	beq.n	800ba56 <spi_lld_serve_rx_interrupt.lto_priv.175+0x76>
 800ba36:	2320      	movs	r3, #32
 800ba38:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800ba3c:	f003 f940 	bl	800ecc0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800ba40:	f104 0008 	add.w	r0, r4, #8
 800ba44:	2100      	movs	r1, #0
 800ba46:	f002 fff3 	bl	800ea30 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800ba4a:	f003 f921 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800ba4e:	2300      	movs	r3, #0
 800ba50:	f383 8811 	msr	BASEPRI, r3
 800ba54:	bd38      	pop	{r3, r4, r5, pc}
 800ba56:	2302      	movs	r3, #2
 800ba58:	7023      	strb	r3, [r4, #0]
 800ba5a:	e7ec      	b.n	800ba36 <spi_lld_serve_rx_interrupt.lto_priv.175+0x56>
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 800ba5c:	4801      	ldr	r0, [pc, #4]	; (800ba64 <spi_lld_serve_rx_interrupt.lto_priv.175+0x84>)
 800ba5e:	f002 fe7f 	bl	800e760 <chSysHalt>
 800ba62:	bf00      	nop
 800ba64:	080158e4 	.word	0x080158e4
	...

0800ba70 <VectorC8>:
/**
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
 800ba70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD2.i2c->SR1;
 800ba72:	4c39      	ldr	r4, [pc, #228]	; (800bb58 <VectorC8+0xe8>)

  OSAL_IRQ_PROLOGUE();
 800ba74:	4839      	ldr	r0, [pc, #228]	; (800bb5c <VectorC8+0xec>)
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 800ba76:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800ba78:	695e      	ldr	r6, [r3, #20]

  OSAL_IRQ_PROLOGUE();
 800ba7a:	f002 fe51 	bl	800e720 <_trace_isr_enter>
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 800ba7e:	b2b5      	uxth	r5, r6

  OSAL_IRQ_PROLOGUE();
 800ba80:	f003 f8ee 	bl	800ec60 <_dbg_check_enter_isr>
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800ba84:	6b27      	ldr	r7, [r4, #48]	; 0x30
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 800ba86:	6b61      	ldr	r1, [r4, #52]	; 0x34
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800ba88:	683a      	ldr	r2, [r7, #0]
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 800ba8a:	f405 435f 	and.w	r3, r5, #57088	; 0xdf00
 800ba8e:	43db      	mvns	r3, r3
 800ba90:	614b      	str	r3, [r1, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800ba92:	6813      	ldr	r3, [r2, #0]
 800ba94:	f023 031f 	bic.w	r3, r3, #31
 800ba98:	6013      	str	r3, [r2, #0]
 800ba9a:	6813      	ldr	r3, [r2, #0]
 800ba9c:	07d8      	lsls	r0, r3, #31
 800ba9e:	d4fc      	bmi.n	800ba9a <VectorC8+0x2a>
 800baa0:	7a3a      	ldrb	r2, [r7, #8]
  dmaStreamDisable(i2cp->dmarx);
 800baa2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800baa4:	687f      	ldr	r7, [r7, #4]
 800baa6:	233d      	movs	r3, #61	; 0x3d
 800baa8:	4093      	lsls	r3, r2
  dmaStreamDisable(i2cp->dmarx);
 800baaa:	6802      	ldr	r2, [r0, #0]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 800baac:	603b      	str	r3, [r7, #0]
  dmaStreamDisable(i2cp->dmarx);
 800baae:	6813      	ldr	r3, [r2, #0]
 800bab0:	f023 031f 	bic.w	r3, r3, #31
 800bab4:	6013      	str	r3, [r2, #0]
 800bab6:	6813      	ldr	r3, [r2, #0]
 800bab8:	f013 0301 	ands.w	r3, r3, #1
 800babc:	d1fb      	bne.n	800bab6 <VectorC8+0x46>
 800babe:	7a07      	ldrb	r7, [r0, #8]
 800bac0:	6840      	ldr	r0, [r0, #4]
 800bac2:	223d      	movs	r2, #61	; 0x3d
 800bac4:	40ba      	lsls	r2, r7
 800bac6:	6002      	str	r2, [r0, #0]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 800bac8:	05ea      	lsls	r2, r5, #23
    i2cp->errors |= I2C_BUS_ERROR;
 800baca:	bf48      	it	mi
 800bacc:	2301      	movmi	r3, #1

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 800bace:	05af      	lsls	r7, r5, #22
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 800bad0:	60a3      	str	r3, [r4, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;
 800bad2:	bf44      	itt	mi
 800bad4:	f043 0302 	orrmi.w	r3, r3, #2
 800bad8:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 800bada:	0568      	lsls	r0, r5, #21
 800badc:	d50a      	bpl.n	800baf4 <VectorC8+0x84>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 800bade:	684a      	ldr	r2, [r1, #4]
 800bae0:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800bae4:	604a      	str	r2, [r1, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800bae6:	680a      	ldr	r2, [r1, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 800bae8:	f043 0304 	orr.w	r3, r3, #4
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 800baec:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800baf0:	600a      	str	r2, [r1, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 800baf2:	60a3      	str	r3, [r4, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 800baf4:	052a      	lsls	r2, r5, #20
    i2cp->errors |= I2C_OVERRUN;
 800baf6:	bf44      	itt	mi
 800baf8:	f043 0308 	orrmi.w	r3, r3, #8
 800bafc:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 800bafe:	046f      	lsls	r7, r5, #17
    i2cp->errors |= I2C_TIMEOUT;
 800bb00:	bf44      	itt	mi
 800bb02:	f043 0320 	orrmi.w	r3, r3, #32
 800bb06:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 800bb08:	04e8      	lsls	r0, r5, #19
 800bb0a:	d51c      	bpl.n	800bb46 <VectorC8+0xd6>
    i2cp->errors |= I2C_PEC_ERROR;
 800bb0c:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800bb10:	0431      	lsls	r1, r6, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 800bb12:	60a3      	str	r3, [r4, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800bb14:	d41c      	bmi.n	800bb50 <VectorC8+0xe0>
 800bb16:	2320      	movs	r3, #32
 800bb18:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800bb1c:	f003 f8d0 	bl	800ecc0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800bb20:	f06f 0101 	mvn.w	r1, #1
 800bb24:	480e      	ldr	r0, [pc, #56]	; (800bb60 <VectorC8+0xf0>)
 800bb26:	f002 ff83 	bl	800ea30 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800bb2a:	f003 f8b1 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800bb2e:	2300      	movs	r3, #0
 800bb30:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 800bb34:	f003 f87c 	bl	800ec30 <_dbg_check_leave_isr>
 800bb38:	4808      	ldr	r0, [pc, #32]	; (800bb5c <VectorC8+0xec>)
 800bb3a:	f002 fdd1 	bl	800e6e0 <_trace_isr_leave>
}
 800bb3e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 800bb42:	f7ff bb7d 	b.w	800b240 <_port_irq_epilogue>
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 800bb46:	0432      	lsls	r2, r6, #16
 800bb48:	d402      	bmi.n	800bb50 <VectorC8+0xe0>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 800bb4a:	2b00      	cmp	r3, #0
 800bb4c:	d0f2      	beq.n	800bb34 <VectorC8+0xc4>
 800bb4e:	e7e2      	b.n	800bb16 <VectorC8+0xa6>

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 800bb50:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800bb54:	60a3      	str	r3, [r4, #8]
 800bb56:	e7de      	b.n	800bb16 <VectorC8+0xa6>
 800bb58:	200287cc 	.word	0x200287cc
 800bb5c:	080158f8 	.word	0x080158f8
 800bb60:	200287e8 	.word	0x200287e8
	...

0800bb70 <VectorC4>:
/**
 * @brief   I2C2 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {
 800bb70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800bb72:	4d40      	ldr	r5, [pc, #256]	; (800bc74 <VectorC4+0x104>)
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800bb74:	4840      	ldr	r0, [pc, #256]	; (800bc78 <VectorC4+0x108>)
 800bb76:	f002 fdd3 	bl	800e720 <_trace_isr_enter>
 800bb7a:	f003 f871 	bl	800ec60 <_dbg_check_enter_isr>
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800bb7e:	6b6c      	ldr	r4, [r5, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800bb80:	4a3e      	ldr	r2, [pc, #248]	; (800bc7c <VectorC4+0x10c>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 800bb82:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 800bb84:	6966      	ldr	r6, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800bb86:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
 800bb8a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800bb8e:	4293      	cmp	r3, r2
 800bb90:	d04e      	beq.n	800bc30 <VectorC4+0xc0>
 800bb92:	d823      	bhi.n	800bbdc <VectorC4+0x6c>
 800bb94:	3a07      	subs	r2, #7
 800bb96:	4293      	cmp	r3, r2
 800bb98:	d03e      	beq.n	800bc18 <VectorC4+0xa8>
 800bb9a:	3201      	adds	r2, #1
 800bb9c:	4293      	cmp	r3, r2
 800bb9e:	d110      	bne.n	800bbc2 <VectorC4+0x52>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800bba0:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 800bba2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800bba4:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 800bba8:	681b      	ldr	r3, [r3, #0]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800bbaa:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 800bbac:	681a      	ldr	r2, [r3, #0]
 800bbae:	f042 0201 	orr.w	r2, r2, #1
 800bbb2:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 800bbb4:	6862      	ldr	r2, [r4, #4]
 800bbb6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800bbba:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 800bbbc:	685b      	ldr	r3, [r3, #4]
 800bbbe:	2b01      	cmp	r3, #1
 800bbc0:	d952      	bls.n	800bc68 <VectorC4+0xf8>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 800bbc2:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 800bbc6:	bf18      	it	ne
 800bbc8:	69a3      	ldrne	r3, [r4, #24]

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 800bbca:	f003 f831 	bl	800ec30 <_dbg_check_leave_isr>
 800bbce:	482a      	ldr	r0, [pc, #168]	; (800bc78 <VectorC4+0x108>)
 800bbd0:	f002 fd86 	bl	800e6e0 <_trace_isr_leave>
}
 800bbd4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 800bbd8:	f7ff bb32 	b.w	800b240 <_port_irq_epilogue>
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800bbdc:	4a28      	ldr	r2, [pc, #160]	; (800bc80 <VectorC4+0x110>)
 800bbde:	4293      	cmp	r3, r2
 800bbe0:	d00f      	beq.n	800bc02 <VectorC4+0x92>
 800bbe2:	3202      	adds	r2, #2
 800bbe4:	4293      	cmp	r3, r2
 800bbe6:	d1ec      	bne.n	800bbc2 <VectorC4+0x52>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 800bbe8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800bbea:	681b      	ldr	r3, [r3, #0]
 800bbec:	685f      	ldr	r7, [r3, #4]
 800bbee:	b327      	cbz	r7, 800bc3a <VectorC4+0xca>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800bbf0:	8c2a      	ldrh	r2, [r5, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800bbf2:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800bbf4:	f042 0201 	orr.w	r2, r2, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800bbf8:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800bbfc:	842a      	strh	r2, [r5, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800bbfe:	6023      	str	r3, [r4, #0]
 800bc00:	e7e3      	b.n	800bbca <VectorC4+0x5a>
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800bc02:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800bc04:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800bc06:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 800bc0a:	6812      	ldr	r2, [r2, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800bc0c:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800bc0e:	6813      	ldr	r3, [r2, #0]
 800bc10:	f043 0301 	orr.w	r3, r3, #1
 800bc14:	6013      	str	r3, [r2, #0]
 800bc16:	e7d4      	b.n	800bbc2 <VectorC4+0x52>
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 800bc18:	8c2b      	ldrh	r3, [r5, #32]
 800bc1a:	0a1a      	lsrs	r2, r3, #8
 800bc1c:	d00b      	beq.n	800bc36 <VectorC4+0xc6>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 800bc1e:	f003 0301 	and.w	r3, r3, #1
 800bc22:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 800bc26:	f002 0206 	and.w	r2, r2, #6
 800bc2a:	4313      	orrs	r3, r2
 800bc2c:	6123      	str	r3, [r4, #16]
 800bc2e:	e7c8      	b.n	800bbc2 <VectorC4+0x52>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 800bc30:	8c2b      	ldrh	r3, [r5, #32]
 800bc32:	f3c3 0347 	ubfx	r3, r3, #1, #8
 800bc36:	6123      	str	r3, [r4, #16]
 800bc38:	e7c3      	b.n	800bbc2 <VectorC4+0x52>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800bc3a:	6863      	ldr	r3, [r4, #4]
 800bc3c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800bc40:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 800bc42:	6823      	ldr	r3, [r4, #0]
 800bc44:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800bc48:	6023      	str	r3, [r4, #0]
 800bc4a:	2320      	movs	r3, #32
 800bc4c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800bc50:	f003 f836 	bl	800ecc0 <_dbg_check_lock_from_isr>
 800bc54:	4639      	mov	r1, r7
 800bc56:	f105 001c 	add.w	r0, r5, #28
 800bc5a:	f002 fee9 	bl	800ea30 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800bc5e:	f003 f817 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800bc62:	f387 8811 	msr	BASEPRI, r7
 800bc66:	e7ac      	b.n	800bbc2 <VectorC4+0x52>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 800bc68:	6823      	ldr	r3, [r4, #0]
 800bc6a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800bc6e:	6023      	str	r3, [r4, #0]
 800bc70:	e7a7      	b.n	800bbc2 <VectorC4+0x52>
 800bc72:	bf00      	nop
 800bc74:	200287cc 	.word	0x200287cc
 800bc78:	080158b4 	.word	0x080158b4
 800bc7c:	00030008 	.word	0x00030008
 800bc80:	00070082 	.word	0x00070082
	...

0800bc90 <i2c_lld_serve_rx_end_irq.lto_priv.106>:
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800bc90:	f011 0f0c 	tst.w	r1, #12
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 800bc94:	b570      	push	{r4, r5, r6, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 800bc96:	6b42      	ldr	r2, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800bc98:	d12a      	bne.n	800bcf0 <i2c_lld_serve_rx_end_irq.lto_priv.106+0x60>
 800bc9a:	4605      	mov	r5, r0
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 800bc9c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800bc9e:	6803      	ldr	r3, [r0, #0]
 800bca0:	6819      	ldr	r1, [r3, #0]
 800bca2:	f021 011f 	bic.w	r1, r1, #31
 800bca6:	6019      	str	r1, [r3, #0]
 800bca8:	6819      	ldr	r1, [r3, #0]
 800bcaa:	f011 0401 	ands.w	r4, r1, #1
 800bcae:	d1fb      	bne.n	800bca8 <i2c_lld_serve_rx_end_irq.lto_priv.106+0x18>
 800bcb0:	7a06      	ldrb	r6, [r0, #8]
 800bcb2:	6841      	ldr	r1, [r0, #4]
 800bcb4:	233d      	movs	r3, #61	; 0x3d
 800bcb6:	40b3      	lsls	r3, r6
 800bcb8:	600b      	str	r3, [r1, #0]

  dp->CR2 &= ~I2C_CR2_LAST;
 800bcba:	6853      	ldr	r3, [r2, #4]
 800bcbc:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800bcc0:	6053      	str	r3, [r2, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 800bcc2:	6813      	ldr	r3, [r2, #0]
 800bcc4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800bcc8:	6013      	str	r3, [r2, #0]
  dp->CR1 |= I2C_CR1_STOP;
 800bcca:	6813      	ldr	r3, [r2, #0]
 800bccc:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800bcd0:	6013      	str	r3, [r2, #0]
 800bcd2:	2320      	movs	r3, #32
 800bcd4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800bcd8:	f002 fff2 	bl	800ecc0 <_dbg_check_lock_from_isr>
 800bcdc:	4621      	mov	r1, r4
 800bcde:	f105 001c 	add.w	r0, r5, #28
 800bce2:	f002 fea5 	bl	800ea30 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800bce6:	f002 ffd3 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800bcea:	f384 8811 	msr	BASEPRI, r4
 800bcee:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 800bcf0:	4801      	ldr	r0, [pc, #4]	; (800bcf8 <i2c_lld_serve_rx_end_irq.lto_priv.106+0x68>)
 800bcf2:	f002 fd35 	bl	800e760 <chSysHalt>
 800bcf6:	bf00      	nop
 800bcf8:	080158e4 	.word	0x080158e4
 800bcfc:	00000000 	.word	0x00000000

0800bd00 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
 800bd00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
 800bd02:	4828      	ldr	r0, [pc, #160]	; (800bda4 <Vector88+0xa4>)
 800bd04:	f002 fd0c 	bl	800e720 <_trace_isr_enter>
 800bd08:	f002 ffaa 	bl	800ec60 <_dbg_check_enter_isr>

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 800bd0c:	4b26      	ldr	r3, [pc, #152]	; (800bda8 <Vector88+0xa8>)
 800bd0e:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
 800bd10:	2100      	movs	r1, #0
 800bd12:	6019      	str	r1, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 800bd14:	0693      	lsls	r3, r2, #26
 800bd16:	d538      	bpl.n	800bd8a <Vector88+0x8a>
 800bd18:	4c24      	ldr	r4, [pc, #144]	; (800bdac <Vector88+0xac>)
 800bd1a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800bd1c:	680a      	ldr	r2, [r1, #0]
 800bd1e:	6853      	ldr	r3, [r2, #4]
 800bd20:	2b00      	cmp	r3, #0
 800bd22:	d032      	beq.n	800bd8a <Vector88+0x8a>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 800bd24:	6925      	ldr	r5, [r4, #16]
 800bd26:	2d00      	cmp	r5, #0
 800bd28:	d02f      	beq.n	800bd8a <Vector88+0x8a>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800bd2a:	6813      	ldr	r3, [r2, #0]
 800bd2c:	f023 031f 	bic.w	r3, r3, #31
 800bd30:	6013      	str	r3, [r2, #0]
 800bd32:	6813      	ldr	r3, [r2, #0]
 800bd34:	f013 0301 	ands.w	r3, r3, #1
 800bd38:	d1fb      	bne.n	800bd32 <Vector88+0x32>
 800bd3a:	7a08      	ldrb	r0, [r1, #8]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800bd3c:	68ae      	ldr	r6, [r5, #8]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800bd3e:	684f      	ldr	r7, [r1, #4]
  adcp->adc->CR1 = 0;
 800bd40:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800bd42:	4d1a      	ldr	r5, [pc, #104]	; (800bdac <Vector88+0xac>)
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800bd44:	213d      	movs	r1, #61	; 0x3d
 800bd46:	fa01 f000 	lsl.w	r0, r1, r0
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 800bd4a:	2101      	movs	r1, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800bd4c:	6038      	str	r0, [r7, #0]
  adcp->adc->CR1 = 0;
 800bd4e:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
 800bd50:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800bd52:	6091      	str	r1, [r2, #8]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800bd54:	b316      	cbz	r6, 800bd9c <Vector88+0x9c>
 800bd56:	2305      	movs	r3, #5
 800bd58:	702b      	strb	r3, [r5, #0]
 800bd5a:	4628      	mov	r0, r5
 800bd5c:	47b0      	blx	r6
 800bd5e:	782b      	ldrb	r3, [r5, #0]
 800bd60:	2b05      	cmp	r3, #5
 800bd62:	bf04      	itt	eq
 800bd64:	2302      	moveq	r3, #2
 800bd66:	702b      	strbeq	r3, [r5, #0]
 800bd68:	2300      	movs	r3, #0
 800bd6a:	6123      	str	r3, [r4, #16]
 800bd6c:	2320      	movs	r3, #32
 800bd6e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800bd72:	f002 ffa5 	bl	800ecc0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800bd76:	f04f 31ff 	mov.w	r1, #4294967295
 800bd7a:	480d      	ldr	r0, [pc, #52]	; (800bdb0 <Vector88+0xb0>)
 800bd7c:	f002 fe58 	bl	800ea30 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800bd80:	f002 ff86 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800bd84:	2300      	movs	r3, #0
 800bd86:	f383 8811 	msr	BASEPRI, r3
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 800bd8a:	f002 ff51 	bl	800ec30 <_dbg_check_leave_isr>
 800bd8e:	4805      	ldr	r0, [pc, #20]	; (800bda4 <Vector88+0xa4>)
 800bd90:	f002 fca6 	bl	800e6e0 <_trace_isr_leave>
}
 800bd94:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      _adc_isr_error_code(&ADCD3, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 800bd98:	f7ff ba52 	b.w	800b240 <_port_irq_epilogue>
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800bd9c:	2302      	movs	r3, #2
 800bd9e:	612e      	str	r6, [r5, #16]
 800bda0:	702b      	strb	r3, [r5, #0]
 800bda2:	e7e3      	b.n	800bd6c <Vector88+0x6c>
 800bda4:	080158a8 	.word	0x080158a8
 800bda8:	40012000 	.word	0x40012000
 800bdac:	2002773c 	.word	0x2002773c
 800bdb0:	20027750 	.word	0x20027750
	...

0800bdc0 <get_fattime>:
  }
  return RES_PARERR;
}
#endif /* _USE_IOCTL */

DWORD get_fattime(void) {
 800bdc0:	b570      	push	{r4, r5, r6, lr}
 800bdc2:	b082      	sub	sp, #8
 800bdc4:	4668      	mov	r0, sp
 800bdc6:	f006 fc0b 	bl	80125e0 <rtc_lld_get_time.constprop.54>
 */
uint32_t rtcConvertDateTimeToFAT(const RTCDateTime *timespec) {
  uint32_t fattime;
  uint32_t sec, min, hour, day, month;

  sec   = timespec->millisecond / 1000U;
 800bdca:	9c01      	ldr	r4, [sp, #4]
 800bdcc:	491f      	ldr	r1, [pc, #124]	; (800be4c <get_fattime+0x8c>)
  hour  = sec / 3600U;
 800bdce:	4a20      	ldr	r2, [pc, #128]	; (800be50 <get_fattime+0x90>)
  sec  %= 3600U;
  min   = sec / 60U;
 800bdd0:	4d20      	ldr	r5, [pc, #128]	; (800be54 <get_fattime+0x94>)
  sec  %= 60U;
  day   = timespec->day;
  month = timespec->month;
 800bdd2:	f89d 6001 	ldrb.w	r6, [sp, #1]
  sec   = timespec->millisecond / 1000U;
  hour  = sec / 3600U;
  sec  %= 3600U;
  min   = sec / 60U;
  sec  %= 60U;
  day   = timespec->day;
 800bdd6:	f89d 0002 	ldrb.w	r0, [sp, #2]
 */
uint32_t rtcConvertDateTimeToFAT(const RTCDateTime *timespec) {
  uint32_t fattime;
  uint32_t sec, min, hour, day, month;

  sec   = timespec->millisecond / 1000U;
 800bdda:	f3c4 041a 	ubfx	r4, r4, #0, #27
 800bdde:	fba1 3104 	umull	r3, r1, r1, r4
 800bde2:	0989      	lsrs	r1, r1, #6
  hour  = sec / 3600U;
 800bde4:	fba2 3201 	umull	r3, r2, r2, r1
 800bde8:	0ad2      	lsrs	r2, r2, #11
  sec  %= 3600U;
 800bdea:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 800bdee:	fb03 1112 	mls	r1, r3, r2, r1
  min   = sec / 60U;
 800bdf2:	fba5 4301 	umull	r4, r3, r5, r1
 800bdf6:	095b      	lsrs	r3, r3, #5
  sec  %= 60U;
 800bdf8:	ebc3 1503 	rsb	r5, r3, r3, lsl #4
 800bdfc:	eba1 0585 	sub.w	r5, r1, r5, lsl #2
  day   = timespec->day;
  month = timespec->month;

  /* handle DST flag */
  if (1U == timespec->dstflag) {
 800be00:	06f1      	lsls	r1, r6, #27
  sec   = timespec->millisecond / 1000U;
  hour  = sec / 3600U;
  sec  %= 3600U;
  min   = sec / 60U;
  sec  %= 60U;
  day   = timespec->day;
 800be02:	f000 041f 	and.w	r4, r0, #31
  month = timespec->month;
 800be06:	f006 000f 	and.w	r0, r6, #15

  /* handle DST flag */
  if (1U == timespec->dstflag) {
 800be0a:	d502      	bpl.n	800be12 <get_fattime+0x52>
    hour += 1U;
 800be0c:	3201      	adds	r2, #1
    if (hour == 24U) {
 800be0e:	2a18      	cmp	r2, #24
 800be10:	d00e      	beq.n	800be30 <get_fattime+0x70>
 800be12:	02d1      	lsls	r1, r2, #11
 800be14:	0424      	lsls	r4, r4, #16
 800be16:	f89d 2000 	ldrb.w	r2, [sp]
 800be1a:	015b      	lsls	r3, r3, #5
 800be1c:	ea43 0355 	orr.w	r3, r3, r5, lsr #1
 800be20:	ea43 6242 	orr.w	r2, r3, r2, lsl #25
 800be24:	430a      	orrs	r2, r1
 800be26:	4322      	orrs	r2, r4
    rtcGetTime(&RTCD1, &timespec);
    return rtcConvertDateTimeToFAT(&timespec);
#else
    return ((uint32_t)0 | (1 << 16)) | (1 << 21); /* wrong but valid time */
#endif
}
 800be28:	ea42 5040 	orr.w	r0, r2, r0, lsl #21
 800be2c:	b002      	add	sp, #8
 800be2e:	bd70      	pop	{r4, r5, r6, pc}
      hour = 0U;
      day += 1U;
      if (day > month_len[month - 1U]) {
 800be30:	4a09      	ldr	r2, [pc, #36]	; (800be58 <get_fattime+0x98>)
 800be32:	4402      	add	r2, r0
  /* handle DST flag */
  if (1U == timespec->dstflag) {
    hour += 1U;
    if (hour == 24U) {
      hour = 0U;
      day += 1U;
 800be34:	3401      	adds	r4, #1
      if (day > month_len[month - 1U]) {
 800be36:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 800be3a:	4294      	cmp	r4, r2
 800be3c:	bf92      	itee	ls
 800be3e:	0424      	lslls	r4, r4, #16
        day = 1U;
        month += 1U;
 800be40:	3001      	addhi	r0, #1
 800be42:	f44f 3480 	movhi.w	r4, #65536	; 0x10000
 800be46:	2100      	movs	r1, #0
 800be48:	e7e5      	b.n	800be16 <get_fattime+0x56>
 800be4a:	bf00      	nop
 800be4c:	10624dd3 	.word	0x10624dd3
 800be50:	91a2b3c5 	.word	0x91a2b3c5
 800be54:	88888889 	.word	0x88888889
 800be58:	080158c0 	.word	0x080158c0
 800be5c:	00000000 	.word	0x00000000

0800be60 <disk_write>:
    const BYTE *buff,    /* Data to be written */
    DWORD sector,        /* Sector address (LBA) */
    UINT count            /* Number of sectors to write (1..255) */
)
{
  switch (pdrv) {
 800be60:	b108      	cbz	r0, 800be66 <disk_write+0x6>
    if (sdcWrite(&SDCD1, sector, buff, count))
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
 800be62:	2004      	movs	r0, #4
}
 800be64:	4770      	bx	lr
    BYTE pdrv,            /* Physical drive nmuber (0..) */
    const BYTE *buff,    /* Data to be written */
    DWORD sector,        /* Sector address (LBA) */
    UINT count            /* Number of sectors to write (1..255) */
)
{
 800be66:	b570      	push	{r4, r5, r6, lr}
  switch (pdrv) {
#if HAL_USE_MMC_SPI
  case MMC:
    if (blkGetDriverState(&MMCD1) != BLK_READY)
 800be68:	4d1f      	ldr	r5, [pc, #124]	; (800bee8 <disk_write+0x88>)
 800be6a:	460c      	mov	r4, r1
 800be6c:	7929      	ldrb	r1, [r5, #4]
 800be6e:	2905      	cmp	r1, #5
    BYTE pdrv,            /* Physical drive nmuber (0..) */
    const BYTE *buff,    /* Data to be written */
    DWORD sector,        /* Sector address (LBA) */
    UINT count            /* Number of sectors to write (1..255) */
)
{
 800be70:	b082      	sub	sp, #8
  switch (pdrv) {
#if HAL_USE_MMC_SPI
  case MMC:
    if (blkGetDriverState(&MMCD1) != BLK_READY)
        return RES_NOTRDY;
 800be72:	bf18      	it	ne
 800be74:	2003      	movne	r0, #3
)
{
  switch (pdrv) {
#if HAL_USE_MMC_SPI
  case MMC:
    if (blkGetDriverState(&MMCD1) != BLK_READY)
 800be76:	d001      	beq.n	800be7c <disk_write+0x1c>
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
}
 800be78:	b002      	add	sp, #8
 800be7a:	bd70      	pop	{r4, r5, r6, pc}
  case MMC:
    if (blkGetDriverState(&MMCD1) != BLK_READY)
        return RES_NOTRDY;
    if (mmcIsWriteProtected(&MMCD1))
        return RES_WRPRT;
    if (mmcStartSequentialWrite(&MMCD1, sector))
 800be7c:	4611      	mov	r1, r2
 800be7e:	4628      	mov	r0, r5
 800be80:	9301      	str	r3, [sp, #4]
 800be82:	f7ff f8bd 	bl	800b000 <mmcStartSequentialWrite>
 800be86:	9b01      	ldr	r3, [sp, #4]
 800be88:	b920      	cbnz	r0, 800be94 <disk_write+0x34>
        return RES_ERROR;
    while (count > 0) {
 800be8a:	b143      	cbz	r3, 800be9e <disk_write+0x3e>
 */
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
  static const uint8_t start[] = {0xFF, 0xFC};
  uint8_t b[1];

  osalDbgCheck((mmcp != NULL) && (buffer != NULL));
 800be8c:	b124      	cbz	r4, 800be98 <disk_write+0x38>

  if (mmcp->state != BLK_WRITING) {
 800be8e:	792a      	ldrb	r2, [r5, #4]
 800be90:	2a07      	cmp	r2, #7
 800be92:	d016      	beq.n	800bec2 <disk_write+0x62>
    if (blkGetDriverState(&MMCD1) != BLK_READY)
        return RES_NOTRDY;
    if (mmcIsWriteProtected(&MMCD1))
        return RES_WRPRT;
    if (mmcStartSequentialWrite(&MMCD1, sector))
        return RES_ERROR;
 800be94:	2001      	movs	r0, #1
 800be96:	e7ef      	b.n	800be78 <disk_write+0x18>
 */
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
  static const uint8_t start[] = {0xFF, 0xFC};
  uint8_t b[1];

  osalDbgCheck((mmcp != NULL) && (buffer != NULL));
 800be98:	4814      	ldr	r0, [pc, #80]	; (800beec <disk_write+0x8c>)
 800be9a:	f002 fc61 	bl	800e760 <chSysHalt>
bool mmcStopSequentialWrite(MMCDriver *mmcp) {
  static const uint8_t stop[] = {0xFD, 0xFF};

  osalDbgCheck(mmcp != NULL);

  if (mmcp->state != BLK_WRITING) {
 800be9e:	792b      	ldrb	r3, [r5, #4]
 800bea0:	4c11      	ldr	r4, [pc, #68]	; (800bee8 <disk_write+0x88>)
 800bea2:	2b07      	cmp	r3, #7
 800bea4:	d1f6      	bne.n	800be94 <disk_write+0x34>
    return HAL_FAILED;
  }

  spiSend(mmcp->config->spip, sizeof(stop), stop);
 800bea6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800bea8:	4a11      	ldr	r2, [pc, #68]	; (800bef0 <disk_write+0x90>)
 800beaa:	6818      	ldr	r0, [r3, #0]
 800beac:	2102      	movs	r1, #2
 800beae:	f000 ff6f 	bl	800cd90 <spiSend>
  spiUnselect(mmcp->config->spip);
 800beb2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800beb4:	6818      	ldr	r0, [r3, #0]
 800beb6:	f001 f80b 	bl	800ced0 <spiUnselect>

  /* Write operation finished.*/
  mmcp->state = BLK_READY;
 800beba:	2305      	movs	r3, #5
 800bebc:	7123      	strb	r3, [r4, #4]
        buff += MMCSD_BLOCK_SIZE;
        count--;
    }
    if (mmcStopSequentialWrite(&MMCD1))
        return RES_ERROR;
    return RES_OK;
 800bebe:	2000      	movs	r0, #0
 800bec0:	e7da      	b.n	800be78 <disk_write+0x18>
 800bec2:	462e      	mov	r6, r5
 800bec4:	4621      	mov	r1, r4
 800bec6:	4808      	ldr	r0, [pc, #32]	; (800bee8 <disk_write+0x88>)
 800bec8:	9301      	str	r3, [sp, #4]
 800beca:	f7ff f849 	bl	800af60 <mmcSequentialWrite.part.7.lto_priv.170>
    if (mmcIsWriteProtected(&MMCD1))
        return RES_WRPRT;
    if (mmcStartSequentialWrite(&MMCD1, sector))
        return RES_ERROR;
    while (count > 0) {
        if (mmcSequentialWrite(&MMCD1, buff))
 800bece:	2800      	cmp	r0, #0
 800bed0:	d1e0      	bne.n	800be94 <disk_write+0x34>
        return RES_NOTRDY;
    if (mmcIsWriteProtected(&MMCD1))
        return RES_WRPRT;
    if (mmcStartSequentialWrite(&MMCD1, sector))
        return RES_ERROR;
    while (count > 0) {
 800bed2:	9b01      	ldr	r3, [sp, #4]
 800bed4:	3b01      	subs	r3, #1
        if (mmcSequentialWrite(&MMCD1, buff))
            return RES_ERROR;
        buff += MMCSD_BLOCK_SIZE;
 800bed6:	f504 7400 	add.w	r4, r4, #512	; 0x200
        return RES_NOTRDY;
    if (mmcIsWriteProtected(&MMCD1))
        return RES_WRPRT;
    if (mmcStartSequentialWrite(&MMCD1, sector))
        return RES_ERROR;
    while (count > 0) {
 800beda:	d0e0      	beq.n	800be9e <disk_write+0x3e>
 */
bool mmcSequentialWrite(MMCDriver *mmcp, const uint8_t *buffer) {
  static const uint8_t start[] = {0xFF, 0xFC};
  uint8_t b[1];

  osalDbgCheck((mmcp != NULL) && (buffer != NULL));
 800bedc:	2c00      	cmp	r4, #0
 800bede:	d0db      	beq.n	800be98 <disk_write+0x38>

  if (mmcp->state != BLK_WRITING) {
 800bee0:	7932      	ldrb	r2, [r6, #4]
 800bee2:	2a07      	cmp	r2, #7
 800bee4:	d1d6      	bne.n	800be94 <disk_write+0x34>
 800bee6:	e7ed      	b.n	800bec4 <disk_write+0x64>
 800bee8:	20028764 	.word	0x20028764
 800beec:	08015884 	.word	0x08015884
 800bef0:	08015898 	.word	0x08015898
	...

0800bf00 <disk_initialize>:
    BYTE pdrv                /* Physical drive nmuber (0..) */
)
{
  DSTATUS stat;

  switch (pdrv) {
 800bf00:	b928      	cbnz	r0, 800bf0e <disk_initialize+0xe>
#if HAL_USE_MMC_SPI
  case MMC:
    stat = 0;
    /* It is initialized externally, just reads the status.*/
    if (blkGetDriverState(&MMCD1) != BLK_READY)
 800bf02:	4b04      	ldr	r3, [pc, #16]	; (800bf14 <disk_initialize+0x14>)
    if (sdcIsWriteProtected(&SDCD1))
      stat |=  STA_PROTECT;
    return stat;
#endif
  }
  return STA_NOINIT;
 800bf04:	7918      	ldrb	r0, [r3, #4]
 800bf06:	3805      	subs	r0, #5
 800bf08:	bf18      	it	ne
 800bf0a:	2001      	movne	r0, #1
 800bf0c:	4770      	bx	lr
 800bf0e:	2001      	movs	r0, #1
}
 800bf10:	4770      	bx	lr
 800bf12:	bf00      	nop
 800bf14:	20028764 	.word	0x20028764
	...

0800bf20 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 800bf20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bf24:	b087      	sub	sp, #28
 800bf26:	4617      	mov	r7, r2
 800bf28:	f10d 030d 	add.w	r3, sp, #13
 800bf2c:	aa03      	add	r2, sp, #12
 800bf2e:	1a9b      	subs	r3, r3, r2
 800bf30:	4606      	mov	r6, r0
 800bf32:	460d      	mov	r5, r1
 800bf34:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800bf36:	f04f 0a00 	mov.w	sl, #0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800bf3a:	7829      	ldrb	r1, [r5, #0]
 800bf3c:	1c6a      	adds	r2, r5, #1
    if (c == 0)
 800bf3e:	b161      	cbz	r1, 800bf5a <chvprintf+0x3a>
      return n;
    if (c != '%') {
 800bf40:	2925      	cmp	r1, #37	; 0x25
 800bf42:	d00e      	beq.n	800bf62 <chvprintf+0x42>
      streamPut(chp, (uint8_t)c);
 800bf44:	6833      	ldr	r3, [r6, #0]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800bf46:	4615      	mov	r5, r2
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 800bf48:	689b      	ldr	r3, [r3, #8]
 800bf4a:	4630      	mov	r0, r6
 800bf4c:	4798      	blx	r3
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800bf4e:	7829      	ldrb	r1, [r5, #0]
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 800bf50:	f10a 0a01 	add.w	sl, sl, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800bf54:	1c6a      	adds	r2, r5, #1
    if (c == 0)
 800bf56:	2900      	cmp	r1, #0
 800bf58:	d1f2      	bne.n	800bf40 <chvprintf+0x20>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 800bf5a:	4650      	mov	r0, sl
 800bf5c:	b007      	add	sp, #28
 800bf5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 800bf62:	7869      	ldrb	r1, [r5, #1]
 800bf64:	292d      	cmp	r1, #45	; 0x2d
 800bf66:	bf03      	ittte	eq
 800bf68:	78a9      	ldrbeq	r1, [r5, #2]
      fmt++;
 800bf6a:	1caa      	addeq	r2, r5, #2
      left_align = TRUE;
 800bf6c:	f04f 0b01 	moveq.w	fp, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 800bf70:	f04f 0b00 	movne.w	fp, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 800bf74:	2930      	cmp	r1, #48	; 0x30
 800bf76:	bf03      	ittte	eq
 800bf78:	7851      	ldrbeq	r1, [r2, #1]
      fmt++;
 800bf7a:	3201      	addeq	r2, #1
      filler = '0';
 800bf7c:	f04f 0830 	moveq.w	r8, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 800bf80:	f04f 0820 	movne.w	r8, #32
 800bf84:	1c50      	adds	r0, r2, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 800bf86:	f04f 0900 	mov.w	r9, #0
 800bf8a:	e005      	b.n	800bf98 <chvprintf+0x78>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 800bf8c:	783b      	ldrb	r3, [r7, #0]
 800bf8e:	3704      	adds	r7, #4
 800bf90:	7829      	ldrb	r1, [r5, #0]
      else
        break;
      width = width * 10 + c;
 800bf92:	eb03 0942 	add.w	r9, r3, r2, lsl #1
 800bf96:	3001      	adds	r0, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 800bf98:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 800bf9c:	b2db      	uxtb	r3, r3
 800bf9e:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 800bfa0:	4605      	mov	r5, r0
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 800bfa2:	eb09 0289 	add.w	r2, r9, r9, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 800bfa6:	d9f3      	bls.n	800bf90 <chvprintf+0x70>
        c -= '0';
      else if (c == '*')
 800bfa8:	292a      	cmp	r1, #42	; 0x2a
 800bfaa:	d0ef      	beq.n	800bf8c <chvprintf+0x6c>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 800bfac:	292e      	cmp	r1, #46	; 0x2e
 800bfae:	f04f 0000 	mov.w	r0, #0
 800bfb2:	d043      	beq.n	800c03c <chvprintf+0x11c>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800bfb4:	f001 02df 	and.w	r2, r1, #223	; 0xdf
 800bfb8:	2a4c      	cmp	r2, #76	; 0x4c
 800bfba:	d04e      	beq.n	800c05a <chvprintf+0x13a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800bfbc:	f1a1 0244 	sub.w	r2, r1, #68	; 0x44
 800bfc0:	2a34      	cmp	r2, #52	; 0x34
 800bfc2:	f200 80f9 	bhi.w	800c1b8 <chvprintf+0x298>
 800bfc6:	e8df f012 	tbh	[pc, r2, lsl #1]
 800bfca:	00ee      	.short	0x00ee
 800bfcc:	00f700f7 	.word	0x00f700f7
 800bfd0:	00f700f7 	.word	0x00f700f7
 800bfd4:	00f700ee 	.word	0x00f700ee
 800bfd8:	00f700f7 	.word	0x00f700f7
 800bfdc:	00f700f7 	.word	0x00f700f7
 800bfe0:	00f700ec 	.word	0x00f700ec
 800bfe4:	00f700f7 	.word	0x00f700f7
 800bfe8:	00f700f7 	.word	0x00f700f7
 800bfec:	00f700b9 	.word	0x00f700b9
 800bff0:	006f00f7 	.word	0x006f00f7
 800bff4:	00f700f7 	.word	0x00f700f7
 800bff8:	00f700f7 	.word	0x00f700f7
 800bffc:	00f700f7 	.word	0x00f700f7
 800c000:	00f700f7 	.word	0x00f700f7
 800c004:	00f700f7 	.word	0x00f700f7
 800c008:	00ee00e0 	.word	0x00ee00e0
 800c00c:	00f700f7 	.word	0x00f700f7
 800c010:	00f700f7 	.word	0x00f700f7
 800c014:	00f700ee 	.word	0x00f700ee
 800c018:	00f700f7 	.word	0x00f700f7
 800c01c:	00f700f7 	.word	0x00f700f7
 800c020:	00f700ec 	.word	0x00f700ec
 800c024:	00f700f7 	.word	0x00f700f7
 800c028:	00f700bb 	.word	0x00f700bb
 800c02c:	00f700b9 	.word	0x00f700b9
 800c030:	006f00f7 	.word	0x006f00f7
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 800c034:	783b      	ldrb	r3, [r7, #0]
 800c036:	3704      	adds	r7, #4
        else
          break;
        precision *= 10;
        precision += c;
 800c038:	eb03 0042 	add.w	r0, r3, r2, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 800c03c:	f815 1b01 	ldrb.w	r1, [r5], #1
        if (c >= '0' && c <= '9')
 800c040:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 800c044:	b2db      	uxtb	r3, r3
 800c046:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 800c048:	eb00 0280 	add.w	r2, r0, r0, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 800c04c:	d9f4      	bls.n	800c038 <chvprintf+0x118>
          c -= '0';
        else if (c == '*')
 800c04e:	292a      	cmp	r1, #42	; 0x2a
 800c050:	d0f0      	beq.n	800c034 <chvprintf+0x114>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800c052:	f001 02df 	and.w	r2, r1, #223	; 0xdf
 800c056:	2a4c      	cmp	r2, #76	; 0x4c
 800c058:	d1b0      	bne.n	800bfbc <chvprintf+0x9c>
      is_long = TRUE;
      if (*fmt)
 800c05a:	782c      	ldrb	r4, [r5, #0]
 800c05c:	2c00      	cmp	r4, #0
 800c05e:	f000 80ab 	beq.w	800c1b8 <chvprintf+0x298>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800c062:	f1a4 0244 	sub.w	r2, r4, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 800c066:	3501      	adds	r5, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800c068:	2a34      	cmp	r2, #52	; 0x34
 800c06a:	f200 80a4 	bhi.w	800c1b6 <chvprintf+0x296>
 800c06e:	e8df f002 	tbb	[pc, r2]
 800c072:	a29a      	.short	0xa29a
 800c074:	9aa2a2a2 	.word	0x9aa2a2a2
 800c078:	a2a2a2a2 	.word	0xa2a2a2a2
 800c07c:	a2a298a2 	.word	0xa2a298a2
 800c080:	65a2a2a2 	.word	0x65a2a2a2
 800c084:	a21ba2a2 	.word	0xa21ba2a2
 800c088:	a2a2a2a2 	.word	0xa2a2a2a2
 800c08c:	a2a2a2a2 	.word	0xa2a2a2a2
 800c090:	a29a8ca2 	.word	0xa29a8ca2
 800c094:	9aa2a2a2 	.word	0x9aa2a2a2
 800c098:	a2a2a2a2 	.word	0xa2a2a2a2
 800c09c:	a2a298a2 	.word	0xa2a298a2
 800c0a0:	65a267a2 	.word	0x65a267a2
 800c0a4:	a2a2      	.short	0xa2a2
 800c0a6:	1b          	.byte	0x1b
 800c0a7:	00          	.byte	0x00
 800c0a8:	2210      	movs	r2, #16
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 800c0aa:	6839      	ldr	r1, [r7, #0]
      p = ch_ltoa(p, l, c);
 800c0ac:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 800c0ae:	3704      	adds	r7, #4
      p = ch_ltoa(p, l, c);
 800c0b0:	f7ff faee 	bl	800b690 <ch_ltoa>
 800c0b4:	ab03      	add	r3, sp, #12
 800c0b6:	1ac0      	subs	r0, r0, r3
 800c0b8:	1e43      	subs	r3, r0, #1
 800c0ba:	9300      	str	r3, [sp, #0]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800c0bc:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 800c0be:	ebc0 0909 	rsb	r9, r0, r9
 800c0c2:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
      width = 0;
    if (left_align == FALSE)
 800c0c6:	f1bb 0f00 	cmp.w	fp, #0
 800c0ca:	d15a      	bne.n	800c182 <chvprintf+0x262>
      width = -width;
 800c0cc:	f1c9 0b00 	rsb	fp, r9, #0
    if (width < 0) {
 800c0d0:	f1bb 0f00 	cmp.w	fp, #0
 800c0d4:	d078      	beq.n	800c1c8 <chvprintf+0x2a8>
      if (*s == '-' && filler == '0') {
 800c0d6:	7821      	ldrb	r1, [r4, #0]
 800c0d8:	292d      	cmp	r1, #45	; 0x2d
 800c0da:	f000 8088 	beq.w	800c1ee <chvprintf+0x2ce>
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800c0de:	6833      	ldr	r3, [r6, #0]
 800c0e0:	4641      	mov	r1, r8
 800c0e2:	689b      	ldr	r3, [r3, #8]
 800c0e4:	4630      	mov	r0, r6
 800c0e6:	4798      	blx	r3
        n++;
      } while (++width != 0);
 800c0e8:	f11b 0b01 	adds.w	fp, fp, #1
 800c0ec:	d1f7      	bne.n	800c0de <chvprintf+0x1be>
    }
    while (--i >= 0) {
 800c0ee:	9b00      	ldr	r3, [sp, #0]
 800c0f0:	2b00      	cmp	r3, #0
 800c0f2:	44ca      	add	sl, r9
 800c0f4:	f6ff af21 	blt.w	800bf3a <chvprintf+0x1a>
 800c0f8:	46d9      	mov	r9, fp
 800c0fa:	f8dd b000 	ldr.w	fp, [sp]
      streamPut(chp, (uint8_t)*s++);
 800c0fe:	6833      	ldr	r3, [r6, #0]
 800c100:	f814 1b01 	ldrb.w	r1, [r4], #1
 800c104:	689b      	ldr	r3, [r3, #8]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800c106:	f10b 3bff 	add.w	fp, fp, #4294967295
      streamPut(chp, (uint8_t)*s++);
 800c10a:	4630      	mov	r0, r6
 800c10c:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800c10e:	f1bb 3fff 	cmp.w	fp, #4294967295
 800c112:	d1f4      	bne.n	800c0fe <chvprintf+0x1de>
 800c114:	9b00      	ldr	r3, [sp, #0]
 800c116:	f10a 0a01 	add.w	sl, sl, #1
 800c11a:	2b00      	cmp	r3, #0
 800c11c:	bfa8      	it	ge
 800c11e:	449a      	addge	sl, r3
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800c120:	f1b9 0f00 	cmp.w	r9, #0
 800c124:	f43f af09 	beq.w	800bf3a <chvprintf+0x1a>
 800c128:	464c      	mov	r4, r9
      streamPut(chp, (uint8_t)filler);
 800c12a:	6833      	ldr	r3, [r6, #0]
 800c12c:	4641      	mov	r1, r8
 800c12e:	689b      	ldr	r3, [r3, #8]
 800c130:	4630      	mov	r0, r6
 800c132:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800c134:	3c01      	subs	r4, #1
 800c136:	d1f8      	bne.n	800c12a <chvprintf+0x20a>
 800c138:	44ca      	add	sl, r9
 800c13a:	e6fe      	b.n	800bf3a <chvprintf+0x1a>
 800c13c:	220a      	movs	r2, #10
 800c13e:	e7b4      	b.n	800c0aa <chvprintf+0x18a>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 800c140:	683c      	ldr	r4, [r7, #0]
        s = "(null)";
 800c142:	4a37      	ldr	r2, [pc, #220]	; (800c220 <chvprintf+0x300>)
 800c144:	2c00      	cmp	r4, #0
 800c146:	bf08      	it	eq
 800c148:	4614      	moveq	r4, r2
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 800c14a:	3704      	adds	r7, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800c14c:	7822      	ldrb	r2, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 800c14e:	2800      	cmp	r0, #0
 800c150:	d03e      	beq.n	800c1d0 <chvprintf+0x2b0>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800c152:	2a00      	cmp	r2, #0
 800c154:	d040      	beq.n	800c1d8 <chvprintf+0x2b8>
 800c156:	3801      	subs	r0, #1
 800c158:	4622      	mov	r2, r4
 800c15a:	e001      	b.n	800c160 <chvprintf+0x240>
 800c15c:	1c43      	adds	r3, r0, #1
 800c15e:	d004      	beq.n	800c16a <chvprintf+0x24a>
 800c160:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800c164:	3801      	subs	r0, #1
 800c166:	2b00      	cmp	r3, #0
 800c168:	d1f8      	bne.n	800c15c <chvprintf+0x23c>
 800c16a:	1b10      	subs	r0, r2, r4
 800c16c:	1e43      	subs	r3, r0, #1
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 800c16e:	ebc0 0909 	rsb	r9, r0, r9
 800c172:	9300      	str	r3, [sp, #0]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 800c174:	f04f 0820 	mov.w	r8, #32
 800c178:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 800c17c:	f1bb 0f00 	cmp.w	fp, #0
 800c180:	d0a4      	beq.n	800c0cc <chvprintf+0x1ac>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800c182:	9b00      	ldr	r3, [sp, #0]
 800c184:	2b00      	cmp	r3, #0
 800c186:	dab8      	bge.n	800c0fa <chvprintf+0x1da>
 800c188:	e7ca      	b.n	800c120 <chvprintf+0x200>
 800c18a:	9b01      	ldr	r3, [sp, #4]

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 800c18c:	683a      	ldr	r2, [r7, #0]
 800c18e:	f88d 200c 	strb.w	r2, [sp, #12]
 800c192:	4618      	mov	r0, r3
 800c194:	3b01      	subs	r3, #1
 800c196:	3704      	adds	r7, #4
 800c198:	9300      	str	r3, [sp, #0]
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 800c19a:	f04f 0820 	mov.w	r8, #32
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800c19e:	ac03      	add	r4, sp, #12
 800c1a0:	e78d      	b.n	800c0be <chvprintf+0x19e>
 800c1a2:	2208      	movs	r2, #8
 800c1a4:	e781      	b.n	800c0aa <chvprintf+0x18a>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 800c1a6:	6839      	ldr	r1, [r7, #0]
      if (l < 0) {
 800c1a8:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 800c1aa:	f107 0704 	add.w	r7, r7, #4
      if (l < 0) {
 800c1ae:	db2d      	blt.n	800c20c <chvprintf+0x2ec>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800c1b0:	a803      	add	r0, sp, #12
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
        l = -l;
      }
      p = ch_ltoa(p, l, 10);
 800c1b2:	220a      	movs	r2, #10
 800c1b4:	e77c      	b.n	800c0b0 <chvprintf+0x190>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800c1b6:	4621      	mov	r1, r4
 800c1b8:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 800c1ba:	f88d 100c 	strb.w	r1, [sp, #12]
 800c1be:	4618      	mov	r0, r3
 800c1c0:	3b01      	subs	r3, #1
 800c1c2:	9300      	str	r3, [sp, #0]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800c1c4:	ac03      	add	r4, sp, #12
 800c1c6:	e77a      	b.n	800c0be <chvprintf+0x19e>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800c1c8:	9b00      	ldr	r3, [sp, #0]
 800c1ca:	2b00      	cmp	r3, #0
 800c1cc:	da94      	bge.n	800c0f8 <chvprintf+0x1d8>
 800c1ce:	e6b4      	b.n	800bf3a <chvprintf+0x1a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800c1d0:	f647 70fe 	movw	r0, #32766	; 0x7ffe
 800c1d4:	2a00      	cmp	r2, #0
 800c1d6:	d1bf      	bne.n	800c158 <chvprintf+0x238>
 800c1d8:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 800c1dc:	f1bb 0f00 	cmp.w	fp, #0
 800c1e0:	d11b      	bne.n	800c21a <chvprintf+0x2fa>
 800c1e2:	f04f 33ff 	mov.w	r3, #4294967295
 800c1e6:	9300      	str	r3, [sp, #0]
 800c1e8:	f04f 0820 	mov.w	r8, #32
 800c1ec:	e76e      	b.n	800c0cc <chvprintf+0x1ac>
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 800c1ee:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 800c1f2:	f47f af74 	bne.w	800c0de <chvprintf+0x1be>
        streamPut(chp, (uint8_t)*s++);
 800c1f6:	6832      	ldr	r2, [r6, #0]
 800c1f8:	4630      	mov	r0, r6
 800c1fa:	6892      	ldr	r2, [r2, #8]
 800c1fc:	4790      	blx	r2
 800c1fe:	9b00      	ldr	r3, [sp, #0]
 800c200:	3b01      	subs	r3, #1
 800c202:	3401      	adds	r4, #1
        n++;
 800c204:	f10a 0a01 	add.w	sl, sl, #1
 800c208:	9300      	str	r3, [sp, #0]
 800c20a:	e768      	b.n	800c0de <chvprintf+0x1be>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 800c20c:	222d      	movs	r2, #45	; 0x2d
        l = -l;
 800c20e:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 800c210:	f88d 200c 	strb.w	r2, [sp, #12]
 800c214:	f10d 000d 	add.w	r0, sp, #13
 800c218:	e7cb      	b.n	800c1b2 <chvprintf+0x292>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 800c21a:	f04f 0820 	mov.w	r8, #32
 800c21e:	e77f      	b.n	800c120 <chvprintf+0x200>
 800c220:	080158f0 	.word	0x080158f0
	...

0800c230 <chsnprintf>:
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 800c230:	b40c      	push	{r2, r3}
 800c232:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c234:	b087      	sub	sp, #28
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
 800c236:	ab0d      	add	r3, sp, #52	; 0x34
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 800c238:	4605      	mov	r5, r0
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 800c23a:	460c      	mov	r4, r1
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
  retval = chvprintf(chp, fmt, ap);
 800c23c:	461a      	mov	r2, r3
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 800c23e:	b1b9      	cbz	r1, 800c270 <chsnprintf+0x40>
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 800c240:	f8df e04c 	ldr.w	lr, [pc, #76]	; 800c290 <chsnprintf+0x60>
  msp->buffer = buffer;
 800c244:	9002      	str	r0, [sp, #8]
  msp->size   = size;
 800c246:	1e4f      	subs	r7, r1, #1
  msp->eos    = eos;
 800c248:	2600      	movs	r6, #0
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
  retval = chvprintf(chp, fmt, ap);
 800c24a:	990c      	ldr	r1, [sp, #48]	; 0x30
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
 800c24c:	9300      	str	r3, [sp, #0]
  retval = chvprintf(chp, fmt, ap);
 800c24e:	a801      	add	r0, sp, #4
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 800c250:	f8cd e004 	str.w	lr, [sp, #4]
  msp->buffer = buffer;
  msp->size   = size;
 800c254:	9703      	str	r7, [sp, #12]
  msp->eos    = eos;
 800c256:	9604      	str	r6, [sp, #16]
  msp->offset = 0;
 800c258:	9605      	str	r6, [sp, #20]
 800c25a:	f7ff fe61 	bl	800bf20 <chvprintf>
  va_end(ap);

  /* Terminate with a zero, unless size==0.*/
  if (ms.eos < size)
 800c25e:	9b04      	ldr	r3, [sp, #16]
 800c260:	429c      	cmp	r4, r3
 800c262:	d900      	bls.n	800c266 <chsnprintf+0x36>
      str[ms.eos] = 0;
 800c264:	54ee      	strb	r6, [r5, r3]

  /* Return number of bytes that would have been written.*/
  return retval;
}
 800c266:	b007      	add	sp, #28
 800c268:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 800c26c:	b002      	add	sp, #8
 800c26e:	4770      	bx	lr
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 800c270:	4e07      	ldr	r6, [pc, #28]	; (800c290 <chsnprintf+0x60>)
  msp->buffer = buffer;
 800c272:	9002      	str	r0, [sp, #8]
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
  retval = chvprintf(chp, fmt, ap);
 800c274:	990c      	ldr	r1, [sp, #48]	; 0x30
  msp->size   = size;
 800c276:	9403      	str	r4, [sp, #12]
 800c278:	a801      	add	r0, sp, #4
  msp->eos    = eos;
 800c27a:	9404      	str	r4, [sp, #16]
  msp->offset = 0;
 800c27c:	9405      	str	r4, [sp, #20]
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 800c27e:	e88d 0048 	stmia.w	sp, {r3, r6}
 800c282:	f7ff fe4d 	bl	800bf20 <chvprintf>
  if (ms.eos < size)
      str[ms.eos] = 0;

  /* Return number of bytes that would have been written.*/
  return retval;
}
 800c286:	b007      	add	sp, #28
 800c288:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 800c28c:	b002      	add	sp, #8
 800c28e:	4770      	bx	lr
 800c290:	08015904 	.word	0x08015904
	...

0800c2a0 <__early_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800c2a0:	492c      	ldr	r1, [pc, #176]	; (800c354 <__early_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800c2a2:	4b2d      	ldr	r3, [pc, #180]	; (800c358 <__early_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800c2a4:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800c2a8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800c2ac:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800c2ae:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 800c2b0:	680b      	ldr	r3, [r1, #0]
 800c2b2:	f043 0301 	orr.w	r3, r3, #1
 800c2b6:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800c2b8:	680a      	ldr	r2, [r1, #0]
 800c2ba:	4b26      	ldr	r3, [pc, #152]	; (800c354 <__early_init+0xb4>)
 800c2bc:	0790      	lsls	r0, r2, #30
 800c2be:	d5fb      	bpl.n	800c2b8 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800c2c0:	689a      	ldr	r2, [r3, #8]
 800c2c2:	f022 0203 	bic.w	r2, r2, #3
 800c2c6:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800c2c8:	689a      	ldr	r2, [r3, #8]
 800c2ca:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800c2cc:	4619      	mov	r1, r3
 800c2ce:	688b      	ldr	r3, [r1, #8]
 800c2d0:	4a20      	ldr	r2, [pc, #128]	; (800c354 <__early_init+0xb4>)
 800c2d2:	f013 030c 	ands.w	r3, r3, #12
 800c2d6:	d1fa      	bne.n	800c2ce <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800c2d8:	6811      	ldr	r1, [r2, #0]
 800c2da:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800c2de:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800c2e0:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 800c2e2:	6813      	ldr	r3, [r2, #0]
 800c2e4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c2e8:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800c2ea:	6811      	ldr	r1, [r2, #0]
 800c2ec:	4b19      	ldr	r3, [pc, #100]	; (800c354 <__early_init+0xb4>)
 800c2ee:	0389      	lsls	r1, r1, #14
 800c2f0:	d5fb      	bpl.n	800c2ea <__early_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800c2f2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800c2f4:	f042 0201 	orr.w	r2, r2, #1
 800c2f8:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800c2fa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800c2fc:	4915      	ldr	r1, [pc, #84]	; (800c354 <__early_init+0xb4>)
 800c2fe:	0792      	lsls	r2, r2, #30
 800c300:	d5fb      	bpl.n	800c2fa <__early_init+0x5a>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800c302:	4a16      	ldr	r2, [pc, #88]	; (800c35c <__early_init+0xbc>)

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800c304:	4b16      	ldr	r3, [pc, #88]	; (800c360 <__early_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800c306:	608a      	str	r2, [r1, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800c308:	681a      	ldr	r2, [r3, #0]
 800c30a:	4b16      	ldr	r3, [pc, #88]	; (800c364 <__early_init+0xc4>)
 800c30c:	429a      	cmp	r2, r3
 800c30e:	d017      	beq.n	800c340 <__early_init+0xa0>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800c310:	4b15      	ldr	r3, [pc, #84]	; (800c368 <__early_init+0xc8>)
 800c312:	f240 7201 	movw	r2, #1793	; 0x701
 800c316:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800c318:	4a0e      	ldr	r2, [pc, #56]	; (800c354 <__early_init+0xb4>)
 800c31a:	6893      	ldr	r3, [r2, #8]
 800c31c:	f043 0301 	orr.w	r3, r3, #1
 800c320:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800c322:	6893      	ldr	r3, [r2, #8]
 800c324:	490b      	ldr	r1, [pc, #44]	; (800c354 <__early_init+0xb4>)
 800c326:	f003 030c 	and.w	r3, r3, #12
 800c32a:	2b04      	cmp	r3, #4
 800c32c:	d1f9      	bne.n	800c322 <__early_init+0x82>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800c32e:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 800c330:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800c334:	644b      	str	r3, [r1, #68]	; 0x44
 800c336:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 800c338:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800c33c:	664b      	str	r3, [r1, #100]	; 0x64
 800c33e:	4770      	bx	lr

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800c340:	4a0a      	ldr	r2, [pc, #40]	; (800c36c <__early_init+0xcc>)
 800c342:	4b0b      	ldr	r3, [pc, #44]	; (800c370 <__early_init+0xd0>)
 800c344:	6812      	ldr	r2, [r2, #0]
 800c346:	429a      	cmp	r2, r3
 800c348:	d1e2      	bne.n	800c310 <__early_init+0x70>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 800c34a:	4b07      	ldr	r3, [pc, #28]	; (800c368 <__early_init+0xc8>)
 800c34c:	f240 1201 	movw	r2, #257	; 0x101
 800c350:	601a      	str	r2, [r3, #0]
 800c352:	e7e1      	b.n	800c318 <__early_init+0x78>
 800c354:	40023800 	.word	0x40023800
 800c358:	40007000 	.word	0x40007000
 800c35c:	3cc80000 	.word	0x3cc80000
 800c360:	e0042000 	.word	0xe0042000
 800c364:	20006411 	.word	0x20006411
 800c368:	40023c00 	.word	0x40023c00
 800c36c:	e000ed00 	.word	0xe000ed00
 800c370:	410fc241 	.word	0x410fc241
	...

0800c380 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 800c380:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 800c384:	f3c2 1c41 	ubfx	ip, r2, #5, #2
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800c388:	f002 0e03 	and.w	lr, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800c38c:	f3c2 0980 	ubfx	r9, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800c390:	f3c2 08c1 	ubfx	r8, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 800c394:	2700      	movs	r7, #0

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800c396:	f3c2 12c3 	ubfx	r2, r2, #7, #4
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800c39a:	f04f 0b0f 	mov.w	fp, #15
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800c39e:	f04f 0a01 	mov.w	sl, #1
 800c3a2:	e00f      	b.n	800c3c4 <_pal_lld_setgroupmode+0x44>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800c3a4:	6a04      	ldr	r4, [r0, #32]
 800c3a6:	ea24 0303 	bic.w	r3, r4, r3
 800c3aa:	431d      	orrs	r5, r3
 800c3ac:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 800c3ae:	0849      	lsrs	r1, r1, #1
 800c3b0:	d039      	beq.n	800c426 <_pal_lld_setgroupmode+0xa6>
      return;
    otyper <<= 1;
 800c3b2:	ea4f 0949 	mov.w	r9, r9, lsl #1
    ospeedr <<= 2;
 800c3b6:	ea4f 0888 	mov.w	r8, r8, lsl #2
    pupdr <<= 2;
 800c3ba:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    moder <<= 2;
 800c3be:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    bit++;
 800c3c2:	3701      	adds	r7, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800c3c4:	07cb      	lsls	r3, r1, #31
 800c3c6:	d5f2      	bpl.n	800c3ae <_pal_lld_setgroupmode+0x2e>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800c3c8:	6843      	ldr	r3, [r0, #4]
 800c3ca:	fa0a f407 	lsl.w	r4, sl, r7
 800c3ce:	ea23 0304 	bic.w	r3, r3, r4
 800c3d2:	ea43 0309 	orr.w	r3, r3, r9
 800c3d6:	6043      	str	r3, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800c3d8:	2503      	movs	r5, #3
 800c3da:	007c      	lsls	r4, r7, #1
 800c3dc:	6883      	ldr	r3, [r0, #8]
 800c3de:	fa05 f404 	lsl.w	r4, r5, r4
 800c3e2:	43e4      	mvns	r4, r4
 800c3e4:	4023      	ands	r3, r4
 800c3e6:	ea43 0308 	orr.w	r3, r3, r8
 800c3ea:	6083      	str	r3, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800c3ec:	68c5      	ldr	r5, [r0, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800c3ee:	f007 0307 	and.w	r3, r7, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800c3f2:	4025      	ands	r5, r4
 800c3f4:	ea45 050c 	orr.w	r5, r5, ip
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800c3f8:	009b      	lsls	r3, r3, #2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 800c3fa:	f1be 0f02 	cmp.w	lr, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800c3fe:	60c5      	str	r5, [r0, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800c400:	fa02 f503 	lsl.w	r5, r2, r3
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800c404:	fa0b f303 	lsl.w	r3, fp, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 800c408:	d00f      	beq.n	800c42a <_pal_lld_setgroupmode+0xaa>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800c40a:	6806      	ldr	r6, [r0, #0]
 800c40c:	4034      	ands	r4, r6
 800c40e:	ea44 040e 	orr.w	r4, r4, lr
        if (bit < 8)
 800c412:	2f07      	cmp	r7, #7
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800c414:	6004      	str	r4, [r0, #0]
        if (bit < 8)
 800c416:	d9c5      	bls.n	800c3a4 <_pal_lld_setgroupmode+0x24>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800c418:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800c41a:	ea24 0303 	bic.w	r3, r4, r3
 800c41e:	431d      	orrs	r5, r3
      }
    }
    mask >>= 1;
    if (!mask)
 800c420:	0849      	lsrs	r1, r1, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800c422:	6245      	str	r5, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 800c424:	d1c5      	bne.n	800c3b2 <_pal_lld_setgroupmode+0x32>
 800c426:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800c42a:	2f07      	cmp	r7, #7
 800c42c:	d80a      	bhi.n	800c444 <_pal_lld_setgroupmode+0xc4>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800c42e:	6a06      	ldr	r6, [r0, #32]
 800c430:	ea26 0303 	bic.w	r3, r6, r3
 800c434:	431d      	orrs	r5, r3
 800c436:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 800c438:	6803      	ldr	r3, [r0, #0]
 800c43a:	401c      	ands	r4, r3
 800c43c:	f044 0402 	orr.w	r4, r4, #2
 800c440:	6004      	str	r4, [r0, #0]
 800c442:	e7b4      	b.n	800c3ae <_pal_lld_setgroupmode+0x2e>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800c444:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800c446:	ea26 0303 	bic.w	r3, r6, r3
 800c44a:	431d      	orrs	r5, r3
 800c44c:	6245      	str	r5, [r0, #36]	; 0x24
 800c44e:	e7f3      	b.n	800c438 <_pal_lld_setgroupmode+0xb8>

0800c450 <adc_lld_serve_rx_interrupt.lto_priv.144>:
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800c450:	f011 0f0c 	tst.w	r1, #12
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 800c454:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c458:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800c45a:	d034      	beq.n	800c4c6 <adc_lld_serve_rx_interrupt.lto_priv.144+0x76>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800c45c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800c45e:	6803      	ldr	r3, [r0, #0]
 800c460:	681a      	ldr	r2, [r3, #0]
 800c462:	f022 021f 	bic.w	r2, r2, #31
 800c466:	601a      	str	r2, [r3, #0]
 800c468:	6819      	ldr	r1, [r3, #0]
 800c46a:	f011 0101 	ands.w	r1, r1, #1
 800c46e:	d1fb      	bne.n	800c468 <adc_lld_serve_rx_interrupt.lto_priv.144+0x18>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800c470:	6922      	ldr	r2, [r4, #16]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800c472:	7a07      	ldrb	r7, [r0, #8]
 800c474:	6846      	ldr	r6, [r0, #4]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800c476:	6895      	ldr	r5, [r2, #8]
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
 800c478:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800c47a:	223d      	movs	r2, #61	; 0x3d
 800c47c:	40ba      	lsls	r2, r7
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 800c47e:	2001      	movs	r0, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800c480:	6032      	str	r2, [r6, #0]
  adcp->adc->CR1 = 0;
 800c482:	6059      	str	r1, [r3, #4]
  adcp->adc->CR2 = 0;
 800c484:	6099      	str	r1, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800c486:	6098      	str	r0, [r3, #8]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800c488:	2d00      	cmp	r5, #0
 800c48a:	d035      	beq.n	800c4f8 <adc_lld_serve_rx_interrupt.lto_priv.144+0xa8>
 800c48c:	2305      	movs	r3, #5
 800c48e:	7023      	strb	r3, [r4, #0]
 800c490:	4620      	mov	r0, r4
 800c492:	47a8      	blx	r5
 800c494:	7823      	ldrb	r3, [r4, #0]
 800c496:	2b05      	cmp	r3, #5
 800c498:	bf04      	itt	eq
 800c49a:	2302      	moveq	r3, #2
 800c49c:	7023      	strbeq	r3, [r4, #0]
 800c49e:	2300      	movs	r3, #0
 800c4a0:	6123      	str	r3, [r4, #16]
 800c4a2:	2320      	movs	r3, #32
 800c4a4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800c4a8:	f002 fc0a 	bl	800ecc0 <_dbg_check_lock_from_isr>
 800c4ac:	f104 0014 	add.w	r0, r4, #20
 800c4b0:	f04f 31ff 	mov.w	r1, #4294967295
 800c4b4:	f002 fabc 	bl	800ea30 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800c4b8:	f002 fbea 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800c4bc:	2300      	movs	r3, #0
 800c4be:	f383 8811 	msr	BASEPRI, r3
 800c4c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 800c4c6:	6905      	ldr	r5, [r0, #16]
 800c4c8:	b1a5      	cbz	r5, 800c4f4 <adc_lld_serve_rx_interrupt.lto_priv.144+0xa4>

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 800c4ca:	068a      	lsls	r2, r1, #26
 800c4cc:	d510      	bpl.n	800c4f0 <adc_lld_serve_rx_interrupt.lto_priv.144+0xa0>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800c4ce:	782b      	ldrb	r3, [r5, #0]
 800c4d0:	b1fb      	cbz	r3, 800c512 <adc_lld_serve_rx_interrupt.lto_priv.144+0xc2>
 800c4d2:	686b      	ldr	r3, [r5, #4]
 800c4d4:	b173      	cbz	r3, 800c4f4 <adc_lld_serve_rx_interrupt.lto_priv.144+0xa4>
 800c4d6:	68c2      	ldr	r2, [r0, #12]
 800c4d8:	2a01      	cmp	r2, #1
 800c4da:	d94f      	bls.n	800c57c <adc_lld_serve_rx_interrupt.lto_priv.144+0x12c>
 800c4dc:	8869      	ldrh	r1, [r5, #2]
 800c4de:	6884      	ldr	r4, [r0, #8]
 800c4e0:	0852      	lsrs	r2, r2, #1
 800c4e2:	fb02 f101 	mul.w	r1, r2, r1
 800c4e6:	eb04 0141 	add.w	r1, r4, r1, lsl #1
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800c4ea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800c4ee:	4718      	bx	r3
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 800c4f0:	06cb      	lsls	r3, r1, #27
 800c4f2:	d405      	bmi.n	800c500 <adc_lld_serve_rx_interrupt.lto_priv.144+0xb0>
 800c4f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800c4f8:	2302      	movs	r3, #2
 800c4fa:	6125      	str	r5, [r4, #16]
 800c4fc:	7023      	strb	r3, [r4, #0]
 800c4fe:	e7d0      	b.n	800c4a2 <adc_lld_serve_rx_interrupt.lto_priv.144+0x52>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800c500:	686b      	ldr	r3, [r5, #4]
 800c502:	2b00      	cmp	r3, #0
 800c504:	d0f6      	beq.n	800c4f4 <adc_lld_serve_rx_interrupt.lto_priv.144+0xa4>
 800c506:	68c2      	ldr	r2, [r0, #12]
 800c508:	6881      	ldr	r1, [r0, #8]
 800c50a:	0852      	lsrs	r2, r2, #1
      }
    }
  }
}
 800c50c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800c510:	4718      	bx	r3
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800c512:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800c514:	6802      	ldr	r2, [r0, #0]
 800c516:	6813      	ldr	r3, [r2, #0]
 800c518:	f023 031f 	bic.w	r3, r3, #31
 800c51c:	6013      	str	r3, [r2, #0]
 800c51e:	6813      	ldr	r3, [r2, #0]
 800c520:	f013 0301 	ands.w	r3, r3, #1
 800c524:	d1fb      	bne.n	800c51e <adc_lld_serve_rx_interrupt.lto_priv.144+0xce>
 800c526:	7a07      	ldrb	r7, [r0, #8]
 800c528:	6846      	ldr	r6, [r0, #4]
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800c52a:	686d      	ldr	r5, [r5, #4]
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
 800c52c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800c52e:	213d      	movs	r1, #61	; 0x3d
 800c530:	40b9      	lsls	r1, r7
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 800c532:	2001      	movs	r0, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800c534:	6031      	str	r1, [r6, #0]
  adcp->adc->CR1 = 0;
 800c536:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
 800c538:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800c53a:	6090      	str	r0, [r2, #8]
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800c53c:	b1cd      	cbz	r5, 800c572 <adc_lld_serve_rx_interrupt.lto_priv.144+0x122>
 800c53e:	2304      	movs	r3, #4
 800c540:	7023      	strb	r3, [r4, #0]
 800c542:	68e2      	ldr	r2, [r4, #12]
 800c544:	68a1      	ldr	r1, [r4, #8]
 800c546:	4620      	mov	r0, r4
 800c548:	47a8      	blx	r5
 800c54a:	7823      	ldrb	r3, [r4, #0]
 800c54c:	2b04      	cmp	r3, #4
 800c54e:	d010      	beq.n	800c572 <adc_lld_serve_rx_interrupt.lto_priv.144+0x122>
 800c550:	2320      	movs	r3, #32
 800c552:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800c556:	f002 fbb3 	bl	800ecc0 <_dbg_check_lock_from_isr>
 800c55a:	f104 0014 	add.w	r0, r4, #20
 800c55e:	2100      	movs	r1, #0
 800c560:	f002 fa66 	bl	800ea30 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800c564:	f002 fb94 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800c568:	2300      	movs	r3, #0
 800c56a:	f383 8811 	msr	BASEPRI, r3
 800c56e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c572:	2202      	movs	r2, #2
 800c574:	2300      	movs	r3, #0
 800c576:	7022      	strb	r2, [r4, #0]
 800c578:	6123      	str	r3, [r4, #16]
 800c57a:	e7e9      	b.n	800c550 <adc_lld_serve_rx_interrupt.lto_priv.144+0x100>
 800c57c:	6881      	ldr	r1, [r0, #8]
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800c57e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 800c582:	4718      	bx	r3
	...

0800c590 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 800c590:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c592:	480d      	ldr	r0, [pc, #52]	; (800c5c8 <Vector158+0x38>)
 800c594:	f002 f8c4 	bl	800e720 <_trace_isr_enter>
 800c598:	f002 fb62 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800c59c:	4b0b      	ldr	r3, [pc, #44]	; (800c5cc <Vector158+0x3c>)
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 800c59e:	480c      	ldr	r0, [pc, #48]	; (800c5d0 <Vector158+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800c5a0:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 800c5a2:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800c5a4:	0d89      	lsrs	r1, r1, #22
 800c5a6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 800c5aa:	058c      	lsls	r4, r1, #22
 800c5ac:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 800c5ae:	b10a      	cbz	r2, 800c5b4 <Vector158+0x24>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 800c5b0:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 800c5b2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c5b4:	f002 fb3c 	bl	800ec30 <_dbg_check_leave_isr>
 800c5b8:	4803      	ldr	r0, [pc, #12]	; (800c5c8 <Vector158+0x38>)
 800c5ba:	f002 f891 	bl	800e6e0 <_trace_isr_leave>
}
 800c5be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c5c2:	f7fe be3d 	b.w	800b240 <_port_irq_epilogue>
 800c5c6:	bf00      	nop
 800c5c8:	08015920 	.word	0x08015920
 800c5cc:	40026400 	.word	0x40026400
 800c5d0:	20005f28 	.word	0x20005f28
	...

0800c5e0 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 800c5e0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c5e2:	480d      	ldr	r0, [pc, #52]	; (800c618 <Vector154+0x38>)
 800c5e4:	f002 f89c 	bl	800e720 <_trace_isr_enter>
 800c5e8:	f002 fb3a 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800c5ec:	4b0b      	ldr	r3, [pc, #44]	; (800c61c <Vector154+0x3c>)
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 800c5ee:	480c      	ldr	r0, [pc, #48]	; (800c620 <Vector154+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800c5f0:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 800c5f2:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800c5f4:	0c09      	lsrs	r1, r1, #16
 800c5f6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 800c5fa:	040c      	lsls	r4, r1, #16
 800c5fc:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 800c5fe:	b10a      	cbz	r2, 800c604 <Vector154+0x24>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 800c600:	6f40      	ldr	r0, [r0, #116]	; 0x74
 800c602:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c604:	f002 fb14 	bl	800ec30 <_dbg_check_leave_isr>
 800c608:	4803      	ldr	r0, [pc, #12]	; (800c618 <Vector154+0x38>)
 800c60a:	f002 f869 	bl	800e6e0 <_trace_isr_leave>
}
 800c60e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c612:	f7fe be15 	b.w	800b240 <_port_irq_epilogue>
 800c616:	bf00      	nop
 800c618:	08015a64 	.word	0x08015a64
 800c61c:	40026400 	.word	0x40026400
 800c620:	20005f28 	.word	0x20005f28
	...

0800c630 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 800c630:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c632:	480d      	ldr	r0, [pc, #52]	; (800c668 <Vector150+0x38>)
 800c634:	f002 f874 	bl	800e720 <_trace_isr_enter>
 800c638:	f002 fb12 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800c63c:	4b0b      	ldr	r3, [pc, #44]	; (800c66c <Vector150+0x3c>)
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 800c63e:	480c      	ldr	r0, [pc, #48]	; (800c670 <Vector150+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800c640:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 800c642:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800c644:	0989      	lsrs	r1, r1, #6
 800c646:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 800c64a:	018c      	lsls	r4, r1, #6
 800c64c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 800c64e:	b10a      	cbz	r2, 800c654 <Vector150+0x24>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 800c650:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 800c652:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c654:	f002 faec 	bl	800ec30 <_dbg_check_leave_isr>
 800c658:	4803      	ldr	r0, [pc, #12]	; (800c668 <Vector150+0x38>)
 800c65a:	f002 f841 	bl	800e6e0 <_trace_isr_leave>
}
 800c65e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c662:	f7fe bded 	b.w	800b240 <_port_irq_epilogue>
 800c666:	bf00      	nop
 800c668:	08015a58 	.word	0x08015a58
 800c66c:	40026400 	.word	0x40026400
 800c670:	20005f28 	.word	0x20005f28
	...

0800c680 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 800c680:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c682:	480c      	ldr	r0, [pc, #48]	; (800c6b4 <Vector130+0x34>)
 800c684:	f002 f84c 	bl	800e720 <_trace_isr_enter>
 800c688:	f002 faea 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800c68c:	4b0a      	ldr	r3, [pc, #40]	; (800c6b8 <Vector130+0x38>)
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 800c68e:	480b      	ldr	r0, [pc, #44]	; (800c6bc <Vector130+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800c690:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 800c692:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800c694:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 800c698:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 800c69a:	b10a      	cbz	r2, 800c6a0 <Vector130+0x20>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 800c69c:	6e40      	ldr	r0, [r0, #100]	; 0x64
 800c69e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c6a0:	f002 fac6 	bl	800ec30 <_dbg_check_leave_isr>
 800c6a4:	4803      	ldr	r0, [pc, #12]	; (800c6b4 <Vector130+0x34>)
 800c6a6:	f002 f81b 	bl	800e6e0 <_trace_isr_leave>
}
 800c6aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c6ae:	f7fe bdc7 	b.w	800b240 <_port_irq_epilogue>
 800c6b2:	bf00      	nop
 800c6b4:	08015938 	.word	0x08015938
 800c6b8:	40026400 	.word	0x40026400
 800c6bc:	20005f28 	.word	0x20005f28

0800c6c0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 800c6c0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c6c2:	480d      	ldr	r0, [pc, #52]	; (800c6f8 <Vector12C+0x38>)
 800c6c4:	f002 f82c 	bl	800e720 <_trace_isr_enter>
 800c6c8:	f002 faca 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800c6cc:	4b0b      	ldr	r3, [pc, #44]	; (800c6fc <Vector12C+0x3c>)
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 800c6ce:	480c      	ldr	r0, [pc, #48]	; (800c700 <Vector12C+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800c6d0:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 800c6d2:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800c6d4:	0d89      	lsrs	r1, r1, #22
 800c6d6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 800c6da:	058c      	lsls	r4, r1, #22
 800c6dc:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 800c6de:	b10a      	cbz	r2, 800c6e4 <Vector12C+0x24>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 800c6e0:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 800c6e2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c6e4:	f002 faa4 	bl	800ec30 <_dbg_check_leave_isr>
 800c6e8:	4803      	ldr	r0, [pc, #12]	; (800c6f8 <Vector12C+0x38>)
 800c6ea:	f001 fff9 	bl	800e6e0 <_trace_isr_leave>
}
 800c6ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c6f2:	f7fe bda5 	b.w	800b240 <_port_irq_epilogue>
 800c6f6:	bf00      	nop
 800c6f8:	0801596c 	.word	0x0801596c
 800c6fc:	40026400 	.word	0x40026400
 800c700:	20005f28 	.word	0x20005f28
	...

0800c710 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 800c710:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c712:	480d      	ldr	r0, [pc, #52]	; (800c748 <Vector128+0x38>)
 800c714:	f002 f804 	bl	800e720 <_trace_isr_enter>
 800c718:	f002 faa2 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800c71c:	4b0b      	ldr	r3, [pc, #44]	; (800c74c <Vector128+0x3c>)
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 800c71e:	480c      	ldr	r0, [pc, #48]	; (800c750 <Vector128+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800c720:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 800c722:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800c724:	0c09      	lsrs	r1, r1, #16
 800c726:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 800c72a:	040c      	lsls	r4, r1, #16
 800c72c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 800c72e:	b10a      	cbz	r2, 800c734 <Vector128+0x24>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 800c730:	6d40      	ldr	r0, [r0, #84]	; 0x54
 800c732:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c734:	f002 fa7c 	bl	800ec30 <_dbg_check_leave_isr>
 800c738:	4803      	ldr	r0, [pc, #12]	; (800c748 <Vector128+0x38>)
 800c73a:	f001 ffd1 	bl	800e6e0 <_trace_isr_leave>
}
 800c73e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c742:	f7fe bd7d 	b.w	800b240 <_port_irq_epilogue>
 800c746:	bf00      	nop
 800c748:	08015a20 	.word	0x08015a20
 800c74c:	40026400 	.word	0x40026400
 800c750:	20005f28 	.word	0x20005f28
	...

0800c760 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 800c760:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c762:	480d      	ldr	r0, [pc, #52]	; (800c798 <Vector124+0x38>)
 800c764:	f001 ffdc 	bl	800e720 <_trace_isr_enter>
 800c768:	f002 fa7a 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800c76c:	4b0b      	ldr	r3, [pc, #44]	; (800c79c <Vector124+0x3c>)
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 800c76e:	480c      	ldr	r0, [pc, #48]	; (800c7a0 <Vector124+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800c770:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 800c772:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800c774:	0989      	lsrs	r1, r1, #6
 800c776:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 800c77a:	018c      	lsls	r4, r1, #6
 800c77c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 800c77e:	b10a      	cbz	r2, 800c784 <Vector124+0x24>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 800c780:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 800c782:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c784:	f002 fa54 	bl	800ec30 <_dbg_check_leave_isr>
 800c788:	4803      	ldr	r0, [pc, #12]	; (800c798 <Vector124+0x38>)
 800c78a:	f001 ffa9 	bl	800e6e0 <_trace_isr_leave>
}
 800c78e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c792:	f7fe bd55 	b.w	800b240 <_port_irq_epilogue>
 800c796:	bf00      	nop
 800c798:	08015a14 	.word	0x08015a14
 800c79c:	40026400 	.word	0x40026400
 800c7a0:	20005f28 	.word	0x20005f28
	...

0800c7b0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 800c7b0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c7b2:	480c      	ldr	r0, [pc, #48]	; (800c7e4 <Vector120+0x34>)
 800c7b4:	f001 ffb4 	bl	800e720 <_trace_isr_enter>
 800c7b8:	f002 fa52 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800c7bc:	4b0a      	ldr	r3, [pc, #40]	; (800c7e8 <Vector120+0x38>)
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 800c7be:	480b      	ldr	r0, [pc, #44]	; (800c7ec <Vector120+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800c7c0:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 800c7c2:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800c7c4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 800c7c8:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 800c7ca:	b10a      	cbz	r2, 800c7d0 <Vector120+0x20>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 800c7cc:	6c40      	ldr	r0, [r0, #68]	; 0x44
 800c7ce:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c7d0:	f002 fa2e 	bl	800ec30 <_dbg_check_leave_isr>
 800c7d4:	4803      	ldr	r0, [pc, #12]	; (800c7e4 <Vector120+0x34>)
 800c7d6:	f001 ff83 	bl	800e6e0 <_trace_isr_leave>
}
 800c7da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c7de:	f7fe bd2f 	b.w	800b240 <_port_irq_epilogue>
 800c7e2:	bf00      	nop
 800c7e4:	08015a4c 	.word	0x08015a4c
 800c7e8:	40026400 	.word	0x40026400
 800c7ec:	20005f28 	.word	0x20005f28

0800c7f0 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 800c7f0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c7f2:	480d      	ldr	r0, [pc, #52]	; (800c828 <VectorFC+0x38>)
 800c7f4:	f001 ff94 	bl	800e720 <_trace_isr_enter>
 800c7f8:	f002 fa32 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800c7fc:	4b0b      	ldr	r3, [pc, #44]	; (800c82c <VectorFC+0x3c>)
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 800c7fe:	480c      	ldr	r0, [pc, #48]	; (800c830 <VectorFC+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800c800:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 800c802:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800c804:	0d89      	lsrs	r1, r1, #22
 800c806:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 800c80a:	058c      	lsls	r4, r1, #22
 800c80c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 800c80e:	b10a      	cbz	r2, 800c814 <VectorFC+0x24>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 800c810:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 800c812:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c814:	f002 fa0c 	bl	800ec30 <_dbg_check_leave_isr>
 800c818:	4803      	ldr	r0, [pc, #12]	; (800c828 <VectorFC+0x38>)
 800c81a:	f001 ff61 	bl	800e6e0 <_trace_isr_leave>
}
 800c81e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c822:	f7fe bd0d 	b.w	800b240 <_port_irq_epilogue>
 800c826:	bf00      	nop
 800c828:	080159e0 	.word	0x080159e0
 800c82c:	40026000 	.word	0x40026000
 800c830:	20005f28 	.word	0x20005f28
	...

0800c840 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 800c840:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c842:	480d      	ldr	r0, [pc, #52]	; (800c878 <Vector84+0x38>)
 800c844:	f001 ff6c 	bl	800e720 <_trace_isr_enter>
 800c848:	f002 fa0a 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800c84c:	4b0b      	ldr	r3, [pc, #44]	; (800c87c <Vector84+0x3c>)
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 800c84e:	480c      	ldr	r0, [pc, #48]	; (800c880 <Vector84+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800c850:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 800c852:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800c854:	0c09      	lsrs	r1, r1, #16
 800c856:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 800c85a:	040c      	lsls	r4, r1, #16
 800c85c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 800c85e:	b10a      	cbz	r2, 800c864 <Vector84+0x24>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 800c860:	6b40      	ldr	r0, [r0, #52]	; 0x34
 800c862:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c864:	f002 f9e4 	bl	800ec30 <_dbg_check_leave_isr>
 800c868:	4803      	ldr	r0, [pc, #12]	; (800c878 <Vector84+0x38>)
 800c86a:	f001 ff39 	bl	800e6e0 <_trace_isr_leave>
}
 800c86e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c872:	f7fe bce5 	b.w	800b240 <_port_irq_epilogue>
 800c876:	bf00      	nop
 800c878:	080159bc 	.word	0x080159bc
 800c87c:	40026000 	.word	0x40026000
 800c880:	20005f28 	.word	0x20005f28
	...

0800c890 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 800c890:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c892:	480d      	ldr	r0, [pc, #52]	; (800c8c8 <Vector80+0x38>)
 800c894:	f001 ff44 	bl	800e720 <_trace_isr_enter>
 800c898:	f002 f9e2 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800c89c:	4b0b      	ldr	r3, [pc, #44]	; (800c8cc <Vector80+0x3c>)
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 800c89e:	480c      	ldr	r0, [pc, #48]	; (800c8d0 <Vector80+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800c8a0:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 800c8a2:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800c8a4:	0989      	lsrs	r1, r1, #6
 800c8a6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 800c8aa:	018c      	lsls	r4, r1, #6
 800c8ac:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 800c8ae:	b10a      	cbz	r2, 800c8b4 <Vector80+0x24>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 800c8b0:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800c8b2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c8b4:	f002 f9bc 	bl	800ec30 <_dbg_check_leave_isr>
 800c8b8:	4803      	ldr	r0, [pc, #12]	; (800c8c8 <Vector80+0x38>)
 800c8ba:	f001 ff11 	bl	800e6e0 <_trace_isr_leave>
}
 800c8be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c8c2:	f7fe bcbd 	b.w	800b240 <_port_irq_epilogue>
 800c8c6:	bf00      	nop
 800c8c8:	080159b0 	.word	0x080159b0
 800c8cc:	40026000 	.word	0x40026000
 800c8d0:	20005f28 	.word	0x20005f28
	...

0800c8e0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 800c8e0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c8e2:	480c      	ldr	r0, [pc, #48]	; (800c914 <Vector7C+0x34>)
 800c8e4:	f001 ff1c 	bl	800e720 <_trace_isr_enter>
 800c8e8:	f002 f9ba 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800c8ec:	4b0a      	ldr	r3, [pc, #40]	; (800c918 <Vector7C+0x38>)
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 800c8ee:	480b      	ldr	r0, [pc, #44]	; (800c91c <Vector7C+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800c8f0:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 800c8f2:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800c8f4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 800c8f8:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 800c8fa:	b10a      	cbz	r2, 800c900 <Vector7C+0x20>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 800c8fc:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800c8fe:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c900:	f002 f996 	bl	800ec30 <_dbg_check_leave_isr>
 800c904:	4803      	ldr	r0, [pc, #12]	; (800c914 <Vector7C+0x34>)
 800c906:	f001 feeb 	bl	800e6e0 <_trace_isr_leave>
}
 800c90a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c90e:	f7fe bc97 	b.w	800b240 <_port_irq_epilogue>
 800c912:	bf00      	nop
 800c914:	08015998 	.word	0x08015998
 800c918:	40026000 	.word	0x40026000
 800c91c:	20005f28 	.word	0x20005f28

0800c920 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 800c920:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c922:	480d      	ldr	r0, [pc, #52]	; (800c958 <Vector78+0x38>)
 800c924:	f001 fefc 	bl	800e720 <_trace_isr_enter>
 800c928:	f002 f99a 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800c92c:	4b0b      	ldr	r3, [pc, #44]	; (800c95c <Vector78+0x3c>)
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 800c92e:	480c      	ldr	r0, [pc, #48]	; (800c960 <Vector78+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800c930:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 800c932:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800c934:	0d89      	lsrs	r1, r1, #22
 800c936:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 800c93a:	058c      	lsls	r4, r1, #22
 800c93c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 800c93e:	b10a      	cbz	r2, 800c944 <Vector78+0x24>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 800c940:	69c0      	ldr	r0, [r0, #28]
 800c942:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c944:	f002 f974 	bl	800ec30 <_dbg_check_leave_isr>
 800c948:	4803      	ldr	r0, [pc, #12]	; (800c958 <Vector78+0x38>)
 800c94a:	f001 fec9 	bl	800e6e0 <_trace_isr_leave>
}
 800c94e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c952:	f7fe bc75 	b.w	800b240 <_port_irq_epilogue>
 800c956:	bf00      	nop
 800c958:	08015a40 	.word	0x08015a40
 800c95c:	40026000 	.word	0x40026000
 800c960:	20005f28 	.word	0x20005f28
	...

0800c970 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 800c970:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c972:	480d      	ldr	r0, [pc, #52]	; (800c9a8 <Vector74+0x38>)
 800c974:	f001 fed4 	bl	800e720 <_trace_isr_enter>
 800c978:	f002 f972 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800c97c:	4b0b      	ldr	r3, [pc, #44]	; (800c9ac <Vector74+0x3c>)
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 800c97e:	480c      	ldr	r0, [pc, #48]	; (800c9b0 <Vector74+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800c980:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 800c982:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800c984:	0c09      	lsrs	r1, r1, #16
 800c986:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 800c98a:	040c      	lsls	r4, r1, #16
 800c98c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 800c98e:	b10a      	cbz	r2, 800c994 <Vector74+0x24>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 800c990:	6940      	ldr	r0, [r0, #20]
 800c992:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c994:	f002 f94c 	bl	800ec30 <_dbg_check_leave_isr>
 800c998:	4803      	ldr	r0, [pc, #12]	; (800c9a8 <Vector74+0x38>)
 800c99a:	f001 fea1 	bl	800e6e0 <_trace_isr_leave>
}
 800c99e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c9a2:	f7fe bc4d 	b.w	800b240 <_port_irq_epilogue>
 800c9a6:	bf00      	nop
 800c9a8:	080159c8 	.word	0x080159c8
 800c9ac:	40026000 	.word	0x40026000
 800c9b0:	20005f28 	.word	0x20005f28
	...

0800c9c0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 800c9c0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800c9c2:	480d      	ldr	r0, [pc, #52]	; (800c9f8 <Vector70+0x38>)
 800c9c4:	f001 feac 	bl	800e720 <_trace_isr_enter>
 800c9c8:	f002 f94a 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800c9cc:	4b0b      	ldr	r3, [pc, #44]	; (800c9fc <Vector70+0x3c>)
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 800c9ce:	480c      	ldr	r0, [pc, #48]	; (800ca00 <Vector70+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800c9d0:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 800c9d2:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800c9d4:	0989      	lsrs	r1, r1, #6
 800c9d6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 800c9da:	018c      	lsls	r4, r1, #6
 800c9dc:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 800c9de:	b10a      	cbz	r2, 800c9e4 <Vector70+0x24>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 800c9e0:	68c0      	ldr	r0, [r0, #12]
 800c9e2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 800c9e4:	f002 f924 	bl	800ec30 <_dbg_check_leave_isr>
 800c9e8:	4803      	ldr	r0, [pc, #12]	; (800c9f8 <Vector70+0x38>)
 800c9ea:	f001 fe79 	bl	800e6e0 <_trace_isr_leave>
}
 800c9ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800c9f2:	f7fe bc25 	b.w	800b240 <_port_irq_epilogue>
 800c9f6:	bf00      	nop
 800c9f8:	080159a4 	.word	0x080159a4
 800c9fc:	40026000 	.word	0x40026000
 800ca00:	20005f28 	.word	0x20005f28
	...

0800ca10 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 800ca10:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 800ca12:	480c      	ldr	r0, [pc, #48]	; (800ca44 <Vector6C+0x34>)
 800ca14:	f001 fe84 	bl	800e720 <_trace_isr_enter>
 800ca18:	f002 f922 	bl	800ec60 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800ca1c:	4b0a      	ldr	r3, [pc, #40]	; (800ca48 <Vector6C+0x38>)
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
 800ca1e:	4a0b      	ldr	r2, [pc, #44]	; (800ca4c <Vector6C+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800ca20:	6819      	ldr	r1, [r3, #0]
 800ca22:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 800ca26:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 800ca28:	6813      	ldr	r3, [r2, #0]
 800ca2a:	b10b      	cbz	r3, 800ca30 <Vector6C+0x20>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 800ca2c:	6850      	ldr	r0, [r2, #4]
 800ca2e:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800ca30:	f002 f8fe 	bl	800ec30 <_dbg_check_leave_isr>
 800ca34:	4803      	ldr	r0, [pc, #12]	; (800ca44 <Vector6C+0x34>)
 800ca36:	f001 fe53 	bl	800e6e0 <_trace_isr_leave>
}
 800ca3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800ca3e:	f7fe bbff 	b.w	800b240 <_port_irq_epilogue>
 800ca42:	bf00      	nop
 800ca44:	080159ec 	.word	0x080159ec
 800ca48:	40026000 	.word	0x40026000
 800ca4c:	20005f28 	.word	0x20005f28

0800ca50 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 800ca50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800ca54:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800ca58:	482f      	ldr	r0, [pc, #188]	; (800cb18 <VectorB0+0xc8>)
 800ca5a:	f001 fe61 	bl	800e720 <_trace_isr_enter>
 800ca5e:	f002 f8ff 	bl	800ec60 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800ca62:	693b      	ldr	r3, [r7, #16]
 800ca64:	079b      	lsls	r3, r3, #30
 800ca66:	d408      	bmi.n	800ca7a <VectorB0+0x2a>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 800ca68:	f002 f8e2 	bl	800ec30 <_dbg_check_leave_isr>
 800ca6c:	482a      	ldr	r0, [pc, #168]	; (800cb18 <VectorB0+0xc8>)
 800ca6e:	f001 fe37 	bl	800e6e0 <_trace_isr_leave>
}
 800ca72:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 800ca76:	f7fe bbe3 	b.w	800b240 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 800ca7a:	2600      	movs	r6, #0
 800ca7c:	613e      	str	r6, [r7, #16]
 800ca7e:	f04f 0820 	mov.w	r8, #32
 800ca82:	f388 8811 	msr	BASEPRI, r8
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 800ca86:	4d25      	ldr	r5, [pc, #148]	; (800cb1c <VectorB0+0xcc>)
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800ca88:	f002 f91a 	bl	800ecc0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 800ca8c:	f001 fee0 	bl	800e850 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 800ca90:	f001 fede 	bl	800e850 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 800ca94:	69ec      	ldr	r4, [r5, #28]
 800ca96:	6a78      	ldr	r0, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 800ca98:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800ca9a:	68a1      	ldr	r1, [r4, #8]
 800ca9c:	1ac2      	subs	r2, r0, r3
 800ca9e:	428a      	cmp	r2, r1
 800caa0:	f105 091c 	add.w	r9, r5, #28
 800caa4:	d31c      	bcc.n	800cae0 <VectorB0+0x90>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800caa6:	6822      	ldr	r2, [r4, #0]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 800caa8:	f8d4 a00c 	ldr.w	sl, [r4, #12]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 800caac:	440b      	add	r3, r1
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800caae:	454a      	cmp	r2, r9
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 800cab0:	62ab      	str	r3, [r5, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800cab2:	f8c2 9004 	str.w	r9, [r2, #4]
    ch.vtlist.next = vtp->next;
 800cab6:	61ea      	str	r2, [r5, #28]
    fn = vtp->func;
    vtp->func = NULL;
 800cab8:	60e6      	str	r6, [r4, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800caba:	bf08      	it	eq
 800cabc:	60fe      	streq	r6, [r7, #12]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800cabe:	f002 f8e7 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800cac2:	f386 8811 	msr	BASEPRI, r6
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 800cac6:	6920      	ldr	r0, [r4, #16]
 800cac8:	47d0      	blx	sl
 800caca:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800cace:	f002 f8f7 	bl	800ecc0 <_dbg_check_lock_from_isr>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 800cad2:	69ec      	ldr	r4, [r5, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800cad4:	6a78      	ldr	r0, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 800cad6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800cad8:	68a1      	ldr	r1, [r4, #8]
 800cada:	1ac2      	subs	r2, r0, r3
 800cadc:	4291      	cmp	r1, r2
 800cade:	d9e2      	bls.n	800caa6 <VectorB0+0x56>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800cae0:	454c      	cmp	r4, r9
 800cae2:	d010      	beq.n	800cb06 <VectorB0+0xb6>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 800cae4:	440b      	add	r3, r1
 800cae6:	1a1b      	subs	r3, r3, r0
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800cae8:	2b01      	cmp	r3, #1
 800caea:	bf98      	it	ls
 800caec:	2302      	movls	r3, #2
  }
  port_timer_set_alarm(now + delta);
 800caee:	181c      	adds	r4, r3, r0
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 800caf0:	4620      	mov	r0, r4
 800caf2:	f7fe fb95 	bl	800b220 <stSetAlarm>
 800caf6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 800cafa:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800cafc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800cafe:	1a63      	subs	r3, r4, r1
 800cb00:	1a52      	subs	r2, r2, r1
 800cb02:	429a      	cmp	r2, r3
 800cb04:	d805      	bhi.n	800cb12 <VectorB0+0xc2>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800cb06:	f002 f8c3 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800cb0a:	2300      	movs	r3, #0
 800cb0c:	f383 8811 	msr	BASEPRI, r3
 800cb10:	e7aa      	b.n	800ca68 <VectorB0+0x18>
 800cb12:	4803      	ldr	r0, [pc, #12]	; (800cb20 <VectorB0+0xd0>)
 800cb14:	f001 fe24 	bl	800e760 <chSysHalt>
 800cb18:	080159d4 	.word	0x080159d4
 800cb1c:	20027edc 	.word	0x20027edc
 800cb20:	08015914 	.word	0x08015914
	...

0800cb30 <readt.lto_priv.137>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800cb30:	300c      	adds	r0, #12
 800cb32:	f7fe bcdd 	b.w	800b4f0 <iqReadTimeout>
 800cb36:	bf00      	nop
	...

0800cb40 <read.lto_priv.131>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800cb40:	300c      	adds	r0, #12
 800cb42:	f04f 33ff 	mov.w	r3, #4294967295
 800cb46:	f7fe bcd3 	b.w	800b4f0 <iqReadTimeout>
 800cb4a:	bf00      	nop
 800cb4c:	0000      	movs	r0, r0
	...

0800cb50 <writet.lto_priv.136>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800cb50:	3030      	adds	r0, #48	; 0x30
 800cb52:	f7fe bbf5 	b.w	800b340 <oqWriteTimeout>
 800cb56:	bf00      	nop
	...

0800cb60 <write.lto_priv.130>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800cb60:	3030      	adds	r0, #48	; 0x30
 800cb62:	f04f 33ff 	mov.w	r3, #4294967295
 800cb66:	f7fe bbeb 	b.w	800b340 <oqWriteTimeout>
 800cb6a:	bf00      	nop
 800cb6c:	0000      	movs	r0, r0
	...

0800cb70 <gett.lto_priv.135>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 800cb70:	300c      	adds	r0, #12
 800cb72:	f7fe bd45 	b.w	800b600 <iqGetTimeout>
 800cb76:	bf00      	nop
	...

0800cb80 <get.lto_priv.133>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 800cb80:	300c      	adds	r0, #12
 800cb82:	f04f 31ff 	mov.w	r1, #4294967295
 800cb86:	f7fe bd3b 	b.w	800b600 <iqGetTimeout>
 800cb8a:	bf00      	nop
 800cb8c:	0000      	movs	r0, r0
	...

0800cb90 <putt.lto_priv.134>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 800cb90:	3030      	adds	r0, #48	; 0x30
 800cb92:	f7fe bc5d 	b.w	800b450 <oqPutTimeout>
 800cb96:	bf00      	nop
	...

0800cba0 <put.lto_priv.132>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800cba0:	3030      	adds	r0, #48	; 0x30
 800cba2:	f04f 32ff 	mov.w	r2, #4294967295
 800cba6:	f7fe bc53 	b.w	800b450 <oqPutTimeout>
 800cbaa:	bf00      	nop
 800cbac:	0000      	movs	r0, r0
	...

0800cbb0 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 800cbb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);
 800cbb2:	b378      	cbz	r0, 800cc14 <dmaStreamRelease+0x64>

  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1U << dmastp->selfindex)) != 0U,
 800cbb4:	4e19      	ldr	r6, [pc, #100]	; (800cc1c <dmaStreamRelease+0x6c>)
 800cbb6:	7a43      	ldrb	r3, [r0, #9]
 800cbb8:	6832      	ldr	r2, [r6, #0]
 800cbba:	2101      	movs	r1, #1
 800cbbc:	fa01 f303 	lsl.w	r3, r1, r3
 800cbc0:	4213      	tst	r3, r2
 800cbc2:	d027      	beq.n	800cc14 <dmaStreamRelease+0x64>
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);
 800cbc4:	7a83      	ldrb	r3, [r0, #10]
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800cbc6:	4f16      	ldr	r7, [pc, #88]	; (800cc20 <dmaStreamRelease+0x70>)
 800cbc8:	095c      	lsrs	r4, r3, #5
 800cbca:	3420      	adds	r4, #32
 800cbcc:	f003 051f 	and.w	r5, r3, #31
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800cbd0:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800cbd4:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800cbd8:	fa01 f505 	lsl.w	r5, r1, r5
 800cbdc:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800cbe0:	2400      	movs	r4, #0
 800cbe2:	f883 4300 	strb.w	r4, [r3, #768]	; 0x300

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 800cbe6:	7a43      	ldrb	r3, [r0, #9]
 800cbe8:	fa01 f303 	lsl.w	r3, r1, r3
 800cbec:	ea22 0303 	bic.w	r3, r2, r3

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 800cbf0:	f013 0fff 	tst.w	r3, #255	; 0xff

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 800cbf4:	6033      	str	r3, [r6, #0]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 800cbf6:	d104      	bne.n	800cc02 <dmaStreamRelease+0x52>
    rccDisableDMA1(false);
 800cbf8:	490a      	ldr	r1, [pc, #40]	; (800cc24 <dmaStreamRelease+0x74>)
 800cbfa:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 800cbfc:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800cc00:	630a      	str	r2, [r1, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 800cc02:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 800cc06:	d104      	bne.n	800cc12 <dmaStreamRelease+0x62>
    rccDisableDMA2(false);
 800cc08:	4a06      	ldr	r2, [pc, #24]	; (800cc24 <dmaStreamRelease+0x74>)
 800cc0a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800cc0c:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 800cc10:	6313      	str	r3, [r2, #48]	; 0x30
 800cc12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {

  osalDbgCheck(dmastp != NULL);
 800cc14:	4804      	ldr	r0, [pc, #16]	; (800cc28 <dmaStreamRelease+0x78>)
 800cc16:	f001 fda3 	bl	800e760 <chSysHalt>
 800cc1a:	bf00      	nop
 800cc1c:	20027728 	.word	0x20027728
 800cc20:	e000e100 	.word	0xe000e100
 800cc24:	40023800 	.word	0x40023800
 800cc28:	08015958 	.word	0x08015958
 800cc2c:	00000000 	.word	0x00000000

0800cc30 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 800cc30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);
 800cc32:	2800      	cmp	r0, #0
 800cc34:	d051      	beq.n	800ccda <dmaStreamAllocate+0xaa>

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 800cc36:	4f2a      	ldr	r7, [pc, #168]	; (800cce0 <dmaStreamAllocate+0xb0>)
 800cc38:	7a46      	ldrb	r6, [r0, #9]
 800cc3a:	683d      	ldr	r5, [r7, #0]
 800cc3c:	2401      	movs	r4, #1
 800cc3e:	fa04 fe06 	lsl.w	lr, r4, r6
 800cc42:	ea1e 0f05 	tst.w	lr, r5
 800cc46:	d144      	bne.n	800ccd2 <dmaStreamAllocate+0xa2>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800cc48:	4c26      	ldr	r4, [pc, #152]	; (800cce4 <dmaStreamAllocate+0xb4>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 800cc4a:	ea4e 0505 	orr.w	r5, lr, r5
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800cc4e:	eb04 0ec6 	add.w	lr, r4, r6, lsl #3
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 800cc52:	f015 0fff 	tst.w	r5, #255	; 0xff
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 800cc56:	603d      	str	r5, [r7, #0]
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800cc58:	f844 2036 	str.w	r2, [r4, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800cc5c:	f8ce 3004 	str.w	r3, [lr, #4]
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 800cc60:	d004      	beq.n	800cc6c <dmaStreamAllocate+0x3c>
    rccEnableDMA1(false);
 800cc62:	4c21      	ldr	r4, [pc, #132]	; (800cce8 <dmaStreamAllocate+0xb8>)
 800cc64:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800cc66:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800cc6a:	6323      	str	r3, [r4, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 800cc6c:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
 800cc70:	d129      	bne.n	800ccc6 <dmaStreamAllocate+0x96>
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800cc72:	6805      	ldr	r5, [r0, #0]
 800cc74:	682b      	ldr	r3, [r5, #0]
 800cc76:	f023 031f 	bic.w	r3, r3, #31
 800cc7a:	602b      	str	r3, [r5, #0]
 800cc7c:	682b      	ldr	r3, [r5, #0]
 800cc7e:	f013 0301 	ands.w	r3, r3, #1
 800cc82:	d1fb      	bne.n	800cc7c <dmaStreamAllocate+0x4c>
 800cc84:	7a07      	ldrb	r7, [r0, #8]
 800cc86:	6846      	ldr	r6, [r0, #4]
 800cc88:	243d      	movs	r4, #61	; 0x3d
 800cc8a:	40bc      	lsls	r4, r7
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800cc8c:	2721      	movs	r7, #33	; 0x21
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800cc8e:	6034      	str	r4, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 800cc90:	602b      	str	r3, [r5, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800cc92:	616f      	str	r7, [r5, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 800cc94:	b1fa      	cbz	r2, 800ccd6 <dmaStreamAllocate+0xa6>
    nvicEnableVector(dmastp->vector, priority);
 800cc96:	7a80      	ldrb	r0, [r0, #10]
 800cc98:	0942      	lsrs	r2, r0, #5
 800cc9a:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800cc9c:	f100 4560 	add.w	r5, r0, #3758096384	; 0xe0000000
 800cca0:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 800cca4:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 800cca8:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800ccac:	f000 001f 	and.w	r0, r0, #31

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800ccb0:	0109      	lsls	r1, r1, #4
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800ccb2:	2401      	movs	r4, #1
 800ccb4:	4084      	lsls	r4, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800ccb6:	b2c9      	uxtb	r1, r1
 800ccb8:	f885 1300 	strb.w	r1, [r5, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800ccbc:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800ccc0:	6014      	str	r4, [r2, #0]
 800ccc2:	4618      	mov	r0, r3
 800ccc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
    rccEnableDMA1(false);
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
 800ccc6:	4c08      	ldr	r4, [pc, #32]	; (800cce8 <dmaStreamAllocate+0xb8>)
 800ccc8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800ccca:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800ccce:	6323      	str	r3, [r4, #48]	; 0x30
 800ccd0:	e7cf      	b.n	800cc72 <dmaStreamAllocate+0x42>

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 800ccd2:	4620      	mov	r0, r4
 800ccd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  dmaStreamDisable(dmastp);
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 800ccd6:	4610      	mov	r0, r2
    nvicEnableVector(dmastp->vector, priority);
  }

  return false;
}
 800ccd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {

  osalDbgCheck(dmastp != NULL);
 800ccda:	4804      	ldr	r0, [pc, #16]	; (800ccec <dmaStreamAllocate+0xbc>)
 800ccdc:	f001 fd40 	bl	800e760 <chSysHalt>
 800cce0:	20027728 	.word	0x20027728
 800cce4:	20005f28 	.word	0x20005f28
 800cce8:	40023800 	.word	0x40023800
 800ccec:	08015944 	.word	0x08015944

0800ccf0 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 800ccf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));
 800ccf2:	b160      	cbz	r0, 800cd0e <spiReceive+0x1e>
 800ccf4:	460d      	mov	r5, r1
 800ccf6:	b151      	cbz	r1, 800cd0e <spiReceive+0x1e>
 800ccf8:	4616      	mov	r6, r2
 800ccfa:	b142      	cbz	r2, 800cd0e <spiReceive+0x1e>
 800ccfc:	4604      	mov	r4, r0
 800ccfe:	2320      	movs	r3, #32
 800cd00:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800cd04:	f002 f83c 	bl	800ed80 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800cd08:	7823      	ldrb	r3, [r4, #0]
 800cd0a:	2b02      	cmp	r3, #2
 800cd0c:	d002      	beq.n	800cd14 <spiReceive+0x24>
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));
 800cd0e:	481c      	ldr	r0, [pc, #112]	; (800cd80 <spiReceive+0x90>)
 800cd10:	f001 fd26 	bl	800e760 <chSysHalt>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 800cd14:	6863      	ldr	r3, [r4, #4]
 800cd16:	681b      	ldr	r3, [r3, #0]
 800cd18:	2b00      	cmp	r3, #0
 800cd1a:	d1f8      	bne.n	800cd0e <spiReceive+0x1e>
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800cd1c:	6a22      	ldr	r2, [r4, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800cd1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800cd20:	6aa1      	ldr	r1, [r4, #40]	; 0x28

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800cd22:	681b      	ldr	r3, [r3, #0]
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800cd24:	6812      	ldr	r2, [r2, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800cd26:	6ae0      	ldr	r0, [r4, #44]	; 0x2c

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800cd28:	4f16      	ldr	r7, [pc, #88]	; (800cd84 <spiReceive+0x94>)
  spiStartReceiveI(spip, n, rxbuf);
 800cd2a:	f04f 0e03 	mov.w	lr, #3
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800cd2e:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 800cd32:	f884 e000 	strb.w	lr, [r4]
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800cd36:	60d6      	str	r6, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800cd38:	6055      	str	r5, [r2, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800cd3a:	6011      	str	r1, [r2, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800cd3c:	60df      	str	r7, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800cd3e:	605d      	str	r5, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800cd40:	6018      	str	r0, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800cd42:	6811      	ldr	r1, [r2, #0]
 800cd44:	f041 0101 	orr.w	r1, r1, #1
 800cd48:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 800cd4a:	681a      	ldr	r2, [r3, #0]
 800cd4c:	f042 0201 	orr.w	r2, r2, #1
 800cd50:	601a      	str	r2, [r3, #0]
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 800cd52:	f104 0008 	add.w	r0, r4, #8
 800cd56:	f001 fd63 	bl	800e820 <chThdSuspendS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800cd5a:	f002 f801 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cd5e:	4b0a      	ldr	r3, [pc, #40]	; (800cd88 <spiReceive+0x98>)
 800cd60:	681a      	ldr	r2, [r3, #0]
 800cd62:	429a      	cmp	r2, r3
 800cd64:	d004      	beq.n	800cd70 <spiReceive+0x80>
 800cd66:	6999      	ldr	r1, [r3, #24]
 800cd68:	6893      	ldr	r3, [r2, #8]
 800cd6a:	688a      	ldr	r2, [r1, #8]
 800cd6c:	429a      	cmp	r2, r3
 800cd6e:	d303      	bcc.n	800cd78 <spiReceive+0x88>
 800cd70:	2300      	movs	r3, #0
 800cd72:	f383 8811 	msr	BASEPRI, r3
 800cd76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cd78:	4804      	ldr	r0, [pc, #16]	; (800cd8c <spiReceive+0x9c>)
 800cd7a:	f001 fcf1 	bl	800e760 <chSysHalt>
 800cd7e:	bf00      	nop
 800cd80:	0801592c 	.word	0x0801592c
 800cd84:	08015956 	.word	0x08015956
 800cd88:	20027edc 	.word	0x20027edc
 800cd8c:	0801751c 	.word	0x0801751c

0800cd90 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 800cd90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));
 800cd92:	b160      	cbz	r0, 800cdae <spiSend+0x1e>
 800cd94:	460d      	mov	r5, r1
 800cd96:	b151      	cbz	r1, 800cdae <spiSend+0x1e>
 800cd98:	4616      	mov	r6, r2
 800cd9a:	b142      	cbz	r2, 800cdae <spiSend+0x1e>
 800cd9c:	4604      	mov	r4, r0
 800cd9e:	2320      	movs	r3, #32
 800cda0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800cda4:	f001 ffec 	bl	800ed80 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800cda8:	7823      	ldrb	r3, [r4, #0]
 800cdaa:	2b02      	cmp	r3, #2
 800cdac:	d002      	beq.n	800cdb4 <spiSend+0x24>
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));
 800cdae:	481c      	ldr	r0, [pc, #112]	; (800ce20 <spiSend+0x90>)
 800cdb0:	f001 fcd6 	bl	800e760 <chSysHalt>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 800cdb4:	6863      	ldr	r3, [r4, #4]
 800cdb6:	681b      	ldr	r3, [r3, #0]
 800cdb8:	2b00      	cmp	r3, #0
 800cdba:	d1f8      	bne.n	800cdae <spiSend+0x1e>
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800cdbc:	6a22      	ldr	r2, [r4, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800cdbe:	6a63      	ldr	r3, [r4, #36]	; 0x24
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800cdc0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800cdc2:	681b      	ldr	r3, [r3, #0]
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800cdc4:	6812      	ldr	r2, [r2, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800cdc6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800cdc8:	4f16      	ldr	r7, [pc, #88]	; (800ce24 <spiSend+0x94>)
  spiStartSendI(spip, n, txbuf);
 800cdca:	f04f 0e03 	mov.w	lr, #3
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800cdce:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 800cdd2:	f884 e000 	strb.w	lr, [r4]
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800cdd6:	60d7      	str	r7, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800cdd8:	6055      	str	r5, [r2, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800cdda:	6010      	str	r0, [r2, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800cddc:	60de      	str	r6, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800cdde:	605d      	str	r5, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800cde0:	6019      	str	r1, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800cde2:	6811      	ldr	r1, [r2, #0]
 800cde4:	f041 0101 	orr.w	r1, r1, #1
 800cde8:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 800cdea:	681a      	ldr	r2, [r3, #0]
 800cdec:	f042 0201 	orr.w	r2, r2, #1
 800cdf0:	601a      	str	r2, [r3, #0]
 800cdf2:	f104 0008 	add.w	r0, r4, #8
 800cdf6:	f001 fd13 	bl	800e820 <chThdSuspendS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800cdfa:	f001 ffb1 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cdfe:	4b0a      	ldr	r3, [pc, #40]	; (800ce28 <spiSend+0x98>)
 800ce00:	681a      	ldr	r2, [r3, #0]
 800ce02:	429a      	cmp	r2, r3
 800ce04:	d004      	beq.n	800ce10 <spiSend+0x80>
 800ce06:	6999      	ldr	r1, [r3, #24]
 800ce08:	6893      	ldr	r3, [r2, #8]
 800ce0a:	688a      	ldr	r2, [r1, #8]
 800ce0c:	429a      	cmp	r2, r3
 800ce0e:	d303      	bcc.n	800ce18 <spiSend+0x88>
 800ce10:	2300      	movs	r3, #0
 800ce12:	f383 8811 	msr	BASEPRI, r3
 800ce16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ce18:	4804      	ldr	r0, [pc, #16]	; (800ce2c <spiSend+0x9c>)
 800ce1a:	f001 fca1 	bl	800e760 <chSysHalt>
 800ce1e:	bf00      	nop
 800ce20:	08015a38 	.word	0x08015a38
 800ce24:	20027894 	.word	0x20027894
 800ce28:	20027edc 	.word	0x20027edc
 800ce2c:	0801751c 	.word	0x0801751c

0800ce30 <spiIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {
 800ce30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck((spip != NULL) && (n > 0U));
 800ce32:	b168      	cbz	r0, 800ce50 <spiIgnore+0x20>
 800ce34:	460d      	mov	r5, r1
 800ce36:	b159      	cbz	r1, 800ce50 <spiIgnore+0x20>
 800ce38:	4604      	mov	r4, r0
 800ce3a:	2320      	movs	r3, #32
 800ce3c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ce40:	f001 ff9e 	bl	800ed80 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800ce44:	7823      	ldrb	r3, [r4, #0]
 800ce46:	2b02      	cmp	r3, #2
 800ce48:	d102      	bne.n	800ce50 <spiIgnore+0x20>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 800ce4a:	6863      	ldr	r3, [r4, #4]
 800ce4c:	681b      	ldr	r3, [r3, #0]
 800ce4e:	b113      	cbz	r3, 800ce56 <spiIgnore+0x26>
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {

  osalDbgCheck((spip != NULL) && (n > 0U));
 800ce50:	4819      	ldr	r0, [pc, #100]	; (800ceb8 <spiIgnore+0x88>)
 800ce52:	f001 fc85 	bl	800e760 <chSysHalt>
 *
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800ce56:	6a22      	ldr	r2, [r4, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800ce58:	6a63      	ldr	r3, [r4, #36]	; 0x24
 *
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800ce5a:	6812      	ldr	r2, [r2, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800ce5c:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800ce5e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 */
void spi_lld_ignore(SPIDriver *spip, size_t n) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800ce60:	6aa6      	ldr	r6, [r4, #40]	; 0x28

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800ce62:	4816      	ldr	r0, [pc, #88]	; (800cebc <spiIgnore+0x8c>)
 *
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800ce64:	4f16      	ldr	r7, [pc, #88]	; (800cec0 <spiIgnore+0x90>)

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartIgnoreI(spip, n);
 800ce66:	f04f 0e03 	mov.w	lr, #3
 800ce6a:	f884 e000 	strb.w	lr, [r4]
 800ce6e:	60d7      	str	r7, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800ce70:	6055      	str	r5, [r2, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800ce72:	6016      	str	r6, [r2, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800ce74:	60d8      	str	r0, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800ce76:	605d      	str	r5, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800ce78:	6019      	str	r1, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800ce7a:	6811      	ldr	r1, [r2, #0]
 800ce7c:	f041 0101 	orr.w	r1, r1, #1
 800ce80:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 800ce82:	681a      	ldr	r2, [r3, #0]
 800ce84:	f042 0201 	orr.w	r2, r2, #1
 800ce88:	601a      	str	r2, [r3, #0]
 800ce8a:	f104 0008 	add.w	r0, r4, #8
 800ce8e:	f001 fcc7 	bl	800e820 <chThdSuspendS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800ce92:	f001 ff65 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ce96:	4b0b      	ldr	r3, [pc, #44]	; (800cec4 <spiIgnore+0x94>)
 800ce98:	681a      	ldr	r2, [r3, #0]
 800ce9a:	429a      	cmp	r2, r3
 800ce9c:	d004      	beq.n	800cea8 <spiIgnore+0x78>
 800ce9e:	6999      	ldr	r1, [r3, #24]
 800cea0:	6893      	ldr	r3, [r2, #8]
 800cea2:	688a      	ldr	r2, [r1, #8]
 800cea4:	429a      	cmp	r2, r3
 800cea6:	d303      	bcc.n	800ceb0 <spiIgnore+0x80>
 800cea8:	2300      	movs	r3, #0
 800ceaa:	f383 8811 	msr	BASEPRI, r3
 800ceae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ceb0:	4805      	ldr	r0, [pc, #20]	; (800cec8 <spiIgnore+0x98>)
 800ceb2:	f001 fc55 	bl	800e760 <chSysHalt>
 800ceb6:	bf00      	nop
 800ceb8:	08015984 	.word	0x08015984
 800cebc:	08015956 	.word	0x08015956
 800cec0:	20027894 	.word	0x20027894
 800cec4:	20027edc 	.word	0x20027edc
 800cec8:	0801751c 	.word	0x0801751c
 800cecc:	00000000 	.word	0x00000000

0800ced0 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 800ced0:	b510      	push	{r4, lr}

  osalDbgCheck(spip != NULL);
 800ced2:	b140      	cbz	r0, 800cee6 <spiUnselect+0x16>
 800ced4:	4604      	mov	r4, r0
 800ced6:	2320      	movs	r3, #32
 800ced8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800cedc:	f001 ff50 	bl	800ed80 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800cee0:	7823      	ldrb	r3, [r4, #0]
 800cee2:	2b02      	cmp	r3, #2
 800cee4:	d002      	beq.n	800ceec <spiUnselect+0x1c>
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
 800cee6:	480e      	ldr	r0, [pc, #56]	; (800cf20 <spiUnselect+0x50>)
 800cee8:	f001 fc3a 	bl	800e760 <chSysHalt>
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {

  palSetPad(spip->config->ssport, spip->config->sspad);
 800ceec:	6862      	ldr	r2, [r4, #4]
 800ceee:	8911      	ldrh	r1, [r2, #8]
 800cef0:	6852      	ldr	r2, [r2, #4]
 800cef2:	2301      	movs	r3, #1
 800cef4:	408b      	lsls	r3, r1
 800cef6:	b29b      	uxth	r3, r3
 800cef8:	8313      	strh	r3, [r2, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800cefa:	f001 ff31 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cefe:	4b09      	ldr	r3, [pc, #36]	; (800cf24 <spiUnselect+0x54>)
 800cf00:	681a      	ldr	r2, [r3, #0]
 800cf02:	429a      	cmp	r2, r3
 800cf04:	d004      	beq.n	800cf10 <spiUnselect+0x40>
 800cf06:	6999      	ldr	r1, [r3, #24]
 800cf08:	6893      	ldr	r3, [r2, #8]
 800cf0a:	688a      	ldr	r2, [r1, #8]
 800cf0c:	429a      	cmp	r2, r3
 800cf0e:	d303      	bcc.n	800cf18 <spiUnselect+0x48>
 800cf10:	2300      	movs	r3, #0
 800cf12:	f383 8811 	msr	BASEPRI, r3
 800cf16:	bd10      	pop	{r4, pc}
 800cf18:	4803      	ldr	r0, [pc, #12]	; (800cf28 <spiUnselect+0x58>)
 800cf1a:	f001 fc21 	bl	800e760 <chSysHalt>
 800cf1e:	bf00      	nop
 800cf20:	08015a2c 	.word	0x08015a2c
 800cf24:	20027edc 	.word	0x20027edc
 800cf28:	0801751c 	.word	0x0801751c
 800cf2c:	00000000 	.word	0x00000000

0800cf30 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 800cf30:	b510      	push	{r4, lr}

  osalDbgCheck(spip != NULL);
 800cf32:	b140      	cbz	r0, 800cf46 <spiSelect+0x16>
 800cf34:	4604      	mov	r4, r0
 800cf36:	2320      	movs	r3, #32
 800cf38:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800cf3c:	f001 ff20 	bl	800ed80 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800cf40:	7823      	ldrb	r3, [r4, #0]
 800cf42:	2b02      	cmp	r3, #2
 800cf44:	d002      	beq.n	800cf4c <spiSelect+0x1c>
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
 800cf46:	480e      	ldr	r0, [pc, #56]	; (800cf80 <spiSelect+0x50>)
 800cf48:	f001 fc0a 	bl	800e760 <chSysHalt>
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {

  palClearPad(spip->config->ssport, spip->config->sspad);
 800cf4c:	6862      	ldr	r2, [r4, #4]
 800cf4e:	8911      	ldrh	r1, [r2, #8]
 800cf50:	6852      	ldr	r2, [r2, #4]
 800cf52:	2301      	movs	r3, #1
 800cf54:	408b      	lsls	r3, r1
 800cf56:	b29b      	uxth	r3, r3
 800cf58:	8353      	strh	r3, [r2, #26]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800cf5a:	f001 ff01 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cf5e:	4b09      	ldr	r3, [pc, #36]	; (800cf84 <spiSelect+0x54>)
 800cf60:	681a      	ldr	r2, [r3, #0]
 800cf62:	429a      	cmp	r2, r3
 800cf64:	d004      	beq.n	800cf70 <spiSelect+0x40>
 800cf66:	6999      	ldr	r1, [r3, #24]
 800cf68:	6893      	ldr	r3, [r2, #8]
 800cf6a:	688a      	ldr	r2, [r1, #8]
 800cf6c:	429a      	cmp	r2, r3
 800cf6e:	d303      	bcc.n	800cf78 <spiSelect+0x48>
 800cf70:	2300      	movs	r3, #0
 800cf72:	f383 8811 	msr	BASEPRI, r3
 800cf76:	bd10      	pop	{r4, pc}
 800cf78:	4803      	ldr	r0, [pc, #12]	; (800cf88 <spiSelect+0x58>)
 800cf7a:	f001 fbf1 	bl	800e760 <chSysHalt>
 800cf7e:	bf00      	nop
 800cf80:	08015a08 	.word	0x08015a08
 800cf84:	20027edc 	.word	0x20027edc
 800cf88:	0801751c 	.word	0x0801751c
 800cf8c:	00000000 	.word	0x00000000

0800cf90 <spiStop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiStop(SPIDriver *spip) {
 800cf90:	b510      	push	{r4, lr}

  osalDbgCheck(spip != NULL);
 800cf92:	b148      	cbz	r0, 800cfa8 <spiStop+0x18>
 800cf94:	4604      	mov	r4, r0
 800cf96:	2320      	movs	r3, #32
 800cf98:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800cf9c:	f001 fef0 	bl	800ed80 <_dbg_check_lock>

  osalSysLock();

  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 800cfa0:	7823      	ldrb	r3, [r4, #0]
 800cfa2:	1e5a      	subs	r2, r3, #1
 800cfa4:	2a01      	cmp	r2, #1
 800cfa6:	d902      	bls.n	800cfae <spiStop+0x1e>
 *
 * @api
 */
void spiStop(SPIDriver *spip) {

  osalDbgCheck(spip != NULL);
 800cfa8:	4816      	ldr	r0, [pc, #88]	; (800d004 <spiStop+0x74>)
 800cfaa:	f001 fbd9 	bl	800e760 <chSysHalt>
 * @notapi
 */
void spi_lld_stop(SPIDriver *spip) {

  /* If in ready state then disables the SPI clock.*/
  if (spip->state == SPI_READY) {
 800cfae:	2b02      	cmp	r3, #2
 800cfb0:	d015      	beq.n	800cfde <spiStop+0x4e>

  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");

  spi_lld_stop(spip);
  spip->config = NULL;
 800cfb2:	2200      	movs	r2, #0
  spip->state  = SPI_STOP;
 800cfb4:	2301      	movs	r3, #1

  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");

  spi_lld_stop(spip);
  spip->config = NULL;
 800cfb6:	6062      	str	r2, [r4, #4]
  spip->state  = SPI_STOP;
 800cfb8:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800cfba:	f001 fed1 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cfbe:	4b12      	ldr	r3, [pc, #72]	; (800d008 <spiStop+0x78>)
 800cfc0:	681a      	ldr	r2, [r3, #0]
 800cfc2:	429a      	cmp	r2, r3
 800cfc4:	d004      	beq.n	800cfd0 <spiStop+0x40>
 800cfc6:	6999      	ldr	r1, [r3, #24]
 800cfc8:	6893      	ldr	r3, [r2, #8]
 800cfca:	688a      	ldr	r2, [r1, #8]
 800cfcc:	429a      	cmp	r2, r3
 800cfce:	d303      	bcc.n	800cfd8 <spiStop+0x48>
 800cfd0:	2300      	movs	r3, #0
 800cfd2:	f383 8811 	msr	BASEPRI, r3
 800cfd6:	bd10      	pop	{r4, pc}
 800cfd8:	480c      	ldr	r0, [pc, #48]	; (800d00c <spiStop+0x7c>)
 800cfda:	f001 fbc1 	bl	800e760 <chSysHalt>

    /* SPI disable.*/
    spip->spi->CR1 = 0;
 800cfde:	69e3      	ldr	r3, [r4, #28]
    spip->spi->CR2 = 0;
    dmaStreamRelease(spip->dmarx);
 800cfe0:	6a20      	ldr	r0, [r4, #32]

  /* If in ready state then disables the SPI clock.*/
  if (spip->state == SPI_READY) {

    /* SPI disable.*/
    spip->spi->CR1 = 0;
 800cfe2:	2200      	movs	r2, #0
 800cfe4:	601a      	str	r2, [r3, #0]
    spip->spi->CR2 = 0;
 800cfe6:	605a      	str	r2, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 800cfe8:	f7ff fde2 	bl	800cbb0 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 800cfec:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800cfee:	f7ff fddf 	bl	800cbb0 <dmaStreamRelease>
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip)
      rccDisableSPI1(FALSE);
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip)
 800cff2:	4b07      	ldr	r3, [pc, #28]	; (800d010 <spiStop+0x80>)
 800cff4:	429c      	cmp	r4, r3
 800cff6:	d1dc      	bne.n	800cfb2 <spiStop+0x22>
      rccDisableSPI2(FALSE);
 800cff8:	4a06      	ldr	r2, [pc, #24]	; (800d014 <spiStop+0x84>)
 800cffa:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800cffc:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800d000:	6413      	str	r3, [r2, #64]	; 0x40
 800d002:	e7d6      	b.n	800cfb2 <spiStop+0x22>
 800d004:	08015990 	.word	0x08015990
 800d008:	20027edc 	.word	0x20027edc
 800d00c:	0801751c 	.word	0x0801751c
 800d010:	2002879c 	.word	0x2002879c
 800d014:	40023800 	.word	0x40023800
	...

0800d020 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 800d020:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheck((spip != NULL) && (config != NULL));
 800d022:	b158      	cbz	r0, 800d03c <spiStart+0x1c>
 800d024:	460d      	mov	r5, r1
 800d026:	b149      	cbz	r1, 800d03c <spiStart+0x1c>
 800d028:	4604      	mov	r4, r0
 800d02a:	2320      	movs	r3, #32
 800d02c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800d030:	f001 fea6 	bl	800ed80 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 800d034:	7823      	ldrb	r3, [r4, #0]
 800d036:	1e5a      	subs	r2, r3, #1
 800d038:	2a01      	cmp	r2, #1
 800d03a:	d902      	bls.n	800d042 <spiStart+0x22>
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {

  osalDbgCheck((spip != NULL) && (config != NULL));
 800d03c:	482f      	ldr	r0, [pc, #188]	; (800d0fc <spiStart+0xdc>)
 800d03e:	f001 fb8f 	bl	800e760 <chSysHalt>
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800d042:	2b01      	cmp	r3, #1

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 800d044:	6065      	str	r5, [r4, #4]
 800d046:	d033      	beq.n	800d0b0 <spiStart+0x90>
 800d048:	69e3      	ldr	r3, [r4, #28]
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800d04a:	8969      	ldrh	r1, [r5, #10]
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800d04c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800d04e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800d050:	f411 6f00 	tst.w	r1, #2048	; 0x800
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800d054:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800d058:	bf18      	it	ne
 800d05a:	f442 5220 	orrne.w	r2, r2, #10240	; 0x2800
 800d05e:	62e2      	str	r2, [r4, #44]	; 0x2c
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800d060:	89aa      	ldrh	r2, [r5, #12]
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800d062:	f420 40f0 	bic.w	r0, r0, #30720	; 0x7800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800d066:	bf18      	it	ne
 800d068:	f440 5020 	orrne.w	r0, r0, #10240	; 0x2800
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800d06c:	f042 0207 	orr.w	r2, r2, #7
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800d070:	62a0      	str	r0, [r4, #40]	; 0x28
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800d072:	b292      	uxth	r2, r2
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800d074:	f441 7141 	orr.w	r1, r1, #772	; 0x304
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 800d078:	2000      	movs	r0, #0
 800d07a:	6018      	str	r0, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800d07c:	6019      	str	r1, [r3, #0]
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800d07e:	605a      	str	r2, [r3, #4]
                    SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 800d080:	681a      	ldr	r2, [r3, #0]
  spi_lld_start(spip);
  spip->state = SPI_READY;
 800d082:	2102      	movs	r1, #2
 800d084:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800d088:	601a      	str	r2, [r3, #0]
 800d08a:	7021      	strb	r1, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800d08c:	f001 fe68 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800d090:	4b1b      	ldr	r3, [pc, #108]	; (800d100 <spiStart+0xe0>)
 800d092:	681a      	ldr	r2, [r3, #0]
 800d094:	429a      	cmp	r2, r3
 800d096:	d004      	beq.n	800d0a2 <spiStart+0x82>
 800d098:	6999      	ldr	r1, [r3, #24]
 800d09a:	6893      	ldr	r3, [r2, #8]
 800d09c:	688a      	ldr	r2, [r1, #8]
 800d09e:	429a      	cmp	r2, r3
 800d0a0:	d303      	bcc.n	800d0aa <spiStart+0x8a>
 800d0a2:	2300      	movs	r3, #0
 800d0a4:	f383 8811 	msr	BASEPRI, r3
 800d0a8:	bd38      	pop	{r3, r4, r5, pc}
 800d0aa:	4816      	ldr	r0, [pc, #88]	; (800d104 <spiStart+0xe4>)
 800d0ac:	f001 fb58 	bl	800e760 <chSysHalt>
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
 800d0b0:	4b15      	ldr	r3, [pc, #84]	; (800d108 <spiStart+0xe8>)
 800d0b2:	429c      	cmp	r4, r3
 800d0b4:	d009      	beq.n	800d0ca <spiStart+0xaa>
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800d0b6:	6a21      	ldr	r1, [r4, #32]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800d0b8:	6a62      	ldr	r2, [r4, #36]	; 0x24
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800d0ba:	69e3      	ldr	r3, [r4, #28]
 800d0bc:	6808      	ldr	r0, [r1, #0]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800d0be:	6811      	ldr	r1, [r2, #0]
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800d0c0:	f103 020c 	add.w	r2, r3, #12
 800d0c4:	6082      	str	r2, [r0, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800d0c6:	608a      	str	r2, [r1, #8]
 800d0c8:	e7bf      	b.n	800d04a <spiStart+0x2a>
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 800d0ca:	4623      	mov	r3, r4
 800d0cc:	4a0f      	ldr	r2, [pc, #60]	; (800d10c <spiStart+0xec>)
 800d0ce:	6a20      	ldr	r0, [r4, #32]
 800d0d0:	210a      	movs	r1, #10
 800d0d2:	f7ff fdad 	bl	800cc30 <dmaStreamAllocate>
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 800d0d6:	b968      	cbnz	r0, 800d0f4 <spiStart+0xd4>
      b = dmaStreamAllocate(spip->dmatx,
 800d0d8:	4623      	mov	r3, r4
 800d0da:	4a0d      	ldr	r2, [pc, #52]	; (800d110 <spiStart+0xf0>)
 800d0dc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800d0de:	210a      	movs	r1, #10
 800d0e0:	f7ff fda6 	bl	800cc30 <dmaStreamAllocate>
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 800d0e4:	b930      	cbnz	r0, 800d0f4 <spiStart+0xd4>
      rccEnableSPI2(FALSE);
 800d0e6:	4a0b      	ldr	r2, [pc, #44]	; (800d114 <spiStart+0xf4>)
 800d0e8:	6865      	ldr	r5, [r4, #4]
 800d0ea:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800d0ec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800d0f0:	6413      	str	r3, [r2, #64]	; 0x40
 800d0f2:	e7e0      	b.n	800d0b6 <spiStart+0x96>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 800d0f4:	4808      	ldr	r0, [pc, #32]	; (800d118 <spiStart+0xf8>)
 800d0f6:	f001 fb33 	bl	800e760 <chSysHalt>
 800d0fa:	bf00      	nop
 800d0fc:	08015978 	.word	0x08015978
 800d100:	20027edc 	.word	0x20027edc
 800d104:	0801751c 	.word	0x0801751c
 800d108:	2002879c 	.word	0x2002879c
 800d10c:	0800b9e1 	.word	0x0800b9e1
 800d110:	0800b741 	.word	0x0800b741
 800d114:	40023800 	.word	0x40023800
 800d118:	080159f8 	.word	0x080159f8
 800d11c:	00000000 	.word	0x00000000

0800d120 <BME280_getPressure.constprop.24>:
/**
  * Reads the barometric pressure
  * @param Values to be sampled
  * @return Pressure in Pa * 10
  */
uint32_t BME280_getPressure(bme280_t *handle, uint16_t means) {
 800d120:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int64_t var1, var2, p;
	uint16_t tmp;

	uint64_t sum = 0;
 800d124:	2100      	movs	r1, #0
/**
  * Reads the barometric pressure
  * @param Values to be sampled
  * @return Pressure in Pa * 10
  */
uint32_t BME280_getPressure(bme280_t *handle, uint16_t means) {
 800d126:	b09f      	sub	sp, #124	; 0x7c
	int64_t var1, var2, p;
	uint16_t tmp;

	uint64_t sum = 0;
 800d128:	2200      	movs	r2, #0
 800d12a:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
/**
  * Reads the barometric pressure
  * @param Values to be sampled
  * @return Pressure in Pa * 10
  */
uint32_t BME280_getPressure(bme280_t *handle, uint16_t means) {
 800d12e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d132:	4682      	mov	sl, r0
 800d134:	469b      	mov	fp, r3
	uint16_t tmp;

	uint64_t sum = 0;
	for(uint16_t i=0; i<means; i++) {
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
 800d136:	f10d 0276 	add.w	r2, sp, #118	; 0x76
 800d13a:	21f7      	movs	r1, #247	; 0xf7
 800d13c:	f89a 0000 	ldrb.w	r0, [sl]
 800d140:	f7fd f926 	bl	800a390 <I2C_read16>
		adc_P = tmp;
 800d144:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
 800d148:	f89a 0000 	ldrb.w	r0, [sl]

	uint64_t sum = 0;
	for(uint16_t i=0; i<means; i++) {
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
 800d14c:	931b      	str	r3, [sp, #108]	; 0x6c
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
 800d14e:	f10d 0276 	add.w	r2, sp, #118	; 0x76
 800d152:	21f9      	movs	r1, #249	; 0xf9
 800d154:	f7fd f8b4 	bl	800a2c0 <I2C_read8>
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
 800d158:	f8da 2004 	ldr.w	r2, [sl, #4]
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d15c:	f9ba 4012 	ldrsh.w	r4, [sl, #18]

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d160:	f9ba 0010 	ldrsh.w	r0, [sl, #16]
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
 800d164:	f89d e076 	ldrb.w	lr, [sp, #118]	; 0x76
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
 800d168:	17d3      	asrs	r3, r2, #31
 800d16a:	f5b2 32fa 	subs.w	r2, r2, #128000	; 0x1f400
 800d16e:	f143 33ff 	adc.w	r3, r3, #4294967295
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
 800d172:	fba2 8902 	umull	r8, r9, r2, r2
 800d176:	fb02 f103 	mul.w	r1, r2, r3
 800d17a:	eb09 0941 	add.w	r9, r9, r1, lsl #1
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d17e:	fb00 f703 	mul.w	r7, r0, r3
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d182:	17e5      	asrs	r5, r4, #31

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d184:	17c1      	asrs	r1, r0, #31
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d186:	fb04 f609 	mul.w	r6, r4, r9

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d18a:	fb02 7701 	mla	r7, r2, r1, r7
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d18e:	fb08 6605 	mla	r6, r8, r5, r6

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d192:	fba0 0102 	umull	r0, r1, r0, r2
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d196:	fba4 4508 	umull	r4, r5, r4, r8
 800d19a:	4435      	add	r5, r6

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d19c:	4439      	add	r1, r7
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d19e:	0a26      	lsrs	r6, r4, #8
 800d1a0:	9604      	str	r6, [sp, #16]

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d1a2:	030e      	lsls	r6, r1, #12
 800d1a4:	9601      	str	r6, [sp, #4]
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1a6:	9e04      	ldr	r6, [sp, #16]
 800d1a8:	ea46 6605 	orr.w	r6, r6, r5, lsl #24
 800d1ac:	9604      	str	r6, [sp, #16]

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d1ae:	9e01      	ldr	r6, [sp, #4]
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1b0:	122c      	asrs	r4, r5, #8

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d1b2:	ea46 5610 	orr.w	r6, r6, r0, lsr #20
 800d1b6:	0300      	lsls	r0, r0, #12
 800d1b8:	9601      	str	r6, [sp, #4]
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1ba:	9405      	str	r4, [sp, #20]
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d1bc:	f9ba 6016 	ldrsh.w	r6, [sl, #22]
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d1c0:	9000      	str	r0, [sp, #0]
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1c2:	e9dd 4500 	ldrd	r4, r5, [sp]
 800d1c6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d1ca:	17f7      	asrs	r7, r6, #31
 800d1cc:	fb06 f303 	mul.w	r3, r6, r3
 800d1d0:	fb02 3307 	mla	r3, r2, r7, r3
 800d1d4:	fba6 6702 	umull	r6, r7, r6, r2
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1d8:	1900      	adds	r0, r0, r4
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d1da:	441f      	add	r7, r3
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1dc:	4169      	adcs	r1, r5
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d1de:	047a      	lsls	r2, r7, #17
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1e0:	1c04      	adds	r4, r0, #0
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d1e2:	9203      	str	r2, [sp, #12]
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1e4:	f541 4500 	adc.w	r5, r1, #32768	; 0x8000
 800d1e8:	e9cd 4516 	strd	r4, r5, [sp, #88]	; 0x58
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d1ec:	9803      	ldr	r0, [sp, #12]
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d1ee:	f8ba 400e 	ldrh.w	r4, [sl, #14]
 800d1f2:	9916      	ldr	r1, [sp, #88]	; 0x58
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
 800d1f4:	f9ba 2018 	ldrsh.w	r2, [sl, #24]
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d1f8:	ea40 30d6 	orr.w	r0, r0, r6, lsr #15
 800d1fc:	9003      	str	r0, [sp, #12]
 800d1fe:	0470      	lsls	r0, r6, #17
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d200:	fba1 6704 	umull	r6, r7, r1, r4
 800d204:	9917      	ldr	r1, [sp, #92]	; 0x5c
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d206:	9002      	str	r0, [sp, #8]
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d208:	fb04 7701 	mla	r7, r4, r1, r7
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d20c:	f9ba 0014 	ldrsh.w	r0, [sl, #20]
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
 800d210:	991b      	ldr	r1, [sp, #108]	; 0x6c
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d212:	00c0      	lsls	r0, r0, #3
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
 800d214:	ea4e 2e01 	orr.w	lr, lr, r1, lsl #8
		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d218:	17f9      	asrs	r1, r7, #31
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d21a:	9013      	str	r0, [sp, #76]	; 0x4c
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d21c:	9115      	str	r1, [sp, #84]	; 0x54
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d21e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
 800d222:	17d3      	asrs	r3, r2, #31
 800d224:	fb02 f409 	mul.w	r4, r2, r9
 800d228:	fb08 4403 	mla	r4, r8, r3, r4
 800d22c:	fba2 2308 	umull	r2, r3, r2, r8
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d230:	1880      	adds	r0, r0, r2
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
 800d232:	4423      	add	r3, r4
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d234:	4159      	adcs	r1, r3
 800d236:	460b      	mov	r3, r1
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d238:	2100      	movs	r1, #0
 800d23a:	9112      	str	r1, [sp, #72]	; 0x48
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d23c:	4602      	mov	r2, r0
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d23e:	107d      	asrs	r5, r7, #1
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d240:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d244:	9514      	str	r5, [sp, #80]	; 0x50

		if (var1 == 0)
 800d246:	e9dd 6714 	ldrd	r6, r7, [sp, #80]	; 0x50
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d24a:	1880      	adds	r0, r0, r2
 800d24c:	4159      	adcs	r1, r3
 800d24e:	4602      	mov	r2, r0
 800d250:	460b      	mov	r3, r1
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;

		if (var1 == 0)
 800d252:	4630      	mov	r0, r6
 800d254:	4639      	mov	r1, r7
 800d256:	4301      	orrs	r1, r0
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;
 800d258:	ea4f 1e2e 	mov.w	lr, lr, asr #4
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;

		if (var1 == 0)
 800d25c:	f000 8098 	beq.w	800d390 <BME280_getPressure.constprop.24+0x270>
			return 0;  // avoid exception caused by division by zero

		p = 1048576 - adc_P;
		p = (((p<<31) - var2)*3125) / var1;
 800d260:	f5ce 1e80 	rsb	lr, lr, #1048576	; 0x100000
 800d264:	4670      	mov	r0, lr
 800d266:	17c1      	asrs	r1, r0, #31
 800d268:	07c9      	lsls	r1, r1, #31
 800d26a:	ea41 015e 	orr.w	r1, r1, lr, lsr #1
 800d26e:	9107      	str	r1, [sp, #28]
 800d270:	ea4f 71ce 	mov.w	r1, lr, lsl #31
 800d274:	9106      	str	r1, [sp, #24]
 800d276:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800d27a:	1a80      	subs	r0, r0, r2
 800d27c:	4602      	mov	r2, r0
 800d27e:	eb61 0103 	sbc.w	r1, r1, r3
 800d282:	1800      	adds	r0, r0, r0
 800d284:	460b      	mov	r3, r1
 800d286:	4149      	adcs	r1, r1
 800d288:	1880      	adds	r0, r0, r2
 800d28a:	4159      	adcs	r1, r3
 800d28c:	018c      	lsls	r4, r1, #6
 800d28e:	ea44 6490 	orr.w	r4, r4, r0, lsr #26
 800d292:	9409      	str	r4, [sp, #36]	; 0x24
 800d294:	0184      	lsls	r4, r0, #6
 800d296:	9408      	str	r4, [sp, #32]
 800d298:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
 800d29c:	1824      	adds	r4, r4, r0
 800d29e:	414d      	adcs	r5, r1
 800d2a0:	4620      	mov	r0, r4
 800d2a2:	00ac      	lsls	r4, r5, #2
 800d2a4:	0085      	lsls	r5, r0, #2
 800d2a6:	ea44 7490 	orr.w	r4, r4, r0, lsr #30
 800d2aa:	18a8      	adds	r0, r5, r2
 800d2ac:	eb44 0103 	adc.w	r1, r4, r3
 800d2b0:	008c      	lsls	r4, r1, #2
 800d2b2:	0085      	lsls	r5, r0, #2
 800d2b4:	ea44 7490 	orr.w	r4, r4, r0, lsr #30
 800d2b8:	18a8      	adds	r0, r5, r2
 800d2ba:	eb44 0103 	adc.w	r1, r4, r3
 800d2be:	4632      	mov	r2, r6
 800d2c0:	463b      	mov	r3, r7
 800d2c2:	f7f3 fffd 	bl	80012c0 <__aeabi_ldivmod>
		var1 = (((int64_t)handle->calib.dig_P9) * (p>>13) * (p>>13)) >> 25;
		var2 = (((int64_t)handle->calib.dig_P8) * p) >> 19;

		sum += ((p + var1 + var2) >> 8) + (((int64_t)handle->calib.dig_P7)<<4);
 800d2c6:	f9ba 201e 	ldrsh.w	r2, [sl, #30]
		if (var1 == 0)
			return 0;  // avoid exception caused by division by zero

		p = 1048576 - adc_P;
		p = (((p<<31) - var2)*3125) / var1;
		var1 = (((int64_t)handle->calib.dig_P9) * (p>>13) * (p>>13)) >> 25;
 800d2ca:	134e      	asrs	r6, r1, #13
 800d2cc:	0b47      	lsrs	r7, r0, #13
 800d2ce:	ea47 47c1 	orr.w	r7, r7, r1, lsl #19
		var2 = (((int64_t)handle->calib.dig_P8) * p) >> 19;

		sum += ((p + var1 + var2) >> 8) + (((int64_t)handle->calib.dig_P7)<<4);
 800d2d2:	fb02 f406 	mul.w	r4, r2, r6
 800d2d6:	17d3      	asrs	r3, r2, #31
 800d2d8:	fb07 4403 	mla	r4, r7, r3, r4
 800d2dc:	fba2 2307 	umull	r2, r3, r2, r7
 800d2e0:	4423      	add	r3, r4
 800d2e2:	fb02 f606 	mul.w	r6, r2, r6
 800d2e6:	f9ba 401c 	ldrsh.w	r4, [sl, #28]
 800d2ea:	fb07 6603 	mla	r6, r7, r3, r6
 800d2ee:	fba2 2307 	umull	r2, r3, r2, r7
 800d2f2:	4433      	add	r3, r6
 800d2f4:	fb04 f701 	mul.w	r7, r4, r1
 800d2f8:	17e5      	asrs	r5, r4, #31
 800d2fa:	0e56      	lsrs	r6, r2, #25
 800d2fc:	fb00 7705 	mla	r7, r0, r5, r7
 800d300:	ea46 16c3 	orr.w	r6, r6, r3, lsl #7
 800d304:	fba4 4500 	umull	r4, r5, r4, r0
 800d308:	443d      	add	r5, r7
 800d30a:	960a      	str	r6, [sp, #40]	; 0x28
 800d30c:	165b      	asrs	r3, r3, #25
 800d30e:	0ce6      	lsrs	r6, r4, #19
 800d310:	930b      	str	r3, [sp, #44]	; 0x2c
 800d312:	ea46 3345 	orr.w	r3, r6, r5, lsl #13
 800d316:	930c      	str	r3, [sp, #48]	; 0x30
 800d318:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 800d31c:	1812      	adds	r2, r2, r0
 800d31e:	414b      	adcs	r3, r1
 800d320:	4619      	mov	r1, r3
 800d322:	14eb      	asrs	r3, r5, #19
 800d324:	930d      	str	r3, [sp, #52]	; 0x34
 800d326:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	; 0x30
 800d32a:	189b      	adds	r3, r3, r2
 800d32c:	f9ba 201a 	ldrsh.w	r2, [sl, #26]
 800d330:	414c      	adcs	r4, r1
 800d332:	4618      	mov	r0, r3
 800d334:	4621      	mov	r1, r4
 800d336:	17d3      	asrs	r3, r2, #31
 800d338:	0a04      	lsrs	r4, r0, #8
 800d33a:	940e      	str	r4, [sp, #56]	; 0x38
 800d33c:	011c      	lsls	r4, r3, #4
 800d33e:	9411      	str	r4, [sp, #68]	; 0x44
 800d340:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 800d342:	ea44 6401 	orr.w	r4, r4, r1, lsl #24
 800d346:	940e      	str	r4, [sp, #56]	; 0x38
 800d348:	9c11      	ldr	r4, [sp, #68]	; 0x44
 800d34a:	1209      	asrs	r1, r1, #8
 800d34c:	ea44 7412 	orr.w	r4, r4, r2, lsr #28
 800d350:	0112      	lsls	r2, r2, #4
 800d352:	f10b 33ff 	add.w	r3, fp, #4294967295
 800d356:	910f      	str	r1, [sp, #60]	; 0x3c
 800d358:	9210      	str	r2, [sp, #64]	; 0x40
 800d35a:	9411      	str	r4, [sp, #68]	; 0x44
 800d35c:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800d360:	fa1f fb83 	uxth.w	fp, r3
 800d364:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 800d368:	1812      	adds	r2, r2, r0
 800d36a:	414b      	adcs	r3, r1
 800d36c:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 800d370:	1880      	adds	r0, r0, r2
 800d372:	4159      	adcs	r1, r3
 800d374:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
uint32_t BME280_getPressure(bme280_t *handle, uint16_t means) {
	int64_t var1, var2, p;
	uint16_t tmp;

	uint64_t sum = 0;
	for(uint16_t i=0; i<means; i++) {
 800d378:	f1bb 0f00 	cmp.w	fp, #0
 800d37c:	f47f aedb 	bne.w	800d136 <BME280_getPressure.constprop.24+0x16>
		var2 = (((int64_t)handle->calib.dig_P8) * p) >> 19;

		sum += ((p + var1 + var2) >> 8) + (((int64_t)handle->calib.dig_P7)<<4);
	}

	return sum/(means*26);
 800d380:	f44f 52d0 	mov.w	r2, #6656	; 0x1a00
 800d384:	2300      	movs	r3, #0
 800d386:	f7f3 ffeb 	bl	8001360 <__aeabi_uldivmod>
}
 800d38a:	b01f      	add	sp, #124	; 0x7c
 800d38c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;

		if (var1 == 0)
			return 0;  // avoid exception caused by division by zero
 800d390:	9812      	ldr	r0, [sp, #72]	; 0x48

		sum += ((p + var1 + var2) >> 8) + (((int64_t)handle->calib.dig_P7)<<4);
	}

	return sum/(means*26);
}
 800d392:	b01f      	add	sp, #124	; 0x7c
 800d394:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0800d3a0 <gps_receive_payload.constprop.23>:
 * the caller has to ensure suitable buffer length!
 *
 * returns the length of the payload
 *
 */
uint16_t gps_receive_payload(uint8_t class_id, uint8_t msg_id, unsigned char *payload, uint16_t timeout) {
 800d3a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d3a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800d3a8:	4699      	mov	r9, r3
 800d3aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d3ac:	b085      	sub	sp, #20
	uint8_t rx_byte;
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;
 800d3ae:	2500      	movs	r5, #0

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
 800d3b0:	f503 38c3 	add.w	r8, r3, #99840	; 0x18600
 * the caller has to ensure suitable buffer length!
 *
 * returns the length of the payload
 *
 */
uint16_t gps_receive_payload(uint8_t class_id, uint8_t msg_id, unsigned char *payload, uint16_t timeout) {
 800d3b4:	9000      	str	r0, [sp, #0]
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
 800d3b6:	f108 08a0 	add.w	r8, r8, #160	; 0xa0
 */
uint16_t gps_receive_payload(uint8_t class_id, uint8_t msg_id, unsigned char *payload, uint16_t timeout) {
	uint8_t rx_byte;
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
 800d3ba:	46aa      	mov	sl, r5
 *
 */
uint16_t gps_receive_payload(uint8_t class_id, uint8_t msg_id, unsigned char *payload, uint16_t timeout) {
	uint8_t rx_byte;
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
 800d3bc:	46ab      	mov	fp, r5
 * returns the length of the payload
 *
 */
uint16_t gps_receive_payload(uint8_t class_id, uint8_t msg_id, unsigned char *payload, uint16_t timeout) {
	uint8_t rx_byte;
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
 800d3be:	462f      	mov	r7, r5
 800d3c0:	462b      	mov	r3, r5
 800d3c2:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d3c6:	4590      	cmp	r8, r2
 800d3c8:	d33b      	bcc.n	800d442 <gps_receive_payload.constprop.23+0xa2>
 800d3ca:	f10d 060e 	add.w	r6, sp, #14

		// Receive one byte
		if(!bytes_avail)
 800d3ce:	2b00      	cmp	r3, #0
 800d3d0:	d03c      	beq.n	800d44c <gps_receive_payload.constprop.23+0xac>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d3d2:	4632      	mov	r2, r6
 800d3d4:	21ff      	movs	r1, #255	; 0xff
 800d3d6:	2042      	movs	r0, #66	; 0x42
 800d3d8:	9301      	str	r3, [sp, #4]
 800d3da:	f7fc ff71 	bl	800a2c0 <I2C_read8>
 800d3de:	9b01      	ldr	r3, [sp, #4]
 800d3e0:	2800      	cmp	r0, #0
 800d3e2:	f040 8107 	bne.w	800d5f4 <gps_receive_payload.constprop.23+0x254>
 800d3e6:	461c      	mov	r4, r3
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d3e8:	3c01      	subs	r4, #1
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
	else
		return 0x00;
 800d3ea:	f04f 0e00 	mov.w	lr, #0
		
		rx_byte = gps_receive_byte();
		bytes_avail--;

		// Process one byte
		switch (state) {
 800d3ee:	3f01      	subs	r7, #1
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d3f0:	b2a4      	uxth	r4, r4
 800d3f2:	4670      	mov	r0, lr

		// Process one byte
		switch (state) {
 800d3f4:	2f05      	cmp	r7, #5
 800d3f6:	d811      	bhi.n	800d41c <gps_receive_payload.constprop.23+0x7c>
 800d3f8:	e8df f017 	tbh	[pc, r7, lsl #1]
 800d3fc:	00350035 	.word	0x00350035
 800d400:	0266009b 	.word	0x0266009b
 800d404:	0263005c 	.word	0x0263005c
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d408:	4632      	mov	r2, r6
 800d40a:	21ff      	movs	r1, #255	; 0xff
 800d40c:	2042      	movs	r0, #66	; 0x42
 800d40e:	f7fc ff57 	bl	800a2c0 <I2C_read8>
 800d412:	2800      	cmp	r0, #0
 800d414:	f040 80b7 	bne.w	800d586 <gps_receive_payload.constprop.23+0x1e6>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d418:	1e6c      	subs	r4, r5, #1
 800d41a:	b2a4      	uxth	r4, r4
 800d41c:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d420:	4598      	cmp	r8, r3
 800d422:	d30e      	bcc.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d424:	4632      	mov	r2, r6

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
 800d426:	2c00      	cmp	r4, #0
 800d428:	f000 80b2 	beq.w	800d590 <gps_receive_payload.constprop.23+0x1f0>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d42c:	21ff      	movs	r1, #255	; 0xff
 800d42e:	2042      	movs	r0, #66	; 0x42
 800d430:	f7fc ff46 	bl	800a2c0 <I2C_read8>
 800d434:	bb28      	cbnz	r0, 800d482 <gps_receive_payload.constprop.23+0xe2>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d436:	3c01      	subs	r4, #1
 800d438:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d43c:	4598      	cmp	r8, r3
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d43e:	b2a4      	uxth	r4, r4
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d440:	d2f0      	bcs.n	800d424 <gps_receive_payload.constprop.23+0x84>
			default:
				state = UBX_A;
		}
	}

	return 0;
 800d442:	2000      	movs	r0, #0
}
 800d444:	b005      	add	sp, #20
 800d446:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d44a:	461f      	mov	r7, r3
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d44c:	4632      	mov	r2, r6
 800d44e:	21fd      	movs	r1, #253	; 0xfd
 800d450:	2042      	movs	r0, #66	; 0x42
 800d452:	f7fc ff9d 	bl	800a390 <I2C_read16>
 800d456:	b9f0      	cbnz	r0, 800d496 <gps_receive_payload.constprop.23+0xf6>

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
			chThdSleepMilliseconds(50);
 800d458:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d45c:	f001 fe18 	bl	800f090 <chThdSleep>
 800d460:	2400      	movs	r4, #0
 800d462:	4623      	mov	r3, r4
 800d464:	e7ad      	b.n	800d3c2 <gps_receive_payload.constprop.23+0x22>
 800d466:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d46a:	4598      	cmp	r8, r3
 800d46c:	d3e9      	bcc.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d46e:	4632      	mov	r2, r6

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
 800d470:	2c00      	cmp	r4, #0
 800d472:	d073      	beq.n	800d55c <gps_receive_payload.constprop.23+0x1bc>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d474:	21ff      	movs	r1, #255	; 0xff
 800d476:	2042      	movs	r0, #66	; 0x42
 800d478:	f7fc ff22 	bl	800a2c0 <I2C_read8>
				if (rx_byte == 0xB5)	state = UBX_B;
				else 			state = UBX_A;
				break;
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
				else			state = UBX_A;
 800d47c:	2700      	movs	r7, #0
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d47e:	2800      	cmp	r0, #0
 800d480:	d0b2      	beq.n	800d3e8 <gps_receive_payload.constprop.23+0x48>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d482:	3c01      	subs	r4, #1

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d484:	f89d e00e 	ldrb.w	lr, [sp, #14]
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d488:	b2a4      	uxth	r4, r4

		// Process one byte
		switch (state) {
			case UBX_A:
				if (rx_byte == 0xB5)	state = UBX_B;
 800d48a:	f1ae 07b5 	sub.w	r7, lr, #181	; 0xb5
 800d48e:	fab7 f787 	clz	r7, r7
 800d492:	097f      	lsrs	r7, r7, #5
 800d494:	e7e5      	b.n	800d462 <gps_receive_payload.constprop.23+0xc2>

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
		return val;
 800d496:	f8bd 300e 	ldrh.w	r3, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d49a:	2b00      	cmp	r3, #0
 800d49c:	d0dc      	beq.n	800d458 <gps_receive_payload.constprop.23+0xb8>
 800d49e:	e798      	b.n	800d3d2 <gps_receive_payload.constprop.23+0x32>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d4a0:	4632      	mov	r2, r6
 800d4a2:	21ff      	movs	r1, #255	; 0xff
 800d4a4:	2042      	movs	r0, #66	; 0x42
 800d4a6:	f7fc ff0b 	bl	800a2c0 <I2C_read8>
 800d4aa:	2800      	cmp	r0, #0
 800d4ac:	f040 811e 	bne.w	800d6ec <gps_receive_payload.constprop.23+0x34c>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d4b0:	3c01      	subs	r4, #1
 800d4b2:	b2a4      	uxth	r4, r4
 800d4b4:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
			case LEN_A:
				payload_len = rx_byte;
				state = LEN_B;
				break;
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
 800d4b8:	ea40 0a0a 	orr.w	sl, r0, sl
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d4bc:	4598      	cmp	r8, r3
			case LEN_A:
				payload_len = rx_byte;
				state = LEN_B;
				break;
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
 800d4be:	fa1f fa8a 	uxth.w	sl, sl
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d4c2:	d3be      	bcc.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d4c4:	4632      	mov	r2, r6

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
 800d4c6:	2c00      	cmp	r4, #0
 800d4c8:	f000 812e 	beq.w	800d728 <gps_receive_payload.constprop.23+0x388>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d4cc:	21ff      	movs	r1, #255	; 0xff
 800d4ce:	2042      	movs	r0, #66	; 0x42
 800d4d0:	f7fc fef6 	bl	800a2c0 <I2C_read8>
 800d4d4:	2800      	cmp	r0, #0
 800d4d6:	d03f      	beq.n	800d558 <gps_receive_payload.constprop.23+0x1b8>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d4d8:	3c01      	subs	r4, #1

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d4da:	f89d e00e 	ldrb.w	lr, [sp, #14]
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d4de:	b2a4      	uxth	r4, r4
 800d4e0:	4dc6      	ldr	r5, [pc, #792]	; (800d7fc <gps_receive_payload.constprop.23+0x45c>)
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
				state = PAYLOAD;
				break;
			case PAYLOAD:
				payload[payload_cnt] = rx_byte;
 800d4e2:	f805 e00b 	strb.w	lr, [r5, fp]
				payload_cnt++;
 800d4e6:	f10b 0b01 	add.w	fp, fp, #1
 800d4ea:	fa1f fb8b 	uxth.w	fp, fp
				if (payload_cnt == payload_len)
 800d4ee:	45d3      	cmp	fp, sl
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d4f0:	4632      	mov	r2, r6
 800d4f2:	f04f 01ff 	mov.w	r1, #255	; 0xff
 800d4f6:	f04f 0042 	mov.w	r0, #66	; 0x42
				state = PAYLOAD;
				break;
			case PAYLOAD:
				payload[payload_cnt] = rx_byte;
				payload_cnt++;
				if (payload_cnt == payload_len)
 800d4fa:	f000 81dd 	beq.w	800d8b8 <gps_receive_payload.constprop.23+0x518>
 800d4fe:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d502:	4598      	cmp	r8, r3
 800d504:	d39d      	bcc.n	800d442 <gps_receive_payload.constprop.23+0xa2>

		// Receive one byte
		if(!bytes_avail)
 800d506:	2c00      	cmp	r4, #0
 800d508:	f000 813c 	beq.w	800d784 <gps_receive_payload.constprop.23+0x3e4>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d50c:	f7fc fed8 	bl	800a2c0 <I2C_read8>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d510:	1e63      	subs	r3, r4, #1
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d512:	b308      	cbz	r0, 800d558 <gps_receive_payload.constprop.23+0x1b8>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d514:	b29c      	uxth	r4, r3

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d516:	f89d e00e 	ldrb.w	lr, [sp, #14]
 800d51a:	e7e2      	b.n	800d4e2 <gps_receive_payload.constprop.23+0x142>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d51c:	4632      	mov	r2, r6
 800d51e:	21ff      	movs	r1, #255	; 0xff
 800d520:	2042      	movs	r0, #66	; 0x42
 800d522:	f7fc fecd 	bl	800a2c0 <I2C_read8>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d526:	3c01      	subs	r4, #1
 800d528:	b2a4      	uxth	r4, r4
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d52a:	2800      	cmp	r0, #0
 800d52c:	f040 81c1 	bne.w	800d8b2 <gps_receive_payload.constprop.23+0x512>
		return val;
	else
		return 0x00;
 800d530:	4686      	mov	lr, r0
			case CLASSID:
				if (rx_byte == class_id)state = MSGID;
				else			state = UBX_A;
				break;
			case MSGID:
				if (rx_byte == msg_id)	state = LEN_A;
 800d532:	9b00      	ldr	r3, [sp, #0]
 800d534:	4573      	cmp	r3, lr
 800d536:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800d53a:	f000 8115 	beq.w	800d768 <gps_receive_payload.constprop.23+0x3c8>
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d53e:	4598      	cmp	r8, r3
 800d540:	f4ff af7f 	bcc.w	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d544:	4632      	mov	r2, r6

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
 800d546:	b14c      	cbz	r4, 800d55c <gps_receive_payload.constprop.23+0x1bc>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d548:	21ff      	movs	r1, #255	; 0xff
 800d54a:	2042      	movs	r0, #66	; 0x42
 800d54c:	f7fc feb8 	bl	800a2c0 <I2C_read8>
 800d550:	2800      	cmp	r0, #0
 800d552:	d196      	bne.n	800d482 <gps_receive_payload.constprop.23+0xe2>
				if (rx_byte == class_id)state = MSGID;
				else			state = UBX_A;
				break;
			case MSGID:
				if (rx_byte == msg_id)	state = LEN_A;
				else			state = UBX_A;
 800d554:	4607      	mov	r7, r0
 800d556:	e747      	b.n	800d3e8 <gps_receive_payload.constprop.23+0x48>
				payload_len = rx_byte;
				state = LEN_B;
				break;
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
				state = PAYLOAD;
 800d558:	2706      	movs	r7, #6
 800d55a:	e745      	b.n	800d3e8 <gps_receive_payload.constprop.23+0x48>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d55c:	21fd      	movs	r1, #253	; 0xfd
 800d55e:	2042      	movs	r0, #66	; 0x42
 800d560:	f7fc ff16 	bl	800a390 <I2C_read16>
 800d564:	b120      	cbz	r0, 800d570 <gps_receive_payload.constprop.23+0x1d0>
		return val;
 800d566:	f8bd 500e 	ldrh.w	r5, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d56a:	2d00      	cmp	r5, #0
 800d56c:	f47f af4c 	bne.w	800d408 <gps_receive_payload.constprop.23+0x68>
			chThdSleepMilliseconds(50);
 800d570:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d574:	f001 fd8c 	bl	800f090 <chThdSleep>
 800d578:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d57c:	4598      	cmp	r8, r3
				if (rx_byte == class_id)state = MSGID;
				else			state = UBX_A;
				break;
			case MSGID:
				if (rx_byte == msg_id)	state = LEN_A;
				else			state = UBX_A;
 800d57e:	4627      	mov	r7, r4
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d580:	f4bf af64 	bcs.w	800d44c <gps_receive_payload.constprop.23+0xac>
 800d584:	e75d      	b.n	800d442 <gps_receive_payload.constprop.23+0xa2>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d586:	1e6c      	subs	r4, r5, #1
 800d588:	b2a4      	uxth	r4, r4

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d58a:	f89d e00e 	ldrb.w	lr, [sp, #14]
 800d58e:	e77c      	b.n	800d48a <gps_receive_payload.constprop.23+0xea>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d590:	21fd      	movs	r1, #253	; 0xfd
 800d592:	2042      	movs	r0, #66	; 0x42
 800d594:	f7fc fefc 	bl	800a390 <I2C_read16>
 800d598:	b110      	cbz	r0, 800d5a0 <gps_receive_payload.constprop.23+0x200>
		return val;
 800d59a:	f8bd 500e 	ldrh.w	r5, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d59e:	b95d      	cbnz	r5, 800d5b8 <gps_receive_payload.constprop.23+0x218>
			chThdSleepMilliseconds(50);
 800d5a0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d5a4:	f001 fd74 	bl	800f090 <chThdSleep>
 800d5a8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800d5ac:	4627      	mov	r7, r4
 800d5ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d5b0:	4598      	cmp	r8, r3
 800d5b2:	f4bf af4b 	bcs.w	800d44c <gps_receive_payload.constprop.23+0xac>
 800d5b6:	e744      	b.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d5b8:	4632      	mov	r2, r6
 800d5ba:	21ff      	movs	r1, #255	; 0xff
 800d5bc:	2042      	movs	r0, #66	; 0x42
 800d5be:	f7fc fe7f 	bl	800a2c0 <I2C_read8>
 800d5c2:	2800      	cmp	r0, #0
 800d5c4:	d1df      	bne.n	800d586 <gps_receive_payload.constprop.23+0x1e6>
 800d5c6:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d5ca:	1e6b      	subs	r3, r5, #1
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d5cc:	4590      	cmp	r8, r2
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d5ce:	b29f      	uxth	r7, r3
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d5d0:	f4ff af37 	bcc.w	800d442 <gps_receive_payload.constprop.23+0xa2>
				payload_cnt++;
				if (payload_cnt == payload_len)
					return payload_len;
				break;
			default:
				state = UBX_A;
 800d5d4:	4623      	mov	r3, r4

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
 800d5d6:	2f00      	cmp	r7, #0
 800d5d8:	f43f af37 	beq.w	800d44a <gps_receive_payload.constprop.23+0xaa>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d5dc:	4632      	mov	r2, r6
 800d5de:	21ff      	movs	r1, #255	; 0xff
 800d5e0:	2042      	movs	r0, #66	; 0x42
 800d5e2:	f7fc fe6d 	bl	800a2c0 <I2C_read8>
				payload_cnt++;
				if (payload_cnt == payload_len)
					return payload_len;
				break;
			default:
				state = UBX_A;
 800d5e6:	4623      	mov	r3, r4
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d5e8:	2800      	cmp	r0, #0
 800d5ea:	f000 8167 	beq.w	800d8bc <gps_receive_payload.constprop.23+0x51c>
 800d5ee:	461a      	mov	r2, r3
 800d5f0:	463b      	mov	r3, r7
 800d5f2:	4617      	mov	r7, r2
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d5f4:	1e5c      	subs	r4, r3, #1
 800d5f6:	b2a4      	uxth	r4, r4

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d5f8:	f89d e00e 	ldrb.w	lr, [sp, #14]
		
		rx_byte = gps_receive_byte();
		bytes_avail--;

		// Process one byte
		switch (state) {
 800d5fc:	2f06      	cmp	r7, #6
 800d5fe:	d84a      	bhi.n	800d696 <gps_receive_payload.constprop.23+0x2f6>
 800d600:	a201      	add	r2, pc, #4	; (adr r2, 800d608 <gps_receive_payload.constprop.23+0x268>)
 800d602:	f852 f027 	ldr.w	pc, [r2, r7, lsl #2]
 800d606:	bf00      	nop
 800d608:	0800d48b 	.word	0x0800d48b
 800d60c:	0800d625 	.word	0x0800d625
 800d610:	0800d66b 	.word	0x0800d66b
 800d614:	0800d533 	.word	0x0800d533
 800d618:	0800d6cd 	.word	0x0800d6cd
 800d61c:	0800d6f5 	.word	0x0800d6f5
 800d620:	0800d4e1 	.word	0x0800d4e1
			case UBX_A:
				if (rx_byte == 0xB5)	state = UBX_B;
				else 			state = UBX_A;
				break;
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
 800d624:	f1be 0f62 	cmp.w	lr, #98	; 0x62
 800d628:	f47f af1d 	bne.w	800d466 <gps_receive_payload.constprop.23+0xc6>
 800d62c:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d630:	4590      	cmp	r8, r2
 800d632:	f4ff af06 	bcc.w	800d442 <gps_receive_payload.constprop.23+0xa2>

		// Receive one byte
		if(!bytes_avail)
 800d636:	2c00      	cmp	r4, #0
 800d638:	f000 80ed 	beq.w	800d816 <gps_receive_payload.constprop.23+0x476>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d63c:	4632      	mov	r2, r6
 800d63e:	21ff      	movs	r1, #255	; 0xff
 800d640:	2042      	movs	r0, #66	; 0x42
 800d642:	9301      	str	r3, [sp, #4]
 800d644:	f7fc fe3c 	bl	800a2c0 <I2C_read8>
 800d648:	2800      	cmp	r0, #0
 800d64a:	f040 80d9 	bne.w	800d800 <gps_receive_payload.constprop.23+0x460>
			case UBX_A:
				if (rx_byte == 0xB5)	state = UBX_B;
				else 			state = UBX_A;
				break;
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
 800d64e:	2702      	movs	r7, #2
 800d650:	e6ca      	b.n	800d3e8 <gps_receive_payload.constprop.23+0x48>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d652:	4632      	mov	r2, r6
 800d654:	21ff      	movs	r1, #255	; 0xff
 800d656:	2042      	movs	r0, #66	; 0x42
 800d658:	f7fc fe32 	bl	800a2c0 <I2C_read8>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d65c:	3c01      	subs	r4, #1
 800d65e:	b2a4      	uxth	r4, r4
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d660:	2800      	cmp	r0, #0
 800d662:	f43f af00 	beq.w	800d466 <gps_receive_payload.constprop.23+0xc6>
		return val;
 800d666:	f89d e00e 	ldrb.w	lr, [sp, #14]
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
				else			state = UBX_A;
				break;
			case CLASSID:
				if (rx_byte == class_id)state = MSGID;
 800d66a:	f1be 0f01 	cmp.w	lr, #1
 800d66e:	f47f aefa 	bne.w	800d466 <gps_receive_payload.constprop.23+0xc6>
 800d672:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d676:	4598      	cmp	r8, r3
 800d678:	f4ff aee3 	bcc.w	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d67c:	4632      	mov	r2, r6

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
 800d67e:	2c00      	cmp	r4, #0
 800d680:	f000 80e0 	beq.w	800d844 <gps_receive_payload.constprop.23+0x4a4>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d684:	21ff      	movs	r1, #255	; 0xff
 800d686:	2042      	movs	r0, #66	; 0x42
 800d688:	f7fc fe1a 	bl	800a2c0 <I2C_read8>
 800d68c:	2800      	cmp	r0, #0
 800d68e:	f040 80bd 	bne.w	800d80c <gps_receive_payload.constprop.23+0x46c>
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
				else			state = UBX_A;
				break;
			case CLASSID:
				if (rx_byte == class_id)state = MSGID;
 800d692:	2703      	movs	r7, #3
 800d694:	e6a8      	b.n	800d3e8 <gps_receive_payload.constprop.23+0x48>
 800d696:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d69a:	4590      	cmp	r8, r2
 800d69c:	f4ff aed1 	bcc.w	800d442 <gps_receive_payload.constprop.23+0xa2>

		// Receive one byte
		if(!bytes_avail)
 800d6a0:	2c00      	cmp	r4, #0
 800d6a2:	f000 8091 	beq.w	800d7c8 <gps_receive_payload.constprop.23+0x428>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d6a6:	4632      	mov	r2, r6
 800d6a8:	21ff      	movs	r1, #255	; 0xff
 800d6aa:	2042      	movs	r0, #66	; 0x42
 800d6ac:	9301      	str	r3, [sp, #4]
 800d6ae:	f7fc fe07 	bl	800a2c0 <I2C_read8>
 800d6b2:	2800      	cmp	r0, #0
 800d6b4:	f43f aebf 	beq.w	800d436 <gps_receive_payload.constprop.23+0x96>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d6b8:	9b01      	ldr	r3, [sp, #4]

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d6ba:	f89d e00e 	ldrb.w	lr, [sp, #14]
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d6be:	3b02      	subs	r3, #2
 800d6c0:	b29c      	uxth	r4, r3
 800d6c2:	e6e2      	b.n	800d48a <gps_receive_payload.constprop.23+0xea>
 800d6c4:	3c01      	subs	r4, #1

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d6c6:	f89d e00e 	ldrb.w	lr, [sp, #14]
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d6ca:	b2a4      	uxth	r4, r4
 800d6cc:	fa1f fa8e 	uxth.w	sl, lr
 800d6d0:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d6d4:	4598      	cmp	r8, r3
 800d6d6:	f4ff aeb4 	bcc.w	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d6da:	4632      	mov	r2, r6

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
 800d6dc:	b174      	cbz	r4, 800d6fc <gps_receive_payload.constprop.23+0x35c>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d6de:	21ff      	movs	r1, #255	; 0xff
 800d6e0:	2042      	movs	r0, #66	; 0x42
 800d6e2:	f7fc fded 	bl	800a2c0 <I2C_read8>
 800d6e6:	b908      	cbnz	r0, 800d6ec <gps_receive_payload.constprop.23+0x34c>
				if (rx_byte == msg_id)	state = LEN_A;
				else			state = UBX_A;
				break;
			case LEN_A:
				payload_len = rx_byte;
				state = LEN_B;
 800d6e8:	2705      	movs	r7, #5
 800d6ea:	e67d      	b.n	800d3e8 <gps_receive_payload.constprop.23+0x48>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d6ec:	3c01      	subs	r4, #1

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d6ee:	f89d e00e 	ldrb.w	lr, [sp, #14]
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d6f2:	b2a4      	uxth	r4, r4
 800d6f4:	ea4f 200e 	mov.w	r0, lr, lsl #8
 800d6f8:	b200      	sxth	r0, r0
 800d6fa:	e6db      	b.n	800d4b4 <gps_receive_payload.constprop.23+0x114>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d6fc:	21fd      	movs	r1, #253	; 0xfd
 800d6fe:	2042      	movs	r0, #66	; 0x42
 800d700:	f7fc fe46 	bl	800a390 <I2C_read16>
 800d704:	b120      	cbz	r0, 800d710 <gps_receive_payload.constprop.23+0x370>
		return val;
 800d706:	f8bd 400e 	ldrh.w	r4, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d70a:	2c00      	cmp	r4, #0
 800d70c:	f47f aec8 	bne.w	800d4a0 <gps_receive_payload.constprop.23+0x100>
			chThdSleepMilliseconds(50);
 800d710:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d714:	f001 fcbc 	bl	800f090 <chThdSleep>
 800d718:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d71c:	4598      	cmp	r8, r3
				if (rx_byte == msg_id)	state = LEN_A;
				else			state = UBX_A;
				break;
			case LEN_A:
				payload_len = rx_byte;
				state = LEN_B;
 800d71e:	f04f 0705 	mov.w	r7, #5
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d722:	f4bf ae93 	bcs.w	800d44c <gps_receive_payload.constprop.23+0xac>
 800d726:	e68c      	b.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d728:	21fd      	movs	r1, #253	; 0xfd
 800d72a:	2042      	movs	r0, #66	; 0x42
 800d72c:	f7fc fe30 	bl	800a390 <I2C_read16>
 800d730:	b110      	cbz	r0, 800d738 <gps_receive_payload.constprop.23+0x398>
		return val;
 800d732:	f8bd 400e 	ldrh.w	r4, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d736:	b95c      	cbnz	r4, 800d750 <gps_receive_payload.constprop.23+0x3b0>
			chThdSleepMilliseconds(50);
 800d738:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d73c:	f001 fca8 	bl	800f090 <chThdSleep>
 800d740:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d744:	4598      	cmp	r8, r3
				payload_len = rx_byte;
				state = LEN_B;
				break;
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
				state = PAYLOAD;
 800d746:	f04f 0706 	mov.w	r7, #6
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d74a:	f4bf ae7f 	bcs.w	800d44c <gps_receive_payload.constprop.23+0xac>
 800d74e:	e678      	b.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d750:	4632      	mov	r2, r6
 800d752:	21ff      	movs	r1, #255	; 0xff
 800d754:	2042      	movs	r0, #66	; 0x42
 800d756:	f7fc fdb3 	bl	800a2c0 <I2C_read8>
 800d75a:	2800      	cmp	r0, #0
 800d75c:	f47f aebc 	bne.w	800d4d8 <gps_receive_payload.constprop.23+0x138>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d760:	3c01      	subs	r4, #1
 800d762:	b2a4      	uxth	r4, r4
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
	else
		return 0x00;
 800d764:	4686      	mov	lr, r0
 800d766:	e6bb      	b.n	800d4e0 <gps_receive_payload.constprop.23+0x140>
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d768:	4598      	cmp	r8, r3
 800d76a:	f4ff ae6a 	bcc.w	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d76e:	4632      	mov	r2, r6

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
 800d770:	2c00      	cmp	r4, #0
 800d772:	d07d      	beq.n	800d870 <gps_receive_payload.constprop.23+0x4d0>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d774:	21ff      	movs	r1, #255	; 0xff
 800d776:	2042      	movs	r0, #66	; 0x42
 800d778:	f7fc fda2 	bl	800a2c0 <I2C_read8>
 800d77c:	2800      	cmp	r0, #0
 800d77e:	d1a1      	bne.n	800d6c4 <gps_receive_payload.constprop.23+0x324>
			case CLASSID:
				if (rx_byte == class_id)state = MSGID;
				else			state = UBX_A;
				break;
			case MSGID:
				if (rx_byte == msg_id)	state = LEN_A;
 800d780:	2704      	movs	r7, #4
 800d782:	e631      	b.n	800d3e8 <gps_receive_payload.constprop.23+0x48>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d784:	4632      	mov	r2, r6
 800d786:	21fd      	movs	r1, #253	; 0xfd
 800d788:	2042      	movs	r0, #66	; 0x42
 800d78a:	f7fc fe01 	bl	800a390 <I2C_read16>
 800d78e:	b110      	cbz	r0, 800d796 <gps_receive_payload.constprop.23+0x3f6>
		return val;
 800d790:	f8bd 400e 	ldrh.w	r4, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d794:	b95c      	cbnz	r4, 800d7ae <gps_receive_payload.constprop.23+0x40e>
			chThdSleepMilliseconds(50);
 800d796:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d79a:	f001 fc79 	bl	800f090 <chThdSleep>
 800d79e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800d7a2:	2706      	movs	r7, #6
 800d7a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d7a6:	4598      	cmp	r8, r3
 800d7a8:	f4bf ae50 	bcs.w	800d44c <gps_receive_payload.constprop.23+0xac>
 800d7ac:	e649      	b.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d7ae:	4632      	mov	r2, r6
 800d7b0:	21ff      	movs	r1, #255	; 0xff
 800d7b2:	2042      	movs	r0, #66	; 0x42
 800d7b4:	f7fc fd84 	bl	800a2c0 <I2C_read8>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d7b8:	3c01      	subs	r4, #1
 800d7ba:	b2a4      	uxth	r4, r4
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d7bc:	b908      	cbnz	r0, 800d7c2 <gps_receive_payload.constprop.23+0x422>
		return val;
	else
		return 0x00;
 800d7be:	4686      	mov	lr, r0
 800d7c0:	e68f      	b.n	800d4e2 <gps_receive_payload.constprop.23+0x142>

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d7c2:	f89d e00e 	ldrb.w	lr, [sp, #14]
 800d7c6:	e68c      	b.n	800d4e2 <gps_receive_payload.constprop.23+0x142>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d7c8:	4632      	mov	r2, r6
 800d7ca:	21fd      	movs	r1, #253	; 0xfd
 800d7cc:	2042      	movs	r0, #66	; 0x42
 800d7ce:	f7fc fddf 	bl	800a390 <I2C_read16>
 800d7d2:	2800      	cmp	r0, #0
 800d7d4:	f43f aecc 	beq.w	800d570 <gps_receive_payload.constprop.23+0x1d0>
		return val;
 800d7d8:	f8bd 500e 	ldrh.w	r5, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d7dc:	2d00      	cmp	r5, #0
 800d7de:	f43f aec7 	beq.w	800d570 <gps_receive_payload.constprop.23+0x1d0>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d7e2:	4632      	mov	r2, r6
 800d7e4:	21ff      	movs	r1, #255	; 0xff
 800d7e6:	2042      	movs	r0, #66	; 0x42
 800d7e8:	f7fc fd6a 	bl	800a2c0 <I2C_read8>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d7ec:	1e6c      	subs	r4, r5, #1
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d7ee:	2800      	cmp	r0, #0
 800d7f0:	f43f ae22 	beq.w	800d438 <gps_receive_payload.constprop.23+0x98>
		return val;
 800d7f4:	f89d e00e 	ldrb.w	lr, [sp, #14]
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d7f8:	b2a4      	uxth	r4, r4
 800d7fa:	e646      	b.n	800d48a <gps_receive_payload.constprop.23+0xea>
 800d7fc:	2002789c 	.word	0x2002789c
 800d800:	9b01      	ldr	r3, [sp, #4]

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d802:	f89d e00e 	ldrb.w	lr, [sp, #14]
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d806:	3b02      	subs	r3, #2
 800d808:	b29c      	uxth	r4, r3
 800d80a:	e72e      	b.n	800d66a <gps_receive_payload.constprop.23+0x2ca>
 800d80c:	3c01      	subs	r4, #1
 800d80e:	b2a4      	uxth	r4, r4

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d810:	f89d e00e 	ldrb.w	lr, [sp, #14]
 800d814:	e68d      	b.n	800d532 <gps_receive_payload.constprop.23+0x192>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d816:	4632      	mov	r2, r6
 800d818:	21fd      	movs	r1, #253	; 0xfd
 800d81a:	2042      	movs	r0, #66	; 0x42
 800d81c:	f7fc fdb8 	bl	800a390 <I2C_read16>
 800d820:	b120      	cbz	r0, 800d82c <gps_receive_payload.constprop.23+0x48c>
		return val;
 800d822:	f8bd 400e 	ldrh.w	r4, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d826:	2c00      	cmp	r4, #0
 800d828:	f47f af13 	bne.w	800d652 <gps_receive_payload.constprop.23+0x2b2>
			chThdSleepMilliseconds(50);
 800d82c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d830:	f001 fc2e 	bl	800f090 <chThdSleep>
 800d834:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d838:	4598      	cmp	r8, r3
			case UBX_A:
				if (rx_byte == 0xB5)	state = UBX_B;
				else 			state = UBX_A;
				break;
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
 800d83a:	f04f 0702 	mov.w	r7, #2
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d83e:	f4bf ae05 	bcs.w	800d44c <gps_receive_payload.constprop.23+0xac>
 800d842:	e5fe      	b.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d844:	21fd      	movs	r1, #253	; 0xfd
 800d846:	2042      	movs	r0, #66	; 0x42
 800d848:	f7fc fda2 	bl	800a390 <I2C_read16>
 800d84c:	b120      	cbz	r0, 800d858 <gps_receive_payload.constprop.23+0x4b8>
		return val;
 800d84e:	f8bd 400e 	ldrh.w	r4, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d852:	2c00      	cmp	r4, #0
 800d854:	f47f ae62 	bne.w	800d51c <gps_receive_payload.constprop.23+0x17c>
			chThdSleepMilliseconds(50);
 800d858:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d85c:	f001 fc18 	bl	800f090 <chThdSleep>
 800d860:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d864:	4598      	cmp	r8, r3
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
				else			state = UBX_A;
				break;
			case CLASSID:
				if (rx_byte == class_id)state = MSGID;
 800d866:	f04f 0703 	mov.w	r7, #3
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d86a:	f4bf adef 	bcs.w	800d44c <gps_receive_payload.constprop.23+0xac>
 800d86e:	e5e8      	b.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d870:	21fd      	movs	r1, #253	; 0xfd
 800d872:	2042      	movs	r0, #66	; 0x42
 800d874:	f7fc fd8c 	bl	800a390 <I2C_read16>
 800d878:	b110      	cbz	r0, 800d880 <gps_receive_payload.constprop.23+0x4e0>
		return val;
 800d87a:	f8bd 400e 	ldrh.w	r4, [sp, #14]
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!bytes_avail)
			bytes_avail = gps_bytes_avail();
		if(!bytes_avail) {
 800d87e:	b95c      	cbnz	r4, 800d898 <gps_receive_payload.constprop.23+0x4f8>
			chThdSleepMilliseconds(50);
 800d880:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800d884:	f001 fc04 	bl	800f090 <chThdSleep>
 800d888:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d88c:	4598      	cmp	r8, r3
			case CLASSID:
				if (rx_byte == class_id)state = MSGID;
				else			state = UBX_A;
				break;
			case MSGID:
				if (rx_byte == msg_id)	state = LEN_A;
 800d88e:	f04f 0704 	mov.w	r7, #4
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;
	uint16_t bytes_avail = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d892:	f4bf addb 	bcs.w	800d44c <gps_receive_payload.constprop.23+0xac>
 800d896:	e5d4      	b.n	800d442 <gps_receive_payload.constprop.23+0xa2>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d898:	4632      	mov	r2, r6
 800d89a:	21ff      	movs	r1, #255	; 0xff
 800d89c:	2042      	movs	r0, #66	; 0x42
 800d89e:	f7fc fd0f 	bl	800a2c0 <I2C_read8>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d8a2:	3c01      	subs	r4, #1
 800d8a4:	b2a4      	uxth	r4, r4
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d8a6:	b908      	cbnz	r0, 800d8ac <gps_receive_payload.constprop.23+0x50c>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d8a8:	4682      	mov	sl, r0
 800d8aa:	e711      	b.n	800d6d0 <gps_receive_payload.constprop.23+0x330>

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
 800d8ac:	f89d e00e 	ldrb.w	lr, [sp, #14]
 800d8b0:	e70c      	b.n	800d6cc <gps_receive_payload.constprop.23+0x32c>
 800d8b2:	f89d e00e 	ldrb.w	lr, [sp, #14]
 800d8b6:	e63c      	b.n	800d532 <gps_receive_payload.constprop.23+0x192>
				state = PAYLOAD;
				break;
			case PAYLOAD:
				payload[payload_cnt] = rx_byte;
				payload_cnt++;
				if (payload_cnt == payload_len)
 800d8b8:	4658      	mov	r0, fp
 800d8ba:	e5c3      	b.n	800d444 <gps_receive_payload.constprop.23+0xa4>
			chThdSleepMilliseconds(50);
			continue;
		}
		
		rx_byte = gps_receive_byte();
		bytes_avail--;
 800d8bc:	1eac      	subs	r4, r5, #2
 800d8be:	b2a4      	uxth	r4, r4
 800d8c0:	e5ac      	b.n	800d41c <gps_receive_payload.constprop.23+0x7c>
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
		return val;
	else
		return 0x00;
 800d8c2:	f04f 0e00 	mov.w	lr, #0
 800d8c6:	e60b      	b.n	800d4e0 <gps_receive_payload.constprop.23+0x140>
		
		rx_byte = gps_receive_byte();
		bytes_avail--;

		// Process one byte
		switch (state) {
 800d8c8:	f04f 0a00 	mov.w	sl, #0
 800d8cc:	e700      	b.n	800d6d0 <gps_receive_payload.constprop.23+0x330>
 800d8ce:	bf00      	nop

0800d8d0 <gps_receive_ack.constprop.21>:
 * waits for transmission of an ACK/NAK message from the GPS.
 *
 * returns 1 if ACK was received, 0 if NAK was received
 *
 */
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
 800d8d0:	b5f0      	push	{r4, r5, r6, r7, lr}
	int match_count = 0;
	int msg_ack = 0;
	uint8_t rx_byte;
	uint8_t ack[] = {0xB5, 0x62, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00};
 800d8d2:	4b2c      	ldr	r3, [pc, #176]	; (800d984 <gps_receive_ack.constprop.21+0xb4>)
 * waits for transmission of an ACK/NAK message from the GPS.
 *
 * returns 1 if ACK was received, 0 if NAK was received
 *
 */
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
 800d8d4:	b087      	sub	sp, #28
 800d8d6:	4604      	mov	r4, r0
	int match_count = 0;
	int msg_ack = 0;
	uint8_t rx_byte;
	uint8_t ack[] = {0xB5, 0x62, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00};
 800d8d8:	6859      	ldr	r1, [r3, #4]
 800d8da:	6818      	ldr	r0, [r3, #0]
 800d8dc:	aa02      	add	r2, sp, #8
 800d8de:	c203      	stmia	r2!, {r0, r1}
	uint8_t nak[] = {0xB5, 0x62, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00};
 800d8e0:	f853 0f08 	ldr.w	r0, [r3, #8]!
	ack[6] = class_id;
	nak[6] = class_id;
	ack[7] = msg_id;
 800d8e4:	f88d 400f 	strb.w	r4, [sp, #15]
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
	int match_count = 0;
	int msg_ack = 0;
	uint8_t rx_byte;
	uint8_t ack[] = {0xB5, 0x62, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00};
	uint8_t nak[] = {0xB5, 0x62, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00};
 800d8e8:	6859      	ldr	r1, [r3, #4]
 800d8ea:	ab04      	add	r3, sp, #16
 800d8ec:	c303      	stmia	r3!, {r0, r1}
 800d8ee:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
	ack[6] = class_id;
 800d8f2:	2306      	movs	r3, #6
	nak[6] = class_id;
	ack[7] = msg_id;
	nak[7] = msg_id;
 800d8f4:	f88d 4017 	strb.w	r4, [sp, #23]
	int match_count = 0;
	int msg_ack = 0;
	uint8_t rx_byte;
	uint8_t ack[] = {0xB5, 0x62, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00};
	uint8_t nak[] = {0xB5, 0x62, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00};
	ack[6] = class_id;
 800d8f8:	f88d 300e 	strb.w	r3, [sp, #14]
	nak[6] = class_id;
 800d8fc:	f88d 3016 	strb.w	r3, [sp, #22]
 800d900:	6a75      	ldr	r5, [r6, #36]	; 0x24
 * returns 1 if ACK was received, 0 if NAK was received
 *
 */
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
	int match_count = 0;
	int msg_ack = 0;
 800d902:	2700      	movs	r7, #0
	nak[6] = class_id;
	ack[7] = msg_id;
	nak[7] = msg_id;

	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
 800d904:	f505 459c 	add.w	r5, r5, #19968	; 0x4e00
 800d908:	3520      	adds	r5, #32
 *
 * returns 1 if ACK was received, 0 if NAK was received
 *
 */
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
	int match_count = 0;
 800d90a:	463c      	mov	r4, r7
 800d90c:	6a73      	ldr	r3, [r6, #36]	; 0x24
	ack[7] = msg_id;
	nak[7] = msg_id;

	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d90e:	429d      	cmp	r5, r3
 800d910:	d321      	bcc.n	800d956 <gps_receive_ack.constprop.21+0x86>
}

uint16_t gps_bytes_avail(void)
{
	uint16_t val;
	if(I2C_read16(UBLOX_MAX_ADDRESS, 0xFD, &val))
 800d912:	f10d 0206 	add.w	r2, sp, #6
 800d916:	21fd      	movs	r1, #253	; 0xfd
 800d918:	2042      	movs	r0, #66	; 0x42
 800d91a:	f7fc fd39 	bl	800a390 <I2C_read16>
 800d91e:	b1e8      	cbz	r0, 800d95c <gps_receive_ack.constprop.21+0x8c>
		return val;
 800d920:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!gps_bytes_avail()) { // No byte available
 800d924:	b1d3      	cbz	r3, 800d95c <gps_receive_ack.constprop.21+0x8c>
}

uint8_t gps_receive_byte(void)
{
	uint8_t val;
	if(I2C_read8(UBLOX_MAX_ADDRESS, 0xFF, &val))
 800d926:	f10d 0206 	add.w	r2, sp, #6
 800d92a:	21ff      	movs	r1, #255	; 0xff
 800d92c:	2042      	movs	r0, #66	; 0x42
 800d92e:	f7fc fcc7 	bl	800a2c0 <I2C_read8>
 800d932:	b108      	cbz	r0, 800d938 <gps_receive_ack.constprop.21+0x68>
		return val;
 800d934:	f89d 0006 	ldrb.w	r0, [sp, #6]
			continue;
		}
		rx_byte = gps_receive_byte();

		// Process one byte
		if (rx_byte == ack[match_count] || rx_byte == nak[match_count]) {
 800d938:	ab06      	add	r3, sp, #24
 800d93a:	4423      	add	r3, r4
 800d93c:	f813 2c10 	ldrb.w	r2, [r3, #-16]
 800d940:	4282      	cmp	r2, r0
 800d942:	d010      	beq.n	800d966 <gps_receive_ack.constprop.21+0x96>
 800d944:	f813 3c08 	ldrb.w	r3, [r3, #-8]
 800d948:	4283      	cmp	r3, r0
 800d94a:	d00c      	beq.n	800d966 <gps_receive_ack.constprop.21+0x96>
 800d94c:	6a73      	ldr	r3, [r6, #36]	; 0x24
	ack[7] = msg_id;
	nak[7] = msg_id;

	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d94e:	429d      	cmp	r5, r3
			if (match_count == 7) { 
				return msg_ack;
			}
			match_count++;
		} else {
			match_count = 0;
 800d950:	f04f 0400 	mov.w	r4, #0
	ack[7] = msg_id;
	nak[7] = msg_id;

	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d954:	d2dd      	bcs.n	800d912 <gps_receive_ack.constprop.21+0x42>
			match_count = 0;
		}

	}

	return false;
 800d956:	2000      	movs	r0, #0
}
 800d958:	b007      	add	sp, #28
 800d95a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		if(!gps_bytes_avail()) { // No byte available
			chThdSleepMilliseconds(100);
 800d95c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800d960:	f001 fb96 	bl	800f090 <chThdSleep>
 800d964:	e7d2      	b.n	800d90c <gps_receive_ack.constprop.21+0x3c>
		}
		rx_byte = gps_receive_byte();

		// Process one byte
		if (rx_byte == ack[match_count] || rx_byte == nak[match_count]) {
			if (match_count == 3) {	/* test ACK/NAK byte */
 800d966:	2c03      	cmp	r4, #3
 800d968:	d003      	beq.n	800d972 <gps_receive_ack.constprop.21+0xa2>
					msg_ack = 1;
				} else {
					msg_ack = 0;
				}
			}
			if (match_count == 7) { 
 800d96a:	2c07      	cmp	r4, #7
 800d96c:	d006      	beq.n	800d97c <gps_receive_ack.constprop.21+0xac>
				return msg_ack;
			}
			match_count++;
 800d96e:	3401      	adds	r4, #1
 800d970:	e7cc      	b.n	800d90c <gps_receive_ack.constprop.21+0x3c>
		if (rx_byte == ack[match_count] || rx_byte == nak[match_count]) {
			if (match_count == 3) {	/* test ACK/NAK byte */
				if (rx_byte == ack[match_count]) {
					msg_ack = 1;
				} else {
					msg_ack = 0;
 800d972:	1a17      	subs	r7, r2, r0
 800d974:	fab7 f787 	clz	r7, r7
 800d978:	097f      	lsrs	r7, r7, #5
 800d97a:	e7f8      	b.n	800d96e <gps_receive_ack.constprop.21+0x9e>
				}
			}
			if (match_count == 7) { 
				return msg_ack;
 800d97c:	b2f8      	uxtb	r0, r7
		}

	}

	return false;
}
 800d97e:	b007      	add	sp, #28
 800d980:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d982:	bf00      	nop
 800d984:	08013bf4 	.word	0x08013bf4
	...

0800d990 <radioTune.constprop.18>:
 * Tunes the radio and activates transmission.
 * @param frequency Transmission frequency in Hz
 * @param shift Shift of FSK in Hz
 * @param level Transmission power level in dBm
 */
bool radioTune(radio_t radio, uint32_t frequency, uint16_t shift, int8_t level, uint16_t size) {
 800d990:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d994:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 800d998:	b08b      	sub	sp, #44	; 0x2c
 800d99a:	4605      	mov	r5, r0
	// Tracing
	TRACE_INFO("SI %d > Tune Si4464", radio);
 800d99c:	48aa      	ldr	r0, [pc, #680]	; (800dc48 <radioTune.constprop.18+0x2b8>)
 800d99e:	4fab      	ldr	r7, [pc, #684]	; (800dc4c <radioTune.constprop.18+0x2bc>)
 800d9a0:	f8df 9300 	ldr.w	r9, [pc, #768]	; 800dca4 <radioTune.constprop.18+0x314>
 * Tunes the radio and activates transmission.
 * @param frequency Transmission frequency in Hz
 * @param shift Shift of FSK in Hz
 * @param level Transmission power level in dBm
 */
bool radioTune(radio_t radio, uint32_t frequency, uint16_t shift, int8_t level, uint16_t size) {
 800d9a4:	460c      	mov	r4, r1
 800d9a6:	4692      	mov	sl, r2
 800d9a8:	469b      	mov	fp, r3
	// Tracing
	TRACE_INFO("SI %d > Tune Si4464", radio);
 800d9aa:	f001 faa1 	bl	800eef0 <chMtxLock>
 800d9ae:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800d9b2:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800d9b6:	49a6      	ldr	r1, [pc, #664]	; (800dc50 <radioTune.constprop.18+0x2c0>)
 800d9b8:	48a6      	ldr	r0, [pc, #664]	; (800dc54 <radioTune.constprop.18+0x2c4>)
 800d9ba:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800d9be:	fb06 fe03 	mul.w	lr, r6, r3
 800d9c2:	fba7 3e0e 	umull	r3, lr, r7, lr
 800d9c6:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 800d9ca:	fba9 c30e 	umull	ip, r3, r9, lr
 800d9ce:	fba7 c202 	umull	ip, r2, r7, r2
 800d9d2:	099b      	lsrs	r3, r3, #6
 800d9d4:	fb06 e313 	mls	r3, r6, r3, lr
 800d9d8:	0b92      	lsrs	r2, r2, #14
 800d9da:	f004 fe81 	bl	80126e0 <chprintf.constprop.35>
 800d9de:	4a9e      	ldr	r2, [pc, #632]	; (800dc58 <radioTune.constprop.18+0x2c8>)
 800d9e0:	499e      	ldr	r1, [pc, #632]	; (800dc5c <radioTune.constprop.18+0x2cc>)
 800d9e2:	489c      	ldr	r0, [pc, #624]	; (800dc54 <radioTune.constprop.18+0x2c4>)
 800d9e4:	f004 fe7c 	bl	80126e0 <chprintf.constprop.35>
 800d9e8:	f240 134d 	movw	r3, #333	; 0x14d
 800d9ec:	4a9c      	ldr	r2, [pc, #624]	; (800dc60 <radioTune.constprop.18+0x2d0>)
 800d9ee:	499d      	ldr	r1, [pc, #628]	; (800dc64 <radioTune.constprop.18+0x2d4>)
 800d9f0:	4898      	ldr	r0, [pc, #608]	; (800dc54 <radioTune.constprop.18+0x2c4>)
 800d9f2:	f004 fe75 	bl	80126e0 <chprintf.constprop.35>
 800d9f6:	499c      	ldr	r1, [pc, #624]	; (800dc68 <radioTune.constprop.18+0x2d8>)
 800d9f8:	4896      	ldr	r0, [pc, #600]	; (800dc54 <radioTune.constprop.18+0x2c4>)
 800d9fa:	f004 fe71 	bl	80126e0 <chprintf.constprop.35>
 800d9fe:	462a      	mov	r2, r5
 800da00:	499a      	ldr	r1, [pc, #616]	; (800dc6c <radioTune.constprop.18+0x2dc>)
 800da02:	4894      	ldr	r0, [pc, #592]	; (800dc54 <radioTune.constprop.18+0x2c4>)
 800da04:	f004 fe6c 	bl	80126e0 <chprintf.constprop.35>
 800da08:	4999      	ldr	r1, [pc, #612]	; (800dc70 <radioTune.constprop.18+0x2e0>)
 800da0a:	4892      	ldr	r0, [pc, #584]	; (800dc54 <radioTune.constprop.18+0x2c4>)
 800da0c:	f004 fe68 	bl	80126e0 <chprintf.constprop.35>
 800da10:	488d      	ldr	r0, [pc, #564]	; (800dc48 <radioTune.constprop.18+0x2b8>)
 800da12:	f001 fa0d 	bl	800ee30 <chMtxUnlock>

	if(!RADIO_WITHIN_FREQ_RANGE(frequency)) {
 800da16:	4b97      	ldr	r3, [pc, #604]	; (800dc74 <radioTune.constprop.18+0x2e4>)
 800da18:	4a97      	ldr	r2, [pc, #604]	; (800dc78 <radioTune.constprop.18+0x2e8>)
 800da1a:	4423      	add	r3, r4
 800da1c:	4293      	cmp	r3, r2
 800da1e:	f200 81e5 	bhi.w	800ddec <radioTune.constprop.18+0x45c>
		TRACE_ERROR("SI %d > Frequency out of range", radio);
		TRACE_ERROR("SI %d > abort transmission", radio);
		return false;
	}

	if(!RADIO_WITHIN_MAX_PWR(radio, level)) {
 800da22:	f1bb 0f14 	cmp.w	fp, #20
 800da26:	f300 813f 	bgt.w	800dca8 <radioTune.constprop.18+0x318>
}

void setFrequency(radio_t radio, uint32_t freq, uint16_t shift) {
	// Set the output divider according to recommended ranges given in Si4464 datasheet
	uint32_t band = 0;
	if(freq < 705000000UL) {outdiv = 6;  band = 1;};
 800da2a:	4b94      	ldr	r3, [pc, #592]	; (800dc7c <radioTune.constprop.18+0x2ec>)
 800da2c:	429c      	cmp	r4, r3
 800da2e:	d814      	bhi.n	800da5a <radioTune.constprop.18+0xca>
	if(freq < 525000000UL) {outdiv = 8;  band = 2;};
 800da30:	4b93      	ldr	r3, [pc, #588]	; (800dc80 <radioTune.constprop.18+0x2f0>)
 800da32:	429c      	cmp	r4, r3
 800da34:	f200 8250 	bhi.w	800ded8 <radioTune.constprop.18+0x548>
	if(freq < 353000000UL) {outdiv = 12; band = 3;};
 800da38:	4b92      	ldr	r3, [pc, #584]	; (800dc84 <radioTune.constprop.18+0x2f4>)
 800da3a:	429c      	cmp	r4, r3
 800da3c:	f200 8251 	bhi.w	800dee2 <radioTune.constprop.18+0x552>
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
 800da40:	4b91      	ldr	r3, [pc, #580]	; (800dc88 <radioTune.constprop.18+0x2f8>)
 800da42:	429c      	cmp	r4, r3
 800da44:	f200 8252 	bhi.w	800deec <radioTune.constprop.18+0x55c>
	if(freq < 177000000UL) {outdiv = 24; band = 5;};
 800da48:	4b90      	ldr	r3, [pc, #576]	; (800dc8c <radioTune.constprop.18+0x2fc>)
 800da4a:	4f91      	ldr	r7, [pc, #580]	; (800dc90 <radioTune.constprop.18+0x300>)
 800da4c:	429c      	cmp	r4, r3
 800da4e:	f200 8252 	bhi.w	800def6 <radioTune.constprop.18+0x566>
 800da52:	2318      	movs	r3, #24
 800da54:	603b      	str	r3, [r7, #0]
 800da56:	230d      	movs	r3, #13
 800da58:	e001      	b.n	800da5e <radioTune.constprop.18+0xce>
 800da5a:	4f8d      	ldr	r7, [pc, #564]	; (800dc90 <radioTune.constprop.18+0x300>)
}

void setFrequency(radio_t radio, uint32_t freq, uint16_t shift) {
	// Set the output divider according to recommended ranges given in Si4464 datasheet
	uint32_t band = 0;
	if(freq < 705000000UL) {outdiv = 6;  band = 1;};
 800da5c:	2308      	movs	r3, #8
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
	if(freq < 177000000UL) {outdiv = 24; band = 5;};

	// Set the band parameter
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
 800da5e:	f04f 0c01 	mov.w	ip, #1
 800da62:	f04f 0e51 	mov.w	lr, #81	; 0x51
	Si4464_write(radio, set_band_property_command, 5);
 800da66:	a903      	add	r1, sp, #12
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
	if(freq < 177000000UL) {outdiv = 24; band = 5;};

	// Set the band parameter
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
 800da68:	2611      	movs	r6, #17
 800da6a:	f04f 0820 	mov.w	r8, #32
	Si4464_write(radio, set_band_property_command, 5);
 800da6e:	2205      	movs	r2, #5
 800da70:	4628      	mov	r0, r5
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
	if(freq < 177000000UL) {outdiv = 24; band = 5;};

	// Set the band parameter
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
 800da72:	f88d c00e 	strb.w	ip, [sp, #14]
 800da76:	f88d e00f 	strb.w	lr, [sp, #15]
 800da7a:	f88d 3010 	strb.w	r3, [sp, #16]
 800da7e:	f88d 600c 	strb.w	r6, [sp, #12]
 800da82:	f88d 800d 	strb.w	r8, [sp, #13]
	Si4464_write(radio, set_band_property_command, 5);
 800da86:	f002 f9ab 	bl	800fde0 <Si4464_write>

	// Set the PLL parameters
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
 800da8a:	683b      	ldr	r3, [r7, #0]
 800da8c:	9301      	str	r3, [sp, #4]
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
 800da8e:	4620      	mov	r0, r4
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
	Si4464_write(radio, set_band_property_command, 5);

	// Set the PLL parameters
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
 800da90:	4a80      	ldr	r2, [pc, #512]	; (800dc94 <radioTune.constprop.18+0x304>)
 800da92:	fbb2 f9f3 	udiv	r9, r2, r3
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
 800da96:	f7f3 f9b9 	bl	8000e0c <__aeabi_ui2f>
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
	Si4464_write(radio, set_band_property_command, 5);

	// Set the PLL parameters
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
 800da9a:	fbb4 f4f9 	udiv	r4, r4, r9
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
 800da9e:	9000      	str	r0, [sp, #0]
 800daa0:	4648      	mov	r0, r9
 800daa2:	f7f3 f9b3 	bl	8000e0c <__aeabi_ui2f>
 800daa6:	9a00      	ldr	r2, [sp, #0]
 800daa8:	4601      	mov	r1, r0
 800daaa:	4610      	mov	r0, r2
 800daac:	f7f3 fabc 	bl	8001028 <__aeabi_fdiv>
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
	Si4464_write(radio, set_band_property_command, 5);

	// Set the PLL parameters
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
 800dab0:	3c01      	subs	r4, #1
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
 800dab2:	4681      	mov	r9, r0
 800dab4:	4620      	mov	r0, r4
 800dab6:	f7f3 f9a9 	bl	8000e0c <__aeabi_ui2f>
 800daba:	4601      	mov	r1, r0
 800dabc:	4648      	mov	r0, r9
 800dabe:	f7f3 f8f3 	bl	8000ca8 <__aeabi_fsub>
 800dac2:	f04f 4192 	mov.w	r1, #1224736768	; 0x49000000
 800dac6:	f7f3 f9fb 	bl	8000ec0 <__aeabi_fmul>
 800daca:	f7f3 fbd9 	bl	8001280 <__aeabi_f2uiz>

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800dace:	9b01      	ldr	r3, [sp, #4]
 800dad0:	4a71      	ldr	r2, [pc, #452]	; (800dc98 <radioTune.constprop.18+0x308>)
 800dad2:	f88d 4020 	strb.w	r4, [sp, #32]
 800dad6:	04db      	lsls	r3, r3, #19
 800dad8:	fb0a f303 	mul.w	r3, sl, r3
 800dadc:	fba2 2303 	umull	r2, r3, r2, r3
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
	uint32_t m2 = m >> 16;
	uint32_t m1 = (m - m2 * 0x10000) >> 8;
 800dae0:	b282      	uxth	r2, r0
 800dae2:	ea4f 2e12 	mov.w	lr, r2, lsr #8

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800dae6:	0e5b      	lsrs	r3, r3, #25
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
	uint32_t m2 = m >> 16;
 800dae8:	0c00      	lsrs	r0, r0, #16
	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
	Si4464_write(radio, set_frequency_property_command, 10);
 800daea:	a907      	add	r1, sp, #28

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800daec:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
 800daf0:	2440      	movs	r4, #64	; 0x40
 800daf2:	2304      	movs	r3, #4
 800daf4:	f88d 2023 	strb.w	r2, [sp, #35]	; 0x23
 800daf8:	f88d e022 	strb.w	lr, [sp, #34]	; 0x22
	Si4464_write(radio, set_frequency_property_command, 10);
 800dafc:	220a      	movs	r2, #10

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800dafe:	f04f 0e00 	mov.w	lr, #0
 800db02:	f88d 0021 	strb.w	r0, [sp, #33]	; 0x21
	Si4464_write(radio, set_frequency_property_command, 10);
 800db06:	4628      	mov	r0, r5

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800db08:	f88d e01f 	strb.w	lr, [sp, #31]
 800db0c:	f88d e024 	strb.w	lr, [sp, #36]	; 0x24
 800db10:	f88d 301e 	strb.w	r3, [sp, #30]
 800db14:	f88d 401d 	strb.w	r4, [sp, #29]
 800db18:	f88d 601c 	strb.w	r6, [sp, #28]
	Si4464_write(radio, set_frequency_property_command, 10);
 800db1c:	f002 f960 	bl	800fde0 <Si4464_write>

	uint32_t x = ((((uint32_t)1 << 19) * outdiv * 1300.0)/(2*OSC_FREQ))*2;
 800db20:	6838      	ldr	r0, [r7, #0]
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
	Si4464_write(radio, set_band_property_command, 5);

	// Set the PLL parameters
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
 800db22:	f8df 916c 	ldr.w	r9, [pc, #364]	; 800dc90 <radioTune.constprop.18+0x300>
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
	Si4464_write(radio, set_frequency_property_command, 10);

	uint32_t x = ((((uint32_t)1 << 19) * outdiv * 1300.0)/(2*OSC_FREQ))*2;
 800db26:	04c0      	lsls	r0, r0, #19
 800db28:	f7f2 fd1c 	bl	8000564 <__aeabi_ui2d>
 800db2c:	a342      	add	r3, pc, #264	; (adr r3, 800dc38 <radioTune.constprop.18+0x2a8>)
 800db2e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800db32:	f7f2 fd8d 	bl	8000650 <__aeabi_dmul>
 800db36:	a342      	add	r3, pc, #264	; (adr r3, 800dc40 <radioTune.constprop.18+0x2b0>)
 800db38:	e9d3 2300 	ldrd	r2, r3, [r3]
 800db3c:	f7f2 feb2 	bl	80008a4 <__aeabi_ddiv>
 800db40:	4602      	mov	r2, r0
 800db42:	460b      	mov	r3, r1
 800db44:	f7f2 fbd2 	bl	80002ec <__adddf3>
 800db48:	f7f3 f83a 	bl	8000bc0 <__aeabi_d2uiz>
	uint8_t x2 = (x >> 16) & 0xFF;
	uint8_t x1 = (x >>  8) & 0xFF;
	uint8_t x0 = (x >>  0) & 0xFF;
	uint8_t set_deviation[] = {0x11, 0x20, 0x03, 0x0a, x2, x1, x0};
 800db4c:	2703      	movs	r7, #3
 800db4e:	ea4f 4e10 	mov.w	lr, r0, lsr #16
 800db52:	0a03      	lsrs	r3, r0, #8
 800db54:	240a      	movs	r4, #10
 800db56:	f88d 001a 	strb.w	r0, [sp, #26]
	Si4464_write(radio, set_deviation, 7);
 800db5a:	2207      	movs	r2, #7
 800db5c:	a905      	add	r1, sp, #20
 800db5e:	4628      	mov	r0, r5

	uint32_t x = ((((uint32_t)1 << 19) * outdiv * 1300.0)/(2*OSC_FREQ))*2;
	uint8_t x2 = (x >> 16) & 0xFF;
	uint8_t x1 = (x >>  8) & 0xFF;
	uint8_t x0 = (x >>  0) & 0xFF;
	uint8_t set_deviation[] = {0x11, 0x20, 0x03, 0x0a, x2, x1, x0};
 800db60:	f88d 6014 	strb.w	r6, [sp, #20]
 800db64:	f88d 8015 	strb.w	r8, [sp, #21]
 800db68:	f88d e018 	strb.w	lr, [sp, #24]
 800db6c:	f88d 3019 	strb.w	r3, [sp, #25]
 800db70:	f88d 7016 	strb.w	r7, [sp, #22]
 800db74:	f88d 4017 	strb.w	r4, [sp, #23]
	Si4464_write(radio, set_deviation, 7);
 800db78:	f002 f932 	bl	800fde0 <Si4464_write>
}

void setShift(radio_t radio, uint16_t shift) {
	if(!shift)
 800db7c:	f1ba 0f00 	cmp.w	sl, #0
 800db80:	d12a      	bne.n	800dbd8 <radioTune.constprop.18+0x248>
	Si4464_write(radio, use_2gfsk, 5);
}

void setPowerLevel(radio_t radio, int8_t level) {
	// Set the Power
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, dBm2powerLvl(level)};
 800db82:	2322      	movs	r3, #34	; 0x22
 800db84:	2401      	movs	r4, #1
 800db86:	2211      	movs	r2, #17
 800db88:	4658      	mov	r0, fp
 800db8a:	f88d 301d 	strb.w	r3, [sp, #29]
 800db8e:	f88d 201c 	strb.w	r2, [sp, #28]
 800db92:	f88d 401e 	strb.w	r4, [sp, #30]
 800db96:	f88d 401f 	strb.w	r4, [sp, #31]
 800db9a:	f002 f8d9 	bl	800fd50 <dBm2powerLvl>
	Si4464_write(radio, set_pa_pwr_lvl_property_command, 5);
 800db9e:	a907      	add	r1, sp, #28
	Si4464_write(radio, use_2gfsk, 5);
}

void setPowerLevel(radio_t radio, int8_t level) {
	// Set the Power
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, dBm2powerLvl(level)};
 800dba0:	f88d 0020 	strb.w	r0, [sp, #32]
	Si4464_write(radio, set_pa_pwr_lvl_property_command, 5);
 800dba4:	2205      	movs	r2, #5
 800dba6:	4628      	mov	r0, r5
 800dba8:	f002 f91a 	bl	800fde0 <Si4464_write>
}

void startTx(radio_t radio, uint16_t size) {
	uint8_t change_state_command[] = {0x31, 0x00, 0x30, (size >> 8) & 0x1F, size & 0xFF};
 800dbac:	2631      	movs	r6, #49	; 0x31
 800dbae:	2300      	movs	r3, #0
	Si4464_write(radio, change_state_command, 5);
 800dbb0:	4628      	mov	r0, r5
 800dbb2:	a907      	add	r1, sp, #28
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, dBm2powerLvl(level)};
	Si4464_write(radio, set_pa_pwr_lvl_property_command, 5);
}

void startTx(radio_t radio, uint16_t size) {
	uint8_t change_state_command[] = {0x31, 0x00, 0x30, (size >> 8) & 0x1F, size & 0xFF};
 800dbb4:	2530      	movs	r5, #48	; 0x30
	Si4464_write(radio, change_state_command, 5);
 800dbb6:	2205      	movs	r2, #5
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, dBm2powerLvl(level)};
	Si4464_write(radio, set_pa_pwr_lvl_property_command, 5);
}

void startTx(radio_t radio, uint16_t size) {
	uint8_t change_state_command[] = {0x31, 0x00, 0x30, (size >> 8) & 0x1F, size & 0xFF};
 800dbb8:	f88d 601c 	strb.w	r6, [sp, #28]
 800dbbc:	f88d 301d 	strb.w	r3, [sp, #29]
 800dbc0:	f88d 301f 	strb.w	r3, [sp, #31]
 800dbc4:	f88d 3020 	strb.w	r3, [sp, #32]
 800dbc8:	f88d 501e 	strb.w	r5, [sp, #30]
	Si4464_write(radio, change_state_command, 5);
 800dbcc:	f002 f908 	bl	800fde0 <Si4464_write>
	setFrequency(radio, frequency, shift);	// Set frequency
	setShift(radio, shift);					// Set shift
	setPowerLevel(radio, level);			// Set power level

	startTx(radio, size);
	return true;
 800dbd0:	4620      	mov	r0, r4
}
 800dbd2:	b00b      	add	sp, #44	; 0x2c
 800dbd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return;

	float units_per_hz = (( 0x40000 * outdiv ) / (float)OSC_FREQ);

	// Set deviation for 2FSK
	uint32_t modem_freq_dev = (uint32_t)(units_per_hz * shift / 2.0 );
 800dbd8:	f8d9 0000 	ldr.w	r0, [r9]
 800dbdc:	0480      	lsls	r0, r0, #18
 800dbde:	f7f3 f915 	bl	8000e0c <__aeabi_ui2f>
 800dbe2:	492e      	ldr	r1, [pc, #184]	; (800dc9c <radioTune.constprop.18+0x30c>)
 800dbe4:	f7f3 fa20 	bl	8001028 <__aeabi_fdiv>
 800dbe8:	4681      	mov	r9, r0
 800dbea:	4650      	mov	r0, sl
 800dbec:	f7f3 f912 	bl	8000e14 <__aeabi_i2f>
 800dbf0:	4601      	mov	r1, r0
 800dbf2:	4648      	mov	r0, r9
 800dbf4:	f7f3 f964 	bl	8000ec0 <__aeabi_fmul>
 800dbf8:	f7f2 fcd6 	bl	80005a8 <__aeabi_f2d>
 800dbfc:	2200      	movs	r2, #0
 800dbfe:	4b28      	ldr	r3, [pc, #160]	; (800dca0 <radioTune.constprop.18+0x310>)
 800dc00:	f7f2 fd26 	bl	8000650 <__aeabi_dmul>
 800dc04:	f7f2 ffdc 	bl	8000bc0 <__aeabi_d2uiz>
	uint8_t modem_freq_dev_0 = 0xFF & modem_freq_dev;
	uint8_t modem_freq_dev_1 = 0xFF & (modem_freq_dev >> 8);
	uint8_t modem_freq_dev_2 = 0xFF & (modem_freq_dev >> 16);

	uint8_t set_modem_freq_dev_command[] = {0x11, 0x20, 0x03, 0x0A, modem_freq_dev_2, modem_freq_dev_1, modem_freq_dev_0};
	Si4464_write(radio, set_modem_freq_dev_command, 7);
 800dc08:	2207      	movs	r2, #7
	uint32_t modem_freq_dev = (uint32_t)(units_per_hz * shift / 2.0 );
	uint8_t modem_freq_dev_0 = 0xFF & modem_freq_dev;
	uint8_t modem_freq_dev_1 = 0xFF & (modem_freq_dev >> 8);
	uint8_t modem_freq_dev_2 = 0xFF & (modem_freq_dev >> 16);

	uint8_t set_modem_freq_dev_command[] = {0x11, 0x20, 0x03, 0x0A, modem_freq_dev_2, modem_freq_dev_1, modem_freq_dev_0};
 800dc0a:	ea4f 4e10 	mov.w	lr, r0, lsr #16
 800dc0e:	0a03      	lsrs	r3, r0, #8
 800dc10:	f88d 0022 	strb.w	r0, [sp, #34]	; 0x22
	Si4464_write(radio, set_modem_freq_dev_command, 7);
 800dc14:	a907      	add	r1, sp, #28
 800dc16:	4628      	mov	r0, r5
	uint32_t modem_freq_dev = (uint32_t)(units_per_hz * shift / 2.0 );
	uint8_t modem_freq_dev_0 = 0xFF & modem_freq_dev;
	uint8_t modem_freq_dev_1 = 0xFF & (modem_freq_dev >> 8);
	uint8_t modem_freq_dev_2 = 0xFF & (modem_freq_dev >> 16);

	uint8_t set_modem_freq_dev_command[] = {0x11, 0x20, 0x03, 0x0A, modem_freq_dev_2, modem_freq_dev_1, modem_freq_dev_0};
 800dc18:	f88d 601c 	strb.w	r6, [sp, #28]
 800dc1c:	f88d 801d 	strb.w	r8, [sp, #29]
 800dc20:	f88d 701e 	strb.w	r7, [sp, #30]
 800dc24:	f88d 401f 	strb.w	r4, [sp, #31]
 800dc28:	f88d e020 	strb.w	lr, [sp, #32]
 800dc2c:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
	Si4464_write(radio, set_modem_freq_dev_command, 7);
 800dc30:	f002 f8d6 	bl	800fde0 <Si4464_write>
 800dc34:	e7a5      	b.n	800db82 <radioTune.constprop.18+0x1f2>
 800dc36:	bf00      	nop
 800dc38:	00000000 	.word	0x00000000
 800dc3c:	40945000 	.word	0x40945000
 800dc40:	c0000000 	.word	0xc0000000
 800dc44:	4188cb88 	.word	0x4188cb88
 800dc48:	20027b2c 	.word	0x20027b2c
 800dc4c:	d1b71759 	.word	0xd1b71759
 800dc50:	08013c50 	.word	0x08013c50
 800dc54:	20027e60 	.word	0x20027e60
 800dc58:	08013cfc 	.word	0x08013cfc
 800dc5c:	08013c5c 	.word	0x08013c5c
 800dc60:	080155e4 	.word	0x080155e4
 800dc64:	08013c78 	.word	0x08013c78
 800dc68:	08013d00 	.word	0x08013d00
 800dc6c:	08015aa0 	.word	0x08015aa0
 800dc70:	08013cac 	.word	0x08013cac
 800dc74:	f8e83440 	.word	0xf8e83440
 800dc78:	377deec0 	.word	0x377deec0
 800dc7c:	2a05723f 	.word	0x2a05723f
 800dc80:	1f4add3f 	.word	0x1f4add3f
 800dc84:	150a5a3f 	.word	0x150a5a3f
 800dc88:	0e3ed9bf 	.word	0x0e3ed9bf
 800dc8c:	0a8cce3f 	.word	0x0a8cce3f
 800dc90:	20027898 	.word	0x20027898
 800dc94:	03197118 	.word	0x03197118
 800dc98:	a531b8d7 	.word	0xa531b8d7
 800dc9c:	4bc65c46 	.word	0x4bc65c46
 800dca0:	3fe00000 	.word	0x3fe00000
 800dca4:	10624dd3 	.word	0x10624dd3
		TRACE_ERROR("SI %d > abort transmission", radio);
		return false;
	}

	if(!RADIO_WITHIN_MAX_PWR(radio, level)) {
		TRACE_WARN("SI %d > Power level out of range (max. %d dBm)", radio, RADIO_MAX_PWR(radio));
 800dca8:	4895      	ldr	r0, [pc, #596]	; (800df00 <radioTune.constprop.18+0x570>)
 800dcaa:	f001 f921 	bl	800eef0 <chMtxLock>
 800dcae:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800dcb2:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800dcb6:	4993      	ldr	r1, [pc, #588]	; (800df04 <radioTune.constprop.18+0x574>)
 800dcb8:	4893      	ldr	r0, [pc, #588]	; (800df08 <radioTune.constprop.18+0x578>)
 800dcba:	fb06 fe03 	mul.w	lr, r6, r3
 800dcbe:	fba7 3e0e 	umull	r3, lr, r7, lr
 800dcc2:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 800dcc6:	fba9 c30e 	umull	ip, r3, r9, lr
 800dcca:	fba7 c202 	umull	ip, r2, r7, r2
 800dcce:	099b      	lsrs	r3, r3, #6
 800dcd0:	fb06 e313 	mls	r3, r6, r3, lr
 800dcd4:	0b92      	lsrs	r2, r2, #14
 800dcd6:	f004 fd03 	bl	80126e0 <chprintf.constprop.35>
 800dcda:	4a8c      	ldr	r2, [pc, #560]	; (800df0c <radioTune.constprop.18+0x57c>)
 800dcdc:	498c      	ldr	r1, [pc, #560]	; (800df10 <radioTune.constprop.18+0x580>)
 800dcde:	488a      	ldr	r0, [pc, #552]	; (800df08 <radioTune.constprop.18+0x578>)
 800dce0:	f004 fcfe 	bl	80126e0 <chprintf.constprop.35>
 800dce4:	f44f 73ab 	mov.w	r3, #342	; 0x156
 800dce8:	4a8a      	ldr	r2, [pc, #552]	; (800df14 <radioTune.constprop.18+0x584>)
 800dcea:	498b      	ldr	r1, [pc, #556]	; (800df18 <radioTune.constprop.18+0x588>)
 800dcec:	4886      	ldr	r0, [pc, #536]	; (800df08 <radioTune.constprop.18+0x578>)
 800dcee:	f004 fcf7 	bl	80126e0 <chprintf.constprop.35>
 800dcf2:	498a      	ldr	r1, [pc, #552]	; (800df1c <radioTune.constprop.18+0x58c>)
 800dcf4:	4884      	ldr	r0, [pc, #528]	; (800df08 <radioTune.constprop.18+0x578>)
 800dcf6:	f004 fcf3 	bl	80126e0 <chprintf.constprop.35>
 800dcfa:	462a      	mov	r2, r5
 800dcfc:	2314      	movs	r3, #20
 800dcfe:	4988      	ldr	r1, [pc, #544]	; (800df20 <radioTune.constprop.18+0x590>)
 800dd00:	4881      	ldr	r0, [pc, #516]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd02:	f004 fced 	bl	80126e0 <chprintf.constprop.35>
 800dd06:	4987      	ldr	r1, [pc, #540]	; (800df24 <radioTune.constprop.18+0x594>)
 800dd08:	487f      	ldr	r0, [pc, #508]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd0a:	f004 fce9 	bl	80126e0 <chprintf.constprop.35>
 800dd0e:	487c      	ldr	r0, [pc, #496]	; (800df00 <radioTune.constprop.18+0x570>)
 800dd10:	f001 f88e 	bl	800ee30 <chMtxUnlock>
		TRACE_WARN("SI %d > Reducing power level to %d dBm", radio, RADIO_MAX_PWR(radio));
 800dd14:	487a      	ldr	r0, [pc, #488]	; (800df00 <radioTune.constprop.18+0x570>)
 800dd16:	f001 f8eb 	bl	800eef0 <chMtxLock>
 800dd1a:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800dd1e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800dd22:	4978      	ldr	r1, [pc, #480]	; (800df04 <radioTune.constprop.18+0x574>)
 800dd24:	4878      	ldr	r0, [pc, #480]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd26:	fb06 fe03 	mul.w	lr, r6, r3
 800dd2a:	fba7 3e0e 	umull	r3, lr, r7, lr
 800dd2e:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 800dd32:	fba9 c30e 	umull	ip, r3, r9, lr
 800dd36:	fba7 c202 	umull	ip, r2, r7, r2
 800dd3a:	099b      	lsrs	r3, r3, #6
 800dd3c:	fb06 e313 	mls	r3, r6, r3, lr
 800dd40:	0b92      	lsrs	r2, r2, #14
 800dd42:	f004 fccd 	bl	80126e0 <chprintf.constprop.35>
 800dd46:	4a71      	ldr	r2, [pc, #452]	; (800df0c <radioTune.constprop.18+0x57c>)
 800dd48:	4971      	ldr	r1, [pc, #452]	; (800df10 <radioTune.constprop.18+0x580>)
 800dd4a:	486f      	ldr	r0, [pc, #444]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd4c:	f004 fcc8 	bl	80126e0 <chprintf.constprop.35>
 800dd50:	f240 1357 	movw	r3, #343	; 0x157
 800dd54:	4a6f      	ldr	r2, [pc, #444]	; (800df14 <radioTune.constprop.18+0x584>)
 800dd56:	4970      	ldr	r1, [pc, #448]	; (800df18 <radioTune.constprop.18+0x588>)
 800dd58:	486b      	ldr	r0, [pc, #428]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd5a:	f004 fcc1 	bl	80126e0 <chprintf.constprop.35>
 800dd5e:	496f      	ldr	r1, [pc, #444]	; (800df1c <radioTune.constprop.18+0x58c>)
 800dd60:	4869      	ldr	r0, [pc, #420]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd62:	f004 fcbd 	bl	80126e0 <chprintf.constprop.35>
 800dd66:	462a      	mov	r2, r5
 800dd68:	2314      	movs	r3, #20
 800dd6a:	496f      	ldr	r1, [pc, #444]	; (800df28 <radioTune.constprop.18+0x598>)
 800dd6c:	4866      	ldr	r0, [pc, #408]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd6e:	f004 fcb7 	bl	80126e0 <chprintf.constprop.35>
 800dd72:	496c      	ldr	r1, [pc, #432]	; (800df24 <radioTune.constprop.18+0x594>)
 800dd74:	4864      	ldr	r0, [pc, #400]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd76:	f004 fcb3 	bl	80126e0 <chprintf.constprop.35>
 800dd7a:	4861      	ldr	r0, [pc, #388]	; (800df00 <radioTune.constprop.18+0x570>)
 800dd7c:	f001 f858 	bl	800ee30 <chMtxUnlock>
		TRACE_WARN("SI %d > continue transmission", radio);
 800dd80:	485f      	ldr	r0, [pc, #380]	; (800df00 <radioTune.constprop.18+0x570>)
 800dd82:	f001 f8b5 	bl	800eef0 <chMtxLock>
 800dd86:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800dd8a:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800dd8e:	495d      	ldr	r1, [pc, #372]	; (800df04 <radioTune.constprop.18+0x574>)
 800dd90:	485d      	ldr	r0, [pc, #372]	; (800df08 <radioTune.constprop.18+0x578>)
 800dd92:	fb06 f303 	mul.w	r3, r6, r3
 800dd96:	fba7 e303 	umull	lr, r3, r7, r3
 800dd9a:	0b9b      	lsrs	r3, r3, #14
 800dd9c:	fba9 e903 	umull	lr, r9, r9, r3
 800dda0:	ea4f 1999 	mov.w	r9, r9, lsr #6
 800dda4:	fba7 7202 	umull	r7, r2, r7, r2
 800dda8:	fb06 3319 	mls	r3, r6, r9, r3
 800ddac:	0b92      	lsrs	r2, r2, #14
 800ddae:	f004 fc97 	bl	80126e0 <chprintf.constprop.35>
 800ddb2:	4a56      	ldr	r2, [pc, #344]	; (800df0c <radioTune.constprop.18+0x57c>)
 800ddb4:	4956      	ldr	r1, [pc, #344]	; (800df10 <radioTune.constprop.18+0x580>)
 800ddb6:	4854      	ldr	r0, [pc, #336]	; (800df08 <radioTune.constprop.18+0x578>)
 800ddb8:	f004 fc92 	bl	80126e0 <chprintf.constprop.35>
 800ddbc:	f44f 73ac 	mov.w	r3, #344	; 0x158
 800ddc0:	4a54      	ldr	r2, [pc, #336]	; (800df14 <radioTune.constprop.18+0x584>)
 800ddc2:	4955      	ldr	r1, [pc, #340]	; (800df18 <radioTune.constprop.18+0x588>)
 800ddc4:	4850      	ldr	r0, [pc, #320]	; (800df08 <radioTune.constprop.18+0x578>)
 800ddc6:	f004 fc8b 	bl	80126e0 <chprintf.constprop.35>
 800ddca:	4954      	ldr	r1, [pc, #336]	; (800df1c <radioTune.constprop.18+0x58c>)
 800ddcc:	484e      	ldr	r0, [pc, #312]	; (800df08 <radioTune.constprop.18+0x578>)
 800ddce:	f004 fc87 	bl	80126e0 <chprintf.constprop.35>
 800ddd2:	462a      	mov	r2, r5
 800ddd4:	4955      	ldr	r1, [pc, #340]	; (800df2c <radioTune.constprop.18+0x59c>)
 800ddd6:	484c      	ldr	r0, [pc, #304]	; (800df08 <radioTune.constprop.18+0x578>)
 800ddd8:	f004 fc82 	bl	80126e0 <chprintf.constprop.35>
 800dddc:	4951      	ldr	r1, [pc, #324]	; (800df24 <radioTune.constprop.18+0x594>)
 800ddde:	484a      	ldr	r0, [pc, #296]	; (800df08 <radioTune.constprop.18+0x578>)
 800dde0:	f004 fc7e 	bl	80126e0 <chprintf.constprop.35>
 800dde4:	4846      	ldr	r0, [pc, #280]	; (800df00 <radioTune.constprop.18+0x570>)
 800dde6:	f001 f823 	bl	800ee30 <chMtxUnlock>
 800ddea:	e61e      	b.n	800da2a <radioTune.constprop.18+0x9a>
bool radioTune(radio_t radio, uint32_t frequency, uint16_t shift, int8_t level, uint16_t size) {
	// Tracing
	TRACE_INFO("SI %d > Tune Si4464", radio);

	if(!RADIO_WITHIN_FREQ_RANGE(frequency)) {
		TRACE_ERROR("SI %d > Frequency out of range", radio);
 800ddec:	4844      	ldr	r0, [pc, #272]	; (800df00 <radioTune.constprop.18+0x570>)
 800ddee:	f001 f87f 	bl	800eef0 <chMtxLock>
 800ddf2:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800ddf6:	f8d8 4024 	ldr.w	r4, [r8, #36]	; 0x24
 800ddfa:	4942      	ldr	r1, [pc, #264]	; (800df04 <radioTune.constprop.18+0x574>)
 800ddfc:	4842      	ldr	r0, [pc, #264]	; (800df08 <radioTune.constprop.18+0x578>)
 800ddfe:	fb06 f404 	mul.w	r4, r6, r4
 800de02:	fba7 3404 	umull	r3, r4, r7, r4
 800de06:	0ba4      	lsrs	r4, r4, #14
 800de08:	fba9 e304 	umull	lr, r3, r9, r4
 800de0c:	fba7 e202 	umull	lr, r2, r7, r2
 800de10:	099b      	lsrs	r3, r3, #6
 800de12:	fb06 4313 	mls	r3, r6, r3, r4
 800de16:	0b92      	lsrs	r2, r2, #14
 800de18:	f004 fc62 	bl	80126e0 <chprintf.constprop.35>
 800de1c:	4a44      	ldr	r2, [pc, #272]	; (800df30 <radioTune.constprop.18+0x5a0>)
 800de1e:	493c      	ldr	r1, [pc, #240]	; (800df10 <radioTune.constprop.18+0x580>)
 800de20:	4839      	ldr	r0, [pc, #228]	; (800df08 <radioTune.constprop.18+0x578>)
 800de22:	f004 fc5d 	bl	80126e0 <chprintf.constprop.35>
 800de26:	f44f 73a8 	mov.w	r3, #336	; 0x150
 800de2a:	4a3a      	ldr	r2, [pc, #232]	; (800df14 <radioTune.constprop.18+0x584>)
 800de2c:	493a      	ldr	r1, [pc, #232]	; (800df18 <radioTune.constprop.18+0x588>)
 800de2e:	4836      	ldr	r0, [pc, #216]	; (800df08 <radioTune.constprop.18+0x578>)
 800de30:	f004 fc56 	bl	80126e0 <chprintf.constprop.35>
 800de34:	4939      	ldr	r1, [pc, #228]	; (800df1c <radioTune.constprop.18+0x58c>)
 800de36:	4834      	ldr	r0, [pc, #208]	; (800df08 <radioTune.constprop.18+0x578>)
 800de38:	f004 fc52 	bl	80126e0 <chprintf.constprop.35>
 800de3c:	462a      	mov	r2, r5
 800de3e:	493d      	ldr	r1, [pc, #244]	; (800df34 <radioTune.constprop.18+0x5a4>)
 800de40:	4831      	ldr	r0, [pc, #196]	; (800df08 <radioTune.constprop.18+0x578>)
 800de42:	f004 fc4d 	bl	80126e0 <chprintf.constprop.35>
 800de46:	4937      	ldr	r1, [pc, #220]	; (800df24 <radioTune.constprop.18+0x594>)
 800de48:	482f      	ldr	r0, [pc, #188]	; (800df08 <radioTune.constprop.18+0x578>)
 800de4a:	f004 fc49 	bl	80126e0 <chprintf.constprop.35>
 800de4e:	482c      	ldr	r0, [pc, #176]	; (800df00 <radioTune.constprop.18+0x570>)
 800de50:	f000 ffee 	bl	800ee30 <chMtxUnlock>
 800de54:	f44f 71a8 	mov.w	r1, #336	; 0x150
 800de58:	482e      	ldr	r0, [pc, #184]	; (800df14 <radioTune.constprop.18+0x584>)
 800de5a:	f002 f881 	bl	800ff60 <log_error>
		TRACE_ERROR("SI %d > abort transmission", radio);
 800de5e:	4828      	ldr	r0, [pc, #160]	; (800df00 <radioTune.constprop.18+0x570>)
 800de60:	f001 f846 	bl	800eef0 <chMtxLock>
 800de64:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800de68:	f8d8 4024 	ldr.w	r4, [r8, #36]	; 0x24
 800de6c:	4925      	ldr	r1, [pc, #148]	; (800df04 <radioTune.constprop.18+0x574>)
 800de6e:	4826      	ldr	r0, [pc, #152]	; (800df08 <radioTune.constprop.18+0x578>)
 800de70:	fb06 f404 	mul.w	r4, r6, r4
 800de74:	fba7 3404 	umull	r3, r4, r7, r4
 800de78:	0ba4      	lsrs	r4, r4, #14
 800de7a:	fba9 e304 	umull	lr, r3, r9, r4
 800de7e:	fba7 7202 	umull	r7, r2, r7, r2
 800de82:	099b      	lsrs	r3, r3, #6
 800de84:	fb06 4313 	mls	r3, r6, r3, r4
 800de88:	0b92      	lsrs	r2, r2, #14
 800de8a:	f004 fc29 	bl	80126e0 <chprintf.constprop.35>
 800de8e:	4a28      	ldr	r2, [pc, #160]	; (800df30 <radioTune.constprop.18+0x5a0>)
 800de90:	491f      	ldr	r1, [pc, #124]	; (800df10 <radioTune.constprop.18+0x580>)
 800de92:	481d      	ldr	r0, [pc, #116]	; (800df08 <radioTune.constprop.18+0x578>)
 800de94:	f004 fc24 	bl	80126e0 <chprintf.constprop.35>
 800de98:	f240 1351 	movw	r3, #337	; 0x151
 800de9c:	4a1d      	ldr	r2, [pc, #116]	; (800df14 <radioTune.constprop.18+0x584>)
 800de9e:	491e      	ldr	r1, [pc, #120]	; (800df18 <radioTune.constprop.18+0x588>)
 800dea0:	4819      	ldr	r0, [pc, #100]	; (800df08 <radioTune.constprop.18+0x578>)
 800dea2:	f004 fc1d 	bl	80126e0 <chprintf.constprop.35>
 800dea6:	491d      	ldr	r1, [pc, #116]	; (800df1c <radioTune.constprop.18+0x58c>)
 800dea8:	4817      	ldr	r0, [pc, #92]	; (800df08 <radioTune.constprop.18+0x578>)
 800deaa:	f004 fc19 	bl	80126e0 <chprintf.constprop.35>
 800deae:	462a      	mov	r2, r5
 800deb0:	4921      	ldr	r1, [pc, #132]	; (800df38 <radioTune.constprop.18+0x5a8>)
 800deb2:	4815      	ldr	r0, [pc, #84]	; (800df08 <radioTune.constprop.18+0x578>)
 800deb4:	f004 fc14 	bl	80126e0 <chprintf.constprop.35>
 800deb8:	491a      	ldr	r1, [pc, #104]	; (800df24 <radioTune.constprop.18+0x594>)
 800deba:	4813      	ldr	r0, [pc, #76]	; (800df08 <radioTune.constprop.18+0x578>)
 800debc:	f004 fc10 	bl	80126e0 <chprintf.constprop.35>
 800dec0:	480f      	ldr	r0, [pc, #60]	; (800df00 <radioTune.constprop.18+0x570>)
 800dec2:	f000 ffb5 	bl	800ee30 <chMtxUnlock>
 800dec6:	f240 1151 	movw	r1, #337	; 0x151
 800deca:	4812      	ldr	r0, [pc, #72]	; (800df14 <radioTune.constprop.18+0x584>)
 800decc:	f002 f848 	bl	800ff60 <log_error>
		return false;
 800ded0:	2000      	movs	r0, #0
	setShift(radio, shift);					// Set shift
	setPowerLevel(radio, level);			// Set power level

	startTx(radio, size);
	return true;
}
 800ded2:	b00b      	add	sp, #44	; 0x2c
 800ded4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
}

void setFrequency(radio_t radio, uint32_t freq, uint16_t shift) {
	// Set the output divider according to recommended ranges given in Si4464 datasheet
	uint32_t band = 0;
	if(freq < 705000000UL) {outdiv = 6;  band = 1;};
 800ded8:	4f18      	ldr	r7, [pc, #96]	; (800df3c <radioTune.constprop.18+0x5ac>)
 800deda:	2306      	movs	r3, #6
 800dedc:	603b      	str	r3, [r7, #0]
 800dede:	2309      	movs	r3, #9
 800dee0:	e5bd      	b.n	800da5e <radioTune.constprop.18+0xce>
	if(freq < 525000000UL) {outdiv = 8;  band = 2;};
 800dee2:	4f16      	ldr	r7, [pc, #88]	; (800df3c <radioTune.constprop.18+0x5ac>)
 800dee4:	2308      	movs	r3, #8
 800dee6:	603b      	str	r3, [r7, #0]
 800dee8:	230a      	movs	r3, #10
 800deea:	e5b8      	b.n	800da5e <radioTune.constprop.18+0xce>
	if(freq < 353000000UL) {outdiv = 12; band = 3;};
 800deec:	4f13      	ldr	r7, [pc, #76]	; (800df3c <radioTune.constprop.18+0x5ac>)
 800deee:	230c      	movs	r3, #12
 800def0:	603b      	str	r3, [r7, #0]
 800def2:	230b      	movs	r3, #11
 800def4:	e5b3      	b.n	800da5e <radioTune.constprop.18+0xce>
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
 800def6:	2310      	movs	r3, #16
 800def8:	603b      	str	r3, [r7, #0]
 800defa:	230c      	movs	r3, #12
 800defc:	e5af      	b.n	800da5e <radioTune.constprop.18+0xce>
 800defe:	bf00      	nop
 800df00:	20027b2c 	.word	0x20027b2c
 800df04:	08013c50 	.word	0x08013c50
 800df08:	20027e60 	.word	0x20027e60
 800df0c:	08013cb0 	.word	0x08013cb0
 800df10:	08013c5c 	.word	0x08013c5c
 800df14:	080155e4 	.word	0x080155e4
 800df18:	08013c78 	.word	0x08013c78
 800df1c:	08013d00 	.word	0x08013d00
 800df20:	08015af0 	.word	0x08015af0
 800df24:	08013cac 	.word	0x08013cac
 800df28:	08015b20 	.word	0x08015b20
 800df2c:	08015b48 	.word	0x08015b48
 800df30:	08013d9c 	.word	0x08013d9c
 800df34:	08015ab4 	.word	0x08015ab4
 800df38:	08015ad4 	.word	0x08015ad4
 800df3c:	20027898 	.word	0x20027898

0800df40 <ax25_send_header.constprop.16>:
	for(i=0; string[i]; i++) {
		ax25_send_byte(packet, string[i]);
	}
}

void ax25_send_header(ax25_t *packet, const char *callsign, uint8_t ssid, const char *path, uint16_t preamble)
 800df40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800df44:	4604      	mov	r4, r0
 800df46:	b084      	sub	sp, #16
	packet->size = 0;
	packet->ones_in_a_row = 0;
	packet->crc = 0xffff;

	// Send preamble ("a bunch of 0s")
	if(packet->mod == MOD_2GFSK) {
 800df48:	f894 e00e 	ldrb.w	lr, [r4, #14]
{
	uint8_t i, j;
	uint8_t tmp[8];
	packet->size = 0;
	packet->ones_in_a_row = 0;
	packet->crc = 0xffff;
 800df4c:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800df50:	81a0      	strh	r0, [r4, #12]

	// Send preamble ("a bunch of 0s")
	if(packet->mod == MOD_2GFSK) {
 800df52:	f1be 0f02 	cmp.w	lr, #2

void ax25_send_header(ax25_t *packet, const char *callsign, uint8_t ssid, const char *path, uint16_t preamble)
{
	uint8_t i, j;
	uint8_t tmp[8];
	packet->size = 0;
 800df56:	f04f 0000 	mov.w	r0, #0
	for(i=0; string[i]; i++) {
		ax25_send_byte(packet, string[i]);
	}
}

void ax25_send_header(ax25_t *packet, const char *callsign, uint8_t ssid, const char *path, uint16_t preamble)
 800df5a:	461d      	mov	r5, r3
 800df5c:	468a      	mov	sl, r1
 800df5e:	4617      	mov	r7, r2
{
	uint8_t i, j;
	uint8_t tmp[8];
	packet->size = 0;
 800df60:	8120      	strh	r0, [r4, #8]
	packet->ones_in_a_row = 0;
 800df62:	7020      	strb	r0, [r4, #0]
	for(i=0; string[i]; i++) {
		ax25_send_byte(packet, string[i]);
	}
}

void ax25_send_header(ax25_t *packet, const char *callsign, uint8_t ssid, const char *path, uint16_t preamble)
 800df64:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
	packet->size = 0;
	packet->ones_in_a_row = 0;
	packet->crc = 0xffff;

	// Send preamble ("a bunch of 0s")
	if(packet->mod == MOD_2GFSK) {
 800df68:	f000 80ac 	beq.w	800e0c4 <ax25_send_header.constprop.16+0x184>
		preamble = preamble * 6 / 5;
	} else {
		preamble = preamble * 3 / 20;
 800df6c:	4a5b      	ldr	r2, [pc, #364]	; (800e0dc <ax25_send_header.constprop.16+0x19c>)
 800df6e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800df72:	fb82 2c03 	smull	r2, ip, r2, r3
 800df76:	17db      	asrs	r3, r3, #31
 800df78:	ebc3 0cec 	rsb	ip, r3, ip, asr #3
 800df7c:	fa1f fc8c 	uxth.w	ip, ip
	}
	for(i=0; i<preamble; i++)
 800df80:	f1bc 0f00 	cmp.w	ip, #0
 800df84:	d023      	beq.n	800dfce <ax25_send_header.constprop.16+0x8e>
 800df86:	2300      	movs	r3, #0
 800df88:	469e      	mov	lr, r3
		if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
			return;
		if((byte >> i) & 1)
			packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
		else
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800df8a:	2001      	movs	r0, #1
	if(packet->mod == MOD_2GFSK) {
		preamble = preamble * 6 / 5;
	} else {
		preamble = preamble * 3 / 20;
	}
	for(i=0; i<preamble; i++)
 800df8c:	2108      	movs	r1, #8
void ax25_send_sync(ax25_t *packet)
{
	unsigned char byte = 0x00;
	int i;
	for(i=0; i<8; i++, packet->size++) {
		if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800df8e:	f8b4 900a 	ldrh.w	r9, [r4, #10]
			return;
		if((byte >> i) & 1)
			packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
		else
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800df92:	f003 0207 	and.w	r2, r3, #7
void ax25_send_sync(ax25_t *packet)
{
	unsigned char byte = 0x00;
	int i;
	for(i=0; i<8; i++, packet->size++) {
		if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800df96:	ebb3 0fc9 	cmp.w	r3, r9, lsl #3
			return;
		if((byte >> i) & 1)
			packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
		else
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800df9a:	ea4f 08d3 	mov.w	r8, r3, lsr #3
 800df9e:	fa00 f202 	lsl.w	r2, r0, r2
void ax25_send_sync(ax25_t *packet)
{
	unsigned char byte = 0x00;
	int i;
	for(i=0; i<8; i++, packet->size++) {
		if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800dfa2:	da0c      	bge.n	800dfbe <ax25_send_header.constprop.16+0x7e>
			return;
		if((byte >> i) & 1)
			packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
		else
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800dfa4:	6866      	ldr	r6, [r4, #4]
 800dfa6:	f816 3008 	ldrb.w	r3, [r6, r8]
 800dfaa:	ea23 0202 	bic.w	r2, r3, r2
 800dfae:	f806 2008 	strb.w	r2, [r6, r8]

void ax25_send_sync(ax25_t *packet)
{
	unsigned char byte = 0x00;
	int i;
	for(i=0; i<8; i++, packet->size++) {
 800dfb2:	8923      	ldrh	r3, [r4, #8]
 800dfb4:	3301      	adds	r3, #1
 800dfb6:	b29b      	uxth	r3, r3
 800dfb8:	3901      	subs	r1, #1
 800dfba:	8123      	strh	r3, [r4, #8]
 800dfbc:	d1e7      	bne.n	800df8e <ax25_send_header.constprop.16+0x4e>
	if(packet->mod == MOD_2GFSK) {
		preamble = preamble * 6 / 5;
	} else {
		preamble = preamble * 3 / 20;
	}
	for(i=0; i<preamble; i++)
 800dfbe:	f10e 0e01 	add.w	lr, lr, #1
 800dfc2:	fa5f fe8e 	uxtb.w	lr, lr
 800dfc6:	45e6      	cmp	lr, ip
 800dfc8:	d201      	bcs.n	800dfce <ax25_send_header.constprop.16+0x8e>
 800dfca:	8923      	ldrh	r3, [r4, #8]
 800dfcc:	e7de      	b.n	800df8c <ax25_send_header.constprop.16+0x4c>
	}

	// Send flag
	for(uint8_t i=0; i<4; i++)
	{
		ax25_send_flag(packet);
 800dfce:	4620      	mov	r0, r4
 800dfd0:	f7fc fa96 	bl	800a500 <ax25_send_flag>
 800dfd4:	4620      	mov	r0, r4
 800dfd6:	f7fc fa93 	bl	800a500 <ax25_send_flag>
 800dfda:	4620      	mov	r0, r4
 800dfdc:	f7fc fa90 	bl	800a500 <ax25_send_flag>
 800dfe0:	4620      	mov	r0, r4
 800dfe2:	f7fc fa8d 	bl	800a500 <ax25_send_flag>
	}

	ax25_send_path(packet, APRS_DEST_CALLSIGN, APRS_DEST_SSID, false);		// Destination callsign
 800dfe6:	2300      	movs	r3, #0
 800dfe8:	461a      	mov	r2, r3
 800dfea:	493d      	ldr	r1, [pc, #244]	; (800e0e0 <ax25_send_header.constprop.16+0x1a0>)
 800dfec:	4620      	mov	r0, r4
 800dfee:	f7fc fb17 	bl	800a620 <ax25_send_path>
	ax25_send_path(packet, callsign, ssid, path[0] == 0 || path == NULL);	// Source callsign
 800dff2:	782b      	ldrb	r3, [r5, #0]
 800dff4:	fab3 f383 	clz	r3, r3
 800dff8:	463a      	mov	r2, r7
 800dffa:	095b      	lsrs	r3, r3, #5
 800dffc:	2600      	movs	r6, #0
 800dffe:	4651      	mov	r1, sl
 800e000:	4620      	mov	r0, r4
 800e002:	f7fc fb0d 	bl	800a620 <ax25_send_path>
		if(path[i] == ',' || path[i] == 0) { // Found block in path
			if(!j) // Block empty
				break;

			// Filter Path until '-'
			tmp[j] = 0;
 800e006:	4637      	mov	r7, r6

	ax25_send_path(packet, APRS_DEST_CALLSIGN, APRS_DEST_SSID, false);		// Destination callsign
	ax25_send_path(packet, callsign, ssid, path[0] == 0 || path == NULL);	// Source callsign

	// Parse path
	for(i=0, j=0; (path[i-1] != 0 || i == 0) && path != NULL; i++) {
 800e008:	4633      	mov	r3, r6
 800e00a:	b2f2      	uxtb	r2, r6
 800e00c:	18a9      	adds	r1, r5, r2
 800e00e:	f811 1c01 	ldrb.w	r1, [r1, #-1]
 800e012:	b959      	cbnz	r1, 800e02c <ax25_send_header.constprop.16+0xec>
 800e014:	b152      	cbz	r2, 800e02c <ax25_send_header.constprop.16+0xec>
			tmp[j++] = path[i];
		}
	}

	// Control field: 3 = APRS-UI frame
	send_byte(packet, 0x03);
 800e016:	4620      	mov	r0, r4
 800e018:	2103      	movs	r1, #3
 800e01a:	f7fc faa1 	bl	800a560 <send_byte.lto_priv.112>

	// Protocol ID: 0xf0 = no layer 3 data
	send_byte(packet, 0xf0);
 800e01e:	4620      	mov	r0, r4
 800e020:	21f0      	movs	r1, #240	; 0xf0
 800e022:	f7fc fa9d 	bl	800a560 <send_byte.lto_priv.112>
}
 800e026:	b004      	add	sp, #16
 800e028:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ax25_send_path(packet, APRS_DEST_CALLSIGN, APRS_DEST_SSID, false);		// Destination callsign
	ax25_send_path(packet, callsign, ssid, path[0] == 0 || path == NULL);	// Source callsign

	// Parse path
	for(i=0, j=0; (path[i-1] != 0 || i == 0) && path != NULL; i++) {
		if(path[i] == ',' || path[i] == 0) { // Found block in path
 800e02c:	f815 9002 	ldrb.w	r9, [r5, r2]
 800e030:	f1b9 0f2c 	cmp.w	r9, #44	; 0x2c
 800e034:	d00a      	beq.n	800e04c <ax25_send_header.constprop.16+0x10c>
 800e036:	f1b9 0f00 	cmp.w	r9, #0
 800e03a:	d007      	beq.n	800e04c <ax25_send_header.constprop.16+0x10c>
			if(s != 0)
				ax25_send_path(packet, p, s, path[i] == 0);
			j = 0;

		} else {
			tmp[j++] = path[i];
 800e03c:	aa04      	add	r2, sp, #16
 800e03e:	441a      	add	r2, r3
 800e040:	3301      	adds	r3, #1
 800e042:	f802 9c10 	strb.w	r9, [r2, #-16]
 800e046:	b2db      	uxtb	r3, r3
 800e048:	3601      	adds	r6, #1
 800e04a:	e7de      	b.n	800e00a <ax25_send_header.constprop.16+0xca>
	ax25_send_path(packet, callsign, ssid, path[0] == 0 || path == NULL);	// Source callsign

	// Parse path
	for(i=0, j=0; (path[i-1] != 0 || i == 0) && path != NULL; i++) {
		if(path[i] == ',' || path[i] == 0) { // Found block in path
			if(!j) // Block empty
 800e04c:	2b00      	cmp	r3, #0
 800e04e:	d0e2      	beq.n	800e016 <ax25_send_header.constprop.16+0xd6>
				break;

			// Filter Path until '-'
			tmp[j] = 0;
 800e050:	aa04      	add	r2, sp, #16
 800e052:	441a      	add	r2, r3
 800e054:	2100      	movs	r1, #0
 800e056:	f802 7c10 	strb.w	r7, [r2, #-16]
 800e05a:	4608      	mov	r0, r1
 800e05c:	f10d 3eff 	add.w	lr, sp, #4294967295
 800e060:	f10d 0c07 	add.w	ip, sp, #7
			char p[8];
			uint8_t t;
			for(t=0; t<j && tmp[t] != '-'; t++)
 800e064:	f81e 2f01 	ldrb.w	r2, [lr, #1]!
 800e068:	2a2d      	cmp	r2, #45	; 0x2d
 800e06a:	4688      	mov	r8, r1
 800e06c:	f101 0101 	add.w	r1, r1, #1
 800e070:	d012      	beq.n	800e098 <ax25_send_header.constprop.16+0x158>
 800e072:	b2c8      	uxtb	r0, r1
 800e074:	4283      	cmp	r3, r0
				p[t] = tmp[t];
 800e076:	f80c 2f01 	strb.w	r2, [ip, #1]!

			// Filter Path until '-'
			tmp[j] = 0;
			char p[8];
			uint8_t t;
			for(t=0; t<j && tmp[t] != '-'; t++)
 800e07a:	d8f3      	bhi.n	800e064 <ax25_send_header.constprop.16+0x124>
				p[t] = tmp[t];
			p[t] = 0;
 800e07c:	ab04      	add	r3, sp, #16
 800e07e:	4403      	add	r3, r0

			// Filter TTL
			uint8_t s = ((tmp[t] == '-' ? tmp[++t] : tmp[--t])-48) & 0x7;
 800e080:	f813 1c10 	ldrb.w	r1, [r3, #-16]
			tmp[j] = 0;
			char p[8];
			uint8_t t;
			for(t=0; t<j && tmp[t] != '-'; t++)
				p[t] = tmp[t];
			p[t] = 0;
 800e084:	f803 7c08 	strb.w	r7, [r3, #-8]

			// Filter TTL
			uint8_t s = ((tmp[t] == '-' ? tmp[++t] : tmp[--t])-48) & 0x7;
 800e088:	292d      	cmp	r1, #45	; 0x2d
 800e08a:	bf18      	it	ne
 800e08c:	f002 0207 	andne.w	r2, r2, #7
 800e090:	d006      	beq.n	800e0a0 <ax25_send_header.constprop.16+0x160>

			if(s != 0)
 800e092:	b97a      	cbnz	r2, 800e0b4 <ax25_send_header.constprop.16+0x174>
				ax25_send_path(packet, p, s, path[i] == 0);
			j = 0;
 800e094:	2300      	movs	r3, #0
 800e096:	e7d7      	b.n	800e048 <ax25_send_header.constprop.16+0x108>
			tmp[j] = 0;
			char p[8];
			uint8_t t;
			for(t=0; t<j && tmp[t] != '-'; t++)
				p[t] = tmp[t];
			p[t] = 0;
 800e098:	ab04      	add	r3, sp, #16
 800e09a:	4498      	add	r8, r3
 800e09c:	f808 7c08 	strb.w	r7, [r8, #-8]

			// Filter TTL
			uint8_t s = ((tmp[t] == '-' ? tmp[++t] : tmp[--t])-48) & 0x7;
 800e0a0:	aa04      	add	r2, sp, #16
 800e0a2:	1c43      	adds	r3, r0, #1
 800e0a4:	fa52 f383 	uxtab	r3, r2, r3
 800e0a8:	f813 2c10 	ldrb.w	r2, [r3, #-16]
 800e0ac:	f002 0207 	and.w	r2, r2, #7

			if(s != 0)
 800e0b0:	2a00      	cmp	r2, #0
 800e0b2:	d0ef      	beq.n	800e094 <ax25_send_header.constprop.16+0x154>
				ax25_send_path(packet, p, s, path[i] == 0);
 800e0b4:	fab9 f389 	clz	r3, r9
 800e0b8:	095b      	lsrs	r3, r3, #5
 800e0ba:	a902      	add	r1, sp, #8
 800e0bc:	4620      	mov	r0, r4
 800e0be:	f7fc faaf 	bl	800a620 <ax25_send_path>
 800e0c2:	e7e7      	b.n	800e094 <ax25_send_header.constprop.16+0x154>
	packet->ones_in_a_row = 0;
	packet->crc = 0xffff;

	// Send preamble ("a bunch of 0s")
	if(packet->mod == MOD_2GFSK) {
		preamble = preamble * 6 / 5;
 800e0c4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800e0c8:	4a04      	ldr	r2, [pc, #16]	; (800e0dc <ax25_send_header.constprop.16+0x19c>)
 800e0ca:	005b      	lsls	r3, r3, #1
 800e0cc:	fb82 2c03 	smull	r2, ip, r2, r3
 800e0d0:	17db      	asrs	r3, r3, #31
 800e0d2:	ebc3 0c6c 	rsb	ip, r3, ip, asr #1
 800e0d6:	fa1f fc8c 	uxth.w	ip, ip
 800e0da:	e751      	b.n	800df80 <ax25_send_header.constprop.16+0x40>
 800e0dc:	66666667 	.word	0x66666667
 800e0e0:	08015b68 	.word	0x08015b68
	...

0800e0f0 <f_mount.constprop.12>:

/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Logical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT f_mount (
 800e0f0:	b510      	push	{r4, lr}
 800e0f2:	b082      	sub	sp, #8
)
{
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 800e0f4:	ab02      	add	r3, sp, #8

/*-----------------------------------------------------------------------*/
/* Mount/Unmount a Logical Drive                                         */
/*-----------------------------------------------------------------------*/

FRESULT f_mount (
 800e0f6:	4604      	mov	r4, r0
)
{
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 800e0f8:	f843 1d04 	str.w	r1, [r3, #-4]!


	vol = get_ldnumber(&rp);
 800e0fc:	4618      	mov	r0, r3
 800e0fe:	f003 fdbf 	bl	8011c80 <get_ldnumber.lto_priv.113>
	if (vol < 0) return FR_INVALID_DRIVE;
 800e102:	2800      	cmp	r0, #0
 800e104:	db0d      	blt.n	800e122 <f_mount.constprop.12+0x32>
	cfs = FatFs[vol];					/* Pointer to fs object */
 800e106:	4b08      	ldr	r3, [pc, #32]	; (800e128 <f_mount.constprop.12+0x38>)
 800e108:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]

	if (cfs) {
 800e10c:	b10a      	cbz	r2, 800e112 <f_mount.constprop.12+0x22>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 800e10e:	2100      	movs	r1, #0
 800e110:	7011      	strb	r1, [r2, #0]
	}

	if (fs) {
 800e112:	b10c      	cbz	r4, 800e118 <f_mount.constprop.12+0x28>
		fs->fs_type = 0;				/* Clear new fs object */
 800e114:	2200      	movs	r2, #0
 800e116:	7022      	strb	r2, [r4, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 800e118:	f843 4020 	str.w	r4, [r3, r0, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800e11c:	2000      	movs	r0, #0

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 800e11e:	b002      	add	sp, #8
 800e120:	bd10      	pop	{r4, pc}
	FRESULT res;
	const TCHAR *rp = path;


	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
 800e122:	200b      	movs	r0, #11

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 800e124:	b002      	add	sp, #8
 800e126:	bd10      	pop	{r4, pc}
 800e128:	20027b3c 	.word	0x20027b3c
 800e12c:	00000000 	.word	0x00000000

0800e130 <dir_sdi.constprop.11>:
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
 800e130:	6881      	ldr	r1, [r0, #8]
{
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
 800e132:	2300      	movs	r3, #0
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 800e134:	2901      	cmp	r1, #1
{
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
 800e136:	80c3      	strh	r3, [r0, #6]
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 800e138:	d003      	beq.n	800e142 <dir_sdi.constprop.11+0x12>
 800e13a:	6803      	ldr	r3, [r0, #0]
 800e13c:	695a      	ldr	r2, [r3, #20]
 800e13e:	4291      	cmp	r1, r2
 800e140:	d301      	bcc.n	800e146 <dir_sdi.constprop.11+0x16>
		return FR_INT_ERR;
 800e142:	2002      	movs	r0, #2
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;
}
 800e144:	4770      	bx	lr
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (
 800e146:	b570      	push	{r4, r5, r6, lr}

	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 800e148:	b951      	cbnz	r1, 800e160 <dir_sdi.constprop.11+0x30>
 800e14a:	781c      	ldrb	r4, [r3, #0]
 800e14c:	2c03      	cmp	r4, #3
 800e14e:	d003      	beq.n	800e158 <dir_sdi.constprop.11+0x28>
		clst = dp->fs->dirbase;

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
 800e150:	891a      	ldrh	r2, [r3, #8]
 800e152:	b9e2      	cbnz	r2, 800e18e <dir_sdi.constprop.11+0x5e>
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
 800e154:	2002      	movs	r0, #2
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;
}
 800e156:	bd70      	pop	{r4, r5, r6, pc}
	dp->index = (WORD)idx;	/* Current index */
	clst = dp->sclust;		/* Table start cluster (0:root) */
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dp->fs->dirbase;
 800e158:	6a5c      	ldr	r4, [r3, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 800e15a:	2c00      	cmp	r4, #0
 800e15c:	d0f8      	beq.n	800e150 <dir_sdi.constprop.11+0x20>
 800e15e:	4621      	mov	r1, r4
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
 800e160:	789d      	ldrb	r5, [r3, #2]
 800e162:	4604      	mov	r4, r0
		while (idx >= ic) {	/* Follow cluster chain */
 800e164:	b135      	cbz	r5, 800e174 <dir_sdi.constprop.11+0x44>
 800e166:	e01b      	b.n	800e1a0 <dir_sdi.constprop.11+0x70>
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
 800e168:	2801      	cmp	r0, #1
 800e16a:	d9f3      	bls.n	800e154 <dir_sdi.constprop.11+0x24>
 800e16c:	6823      	ldr	r3, [r4, #0]
 800e16e:	695a      	ldr	r2, [r3, #20]
 800e170:	4290      	cmp	r0, r2
 800e172:	d2ef      	bcs.n	800e154 <dir_sdi.constprop.11+0x24>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 800e174:	2901      	cmp	r1, #1
 800e176:	d9ed      	bls.n	800e154 <dir_sdi.constprop.11+0x24>
 800e178:	695a      	ldr	r2, [r3, #20]
 800e17a:	428a      	cmp	r2, r1
 800e17c:	d9ea      	bls.n	800e154 <dir_sdi.constprop.11+0x24>
 800e17e:	4618      	mov	r0, r3
 800e180:	f003 fe5e 	bl	8011e40 <get_fat.part.6.lto_priv.114>
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800e184:	1c43      	adds	r3, r0, #1
 800e186:	4601      	mov	r1, r0
 800e188:	d1ee      	bne.n	800e168 <dir_sdi.constprop.11+0x38>
 800e18a:	2001      	movs	r0, #1
 800e18c:	bd70      	pop	{r4, r5, r6, pc}
		clst = dp->fs->dirbase;

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
 800e18e:	6a5d      	ldr	r5, [r3, #36]	; 0x24
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
 800e190:	60c1      	str	r1, [r0, #12]
	if (!sect) return FR_INT_ERR;
 800e192:	2d00      	cmp	r5, #0
 800e194:	d0de      	beq.n	800e154 <dir_sdi.constprop.11+0x24>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
 800e196:	3330      	adds	r3, #48	; 0x30
 800e198:	6143      	str	r3, [r0, #20]
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
	if (!sect) return FR_INT_ERR;
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
 800e19a:	6105      	str	r5, [r0, #16]
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;
 800e19c:	2000      	movs	r0, #0
 800e19e:	bd70      	pop	{r4, r5, r6, pc}
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800e1a0:	3a02      	subs	r2, #2
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 800e1a2:	1e8e      	subs	r6, r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800e1a4:	4296      	cmp	r6, r2
 800e1a6:	d203      	bcs.n	800e1b0 <dir_sdi.constprop.11+0x80>
	return clst * fs->csize + fs->database;
 800e1a8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e1aa:	fb06 2505 	mla	r5, r6, r5, r2
 800e1ae:	e7ef      	b.n	800e190 <dir_sdi.constprop.11+0x60>
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
	}
	dp->clust = clst;	/* Current cluster# */
 800e1b0:	60c1      	str	r1, [r0, #12]
 800e1b2:	e7cf      	b.n	800e154 <dir_sdi.constprop.11+0x24>
	...

0800e1c0 <i2cSendDriver.constprop.25>:
	STD_DUTY_CYCLE,
};

mutex_t pi2c_mtx;

bool i2cSendDriver(I2CDriver *driver, uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout) {
 800e1c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	i2cAcquireBus(driver);
	msg_t i2c_status = i2cMasterTransmitTimeout(driver, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800e1c4:	b284      	uxth	r4, r0
	STD_DUTY_CYCLE,
};

mutex_t pi2c_mtx;

bool i2cSendDriver(I2CDriver *driver, uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout) {
 800e1c6:	4605      	mov	r5, r0
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800e1c8:	48a2      	ldr	r0, [pc, #648]	; (800e454 <i2cSendDriver.constprop.25+0x294>)
 800e1ca:	460f      	mov	r7, r1
 800e1cc:	4616      	mov	r6, r2
 800e1ce:	4698      	mov	r8, r3
 800e1d0:	f000 fe8e 	bl	800eef0 <chMtxLock>
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 800e1d4:	2c00      	cmp	r4, #0
 800e1d6:	d069      	beq.n	800e2ac <i2cSendDriver.constprop.25+0xec>
 800e1d8:	2e00      	cmp	r6, #0
 800e1da:	d067      	beq.n	800e2ac <i2cSendDriver.constprop.25+0xec>
 800e1dc:	2f00      	cmp	r7, #0
 800e1de:	d065      	beq.n	800e2ac <i2cSendDriver.constprop.25+0xec>
 800e1e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e1e2:	2b00      	cmp	r3, #0
 800e1e4:	d15f      	bne.n	800e2a6 <i2cSendDriver.constprop.25+0xe6>
               (txbytes > 0U) && (txbuf != NULL) &&
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 800e1e6:	f8df 927c 	ldr.w	r9, [pc, #636]	; 800e464 <i2cSendDriver.constprop.25+0x2a4>
 800e1ea:	f899 3000 	ldrb.w	r3, [r9]
 800e1ee:	2b02      	cmp	r3, #2
 800e1f0:	d15c      	bne.n	800e2ac <i2cSendDriver.constprop.25+0xec>
 800e1f2:	2320      	movs	r3, #32
 800e1f4:	f383 8811 	msr	BASEPRI, r3
 800e1f8:	f8df a264 	ldr.w	sl, [pc, #612]	; 800e460 <i2cSendDriver.constprop.25+0x2a0>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800e1fc:	f000 fdc0 	bl	800ed80 <_dbg_check_lock>

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 800e200:	0064      	lsls	r4, r4, #1

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 800e202:	2303      	movs	r3, #3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800e204:	2200      	movs	r2, #0
  i2cp->state = I2C_ACTIVE_TX;
 800e206:	f889 3000 	strb.w	r3, [r9]
 800e20a:	f8a9 4020 	strh.w	r4, [r9, #32]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800e20e:	f8c9 2008 	str.w	r2, [r9, #8]
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 800e212:	f8d9 b034 	ldr.w	fp, [r9, #52]	; 0x34
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800e216:	f000 fda3 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800e21a:	f8da 3000 	ldr.w	r3, [sl]
 800e21e:	4553      	cmp	r3, sl
 800e220:	d005      	beq.n	800e22e <i2cSendDriver.constprop.25+0x6e>
 800e222:	f8da 2018 	ldr.w	r2, [sl, #24]
 800e226:	689b      	ldr	r3, [r3, #8]
 800e228:	6892      	ldr	r2, [r2, #8]
 800e22a:	429a      	cmp	r2, r3
 800e22c:	d341      	bcc.n	800e2b2 <i2cSendDriver.constprop.25+0xf2>
 800e22e:	2300      	movs	r3, #0
 800e230:	f383 8811 	msr	BASEPRI, r3

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800e234:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800e238:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800e23c:	6812      	ldr	r2, [r2, #0]
 800e23e:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800e242:	681b      	ldr	r3, [r3, #0]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800e244:	6011      	str	r1, [r2, #0]
 800e246:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800e24a:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 800e24e:	60d7      	str	r7, [r2, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 800e250:	6056      	str	r6, [r2, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 800e252:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800e254:	6019      	str	r1, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 800e256:	f8c3 800c 	str.w	r8, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 800e25a:	605a      	str	r2, [r3, #4]
 800e25c:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800e25e:	f8df 8200 	ldr.w	r8, [pc, #512]	; 800e460 <i2cSendDriver.constprop.25+0x2a0>
 800e262:	2620      	movs	r6, #32
 800e264:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800e268:	f000 fd8a 	bl	800ed80 <_dbg_check_lock>
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 800e26c:	f8db 3018 	ldr.w	r3, [fp, #24]
 800e270:	079a      	lsls	r2, r3, #30
 800e272:	d403      	bmi.n	800e27c <i2cSendDriver.constprop.25+0xbc>
 800e274:	f8db 3000 	ldr.w	r3, [fp]
 800e278:	059b      	lsls	r3, r3, #22
 800e27a:	d53d      	bpl.n	800e2f8 <i2cSendDriver.constprop.25+0x138>
 800e27c:	6a63      	ldr	r3, [r4, #36]	; 0x24
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 800e27e:	1bdb      	subs	r3, r3, r7
 800e280:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800e284:	d218      	bcs.n	800e2b8 <i2cSendDriver.constprop.25+0xf8>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800e286:	f000 fd6b 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800e28a:	f8da 3000 	ldr.w	r3, [sl]
 800e28e:	4553      	cmp	r3, sl
 800e290:	d005      	beq.n	800e29e <i2cSendDriver.constprop.25+0xde>
 800e292:	f8d8 2018 	ldr.w	r2, [r8, #24]
 800e296:	689b      	ldr	r3, [r3, #8]
 800e298:	6892      	ldr	r2, [r2, #8]
 800e29a:	429a      	cmp	r2, r3
 800e29c:	d309      	bcc.n	800e2b2 <i2cSendDriver.constprop.25+0xf2>
 800e29e:	2300      	movs	r3, #0
 800e2a0:	f383 8811 	msr	BASEPRI, r3
 800e2a4:	e7de      	b.n	800e264 <i2cSendDriver.constprop.25+0xa4>
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 800e2a6:	f1b8 0f00 	cmp.w	r8, #0
 800e2aa:	d19c      	bne.n	800e1e6 <i2cSendDriver.constprop.25+0x26>
 800e2ac:	486a      	ldr	r0, [pc, #424]	; (800e458 <i2cSendDriver.constprop.25+0x298>)
 800e2ae:	f000 fa57 	bl	800e760 <chSysHalt>
 800e2b2:	486a      	ldr	r0, [pc, #424]	; (800e45c <i2cSendDriver.constprop.25+0x29c>)
 800e2b4:	f000 fa54 	bl	800e760 <chSysHalt>
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 800e2b8:	2305      	movs	r3, #5
 800e2ba:	f889 3000 	strb.w	r3, [r9]
 800e2be:	f04f 34ff 	mov.w	r4, #4294967295
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800e2c2:	f000 fd4d 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800e2c6:	f8da 3000 	ldr.w	r3, [sl]
 800e2ca:	4a65      	ldr	r2, [pc, #404]	; (800e460 <i2cSendDriver.constprop.25+0x2a0>)
 800e2cc:	4553      	cmp	r3, sl
 800e2ce:	d004      	beq.n	800e2da <i2cSendDriver.constprop.25+0x11a>
 800e2d0:	6992      	ldr	r2, [r2, #24]
 800e2d2:	689b      	ldr	r3, [r3, #8]
 800e2d4:	6892      	ldr	r2, [r2, #8]
 800e2d6:	429a      	cmp	r2, r3
 800e2d8:	d322      	bcc.n	800e320 <i2cSendDriver.constprop.25+0x160>
 800e2da:	2300      	movs	r3, #0
 800e2dc:	f383 8811 	msr	BASEPRI, r3
	i2cAcquireBus(driver);
	msg_t i2c_status = i2cMasterTransmitTimeout(driver, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
	if(i2c_status == MSG_TIMEOUT) { // Restart I2C at timeout
 800e2e0:	1c60      	adds	r0, r4, #1
 800e2e2:	d070      	beq.n	800e3c6 <i2cSendDriver.constprop.25+0x206>
		TRACE_ERROR("I2C  > TIMEOUT > RESTART (ADDR 0x%02x)", addr);
		i2cStop(driver);
		i2cStart(driver, &_i2cfg);
	} else if(i2c_status == MSG_RESET && addr != 0x4C) { // Prevent PAC1720 to produce message while it doesnt work below 2.5V
 800e2e4:	1ca3      	adds	r3, r4, #2
 800e2e6:	d01e      	beq.n	800e326 <i2cSendDriver.constprop.25+0x166>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800e2e8:	485a      	ldr	r0, [pc, #360]	; (800e454 <i2cSendDriver.constprop.25+0x294>)
 800e2ea:	f000 fda1 	bl	800ee30 <chMtxUnlock>
		TRACE_ERROR("I2C  > RESET (ADDR 0x%02x)", addr);
	}
	i2cReleaseBus(driver);
	return i2c_status == MSG_OK;
}
 800e2ee:	fab4 f084 	clz	r0, r4
 800e2f2:	0940      	lsrs	r0, r0, #5
 800e2f4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800e2f8:	f8db 3004 	ldr.w	r3, [fp, #4]
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 800e2fc:	f8d9 201c 	ldr.w	r2, [r9, #28]
 800e300:	4e58      	ldr	r6, [pc, #352]	; (800e464 <i2cSendDriver.constprop.25+0x2a4>)
 800e302:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800e306:	f8cb 3004 	str.w	r3, [fp, #4]
  dp->CR1 |= I2C_CR1_START;
 800e30a:	f8db 3000 	ldr.w	r3, [fp]
 800e30e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800e312:	f8cb 3000 	str.w	r3, [fp]
 800e316:	2a00      	cmp	r2, #0
 800e318:	d043      	beq.n	800e3a2 <i2cSendDriver.constprop.25+0x1e2>
 800e31a:	4853      	ldr	r0, [pc, #332]	; (800e468 <i2cSendDriver.constprop.25+0x2a8>)
 800e31c:	f000 fa20 	bl	800e760 <chSysHalt>
 800e320:	4852      	ldr	r0, [pc, #328]	; (800e46c <i2cSendDriver.constprop.25+0x2ac>)
 800e322:	f000 fa1d 	bl	800e760 <chSysHalt>
	msg_t i2c_status = i2cMasterTransmitTimeout(driver, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
	if(i2c_status == MSG_TIMEOUT) { // Restart I2C at timeout
		TRACE_ERROR("I2C  > TIMEOUT > RESTART (ADDR 0x%02x)", addr);
		i2cStop(driver);
		i2cStart(driver, &_i2cfg);
	} else if(i2c_status == MSG_RESET && addr != 0x4C) { // Prevent PAC1720 to produce message while it doesnt work below 2.5V
 800e326:	2d4c      	cmp	r5, #76	; 0x4c
 800e328:	d0de      	beq.n	800e2e8 <i2cSendDriver.constprop.25+0x128>
		TRACE_ERROR("I2C  > RESET (ADDR 0x%02x)", addr);
 800e32a:	4851      	ldr	r0, [pc, #324]	; (800e470 <i2cSendDriver.constprop.25+0x2b0>)
 800e32c:	4f51      	ldr	r7, [pc, #324]	; (800e474 <i2cSendDriver.constprop.25+0x2b4>)
 800e32e:	f000 fddf 	bl	800eef0 <chMtxLock>
 800e332:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e336:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800e33a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e33c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800e33e:	4b4e      	ldr	r3, [pc, #312]	; (800e478 <i2cSendDriver.constprop.25+0x2b8>)
 800e340:	494e      	ldr	r1, [pc, #312]	; (800e47c <i2cSendDriver.constprop.25+0x2bc>)
 800e342:	fb06 f000 	mul.w	r0, r6, r0
 800e346:	fba7 e000 	umull	lr, r0, r7, r0
 800e34a:	0b80      	lsrs	r0, r0, #14
 800e34c:	fba3 e300 	umull	lr, r3, r3, r0
 800e350:	fba7 7202 	umull	r7, r2, r7, r2
 800e354:	099b      	lsrs	r3, r3, #6
 800e356:	fb06 0313 	mls	r3, r6, r3, r0
 800e35a:	0b92      	lsrs	r2, r2, #14
 800e35c:	4848      	ldr	r0, [pc, #288]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e35e:	f004 f9bf 	bl	80126e0 <chprintf.constprop.35>
 800e362:	4a48      	ldr	r2, [pc, #288]	; (800e484 <i2cSendDriver.constprop.25+0x2c4>)
 800e364:	4948      	ldr	r1, [pc, #288]	; (800e488 <i2cSendDriver.constprop.25+0x2c8>)
 800e366:	4846      	ldr	r0, [pc, #280]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e368:	f004 f9ba 	bl	80126e0 <chprintf.constprop.35>
 800e36c:	2319      	movs	r3, #25
 800e36e:	4a47      	ldr	r2, [pc, #284]	; (800e48c <i2cSendDriver.constprop.25+0x2cc>)
 800e370:	4947      	ldr	r1, [pc, #284]	; (800e490 <i2cSendDriver.constprop.25+0x2d0>)
 800e372:	4843      	ldr	r0, [pc, #268]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e374:	f004 f9b4 	bl	80126e0 <chprintf.constprop.35>
 800e378:	4946      	ldr	r1, [pc, #280]	; (800e494 <i2cSendDriver.constprop.25+0x2d4>)
 800e37a:	4841      	ldr	r0, [pc, #260]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e37c:	f004 f9b0 	bl	80126e0 <chprintf.constprop.35>
 800e380:	462a      	mov	r2, r5
 800e382:	4945      	ldr	r1, [pc, #276]	; (800e498 <i2cSendDriver.constprop.25+0x2d8>)
 800e384:	483e      	ldr	r0, [pc, #248]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e386:	f004 f9ab 	bl	80126e0 <chprintf.constprop.35>
 800e38a:	4944      	ldr	r1, [pc, #272]	; (800e49c <i2cSendDriver.constprop.25+0x2dc>)
 800e38c:	483c      	ldr	r0, [pc, #240]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e38e:	f004 f9a7 	bl	80126e0 <chprintf.constprop.35>
 800e392:	4837      	ldr	r0, [pc, #220]	; (800e470 <i2cSendDriver.constprop.25+0x2b0>)
 800e394:	f000 fd4c 	bl	800ee30 <chMtxUnlock>
 800e398:	2119      	movs	r1, #25
 800e39a:	483c      	ldr	r0, [pc, #240]	; (800e48c <i2cSendDriver.constprop.25+0x2cc>)
 800e39c:	f001 fde0 	bl	800ff60 <log_error>
 800e3a0:	e7a2      	b.n	800e2e8 <i2cSendDriver.constprop.25+0x128>

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 800e3a2:	4633      	mov	r3, r6
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800e3a4:	f8da 2018 	ldr.w	r2, [sl, #24]
 800e3a8:	f843 2f1c 	str.w	r2, [r3, #28]!
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800e3ac:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 800e3b0:	6253      	str	r3, [r2, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800e3b2:	2003      	movs	r0, #3
 800e3b4:	f000 fbf4 	bl	800eba0 <chSchGoSleepTimeoutS>
  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 800e3b8:	1c47      	adds	r7, r0, #1
 800e3ba:	4604      	mov	r4, r0
 800e3bc:	f43f af7c 	beq.w	800e2b8 <i2cSendDriver.constprop.25+0xf8>
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 800e3c0:	2302      	movs	r3, #2
 800e3c2:	7033      	strb	r3, [r6, #0]
 800e3c4:	e77d      	b.n	800e2c2 <i2cSendDriver.constprop.25+0x102>

bool i2cSendDriver(I2CDriver *driver, uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout) {
	i2cAcquireBus(driver);
	msg_t i2c_status = i2cMasterTransmitTimeout(driver, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
	if(i2c_status == MSG_TIMEOUT) { // Restart I2C at timeout
		TRACE_ERROR("I2C  > TIMEOUT > RESTART (ADDR 0x%02x)", addr);
 800e3c6:	482a      	ldr	r0, [pc, #168]	; (800e470 <i2cSendDriver.constprop.25+0x2b0>)
 800e3c8:	f000 fd92 	bl	800eef0 <chMtxLock>
 800e3cc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800e3d0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800e3d4:	6a4f      	ldr	r7, [r1, #36]	; 0x24
 800e3d6:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 800e3d8:	4829      	ldr	r0, [pc, #164]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e3da:	4928      	ldr	r1, [pc, #160]	; (800e47c <i2cSendDriver.constprop.25+0x2bc>)
 800e3dc:	fb03 f606 	mul.w	r6, r3, r6
 800e3e0:	f644 6220 	movw	r2, #20000	; 0x4e20
 800e3e4:	fbb6 f6f2 	udiv	r6, r6, r2
 800e3e8:	fbb7 f2f2 	udiv	r2, r7, r2
 800e3ec:	fbb6 f7f3 	udiv	r7, r6, r3
 800e3f0:	fb03 6317 	mls	r3, r3, r7, r6
 800e3f4:	f004 f974 	bl	80126e0 <chprintf.constprop.35>
 800e3f8:	4a22      	ldr	r2, [pc, #136]	; (800e484 <i2cSendDriver.constprop.25+0x2c4>)
 800e3fa:	4923      	ldr	r1, [pc, #140]	; (800e488 <i2cSendDriver.constprop.25+0x2c8>)
 800e3fc:	4820      	ldr	r0, [pc, #128]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e3fe:	f004 f96f 	bl	80126e0 <chprintf.constprop.35>
 800e402:	2315      	movs	r3, #21
 800e404:	4a21      	ldr	r2, [pc, #132]	; (800e48c <i2cSendDriver.constprop.25+0x2cc>)
 800e406:	4922      	ldr	r1, [pc, #136]	; (800e490 <i2cSendDriver.constprop.25+0x2d0>)
 800e408:	481d      	ldr	r0, [pc, #116]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e40a:	f004 f969 	bl	80126e0 <chprintf.constprop.35>
 800e40e:	4921      	ldr	r1, [pc, #132]	; (800e494 <i2cSendDriver.constprop.25+0x2d4>)
 800e410:	481b      	ldr	r0, [pc, #108]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e412:	f004 f965 	bl	80126e0 <chprintf.constprop.35>
 800e416:	462a      	mov	r2, r5
 800e418:	4921      	ldr	r1, [pc, #132]	; (800e4a0 <i2cSendDriver.constprop.25+0x2e0>)
 800e41a:	4819      	ldr	r0, [pc, #100]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e41c:	f004 f960 	bl	80126e0 <chprintf.constprop.35>
 800e420:	491e      	ldr	r1, [pc, #120]	; (800e49c <i2cSendDriver.constprop.25+0x2dc>)
 800e422:	4817      	ldr	r0, [pc, #92]	; (800e480 <i2cSendDriver.constprop.25+0x2c0>)
 800e424:	f004 f95c 	bl	80126e0 <chprintf.constprop.35>
 800e428:	4811      	ldr	r0, [pc, #68]	; (800e470 <i2cSendDriver.constprop.25+0x2b0>)
 800e42a:	f000 fd01 	bl	800ee30 <chMtxUnlock>
 800e42e:	2115      	movs	r1, #21
 800e430:	4816      	ldr	r0, [pc, #88]	; (800e48c <i2cSendDriver.constprop.25+0x2cc>)
 800e432:	f001 fd95 	bl	800ff60 <log_error>
 800e436:	2320      	movs	r3, #32
 800e438:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800e43c:	f000 fca0 	bl	800ed80 <_dbg_check_lock>

  osalDbgCheck(i2cp != NULL);

  osalSysLock();

  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 800e440:	f899 3000 	ldrb.w	r3, [r9]
 800e444:	1e5a      	subs	r2, r3, #1
 800e446:	2a01      	cmp	r2, #1
 800e448:	d92e      	bls.n	800e4a8 <i2cSendDriver.constprop.25+0x2e8>
 800e44a:	2b05      	cmp	r3, #5
 800e44c:	d02e      	beq.n	800e4ac <i2cSendDriver.constprop.25+0x2ec>
 800e44e:	4815      	ldr	r0, [pc, #84]	; (800e4a4 <i2cSendDriver.constprop.25+0x2e4>)
 800e450:	f000 f986 	bl	800e760 <chSysHalt>
 800e454:	200287d8 	.word	0x200287d8
 800e458:	08015a70 	.word	0x08015a70
 800e45c:	08015a8c 	.word	0x08015a8c
 800e460:	20027edc 	.word	0x20027edc
 800e464:	200287cc 	.word	0x200287cc
 800e468:	08015bb4 	.word	0x08015bb4
 800e46c:	08017534 	.word	0x08017534
 800e470:	20027b2c 	.word	0x20027b2c
 800e474:	d1b71759 	.word	0xd1b71759
 800e478:	10624dd3 	.word	0x10624dd3
 800e47c:	08013c50 	.word	0x08013c50
 800e480:	20027e60 	.word	0x20027e60
 800e484:	08013d9c 	.word	0x08013d9c
 800e488:	08013c5c 	.word	0x08013c5c
 800e48c:	080150c8 	.word	0x080150c8
 800e490:	08013c78 	.word	0x08013c78
 800e494:	08013d00 	.word	0x08013d00
 800e498:	08015b98 	.word	0x08015b98
 800e49c:	08013cac 	.word	0x08013cac
 800e4a0:	08015b70 	.word	0x08015b70
 800e4a4:	08015a98 	.word	0x08015a98
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {

  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {
 800e4a8:	2b01      	cmp	r3, #1
 800e4aa:	d03e      	beq.n	800e52a <i2cSendDriver.constprop.25+0x36a>
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800e4ac:	f8d9 0030 	ldr.w	r0, [r9, #48]	; 0x30
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800e4b0:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800e4b4:	6802      	ldr	r2, [r0, #0]
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 800e4b6:	2100      	movs	r1, #0
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 800e4b8:	f44f 4500 	mov.w	r5, #32768	; 0x8000
 800e4bc:	601d      	str	r5, [r3, #0]
  dp->CR1 = 0;
 800e4be:	6019      	str	r1, [r3, #0]
  dp->CR2 = 0;
 800e4c0:	6059      	str	r1, [r3, #4]
  dp->SR1 = 0;
 800e4c2:	6159      	str	r1, [r3, #20]

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800e4c4:	6813      	ldr	r3, [r2, #0]
 800e4c6:	f023 031f 	bic.w	r3, r3, #31
 800e4ca:	6013      	str	r3, [r2, #0]
 800e4cc:	6813      	ldr	r3, [r2, #0]
 800e4ce:	07d9      	lsls	r1, r3, #31
 800e4d0:	d4fc      	bmi.n	800e4cc <i2cSendDriver.constprop.25+0x30c>
 800e4d2:	7a01      	ldrb	r1, [r0, #8]
  dmaStreamDisable(i2cp->dmarx);
 800e4d4:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800e4d8:	6845      	ldr	r5, [r0, #4]
 800e4da:	233d      	movs	r3, #61	; 0x3d
 800e4dc:	fa03 f101 	lsl.w	r1, r3, r1
  dmaStreamDisable(i2cp->dmarx);
 800e4e0:	6813      	ldr	r3, [r2, #0]
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800e4e2:	6029      	str	r1, [r5, #0]
  dmaStreamDisable(i2cp->dmarx);
 800e4e4:	6819      	ldr	r1, [r3, #0]
 800e4e6:	f021 011f 	bic.w	r1, r1, #31
 800e4ea:	6019      	str	r1, [r3, #0]
 800e4ec:	681d      	ldr	r5, [r3, #0]
 800e4ee:	f015 0501 	ands.w	r5, r5, #1
 800e4f2:	d1fb      	bne.n	800e4ec <i2cSendDriver.constprop.25+0x32c>
 800e4f4:	7a11      	ldrb	r1, [r2, #8]
 800e4f6:	6852      	ldr	r2, [r2, #4]
 800e4f8:	233d      	movs	r3, #61	; 0x3d
 800e4fa:	408b      	lsls	r3, r1
 800e4fc:	6013      	str	r3, [r2, #0]
  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {

    /* I2C disable.*/
    i2c_lld_abort_operation(i2cp);
    dmaStreamRelease(i2cp->dmatx);
 800e4fe:	f7fe fb57 	bl	800cbb0 <dmaStreamRelease>
    dmaStreamRelease(i2cp->dmarx);
 800e502:	f8d9 002c 	ldr.w	r0, [r9, #44]	; 0x2c
 800e506:	f7fe fb53 	bl	800cbb0 <dmaStreamRelease>
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800e50a:	4b14      	ldr	r3, [pc, #80]	; (800e55c <i2cSendDriver.constprop.25+0x39c>)

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      nvicDisableVector(I2C2_EV_IRQn);
      nvicDisableVector(I2C2_ER_IRQn);
      rccDisableI2C2(FALSE);
 800e50c:	4a14      	ldr	r2, [pc, #80]	; (800e560 <i2cSendDriver.constprop.25+0x3a0>)
 800e50e:	2002      	movs	r0, #2
 800e510:	2104      	movs	r1, #4
 800e512:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800e516:	f883 5321 	strb.w	r5, [r3, #801]	; 0x321
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800e51a:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800e51e:	f883 5322 	strb.w	r5, [r3, #802]	; 0x322
 800e522:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800e524:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 800e528:	6413      	str	r3, [r2, #64]	; 0x40
                (i2cp->state == I2C_LOCKED), "invalid state");

  i2c_lld_stop(i2cp);
  i2cp->config = NULL;
 800e52a:	2200      	movs	r2, #0
  i2cp->state  = I2C_STOP;
 800e52c:	2301      	movs	r3, #1

  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  i2c_lld_stop(i2cp);
  i2cp->config = NULL;
 800e52e:	f8c9 2004 	str.w	r2, [r9, #4]
  i2cp->state  = I2C_STOP;
 800e532:	f889 3000 	strb.w	r3, [r9]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800e536:	f000 fc13 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800e53a:	f8da 3000 	ldr.w	r3, [sl]
 800e53e:	4a09      	ldr	r2, [pc, #36]	; (800e564 <i2cSendDriver.constprop.25+0x3a4>)
 800e540:	4553      	cmp	r3, sl
 800e542:	d005      	beq.n	800e550 <i2cSendDriver.constprop.25+0x390>
 800e544:	6992      	ldr	r2, [r2, #24]
 800e546:	689b      	ldr	r3, [r3, #8]
 800e548:	6892      	ldr	r2, [r2, #8]
 800e54a:	429a      	cmp	r2, r3
 800e54c:	f4ff aee8 	bcc.w	800e320 <i2cSendDriver.constprop.25+0x160>
 800e550:	2300      	movs	r3, #0
 800e552:	f383 8811 	msr	BASEPRI, r3
		i2cStop(driver);
		i2cStart(driver, &_i2cfg);
 800e556:	f004 f9c3 	bl	80128e0 <i2cStart.constprop.66>
 800e55a:	e6c5      	b.n	800e2e8 <i2cSendDriver.constprop.25+0x128>
 800e55c:	e000e100 	.word	0xe000e100
 800e560:	40023800 	.word	0x40023800
 800e564:	20027edc 	.word	0x20027edc
	...

0800e570 <I2C_writeN.constprop.22>:
	bool ret = I2C_write8_locked(address, reg, value);
	chMtxUnlock(&pi2c_mtx);
	return ret;
}

bool I2C_writeN(uint8_t address, uint8_t *txbuf, uint32_t length)
 800e570:	b570      	push	{r4, r5, r6, lr}
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800e572:	4c0a      	ldr	r4, [pc, #40]	; (800e59c <I2C_writeN.constprop.22+0x2c>)
	bool ret = I2C_write8_locked(address, reg, value);
	chMtxUnlock(&pi2c_mtx);
	return ret;
}

bool I2C_writeN(uint8_t address, uint8_t *txbuf, uint32_t length)
 800e574:	b082      	sub	sp, #8
 800e576:	4605      	mov	r5, r0
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800e578:	4620      	mov	r0, r4
	bool ret = I2C_write8_locked(address, reg, value);
	chMtxUnlock(&pi2c_mtx);
	return ret;
}

bool I2C_writeN(uint8_t address, uint8_t *txbuf, uint32_t length)
 800e57a:	460e      	mov	r6, r1
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800e57c:	f000 fcb8 	bl	800eef0 <chMtxLock>
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800e580:	2300      	movs	r3, #0
 800e582:	4629      	mov	r1, r5
 800e584:	4632      	mov	r2, r6
 800e586:	9300      	str	r3, [sp, #0]
 800e588:	2042      	movs	r0, #66	; 0x42
 800e58a:	f7ff fe19 	bl	800e1c0 <i2cSendDriver.constprop.25>
 800e58e:	4605      	mov	r5, r0
/**
  * Unlocks all other I2C threads to access I2C
  */
void I2C_unlock(void)
{
	chMtxUnlock(&pi2c_mtx);
 800e590:	4620      	mov	r0, r4
 800e592:	f000 fc4d 	bl	800ee30 <chMtxUnlock>
{
	I2C_lock();
	bool ret = I2C_writeN_locked(address, txbuf, length);
	I2C_unlock();
	return ret;
}
 800e596:	4628      	mov	r0, r5
 800e598:	b002      	add	sp, #8
 800e59a:	bd70      	pop	{r4, r5, r6, pc}
 800e59c:	200278f8 	.word	0x200278f8

0800e5a0 <I2C_write8_locked.constprop.1>:
	chMtxObjectInit(&pi2c_mtx);
}

// I2C Mutex locked access functions

bool I2C_write8_locked(uint8_t address, uint8_t reg, uint8_t value)
 800e5a0:	b500      	push	{lr}
 800e5a2:	b085      	sub	sp, #20
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800e5a4:	2300      	movs	r3, #0

// I2C Mutex locked access functions

bool I2C_write8_locked(uint8_t address, uint8_t reg, uint8_t value)
{
	uint8_t txbuf[] = {reg, value};
 800e5a6:	f88d 000c 	strb.w	r0, [sp, #12]
 800e5aa:	f88d 100d 	strb.w	r1, [sp, #13]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD2, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800e5ae:	9300      	str	r3, [sp, #0]
 800e5b0:	2202      	movs	r2, #2
 800e5b2:	a903      	add	r1, sp, #12
 800e5b4:	2030      	movs	r0, #48	; 0x30
 800e5b6:	f7ff fe03 	bl	800e1c0 <i2cSendDriver.constprop.25>

bool I2C_write8_locked(uint8_t address, uint8_t reg, uint8_t value)
{
	uint8_t txbuf[] = {reg, value};
	return I2C_send(address, txbuf, 2, NULL, 0, MS2ST(100));
}
 800e5ba:	b005      	add	sp, #20
 800e5bc:	f85d fb04 	ldr.w	pc, [sp], #4

0800e5c0 <validate.constprop.7>:
)
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 800e5c0:	4a0a      	ldr	r2, [pc, #40]	; (800e5ec <validate.constprop.7+0x2c>)
/*-----------------------------------------------------------------------*/
/* Check if the file/directory object is valid or not                    */
/*-----------------------------------------------------------------------*/

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
 800e5c2:	b508      	push	{r3, lr}
)
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 800e5c4:	6813      	ldr	r3, [r2, #0]
 800e5c6:	b10b      	cbz	r3, 800e5cc <validate.constprop.7+0xc>
 800e5c8:	7819      	ldrb	r1, [r3, #0]
 800e5ca:	b909      	cbnz	r1, 800e5d0 <validate.constprop.7+0x10>
		return FR_INVALID_OBJECT;
 800e5cc:	2009      	movs	r0, #9

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
 800e5ce:	bd08      	pop	{r3, pc}
)
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 800e5d0:	8892      	ldrh	r2, [r2, #4]
 800e5d2:	88d9      	ldrh	r1, [r3, #6]
 800e5d4:	4291      	cmp	r1, r2
 800e5d6:	d1f9      	bne.n	800e5cc <validate.constprop.7+0xc>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
 800e5d8:	7858      	ldrb	r0, [r3, #1]
 800e5da:	f7fd fc91 	bl	800bf00 <disk_initialize>
 800e5de:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;

	return FR_OK;
 800e5e2:	bf14      	ite	ne
 800e5e4:	2003      	movne	r0, #3
 800e5e6:	2000      	moveq	r0, #0
 800e5e8:	bd08      	pop	{r3, pc}
 800e5ea:	bf00      	nop
 800e5ec:	20027908 	.word	0x20027908

0800e5f0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800e5f0:	f3ef 8309 	mrs	r3, PSP
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800e5f4:	3320      	adds	r3, #32
 800e5f6:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800e5fa:	2300      	movs	r3, #0
 800e5fc:	f383 8811 	msr	BASEPRI, r3
 800e600:	4770      	bx	lr
 800e602:	bf00      	nop
	...

0800e610 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 800e610:	b410      	push	{r4}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 800e612:	4a0b      	ldr	r2, [pc, #44]	; (800e640 <trace_next+0x30>)
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800e614:	480b      	ldr	r0, [pc, #44]	; (800e644 <trace_next+0x34>)
 800e616:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800e618:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800e61c:	6819      	ldr	r1, [r3, #0]
 800e61e:	6a64      	ldr	r4, [r4, #36]	; 0x24
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 800e620:	605c      	str	r4, [r3, #4]
 800e622:	6840      	ldr	r0, [r0, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800e624:	f360 211f 	bfi	r1, r0, #8, #24
 800e628:	f843 1b10 	str.w	r1, [r3], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 800e62c:	f502 6104 	add.w	r1, r2, #2112	; 0x840
 800e630:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 800e632:	bf28      	it	cs
 800e634:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 800e638:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 800e63a:	bc10      	pop	{r4}
 800e63c:	4770      	bx	lr
 800e63e:	bf00      	nop
 800e640:	20027edc 	.word	0x20027edc
 800e644:	e0001000 	.word	0xe0001000
	...

0800e650 <_idle_thread.lto_priv.129>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 800e650:	e7fe      	b.n	800e650 <_idle_thread.lto_priv.129>
 800e652:	bf00      	nop
	...

0800e660 <chTMStopMeasurementX>:
 800e660:	4b0f      	ldr	r3, [pc, #60]	; (800e6a0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800e662:	4910      	ldr	r1, [pc, #64]	; (800e6a4 <chTMStopMeasurementX+0x44>)
 800e664:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800e666:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800e668:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800e66a:	f8d1 7884 	ldr.w	r7, [r1, #2180]	; 0x884
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 800e66e:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800e670:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800e672:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800e676:	1ad3      	subs	r3, r2, r3
 800e678:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 800e67a:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 800e67c:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800e67e:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800e680:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 800e684:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800e686:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 800e68a:	bf88      	it	hi
 800e68c:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 800e68e:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800e690:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800e692:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 800e696:	bf38      	it	cc
 800e698:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800e69a:	bcf0      	pop	{r4, r5, r6, r7}
 800e69c:	4770      	bx	lr
 800e69e:	bf00      	nop
 800e6a0:	e0001000 	.word	0xe0001000
 800e6a4:	20027edc 	.word	0x20027edc
	...

0800e6b0 <_trace_switch.part.0.lto_priv.108>:
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800e6b0:	4909      	ldr	r1, [pc, #36]	; (800e6d8 <_trace_switch.part.0.lto_priv.108+0x28>)
 800e6b2:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 800e6b4:	7813      	ldrb	r3, [r2, #0]
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 800e6b6:	b410      	push	{r4}

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800e6b8:	2401      	movs	r4, #1
 800e6ba:	f364 0302 	bfi	r3, r4, #0, #3
 800e6be:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800e6c0:	f890 4020 	ldrb.w	r4, [r0, #32]
 800e6c4:	f364 03c7 	bfi	r3, r4, #3, #5
 800e6c8:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800e6ca:	698b      	ldr	r3, [r1, #24]
 800e6cc:	6093      	str	r3, [r2, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800e6ce:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800e6d0:	60d3      	str	r3, [r2, #12]
    trace_next();
  }
}
 800e6d2:	bc10      	pop	{r4}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
    trace_next();
 800e6d4:	f7ff bf9c 	b.w	800e610 <trace_next>
 800e6d8:	20027edc 	.word	0x20027edc
 800e6dc:	00000000 	.word	0x00000000

0800e6e0 <_trace_isr_leave>:
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800e6e0:	4b0b      	ldr	r3, [pc, #44]	; (800e710 <_trace_isr_leave+0x30>)
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 800e6e2:	b510      	push	{r4, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800e6e4:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 800e6e6:	f004 0402 	and.w	r4, r4, #2
 800e6ea:	b2a4      	uxth	r4, r4
 800e6ec:	b97c      	cbnz	r4, 800e70e <_trace_isr_leave+0x2e>
 800e6ee:	2220      	movs	r2, #32
 800e6f0:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800e6f4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800e6f6:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800e6f8:	6090      	str	r0, [r2, #8]
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800e6fa:	2103      	movs	r1, #3
 800e6fc:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800e700:	f364 03c7 	bfi	r3, r4, #3, #5
 800e704:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 800e706:	f7ff ff83 	bl	800e610 <trace_next>
 800e70a:	f384 8811 	msr	BASEPRI, r4
 800e70e:	bd10      	pop	{r4, pc}
 800e710:	20027edc 	.word	0x20027edc
	...

0800e720 <_trace_isr_enter>:
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800e720:	4b0b      	ldr	r3, [pc, #44]	; (800e750 <_trace_isr_enter+0x30>)
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 800e722:	b510      	push	{r4, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800e724:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 800e726:	f004 0402 	and.w	r4, r4, #2
 800e72a:	b2a4      	uxth	r4, r4
 800e72c:	b97c      	cbnz	r4, 800e74e <_trace_isr_enter+0x2e>
 800e72e:	2220      	movs	r2, #32
 800e730:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800e734:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800e736:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800e738:	6090      	str	r0, [r2, #8]
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800e73a:	2102      	movs	r1, #2
 800e73c:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800e740:	f364 03c7 	bfi	r3, r4, #3, #5
 800e744:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 800e746:	f7ff ff63 	bl	800e610 <trace_next>
 800e74a:	f384 8811 	msr	BASEPRI, r4
 800e74e:	bd10      	pop	{r4, pc}
 800e750:	20027edc 	.word	0x20027edc
	...

0800e760 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 800e760:	b508      	push	{r3, lr}
 800e762:	4605      	mov	r5, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800e764:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 800e766:	4c0a      	ldr	r4, [pc, #40]	; (800e790 <chSysHalt+0x30>)
 800e768:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800e76a:	f003 0304 	and.w	r3, r3, #4
 800e76e:	b29b      	uxth	r3, r3
 800e770:	b10b      	cbz	r3, 800e776 <chSysHalt+0x16>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800e772:	62e5      	str	r5, [r4, #44]	; 0x2c
 800e774:	e7fe      	b.n	800e774 <chSysHalt+0x14>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800e776:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800e778:	780a      	ldrb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 800e77a:	6088      	str	r0, [r1, #8]
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800e77c:	2004      	movs	r0, #4
 800e77e:	f360 0202 	bfi	r2, r0, #0, #3
    ch.dbg.trace_buffer.ptr->state         = 0;
 800e782:	f363 02c7 	bfi	r2, r3, #3, #5
 800e786:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
    trace_next();
 800e788:	f7ff ff42 	bl	800e610 <trace_next>
 800e78c:	e7f1      	b.n	800e772 <chSysHalt+0x12>
 800e78e:	bf00      	nop
 800e790:	20027edc 	.word	0x20027edc
	...

0800e7a0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 800e7a0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800e7a2:	4b05      	ldr	r3, [pc, #20]	; (800e7b8 <chDbgCheckClassS+0x18>)
 800e7a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800e7a6:	b91a      	cbnz	r2, 800e7b0 <chDbgCheckClassS+0x10>
 800e7a8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800e7aa:	2b00      	cmp	r3, #0
 800e7ac:	dd00      	ble.n	800e7b0 <chDbgCheckClassS+0x10>
 800e7ae:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 800e7b0:	4802      	ldr	r0, [pc, #8]	; (800e7bc <chDbgCheckClassS+0x1c>)
 800e7b2:	f7ff ffd5 	bl	800e760 <chSysHalt>
 800e7b6:	bf00      	nop
 800e7b8:	20027edc 	.word	0x20027edc
 800e7bc:	08015c4c 	.word	0x08015c4c

0800e7c0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800e7c0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 800e7c2:	4c12      	ldr	r4, [pc, #72]	; (800e80c <chSchGoSleepS+0x4c>)
 800e7c4:	69a5      	ldr	r5, [r4, #24]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800e7c6:	4606      	mov	r6, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 800e7c8:	f7ff ffea 	bl	800e7a0 <chDbgCheckClassS>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800e7cc:	6823      	ldr	r3, [r4, #0]

  /* New state.*/
  otp->state = newstate;
 800e7ce:	f885 6020 	strb.w	r6, [r5, #32]

  tqp->next             = tp->queue.next;
 800e7d2:	681a      	ldr	r2, [r3, #0]
 800e7d4:	6022      	str	r2, [r4, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800e7d6:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800e7d8:	6054      	str	r4, [r2, #4]
 800e7da:	f883 1020 	strb.w	r1, [r3, #32]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800e7de:	8f22      	ldrh	r2, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800e7e0:	61a3      	str	r3, [r4, #24]
 800e7e2:	07d3      	lsls	r3, r2, #31
 800e7e4:	d402      	bmi.n	800e7ec <chSchGoSleepS+0x2c>
 800e7e6:	4628      	mov	r0, r5
 800e7e8:	f7ff ff62 	bl	800e6b0 <_trace_switch.part.0.lto_priv.108>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800e7ec:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800e7f0:	69ea      	ldr	r2, [r5, #28]
 800e7f2:	3b24      	subs	r3, #36	; 0x24
 800e7f4:	429a      	cmp	r2, r3
 800e7f6:	d805      	bhi.n	800e804 <chSchGoSleepS+0x44>
 800e7f8:	4629      	mov	r1, r5
 800e7fa:	69a0      	ldr	r0, [r4, #24]
}
 800e7fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800e800:	f7f1 bd4e 	b.w	80002a0 <_port_switch>
 800e804:	4802      	ldr	r0, [pc, #8]	; (800e810 <chSchGoSleepS+0x50>)
 800e806:	f7ff ffab 	bl	800e760 <chSysHalt>
 800e80a:	bf00      	nop
 800e80c:	20027edc 	.word	0x20027edc
 800e810:	08015c54 	.word	0x08015c54
	...

0800e820 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 800e820:	b510      	push	{r4, lr}
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 800e822:	6801      	ldr	r1, [r0, #0]
 800e824:	4c07      	ldr	r4, [pc, #28]	; (800e844 <chThdSuspendS+0x24>)
 800e826:	69a2      	ldr	r2, [r4, #24]
 800e828:	b111      	cbz	r1, 800e830 <chThdSuspendS+0x10>
 800e82a:	4807      	ldr	r0, [pc, #28]	; (800e848 <chThdSuspendS+0x28>)
 800e82c:	f7ff ff98 	bl	800e760 <chSysHalt>
 800e830:	4603      	mov	r3, r0

  *trp = tp;
 800e832:	6002      	str	r2, [r0, #0]
  tp->u.wttrp = trp;
 800e834:	6253      	str	r3, [r2, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 800e836:	2003      	movs	r0, #3
 800e838:	f7ff ffc2 	bl	800e7c0 <chSchGoSleepS>

  return chThdGetSelfX()->u.rdymsg;
 800e83c:	69a3      	ldr	r3, [r4, #24]
}
 800e83e:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800e840:	bd10      	pop	{r4, pc}
 800e842:	bf00      	nop
 800e844:	20027edc 	.word	0x20027edc
 800e848:	08015bec 	.word	0x08015bec
 800e84c:	00000000 	.word	0x00000000

0800e850 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 800e850:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800e852:	4b05      	ldr	r3, [pc, #20]	; (800e868 <chDbgCheckClassI+0x18>)
 800e854:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800e856:	2a00      	cmp	r2, #0
 800e858:	db03      	blt.n	800e862 <chDbgCheckClassI+0x12>
 800e85a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800e85c:	2b00      	cmp	r3, #0
 800e85e:	dd00      	ble.n	800e862 <chDbgCheckClassI+0x12>
 800e860:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 800e862:	4802      	ldr	r0, [pc, #8]	; (800e86c <chDbgCheckClassI+0x1c>)
 800e864:	f7ff ff7c 	bl	800e760 <chSysHalt>
 800e868:	20027edc 	.word	0x20027edc
 800e86c:	08015c64 	.word	0x08015c64

0800e870 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 800e870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e872:	4604      	mov	r4, r0
  thread_t *tp;

  chDbgCheckClassI();
 800e874:	f7ff ffec 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 800e878:	b134      	cbz	r4, 800e888 <chThdCreateSuspendedI+0x18>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 800e87a:	6861      	ldr	r1, [r4, #4]
 800e87c:	074b      	lsls	r3, r1, #29
 800e87e:	d103      	bne.n	800e888 <chThdCreateSuspendedI+0x18>
 800e880:	68a3      	ldr	r3, [r4, #8]
 800e882:	f013 0507 	ands.w	r5, r3, #7
 800e886:	d002      	beq.n	800e88e <chThdCreateSuspendedI+0x1e>
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
  chDbgCheck(tdp != NULL);
 800e888:	4823      	ldr	r0, [pc, #140]	; (800e918 <chThdCreateSuspendedI+0xa8>)
 800e88a:	f7ff ff69 	bl	800e760 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 800e88e:	4299      	cmp	r1, r3
 800e890:	d2fa      	bcs.n	800e888 <chThdCreateSuspendedI+0x18>
 800e892:	1a5a      	subs	r2, r3, r1
 800e894:	2ac7      	cmp	r2, #199	; 0xc7
 800e896:	d9f7      	bls.n	800e888 <chThdCreateSuspendedI+0x18>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 800e898:	68e0      	ldr	r0, [r4, #12]
 800e89a:	28ff      	cmp	r0, #255	; 0xff
 800e89c:	d8f4      	bhi.n	800e888 <chThdCreateSuspendedI+0x18>
 800e89e:	6927      	ldr	r7, [r4, #16]
 800e8a0:	2f00      	cmp	r7, #0
 800e8a2:	d0f1      	beq.n	800e888 <chThdCreateSuspendedI+0x18>
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800e8a4:	4a1d      	ldr	r2, [pc, #116]	; (800e91c <chThdCreateSuspendedI+0xac>)
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800e8a6:	f843 1c2c 	str.w	r1, [r3, #-44]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 800e8aa:	f04f 0e02 	mov.w	lr, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800e8ae:	2601      	movs	r6, #1
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800e8b0:	6961      	ldr	r1, [r4, #20]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 800e8b2:	6824      	ldr	r4, [r4, #0]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 800e8b4:	f803 ec28 	strb.w	lr, [r3, #-40]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800e8b8:	f803 5c27 	strb.w	r5, [r3, #-39]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800e8bc:	f803 6c26 	strb.w	r6, [r3, #-38]
  tp->name      = name;
  REG_INSERT(tp);
 800e8c0:	6956      	ldr	r6, [r2, #20]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800e8c2:	f8df e05c 	ldr.w	lr, [pc, #92]	; 800e920 <chThdCreateSuspendedI+0xb0>
 800e8c6:	f843 7c6c 	str.w	r7, [r3, #-108]
 800e8ca:	f843 1c68 	str.w	r1, [r3, #-104]
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800e8ce:	f843 4c30 	str.w	r4, [r3, #-48]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 800e8d2:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 800e8d6:	f1a3 041c 	sub.w	r4, r3, #28
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800e8da:	f1a3 0c6c 	sub.w	ip, r3, #108	; 0x6c
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800e8de:	f1a3 0720 	sub.w	r7, r3, #32
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800e8e2:	f843 0c40 	str.w	r0, [r3, #-64]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800e8e6:	f843 0c0c 	str.w	r0, [r3, #-12]
  tp->mtxlist   = NULL;
 800e8ea:	f843 5c10 	str.w	r5, [r3, #-16]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800e8ee:	f843 5c14 	str.w	r5, [r3, #-20]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800e8f2:	f843 2c38 	str.w	r2, [r3, #-56]
 800e8f6:	f843 6c34 	str.w	r6, [r3, #-52]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800e8fa:	f843 cc3c 	str.w	ip, [r3, #-60]
 800e8fe:	f843 ec4c 	str.w	lr, [r3, #-76]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 800e902:	4608      	mov	r0, r1
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800e904:	6131      	str	r1, [r6, #16]
 800e906:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800e908:	f843 7c20 	str.w	r7, [r3, #-32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800e90c:	f843 4c1c 	str.w	r4, [r3, #-28]
  tqp->prev = (thread_t *)tqp;
 800e910:	f843 4c18 	str.w	r4, [r3, #-24]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 800e914:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e916:	bf00      	nop
 800e918:	08015d30 	.word	0x08015d30
 800e91c:	20027edc 	.word	0x20027edc
 800e920:	080002b1 	.word	0x080002b1
	...

0800e930 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800e930:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 800e932:	4d1c      	ldr	r5, [pc, #112]	; (800e9a4 <chSchDoReschedule+0x74>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800e934:	682b      	ldr	r3, [r5, #0]
 800e936:	69ae      	ldr	r6, [r5, #24]

  tqp->next             = tp->queue.next;
 800e938:	681c      	ldr	r4, [r3, #0]
 800e93a:	602c      	str	r4, [r5, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800e93c:	2201      	movs	r2, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800e93e:	6065      	str	r5, [r4, #4]
 800e940:	f883 2020 	strb.w	r2, [r3, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800e944:	61ab      	str	r3, [r5, #24]
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
 800e946:	f7ff ff83 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800e94a:	b326      	cbz	r6, 800e996 <chSchDoReschedule+0x66>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800e94c:	f896 3020 	ldrb.w	r3, [r6, #32]
 800e950:	b30b      	cbz	r3, 800e996 <chSchDoReschedule+0x66>
 800e952:	2b0f      	cmp	r3, #15
 800e954:	d01f      	beq.n	800e996 <chSchDoReschedule+0x66>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800e956:	2300      	movs	r3, #0
 800e958:	68b2      	ldr	r2, [r6, #8]
 800e95a:	f886 3020 	strb.w	r3, [r6, #32]
 800e95e:	e000      	b.n	800e962 <chSchDoReschedule+0x32>
 800e960:	6824      	ldr	r4, [r4, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 800e962:	68a3      	ldr	r3, [r4, #8]
 800e964:	4293      	cmp	r3, r2
 800e966:	d8fb      	bhi.n	800e960 <chSchDoReschedule+0x30>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800e968:	6863      	ldr	r3, [r4, #4]
 800e96a:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
 800e96c:	6073      	str	r3, [r6, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800e96e:	6034      	str	r4, [r6, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800e970:	601e      	str	r6, [r3, #0]
 800e972:	07d3      	lsls	r3, r2, #31
  cp->queue.prev             = tp;
 800e974:	6066      	str	r6, [r4, #4]
 800e976:	d402      	bmi.n	800e97e <chSchDoReschedule+0x4e>
 800e978:	4630      	mov	r0, r6
 800e97a:	f7ff fe99 	bl	800e6b0 <_trace_switch.part.0.lto_priv.108>
 800e97e:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800e982:	69f2      	ldr	r2, [r6, #28]
 800e984:	3b24      	subs	r3, #36	; 0x24
 800e986:	429a      	cmp	r2, r3
 800e988:	d808      	bhi.n	800e99c <chSchDoReschedule+0x6c>
 800e98a:	4631      	mov	r1, r6
 800e98c:	69a8      	ldr	r0, [r5, #24]
}
 800e98e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800e992:	f7f1 bc85 	b.w	80002a0 <_port_switch>
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 800e996:	4804      	ldr	r0, [pc, #16]	; (800e9a8 <chSchDoReschedule+0x78>)
 800e998:	f7ff fee2 	bl	800e760 <chSysHalt>

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800e99c:	4803      	ldr	r0, [pc, #12]	; (800e9ac <chSchDoReschedule+0x7c>)
 800e99e:	f7ff fedf 	bl	800e760 <chSysHalt>
 800e9a2:	bf00      	nop
 800e9a4:	20027edc 	.word	0x20027edc
 800e9a8:	08015c9c 	.word	0x08015c9c
 800e9ac:	08015c54 	.word	0x08015c54

0800e9b0 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 800e9b0:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 800e9b2:	f7ff fef5 	bl	800e7a0 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 800e9b6:	f7ff ff4b 	bl	800e850 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 800e9ba:	4b06      	ldr	r3, [pc, #24]	; (800e9d4 <chSchRescheduleS+0x24>)
 800e9bc:	681a      	ldr	r2, [r3, #0]
 800e9be:	699b      	ldr	r3, [r3, #24]

  if (chSchIsRescRequiredI()) {
 800e9c0:	6892      	ldr	r2, [r2, #8]
 800e9c2:	689b      	ldr	r3, [r3, #8]
 800e9c4:	429a      	cmp	r2, r3
 800e9c6:	d800      	bhi.n	800e9ca <chSchRescheduleS+0x1a>
 800e9c8:	bd08      	pop	{r3, pc}
    chSchDoRescheduleAhead();
  }
}
 800e9ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    chSchDoRescheduleAhead();
 800e9ce:	f7ff bfaf 	b.w	800e930 <chSchDoReschedule>
 800e9d2:	bf00      	nop
 800e9d4:	20027edc 	.word	0x20027edc
	...

0800e9e0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800e9e0:	b510      	push	{r4, lr}
 800e9e2:	4604      	mov	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
 800e9e4:	f7ff ff34 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800e9e8:	b1a4      	cbz	r4, 800ea14 <chSchReadyI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800e9ea:	f894 3020 	ldrb.w	r3, [r4, #32]
 800e9ee:	b18b      	cbz	r3, 800ea14 <chSchReadyI+0x34>
 800e9f0:	2b0f      	cmp	r3, #15
 800e9f2:	d00f      	beq.n	800ea14 <chSchReadyI+0x34>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800e9f4:	2200      	movs	r2, #0
 800e9f6:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 800e9f8:	4b08      	ldr	r3, [pc, #32]	; (800ea1c <chSchReadyI+0x3c>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800e9fa:	f884 2020 	strb.w	r2, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800e9fe:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800ea00:	689a      	ldr	r2, [r3, #8]
 800ea02:	428a      	cmp	r2, r1
 800ea04:	d2fb      	bcs.n	800e9fe <chSchReadyI+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800ea06:	685a      	ldr	r2, [r3, #4]
 800ea08:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800ea0a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 800ea0c:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800ea0e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 800ea10:	605c      	str	r4, [r3, #4]

  return tp;
}
 800ea12:	bd10      	pop	{r4, pc}
 */
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 800ea14:	4802      	ldr	r0, [pc, #8]	; (800ea20 <chSchReadyI+0x40>)
 800ea16:	f7ff fea3 	bl	800e760 <chSysHalt>
 800ea1a:	bf00      	nop
 800ea1c:	20027edc 	.word	0x20027edc
 800ea20:	08015c40 	.word	0x08015c40
	...

0800ea30 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 800ea30:	b508      	push	{r3, lr}

  if (*trp != NULL) {
 800ea32:	6803      	ldr	r3, [r0, #0]
 800ea34:	b173      	cbz	r3, 800ea54 <chThdResumeI+0x24>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800ea36:	f893 2020 	ldrb.w	r2, [r3, #32]
 800ea3a:	2a03      	cmp	r2, #3
 800ea3c:	d002      	beq.n	800ea44 <chThdResumeI+0x14>
 800ea3e:	4806      	ldr	r0, [pc, #24]	; (800ea58 <chThdResumeI+0x28>)
 800ea40:	f7ff fe8e 	bl	800e760 <chSysHalt>

    *trp = NULL;
 800ea44:	2200      	movs	r2, #0
 800ea46:	6002      	str	r2, [r0, #0]
    tp->u.rdymsg = msg;
 800ea48:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800ea4a:	4618      	mov	r0, r3
  }
}
 800ea4c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800ea50:	f7ff bfc6 	b.w	800e9e0 <chSchReadyI>
 800ea54:	bd08      	pop	{r3, pc}
 800ea56:	bf00      	nop
 800ea58:	08015c0c 	.word	0x08015c0c
 800ea5c:	00000000 	.word	0x00000000

0800ea60 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800ea60:	b510      	push	{r4, lr}
 800ea62:	4604      	mov	r4, r0

  chDbgCheckClassI();
 800ea64:	f7ff fef4 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800ea68:	2c00      	cmp	r4, #0
 800ea6a:	d033      	beq.n	800ead4 <chVTDoResetI+0x74>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 800ea6c:	68e3      	ldr	r3, [r4, #12]
 800ea6e:	2b00      	cmp	r3, #0
 800ea70:	d030      	beq.n	800ead4 <chVTDoResetI+0x74>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 800ea72:	4b1c      	ldr	r3, [pc, #112]	; (800eae4 <chVTDoResetI+0x84>)
 800ea74:	69da      	ldr	r2, [r3, #28]
 800ea76:	4294      	cmp	r4, r2
 800ea78:	d00f      	beq.n	800ea9a <chVTDoResetI+0x3a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800ea7a:	6861      	ldr	r1, [r4, #4]
 800ea7c:	6822      	ldr	r2, [r4, #0]
 800ea7e:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 800ea80:	6822      	ldr	r2, [r4, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800ea82:	331c      	adds	r3, #28
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
 800ea84:	2000      	movs	r0, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800ea86:	429a      	cmp	r2, r3
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 800ea88:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 800ea8a:	60e0      	str	r0, [r4, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800ea8c:	d004      	beq.n	800ea98 <chVTDoResetI+0x38>
      vtp->next->delta += vtp->delta;
 800ea8e:	68a3      	ldr	r3, [r4, #8]
 800ea90:	6891      	ldr	r1, [r2, #8]
 800ea92:	440b      	add	r3, r1
 800ea94:	6093      	str	r3, [r2, #8]
 800ea96:	bd10      	pop	{r4, pc}
 800ea98:	bd10      	pop	{r4, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800ea9a:	461a      	mov	r2, r3
 800ea9c:	6821      	ldr	r1, [r4, #0]
 800ea9e:	f842 1f1c 	str.w	r1, [r2, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 800eaa2:	2000      	movs	r0, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800eaa4:	4291      	cmp	r1, r2
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800eaa6:	604a      	str	r2, [r1, #4]
  vtp->func = NULL;
 800eaa8:	60e0      	str	r0, [r4, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800eaaa:	d016      	beq.n	800eada <chVTDoResetI+0x7a>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800eaac:	68a2      	ldr	r2, [r4, #8]
 800eaae:	6888      	ldr	r0, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 800eab0:	6a9c      	ldr	r4, [r3, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800eab2:	1883      	adds	r3, r0, r2
 800eab4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800eab8:	608b      	str	r3, [r1, #8]
 800eaba:	6a50      	ldr	r0, [r2, #36]	; 0x24
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 800eabc:	1b02      	subs	r2, r0, r4

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 800eabe:	4293      	cmp	r3, r2
 800eac0:	d9ea      	bls.n	800ea98 <chVTDoResetI+0x38>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 800eac2:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800eac4:	2b01      	cmp	r3, #1
 800eac6:	bf98      	it	ls
 800eac8:	2302      	movls	r3, #2
 800eaca:	4418      	add	r0, r3
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800eacc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800ead0:	f7fc bba6 	b.w	800b220 <stSetAlarm>
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
 800ead4:	4804      	ldr	r0, [pc, #16]	; (800eae8 <chVTDoResetI+0x88>)
 800ead6:	f7ff fe43 	bl	800e760 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800eada:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800eade:	60d8      	str	r0, [r3, #12]
 800eae0:	bd10      	pop	{r4, pc}
 800eae2:	bf00      	nop
 800eae4:	20027edc 	.word	0x20027edc
 800eae8:	08015bfc 	.word	0x08015bfc
 800eaec:	00000000 	.word	0x00000000

0800eaf0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800eaf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800eaf4:	4605      	mov	r5, r0
 800eaf6:	460e      	mov	r6, r1
 800eaf8:	4614      	mov	r4, r2
 800eafa:	4698      	mov	r8, r3
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800eafc:	f7ff fea8 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800eb00:	2d00      	cmp	r5, #0
 800eb02:	d02d      	beq.n	800eb60 <chVTDoSetI+0x70>
 800eb04:	b364      	cbz	r4, 800eb60 <chVTDoSetI+0x70>
 800eb06:	b35e      	cbz	r6, 800eb60 <chVTDoSetI+0x70>
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800eb08:	4f22      	ldr	r7, [pc, #136]	; (800eb94 <chVTDoSetI+0xa4>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 800eb0a:	f8c5 8010 	str.w	r8, [r5, #16]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800eb0e:	463b      	mov	r3, r7
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800eb10:	2e01      	cmp	r6, #1
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800eb12:	f853 2f1c 	ldr.w	r2, [r3, #28]!

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 800eb16:	60ec      	str	r4, [r5, #12]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800eb18:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800eb1c:	bf98      	it	ls
 800eb1e:	2602      	movls	r6, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800eb20:	429a      	cmp	r2, r3
 800eb22:	6a48      	ldr	r0, [r1, #36]	; 0x24
 800eb24:	d022      	beq.n	800eb6c <chVTDoSetI+0x7c>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 800eb26:	6abc      	ldr	r4, [r7, #40]	; 0x28
    if (delta < ch.vtlist.next->delta) {
 800eb28:	6893      	ldr	r3, [r2, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 800eb2a:	4430      	add	r0, r6
 800eb2c:	1b04      	subs	r4, r0, r4
    if (delta < ch.vtlist.next->delta) {
 800eb2e:	429c      	cmp	r4, r3
 800eb30:	d319      	bcc.n	800eb66 <chVTDoSetI+0x76>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
 800eb32:	69fb      	ldr	r3, [r7, #28]
  while (p->delta < delta) {
 800eb34:	689a      	ldr	r2, [r3, #8]
 800eb36:	4294      	cmp	r4, r2
 800eb38:	d904      	bls.n	800eb44 <chVTDoSetI+0x54>
    delta -= p->delta;
    p = p->next;
 800eb3a:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
    delta -= p->delta;
 800eb3c:	1aa4      	subs	r4, r4, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 800eb3e:	689a      	ldr	r2, [r3, #8]
 800eb40:	42a2      	cmp	r2, r4
 800eb42:	d3fa      	bcc.n	800eb3a <chVTDoSetI+0x4a>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 800eb44:	685a      	ldr	r2, [r3, #4]
 800eb46:	606a      	str	r2, [r5, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800eb48:	602b      	str	r3, [r5, #0]
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
 800eb4a:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 800eb4c:	605d      	str	r5, [r3, #4]
  vtp->delta = delta
 800eb4e:	60ac      	str	r4, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 800eb50:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 800eb52:	f04f 31ff 	mov.w	r1, #4294967295
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 800eb56:	1b14      	subs	r4, r2, r4
 800eb58:	609c      	str	r4, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 800eb5a:	6279      	str	r1, [r7, #36]	; 0x24
 800eb5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800eb60:	480d      	ldr	r0, [pc, #52]	; (800eb98 <chVTDoSetI+0xa8>)
 800eb62:	f7ff fdfd 	bl	800e760 <chSysHalt>
 800eb66:	f7fc fb5b 	bl	800b220 <stSetAlarm>
 800eb6a:	e7e2      	b.n	800eb32 <chVTDoSetI+0x42>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800eb6c:	62b8      	str	r0, [r7, #40]	; 0x28
      ch.vtlist.next = vtp;
 800eb6e:	61fd      	str	r5, [r7, #28]
      ch.vtlist.prev = vtp;
 800eb70:	623d      	str	r5, [r7, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 800eb72:	60ae      	str	r6, [r5, #8]
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800eb74:	68cb      	ldr	r3, [r1, #12]
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800eb76:	602a      	str	r2, [r5, #0]
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800eb78:	f013 0302 	ands.w	r3, r3, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800eb7c:	606a      	str	r2, [r5, #4]
 800eb7e:	d106      	bne.n	800eb8e <chVTDoSetI+0x9e>
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 800eb80:	4430      	add	r0, r6
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800eb82:	2202      	movs	r2, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800eb84:	6348      	str	r0, [r1, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800eb86:	610b      	str	r3, [r1, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800eb88:	60ca      	str	r2, [r1, #12]
 800eb8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800eb8e:	4803      	ldr	r0, [pc, #12]	; (800eb9c <chVTDoSetI+0xac>)
 800eb90:	f7ff fde6 	bl	800e760 <chSysHalt>
 800eb94:	20027edc 	.word	0x20027edc
 800eb98:	08015c1c 	.word	0x08015c1c
 800eb9c:	08015d60 	.word	0x08015d60

0800eba0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800eba0:	b570      	push	{r4, r5, r6, lr}
 800eba2:	460c      	mov	r4, r1
 800eba4:	b086      	sub	sp, #24
 800eba6:	4606      	mov	r6, r0

  chDbgCheckClassS();
 800eba8:	f7ff fdfa 	bl	800e7a0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800ebac:	1c63      	adds	r3, r4, #1
 800ebae:	d014      	beq.n	800ebda <chSchGoSleepTimeoutS+0x3a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800ebb0:	4d0e      	ldr	r5, [pc, #56]	; (800ebec <chSchGoSleepTimeoutS+0x4c>)
 800ebb2:	4a0f      	ldr	r2, [pc, #60]	; (800ebf0 <chSchGoSleepTimeoutS+0x50>)
 800ebb4:	69ab      	ldr	r3, [r5, #24]
 800ebb6:	4621      	mov	r1, r4
 800ebb8:	a801      	add	r0, sp, #4
 800ebba:	f7ff ff99 	bl	800eaf0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800ebbe:	4630      	mov	r0, r6
 800ebc0:	f7ff fdfe 	bl	800e7c0 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800ebc4:	f7ff fe44 	bl	800e850 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 800ebc8:	9b04      	ldr	r3, [sp, #16]
 800ebca:	b113      	cbz	r3, 800ebd2 <chSchGoSleepTimeoutS+0x32>
      chVTDoResetI(&vt);
 800ebcc:	a801      	add	r0, sp, #4
 800ebce:	f7ff ff47 	bl	800ea60 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 800ebd2:	69ab      	ldr	r3, [r5, #24]
}
 800ebd4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800ebd6:	b006      	add	sp, #24
 800ebd8:	bd70      	pop	{r4, r5, r6, pc}
 800ebda:	4d04      	ldr	r5, [pc, #16]	; (800ebec <chSchGoSleepTimeoutS+0x4c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800ebdc:	4630      	mov	r0, r6
 800ebde:	f7ff fdef 	bl	800e7c0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 800ebe2:	69ab      	ldr	r3, [r5, #24]
}
 800ebe4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800ebe6:	b006      	add	sp, #24
 800ebe8:	bd70      	pop	{r4, r5, r6, pc}
 800ebea:	bf00      	nop
 800ebec:	20027edc 	.word	0x20027edc
 800ebf0:	0800ecf1 	.word	0x0800ecf1
	...

0800ec00 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 800ec00:	b161      	cbz	r1, 800ec1c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800ec02:	4b08      	ldr	r3, [pc, #32]	; (800ec24 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 800ec04:	b410      	push	{r4}
 800ec06:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 800ec08:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800ec0a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800ec0c:	2004      	movs	r0, #4
 800ec0e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 800ec12:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 800ec14:	6053      	str	r3, [r2, #4]
}
 800ec16:	bc10      	pop	{r4}
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800ec18:	f7ff bfc2 	b.w	800eba0 <chSchGoSleepTimeoutS>
}
 800ec1c:	f04f 30ff 	mov.w	r0, #4294967295
 800ec20:	4770      	bx	lr
 800ec22:	bf00      	nop
 800ec24:	20027edc 	.word	0x20027edc
	...

0800ec30 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 800ec30:	b508      	push	{r3, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800ec32:	2320      	movs	r3, #32
 800ec34:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800ec38:	4a06      	ldr	r2, [pc, #24]	; (800ec54 <_dbg_check_leave_isr+0x24>)
 800ec3a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800ec3c:	2b00      	cmp	r3, #0
 800ec3e:	dd01      	ble.n	800ec44 <_dbg_check_leave_isr+0x14>
 800ec40:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800ec42:	b111      	cbz	r1, 800ec4a <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
 800ec44:	4804      	ldr	r0, [pc, #16]	; (800ec58 <_dbg_check_leave_isr+0x28>)
 800ec46:	f7ff fd8b 	bl	800e760 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800ec4a:	3b01      	subs	r3, #1
 800ec4c:	6313      	str	r3, [r2, #48]	; 0x30
 800ec4e:	f381 8811 	msr	BASEPRI, r1
 800ec52:	bd08      	pop	{r3, pc}
 800ec54:	20027edc 	.word	0x20027edc
 800ec58:	08015c6c 	.word	0x08015c6c
 800ec5c:	00000000 	.word	0x00000000

0800ec60 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 800ec60:	b508      	push	{r3, lr}
 800ec62:	2320      	movs	r3, #32
 800ec64:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800ec68:	4a06      	ldr	r2, [pc, #24]	; (800ec84 <_dbg_check_enter_isr+0x24>)
 800ec6a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800ec6c:	2b00      	cmp	r3, #0
 800ec6e:	db01      	blt.n	800ec74 <_dbg_check_enter_isr+0x14>
 800ec70:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800ec72:	b111      	cbz	r1, 800ec7a <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
 800ec74:	4804      	ldr	r0, [pc, #16]	; (800ec88 <_dbg_check_enter_isr+0x28>)
 800ec76:	f7ff fd73 	bl	800e760 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800ec7a:	3301      	adds	r3, #1
 800ec7c:	6313      	str	r3, [r2, #48]	; 0x30
 800ec7e:	f381 8811 	msr	BASEPRI, r1
 800ec82:	bd08      	pop	{r3, pc}
 800ec84:	20027edc 	.word	0x20027edc
 800ec88:	08015c74 	.word	0x08015c74
 800ec8c:	00000000 	.word	0x00000000

0800ec90 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 800ec90:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800ec92:	4b06      	ldr	r3, [pc, #24]	; (800ecac <_dbg_check_unlock_from_isr+0x1c>)
 800ec94:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ec96:	2a00      	cmp	r2, #0
 800ec98:	dd05      	ble.n	800eca6 <_dbg_check_unlock_from_isr+0x16>
 800ec9a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ec9c:	2a00      	cmp	r2, #0
 800ec9e:	dd02      	ble.n	800eca6 <_dbg_check_unlock_from_isr+0x16>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 800eca0:	2200      	movs	r2, #0
 800eca2:	635a      	str	r2, [r3, #52]	; 0x34
 800eca4:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
 800eca6:	4802      	ldr	r0, [pc, #8]	; (800ecb0 <_dbg_check_unlock_from_isr+0x20>)
 800eca8:	f7ff fd5a 	bl	800e760 <chSysHalt>
 800ecac:	20027edc 	.word	0x20027edc
 800ecb0:	08015c7c 	.word	0x08015c7c
	...

0800ecc0 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 800ecc0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800ecc2:	4b06      	ldr	r3, [pc, #24]	; (800ecdc <_dbg_check_lock_from_isr+0x1c>)
 800ecc4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ecc6:	2a00      	cmp	r2, #0
 800ecc8:	dd01      	ble.n	800ecce <_dbg_check_lock_from_isr+0xe>
 800ecca:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800eccc:	b112      	cbz	r2, 800ecd4 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 800ecce:	4804      	ldr	r0, [pc, #16]	; (800ece0 <_dbg_check_lock_from_isr+0x20>)
 800ecd0:	f7ff fd46 	bl	800e760 <chSysHalt>
  }
  _dbg_enter_lock();
 800ecd4:	2201      	movs	r2, #1
 800ecd6:	635a      	str	r2, [r3, #52]	; 0x34
 800ecd8:	bd08      	pop	{r3, pc}
 800ecda:	bf00      	nop
 800ecdc:	20027edc 	.word	0x20027edc
 800ece0:	08015c84 	.word	0x08015c84
	...

0800ecf0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800ecf0:	b538      	push	{r3, r4, r5, lr}
 800ecf2:	4604      	mov	r4, r0
 800ecf4:	2320      	movs	r3, #32
 800ecf6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800ecfa:	f7ff ffe1 	bl	800ecc0 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 800ecfe:	f894 3020 	ldrb.w	r3, [r4, #32]
 800ed02:	2b07      	cmp	r3, #7
 800ed04:	d810      	bhi.n	800ed28 <wakeup+0x38>
 800ed06:	e8df f003 	tbb	[pc, r3]
 800ed0a:	0f15      	.short	0x0f15
 800ed0c:	040a1b0f 	.word	0x040a1b0f
 800ed10:	0a0f      	.short	0x0a0f
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800ed12:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 800ed14:	f7ff fd9c 	bl	800e850 <chDbgCheckClassI>

  sp->cnt++;
 800ed18:	68ab      	ldr	r3, [r5, #8]
 800ed1a:	3301      	adds	r3, #1
 800ed1c:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800ed1e:	e894 000c 	ldmia.w	r4, {r2, r3}
 800ed22:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800ed24:	6822      	ldr	r2, [r4, #0]
 800ed26:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800ed28:	f04f 33ff 	mov.w	r3, #4294967295
 800ed2c:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 800ed2e:	4620      	mov	r0, r4
 800ed30:	f7ff fe56 	bl	800e9e0 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800ed34:	f7ff ffac 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800ed38:	2300      	movs	r3, #0
 800ed3a:	f383 8811 	msr	BASEPRI, r3
 800ed3e:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800ed40:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ed42:	2200      	movs	r2, #0
 800ed44:	601a      	str	r2, [r3, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800ed46:	f04f 33ff 	mov.w	r3, #4294967295
 800ed4a:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 800ed4c:	4620      	mov	r0, r4
 800ed4e:	f7ff fe47 	bl	800e9e0 <chSchReadyI>
 800ed52:	e7ef      	b.n	800ed34 <wakeup+0x44>
	...

0800ed60 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 800ed60:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800ed62:	4b05      	ldr	r3, [pc, #20]	; (800ed78 <_dbg_check_unlock+0x18>)
 800ed64:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ed66:	b922      	cbnz	r2, 800ed72 <_dbg_check_unlock+0x12>
 800ed68:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800ed6a:	2900      	cmp	r1, #0
 800ed6c:	dd01      	ble.n	800ed72 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800ed6e:	635a      	str	r2, [r3, #52]	; 0x34
 800ed70:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 800ed72:	4802      	ldr	r0, [pc, #8]	; (800ed7c <_dbg_check_unlock+0x1c>)
 800ed74:	f7ff fcf4 	bl	800e760 <chSysHalt>
 800ed78:	20027edc 	.word	0x20027edc
 800ed7c:	08015c8c 	.word	0x08015c8c

0800ed80 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 800ed80:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800ed82:	4b05      	ldr	r3, [pc, #20]	; (800ed98 <_dbg_check_lock+0x18>)
 800ed84:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800ed86:	b90a      	cbnz	r2, 800ed8c <_dbg_check_lock+0xc>
 800ed88:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ed8a:	b112      	cbz	r2, 800ed92 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 800ed8c:	4803      	ldr	r0, [pc, #12]	; (800ed9c <_dbg_check_lock+0x1c>)
 800ed8e:	f7ff fce7 	bl	800e760 <chSysHalt>
  }
  _dbg_enter_lock();
 800ed92:	2201      	movs	r2, #1
 800ed94:	635a      	str	r2, [r3, #52]	; 0x34
 800ed96:	bd08      	pop	{r3, pc}
 800ed98:	20027edc 	.word	0x20027edc
 800ed9c:	08015c94 	.word	0x08015c94

0800eda0 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 800eda0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800eda2:	4605      	mov	r5, r0
 800eda4:	460c      	mov	r4, r1
 800eda6:	2320      	movs	r3, #32
 800eda8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800edac:	f7ff ffe8 	bl	800ed80 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
  uint8_t *p;

  chDbgCheckClassI();
 800edb0:	f7ff fd4e 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800edb4:	b32c      	cbz	r4, 800ee02 <chCoreAllocAligned+0x62>
 800edb6:	1e62      	subs	r2, r4, #1
 800edb8:	ea14 0702 	ands.w	r7, r4, r2
 800edbc:	d121      	bne.n	800ee02 <chCoreAllocAligned+0x62>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800edbe:	4e14      	ldr	r6, [pc, #80]	; (800ee10 <chCoreAllocAligned+0x70>)

  if (((size_t)endmem - (size_t)p) < size) {
 800edc0:	4914      	ldr	r1, [pc, #80]	; (800ee14 <chCoreAllocAligned+0x74>)

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800edc2:	6833      	ldr	r3, [r6, #0]

  if (((size_t)endmem - (size_t)p) < size) {
 800edc4:	6809      	ldr	r1, [r1, #0]

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800edc6:	3b01      	subs	r3, #1
 800edc8:	4423      	add	r3, r4
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800edca:	4264      	negs	r4, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800edcc:	ea03 0004 	and.w	r0, r3, r4
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800edd0:	442a      	add	r2, r5
 800edd2:	4014      	ands	r4, r2
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 800edd4:	1a0b      	subs	r3, r1, r0
 800edd6:	429c      	cmp	r4, r3
    return NULL;
  }
  nextmem = p + size;
 800edd8:	bf9b      	ittet	ls
 800edda:	1824      	addls	r4, r4, r0
 800eddc:	6034      	strls	r4, [r6, #0]

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 800edde:	463c      	movhi	r4, r7
  }
  nextmem = p + size;

  return p;
 800ede0:	4604      	movls	r4, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800ede2:	f7ff ffbd 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ede6:	4b0c      	ldr	r3, [pc, #48]	; (800ee18 <chCoreAllocAligned+0x78>)
 800ede8:	681a      	ldr	r2, [r3, #0]
 800edea:	429a      	cmp	r2, r3
 800edec:	d004      	beq.n	800edf8 <chCoreAllocAligned+0x58>
 800edee:	6999      	ldr	r1, [r3, #24]
 800edf0:	6893      	ldr	r3, [r2, #8]
 800edf2:	688a      	ldr	r2, [r1, #8]
 800edf4:	429a      	cmp	r2, r3
 800edf6:	d307      	bcc.n	800ee08 <chCoreAllocAligned+0x68>
 800edf8:	2300      	movs	r3, #0
 800edfa:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 800edfe:	4620      	mov	r0, r4
 800ee00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800ee02:	4806      	ldr	r0, [pc, #24]	; (800ee1c <chCoreAllocAligned+0x7c>)
 800ee04:	f7ff fcac 	bl	800e760 <chSysHalt>
 800ee08:	4805      	ldr	r0, [pc, #20]	; (800ee20 <chCoreAllocAligned+0x80>)
 800ee0a:	f7ff fca9 	bl	800e760 <chSysHalt>
 800ee0e:	bf00      	nop
 800ee10:	20005f14 	.word	0x20005f14
 800ee14:	20027780 	.word	0x20027780
 800ee18:	20027edc 	.word	0x20027edc
 800ee1c:	08015bcc 	.word	0x08015bcc
 800ee20:	08015d54 	.word	0x08015d54
	...

0800ee30 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 800ee30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  thread_t *ctp = currp;
 800ee34:	4f28      	ldr	r7, [pc, #160]	; (800eed8 <chMtxUnlock+0xa8>)
 800ee36:	69bd      	ldr	r5, [r7, #24]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800ee38:	b150      	cbz	r0, 800ee50 <chMtxUnlock+0x20>
 800ee3a:	4606      	mov	r6, r0
 800ee3c:	2320      	movs	r3, #32
 800ee3e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ee42:	f7ff ff9d 	bl	800ed80 <_dbg_check_lock>

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 800ee46:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800ee48:	b113      	cbz	r3, 800ee50 <chMtxUnlock+0x20>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800ee4a:	689a      	ldr	r2, [r3, #8]
 800ee4c:	4295      	cmp	r5, r2
 800ee4e:	d002      	beq.n	800ee56 <chMtxUnlock+0x26>
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800ee50:	4822      	ldr	r0, [pc, #136]	; (800eedc <chMtxUnlock+0xac>)
 800ee52:	f7ff fc85 	bl	800e760 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 800ee56:	429e      	cmp	r6, r3
 800ee58:	d1fa      	bne.n	800ee50 <chMtxUnlock+0x20>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800ee5a:	68f4      	ldr	r4, [r6, #12]
 800ee5c:	63ac      	str	r4, [r5, #56]	; 0x38
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 800ee5e:	f7ff fc9f 	bl	800e7a0 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800ee62:	f8d6 9000 	ldr.w	r9, [r6]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800ee66:	454e      	cmp	r6, r9
 800ee68:	d033      	beq.n	800eed2 <chMtxUnlock+0xa2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 800ee6a:	f8d5 803c 	ldr.w	r8, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800ee6e:	b15c      	cbz	r4, 800ee88 <chMtxUnlock+0x58>
 800ee70:	f7ff fc96 	bl	800e7a0 <chDbgCheckClassS>
 800ee74:	6823      	ldr	r3, [r4, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800ee76:	429c      	cmp	r4, r3
 800ee78:	d003      	beq.n	800ee82 <chMtxUnlock+0x52>
            (lmp->queue.next->prio > newprio)) {
 800ee7a:	689b      	ldr	r3, [r3, #8]
 800ee7c:	4598      	cmp	r8, r3
 800ee7e:	bf38      	it	cc
 800ee80:	4698      	movcc	r8, r3
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 800ee82:	68e4      	ldr	r4, [r4, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800ee84:	2c00      	cmp	r4, #0
 800ee86:	d1f3      	bne.n	800ee70 <chMtxUnlock+0x40>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800ee88:	f8d9 3000 	ldr.w	r3, [r9]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 800ee8c:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800ee90:	f8c5 8008 	str.w	r8, [r5, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800ee94:	4648      	mov	r0, r9
 800ee96:	6033      	str	r3, [r6, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800ee98:	605e      	str	r6, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 800ee9a:	60f2      	str	r2, [r6, #12]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 800ee9c:	f8c6 9008 	str.w	r9, [r6, #8]
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
 800eea0:	f8c9 6038 	str.w	r6, [r9, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800eea4:	f7ff fd9c 	bl	800e9e0 <chSchReadyI>
      chSchRescheduleS();
 800eea8:	f7ff fd82 	bl	800e9b0 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800eeac:	f7ff ff58 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800eeb0:	683b      	ldr	r3, [r7, #0]
 800eeb2:	4a09      	ldr	r2, [pc, #36]	; (800eed8 <chMtxUnlock+0xa8>)
 800eeb4:	42bb      	cmp	r3, r7
 800eeb6:	d004      	beq.n	800eec2 <chMtxUnlock+0x92>
 800eeb8:	6992      	ldr	r2, [r2, #24]
 800eeba:	689b      	ldr	r3, [r3, #8]
 800eebc:	6892      	ldr	r2, [r2, #8]
 800eebe:	429a      	cmp	r2, r3
 800eec0:	d304      	bcc.n	800eecc <chMtxUnlock+0x9c>
 800eec2:	2300      	movs	r3, #0
 800eec4:	f383 8811 	msr	BASEPRI, r3
 800eec8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800eecc:	4804      	ldr	r0, [pc, #16]	; (800eee0 <chMtxUnlock+0xb0>)
 800eece:	f7ff fc47 	bl	800e760 <chSysHalt>
    }
    else {
      mp->owner = NULL;
 800eed2:	2300      	movs	r3, #0
 800eed4:	60b3      	str	r3, [r6, #8]
 800eed6:	e7e9      	b.n	800eeac <chMtxUnlock+0x7c>
 800eed8:	20027edc 	.word	0x20027edc
 800eedc:	08015be0 	.word	0x08015be0
 800eee0:	08015d48 	.word	0x08015d48
	...

0800eef0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 800eef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800eef2:	4605      	mov	r5, r0
 800eef4:	2320      	movs	r3, #32
 800eef6:	f383 8811 	msr	BASEPRI, r3
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 800eefa:	4e43      	ldr	r6, [pc, #268]	; (800f008 <chMtxLock+0x118>)
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800eefc:	f7ff ff40 	bl	800ed80 <_dbg_check_lock>
 800ef00:	69b4      	ldr	r4, [r6, #24]

  chDbgCheckClassS();
 800ef02:	f7ff fc4d 	bl	800e7a0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800ef06:	b31d      	cbz	r5, 800ef50 <chMtxLock+0x60>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800ef08:	68a8      	ldr	r0, [r5, #8]
 800ef0a:	2800      	cmp	r0, #0
 800ef0c:	d06d      	beq.n	800efea <chMtxLock+0xfa>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800ef0e:	68a2      	ldr	r2, [r4, #8]
 800ef10:	6883      	ldr	r3, [r0, #8]
 800ef12:	429a      	cmp	r2, r3
 800ef14:	d907      	bls.n	800ef26 <chMtxLock+0x36>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800ef16:	f890 3020 	ldrb.w	r3, [r0, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800ef1a:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800ef1c:	2b06      	cmp	r3, #6
 800ef1e:	d039      	beq.n	800ef94 <chMtxLock+0xa4>
 800ef20:	2b07      	cmp	r3, #7
 800ef22:	d023      	beq.n	800ef6c <chMtxLock+0x7c>
 800ef24:	b1bb      	cbz	r3, 800ef56 <chMtxLock+0x66>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800ef26:	462b      	mov	r3, r5
 800ef28:	e003      	b.n	800ef32 <chMtxLock+0x42>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800ef2a:	6899      	ldr	r1, [r3, #8]
 800ef2c:	68a2      	ldr	r2, [r4, #8]
 800ef2e:	4291      	cmp	r1, r2
 800ef30:	d302      	bcc.n	800ef38 <chMtxLock+0x48>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800ef32:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800ef34:	429d      	cmp	r5, r3
 800ef36:	d1f8      	bne.n	800ef2a <chMtxLock+0x3a>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800ef38:	685a      	ldr	r2, [r3, #4]
 800ef3a:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800ef3c:	6023      	str	r3, [r4, #0]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800ef3e:	2006      	movs	r0, #6
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800ef40:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 800ef42:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 800ef44:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800ef46:	f7ff fc3b 	bl	800e7c0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 800ef4a:	68ab      	ldr	r3, [r5, #8]
 800ef4c:	429c      	cmp	r4, r3
 800ef4e:	d03a      	beq.n	800efc6 <chMtxLock+0xd6>
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 800ef50:	482e      	ldr	r0, [pc, #184]	; (800f00c <chMtxLock+0x11c>)
 800ef52:	f7ff fc05 	bl	800e760 <chSysHalt>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800ef56:	e890 000c 	ldmia.w	r0, {r2, r3}
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 800ef5a:	2101      	movs	r1, #1
 800ef5c:	f880 1020 	strb.w	r1, [r0, #32]
 800ef60:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800ef62:	6802      	ldr	r2, [r0, #0]
 800ef64:	6053      	str	r3, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800ef66:	f7ff fd3b 	bl	800e9e0 <chSchReadyI>
 800ef6a:	e7dc      	b.n	800ef26 <chMtxLock+0x36>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800ef6c:	e890 000a 	ldmia.w	r0, {r1, r3}
 800ef70:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800ef72:	6801      	ldr	r1, [r0, #0]
 800ef74:	604b      	str	r3, [r1, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800ef76:	6a47      	ldr	r7, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800ef78:	463b      	mov	r3, r7
 800ef7a:	e002      	b.n	800ef82 <chMtxLock+0x92>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800ef7c:	6899      	ldr	r1, [r3, #8]
 800ef7e:	4291      	cmp	r1, r2
 800ef80:	d302      	bcc.n	800ef88 <chMtxLock+0x98>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800ef82:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800ef84:	429f      	cmp	r7, r3
 800ef86:	d1f9      	bne.n	800ef7c <chMtxLock+0x8c>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800ef88:	685a      	ldr	r2, [r3, #4]
 800ef8a:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800ef8c:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800ef8e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800ef90:	6058      	str	r0, [r3, #4]
 800ef92:	e7c8      	b.n	800ef26 <chMtxLock+0x36>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800ef94:	e890 000a 	ldmia.w	r0, {r1, r3}
 800ef98:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800ef9a:	6801      	ldr	r1, [r0, #0]
 800ef9c:	604b      	str	r3, [r1, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800ef9e:	6a47      	ldr	r7, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800efa0:	463b      	mov	r3, r7
 800efa2:	e002      	b.n	800efaa <chMtxLock+0xba>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800efa4:	6899      	ldr	r1, [r3, #8]
 800efa6:	4291      	cmp	r1, r2
 800efa8:	d302      	bcc.n	800efb0 <chMtxLock+0xc0>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800efaa:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800efac:	429f      	cmp	r7, r3
 800efae:	d1f9      	bne.n	800efa4 <chMtxLock+0xb4>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800efb0:	685a      	ldr	r2, [r3, #4]
 800efb2:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800efb4:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800efb6:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800efb8:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800efba:	68b8      	ldr	r0, [r7, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800efbc:	68a2      	ldr	r2, [r4, #8]
 800efbe:	6883      	ldr	r3, [r0, #8]
 800efc0:	429a      	cmp	r2, r3
 800efc2:	d8a8      	bhi.n	800ef16 <chMtxLock+0x26>
 800efc4:	e7af      	b.n	800ef26 <chMtxLock+0x36>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 800efc6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800efc8:	429d      	cmp	r5, r3
 800efca:	d1c1      	bne.n	800ef50 <chMtxLock+0x60>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800efcc:	f7ff fec8 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800efd0:	6833      	ldr	r3, [r6, #0]
 800efd2:	4a0d      	ldr	r2, [pc, #52]	; (800f008 <chMtxLock+0x118>)
 800efd4:	42b3      	cmp	r3, r6
 800efd6:	d004      	beq.n	800efe2 <chMtxLock+0xf2>
 800efd8:	6992      	ldr	r2, [r2, #24]
 800efda:	689b      	ldr	r3, [r3, #8]
 800efdc:	6892      	ldr	r2, [r2, #8]
 800efde:	429a      	cmp	r2, r3
 800efe0:	d30e      	bcc.n	800f000 <chMtxLock+0x110>
 800efe2:	2300      	movs	r3, #0
 800efe4:	f383 8811 	msr	BASEPRI, r3
 800efe8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 800efea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800efec:	60eb      	str	r3, [r5, #12]
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 800efee:	60ac      	str	r4, [r5, #8]
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
 800eff0:	63a5      	str	r5, [r4, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800eff2:	f7ff feb5 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800eff6:	6833      	ldr	r3, [r6, #0]
 800eff8:	4a03      	ldr	r2, [pc, #12]	; (800f008 <chMtxLock+0x118>)
 800effa:	42b3      	cmp	r3, r6
 800effc:	d1ec      	bne.n	800efd8 <chMtxLock+0xe8>
 800effe:	e7f0      	b.n	800efe2 <chMtxLock+0xf2>
 800f000:	4803      	ldr	r0, [pc, #12]	; (800f010 <chMtxLock+0x120>)
 800f002:	f7ff fbad 	bl	800e760 <chSysHalt>
 800f006:	bf00      	nop
 800f008:	20027edc 	.word	0x20027edc
 800f00c:	08015c34 	.word	0x08015c34
 800f010:	08015d48 	.word	0x08015d48
	...

0800f020 <chThdSleepUntilWindowed>:
 * @param[in] next      absolute system time of the next deadline
 * @return              the @p next parameter
 *
 * @api
 */
systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next) {
 800f020:	b538      	push	{r3, r4, r5, lr}
 800f022:	4604      	mov	r4, r0
 800f024:	460d      	mov	r5, r1
 800f026:	2320      	movs	r3, #32
 800f028:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800f02c:	f7ff fea8 	bl	800ed80 <_dbg_check_lock>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800f030:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  systime_t time;

  chSysLock();
  time = chVTGetSystemTimeX();
  if (chVTIsTimeWithinX(time, prev, next)) {
 800f034:	1b2b      	subs	r3, r5, r4
 800f036:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800f038:	1b0c      	subs	r4, r1, r4
 800f03a:	429c      	cmp	r4, r3
 800f03c:	d312      	bcc.n	800f064 <chThdSleepUntilWindowed+0x44>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800f03e:	f7ff fe8f 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800f042:	4b0d      	ldr	r3, [pc, #52]	; (800f078 <chThdSleepUntilWindowed+0x58>)
 800f044:	681a      	ldr	r2, [r3, #0]
 800f046:	429a      	cmp	r2, r3
 800f048:	d004      	beq.n	800f054 <chThdSleepUntilWindowed+0x34>
 800f04a:	6999      	ldr	r1, [r3, #24]
 800f04c:	6893      	ldr	r3, [r2, #8]
 800f04e:	688a      	ldr	r2, [r1, #8]
 800f050:	429a      	cmp	r2, r3
 800f052:	d304      	bcc.n	800f05e <chThdSleepUntilWindowed+0x3e>
 800f054:	2300      	movs	r3, #0
 800f056:	f383 8811 	msr	BASEPRI, r3
    chThdSleepS(next - time);
  }
  chSysUnlock();

  return next;
}
 800f05a:	4628      	mov	r0, r5
 800f05c:	bd38      	pop	{r3, r4, r5, pc}
 800f05e:	4807      	ldr	r0, [pc, #28]	; (800f07c <chThdSleepUntilWindowed+0x5c>)
 800f060:	f7ff fb7e 	bl	800e760 <chSysHalt>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800f064:	1a69      	subs	r1, r5, r1
 800f066:	d003      	beq.n	800f070 <chThdSleepUntilWindowed+0x50>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800f068:	2008      	movs	r0, #8
 800f06a:	f7ff fd99 	bl	800eba0 <chSchGoSleepTimeoutS>
 800f06e:	e7e6      	b.n	800f03e <chThdSleepUntilWindowed+0x1e>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800f070:	4803      	ldr	r0, [pc, #12]	; (800f080 <chThdSleepUntilWindowed+0x60>)
 800f072:	f7ff fb75 	bl	800e760 <chSysHalt>
 800f076:	bf00      	nop
 800f078:	20027edc 	.word	0x20027edc
 800f07c:	08014f38 	.word	0x08014f38
 800f080:	08015d7c 	.word	0x08015d7c
	...

0800f090 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 800f090:	b510      	push	{r4, lr}
 800f092:	2320      	movs	r3, #32
 800f094:	4604      	mov	r4, r0
 800f096:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800f09a:	f7ff fe71 	bl	800ed80 <_dbg_check_lock>
 800f09e:	b1ac      	cbz	r4, 800f0cc <chThdSleep+0x3c>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800f0a0:	4621      	mov	r1, r4
 800f0a2:	2008      	movs	r0, #8
 800f0a4:	f7ff fd7c 	bl	800eba0 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800f0a8:	f7ff fe5a 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800f0ac:	4b09      	ldr	r3, [pc, #36]	; (800f0d4 <chThdSleep+0x44>)
 800f0ae:	681a      	ldr	r2, [r3, #0]
 800f0b0:	429a      	cmp	r2, r3
 800f0b2:	d004      	beq.n	800f0be <chThdSleep+0x2e>
 800f0b4:	6999      	ldr	r1, [r3, #24]
 800f0b6:	6893      	ldr	r3, [r2, #8]
 800f0b8:	688a      	ldr	r2, [r1, #8]
 800f0ba:	429a      	cmp	r2, r3
 800f0bc:	d303      	bcc.n	800f0c6 <chThdSleep+0x36>
 800f0be:	2300      	movs	r3, #0
 800f0c0:	f383 8811 	msr	BASEPRI, r3
 800f0c4:	bd10      	pop	{r4, pc}
 800f0c6:	4804      	ldr	r0, [pc, #16]	; (800f0d8 <chThdSleep+0x48>)
 800f0c8:	f7ff fb4a 	bl	800e760 <chSysHalt>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800f0cc:	4803      	ldr	r0, [pc, #12]	; (800f0dc <chThdSleep+0x4c>)
 800f0ce:	f7ff fb47 	bl	800e760 <chSysHalt>
 800f0d2:	bf00      	nop
 800f0d4:	20027edc 	.word	0x20027edc
 800f0d8:	08014f38 	.word	0x08014f38
 800f0dc:	08015d7c 	.word	0x08015d7c

0800f0e0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 800f0e0:	b508      	push	{r3, lr}
 800f0e2:	4605      	mov	r5, r0
 800f0e4:	2320      	movs	r3, #32
 800f0e6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800f0ea:	f7ff fe49 	bl	800ed80 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 800f0ee:	4b10      	ldr	r3, [pc, #64]	; (800f130 <chThdExit+0x50>)
 800f0f0:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 800f0f2:	6aa0      	ldr	r0, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 800f0f4:	6265      	str	r5, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800f0f6:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800f0fa:	4285      	cmp	r5, r0
 800f0fc:	d006      	beq.n	800f10c <chThdExit+0x2c>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 800f0fe:	6803      	ldr	r3, [r0, #0]
 800f100:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 800f102:	f7ff fc6d 	bl	800e9e0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 800f106:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800f108:	42a8      	cmp	r0, r5
 800f10a:	d1f8      	bne.n	800f0fe <chThdExit+0x1e>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 800f10c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800f110:	b943      	cbnz	r3, 800f124 <chThdExit+0x44>
 800f112:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 800f116:	079b      	lsls	r3, r3, #30
 800f118:	d104      	bne.n	800f124 <chThdExit+0x44>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 800f11a:	6963      	ldr	r3, [r4, #20]
 800f11c:	6922      	ldr	r2, [r4, #16]
 800f11e:	611a      	str	r2, [r3, #16]
 800f120:	6922      	ldr	r2, [r4, #16]
 800f122:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800f124:	200f      	movs	r0, #15
 800f126:	f7ff fb4b 	bl	800e7c0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800f12a:	4802      	ldr	r0, [pc, #8]	; (800f134 <chThdExit+0x54>)
 800f12c:	f7ff fb18 	bl	800e760 <chSysHalt>
 800f130:	20027edc 	.word	0x20027edc
 800f134:	08015c28 	.word	0x08015c28
	...

0800f140 <chSysGetStatusAndLockX.part.1.lto_priv.109>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 800f140:	b508      	push	{r3, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f142:	f3ef 8305 	mrs	r3, IPSR

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 800f146:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800f14a:	b92b      	cbnz	r3, 800f158 <chSysGetStatusAndLockX.part.1.lto_priv.109+0x18>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800f14c:	2320      	movs	r3, #32
 800f14e:	f383 8811 	msr	BASEPRI, r3
 800f152:	f7ff fe15 	bl	800ed80 <_dbg_check_lock>
    else {
      chSysLock();
    }
  }
  return sts;
}
 800f156:	bd08      	pop	{r3, pc}
 800f158:	2320      	movs	r3, #32
 800f15a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800f15e:	f7ff fdaf 	bl	800ecc0 <_dbg_check_lock_from_isr>
 800f162:	bd08      	pop	{r3, pc}
	...

0800f170 <chSysRestoreStatusX.part.2.lto_priv.110>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 800f170:	b508      	push	{r3, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800f172:	f3ef 8305 	mrs	r3, IPSR

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 800f176:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800f17a:	b983      	cbnz	r3, 800f19e <chSysRestoreStatusX.part.2.lto_priv.110+0x2e>
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 800f17c:	f7ff fc18 	bl	800e9b0 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800f180:	f7ff fdee 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800f184:	4b0a      	ldr	r3, [pc, #40]	; (800f1b0 <chSysRestoreStatusX.part.2.lto_priv.110+0x40>)
 800f186:	681a      	ldr	r2, [r3, #0]
 800f188:	429a      	cmp	r2, r3
 800f18a:	d004      	beq.n	800f196 <chSysRestoreStatusX.part.2.lto_priv.110+0x26>
 800f18c:	6999      	ldr	r1, [r3, #24]
 800f18e:	6893      	ldr	r3, [r2, #8]
 800f190:	688a      	ldr	r2, [r1, #8]
 800f192:	429a      	cmp	r2, r3
 800f194:	d309      	bcc.n	800f1aa <chSysRestoreStatusX.part.2.lto_priv.110+0x3a>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800f196:	2300      	movs	r3, #0
 800f198:	f383 8811 	msr	BASEPRI, r3
 800f19c:	bd08      	pop	{r3, pc}
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800f19e:	f7ff fd77 	bl	800ec90 <_dbg_check_unlock_from_isr>
 800f1a2:	2300      	movs	r3, #0
 800f1a4:	f383 8811 	msr	BASEPRI, r3
 800f1a8:	bd08      	pop	{r3, pc}

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800f1aa:	4802      	ldr	r0, [pc, #8]	; (800f1b4 <chSysRestoreStatusX.part.2.lto_priv.110+0x44>)
 800f1ac:	f7ff fad8 	bl	800e760 <chSysHalt>
 800f1b0:	20027edc 	.word	0x20027edc
 800f1b4:	08015d70 	.word	0x08015d70
	...

0800f1c0 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 800f1c0:	e7fe      	b.n	800f1c0 <BusFault_Handler>
 800f1c2:	bf00      	nop
	...

0800f1d0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800f1d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f1d2:	4f13      	ldr	r7, [pc, #76]	; (800f220 <__init_ram_areas+0x50>)
 800f1d4:	4d13      	ldr	r5, [pc, #76]	; (800f224 <__init_ram_areas+0x54>)
 800f1d6:	4c14      	ldr	r4, [pc, #80]	; (800f228 <__init_ram_areas+0x58>)
 800f1d8:	4b14      	ldr	r3, [pc, #80]	; (800f22c <__init_ram_areas+0x5c>)
 800f1da:	4915      	ldr	r1, [pc, #84]	; (800f230 <__init_ram_areas+0x60>)
 800f1dc:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800f1e0:	2600      	movs	r6, #0
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800f1e2:	429c      	cmp	r4, r3
 800f1e4:	d911      	bls.n	800f20a <__init_ram_areas+0x3a>
 800f1e6:	3904      	subs	r1, #4
 800f1e8:	461a      	mov	r2, r3
      *p = *tp;
 800f1ea:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800f1ee:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800f1f2:	4294      	cmp	r4, r2
 800f1f4:	d8f9      	bhi.n	800f1ea <__init_ram_areas+0x1a>
 800f1f6:	43da      	mvns	r2, r3
 800f1f8:	4414      	add	r4, r2
 800f1fa:	f024 0403 	bic.w	r4, r4, #3
 800f1fe:	3404      	adds	r4, #4
 800f200:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800f202:	429d      	cmp	r5, r3
 800f204:	d903      	bls.n	800f20e <__init_ram_areas+0x3e>
      *p = 0;
 800f206:	f843 6b04 	str.w	r6, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800f20a:	429d      	cmp	r5, r3
 800f20c:	d8fb      	bhi.n	800f206 <__init_ram_areas+0x36>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800f20e:	4577      	cmp	r7, lr
 800f210:	d005      	beq.n	800f21e <__init_ram_areas+0x4e>
 800f212:	6939      	ldr	r1, [r7, #16]
 800f214:	697b      	ldr	r3, [r7, #20]
 800f216:	69bc      	ldr	r4, [r7, #24]
 800f218:	69fd      	ldr	r5, [r7, #28]
 800f21a:	3710      	adds	r7, #16
 800f21c:	e7e1      	b.n	800f1e2 <__init_ram_areas+0x12>
 800f21e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800f220:	08015cb0 	.word	0x08015cb0
 800f224:	20028810 	.word	0x20028810
 800f228:	20028810 	.word	0x20028810
 800f22c:	20028810 	.word	0x20028810
 800f230:	08017b48 	.word	0x08017b48
	...

0800f240 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 800f240:	e7fe      	b.n	800f240 <__default_exit>
 800f242:	bf00      	nop
	...

0800f250 <__late_init>:
 800f250:	4770      	bx	lr
 800f252:	bf00      	nop
	...

0800f260 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 800f260:	4770      	bx	lr
 800f262:	bf00      	nop
	...

0800f270 <OV2640_dma_avail>:

	return size;
}

void OV2640_dma_avail(uint32_t flags)
{
 800f270:	b570      	push	{r4, r5, r6, lr}
	(void)flags;
	TRACE_DEBUG("DMA Interrupt");
 800f272:	4822      	ldr	r0, [pc, #136]	; (800f2fc <OV2640_dma_avail+0x8c>)
 800f274:	4e22      	ldr	r6, [pc, #136]	; (800f300 <OV2640_dma_avail+0x90>)
 800f276:	f7ff fe3b 	bl	800eef0 <chMtxLock>
 800f27a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800f27e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800f282:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f284:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800f286:	4b1f      	ldr	r3, [pc, #124]	; (800f304 <OV2640_dma_avail+0x94>)
 800f288:	491f      	ldr	r1, [pc, #124]	; (800f308 <OV2640_dma_avail+0x98>)
 800f28a:	4820      	ldr	r0, [pc, #128]	; (800f30c <OV2640_dma_avail+0x9c>)
 800f28c:	fb05 f404 	mul.w	r4, r5, r4
 800f290:	fba6 e404 	umull	lr, r4, r6, r4
 800f294:	0ba4      	lsrs	r4, r4, #14
 800f296:	fba3 e304 	umull	lr, r3, r3, r4
 800f29a:	fba6 6202 	umull	r6, r2, r6, r2
 800f29e:	099b      	lsrs	r3, r3, #6
 800f2a0:	fb05 4313 	mls	r3, r5, r3, r4
 800f2a4:	0b92      	lsrs	r2, r2, #14
 800f2a6:	f003 fa1b 	bl	80126e0 <chprintf.constprop.35>
 800f2aa:	4a19      	ldr	r2, [pc, #100]	; (800f310 <OV2640_dma_avail+0xa0>)
 800f2ac:	4919      	ldr	r1, [pc, #100]	; (800f314 <OV2640_dma_avail+0xa4>)
 800f2ae:	4817      	ldr	r0, [pc, #92]	; (800f30c <OV2640_dma_avail+0x9c>)
 800f2b0:	f003 fa16 	bl	80126e0 <chprintf.constprop.35>
 800f2b4:	f240 23a7 	movw	r3, #679	; 0x2a7
 800f2b8:	4a17      	ldr	r2, [pc, #92]	; (800f318 <OV2640_dma_avail+0xa8>)
 800f2ba:	4918      	ldr	r1, [pc, #96]	; (800f31c <OV2640_dma_avail+0xac>)
 800f2bc:	4813      	ldr	r0, [pc, #76]	; (800f30c <OV2640_dma_avail+0x9c>)
 800f2be:	f003 fa0f 	bl	80126e0 <chprintf.constprop.35>
 800f2c2:	4917      	ldr	r1, [pc, #92]	; (800f320 <OV2640_dma_avail+0xb0>)
 800f2c4:	4811      	ldr	r0, [pc, #68]	; (800f30c <OV2640_dma_avail+0x9c>)
 800f2c6:	f003 fa0b 	bl	80126e0 <chprintf.constprop.35>
 800f2ca:	4916      	ldr	r1, [pc, #88]	; (800f324 <OV2640_dma_avail+0xb4>)
 800f2cc:	480f      	ldr	r0, [pc, #60]	; (800f30c <OV2640_dma_avail+0x9c>)
 800f2ce:	f003 fa07 	bl	80126e0 <chprintf.constprop.35>
 800f2d2:	4915      	ldr	r1, [pc, #84]	; (800f328 <OV2640_dma_avail+0xb8>)
 800f2d4:	480d      	ldr	r0, [pc, #52]	; (800f30c <OV2640_dma_avail+0x9c>)
 800f2d6:	f003 fa03 	bl	80126e0 <chprintf.constprop.35>
 800f2da:	4808      	ldr	r0, [pc, #32]	; (800f2fc <OV2640_dma_avail+0x8c>)
 800f2dc:	f7ff fda8 	bl	800ee30 <chMtxUnlock>
	ov2640_samplingFinished = true;
	dmaStreamDisable(STM32_DMA2_STREAM1);
 800f2e0:	4a12      	ldr	r2, [pc, #72]	; (800f32c <OV2640_dma_avail+0xbc>)
 800f2e2:	6813      	ldr	r3, [r2, #0]
 800f2e4:	f023 031f 	bic.w	r3, r3, #31
 800f2e8:	6013      	str	r3, [r2, #0]
 800f2ea:	6813      	ldr	r3, [r2, #0]
 800f2ec:	07db      	lsls	r3, r3, #31
 800f2ee:	d4fc      	bmi.n	800f2ea <OV2640_dma_avail+0x7a>
 800f2f0:	4b0f      	ldr	r3, [pc, #60]	; (800f330 <OV2640_dma_avail+0xc0>)
 800f2f2:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 800f2f6:	601a      	str	r2, [r3, #0]
 800f2f8:	bd70      	pop	{r4, r5, r6, pc}
 800f2fa:	bf00      	nop
 800f2fc:	20027b2c 	.word	0x20027b2c
 800f300:	d1b71759 	.word	0xd1b71759
 800f304:	10624dd3 	.word	0x10624dd3
 800f308:	08013c50 	.word	0x08013c50
 800f30c:	20027e60 	.word	0x20027e60
 800f310:	08015f34 	.word	0x08015f34
 800f314:	08013c5c 	.word	0x08013c5c
 800f318:	080143f4 	.word	0x080143f4
 800f31c:	08013c78 	.word	0x08013c78
 800f320:	08013d00 	.word	0x08013d00
 800f324:	08015f3c 	.word	0x08015f3c
 800f328:	08013cac 	.word	0x08013cac
 800f32c:	40026428 	.word	0x40026428
 800f330:	40026408 	.word	0x40026408
	...

0800f340 <OV2640_init>:

	for(uint32_t i=0; (ov2640_jpeg_regs[i].reg != 0xff) || (ov2640_jpeg_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_jpeg_regs[i].reg, ov2640_jpeg_regs[i].val);
}

void OV2640_init(ssdv_config_t *config) {
 800f340:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ov2640_config = config;
 800f344:	4ead      	ldr	r6, [pc, #692]	; (800f5fc <OV2640_init+0x2bc>)
 800f346:	6030      	str	r0, [r6, #0]
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800f348:	48ad      	ldr	r0, [pc, #692]	; (800f600 <OV2640_init+0x2c0>)
 800f34a:	f7ff fdd1 	bl	800eef0 <chMtxLock>
	// Take I2C (due to silicon bug of OV2640, it interferes if byte 0x30 transmitted on I2C bus)
	I2C_lock();

	// Clearing buffer
	uint32_t i;
	for(i=0; i<ov2640_config->ram_size; i++)
 800f34e:	6832      	ldr	r2, [r6, #0]
 800f350:	6913      	ldr	r3, [r2, #16]
 800f352:	b143      	cbz	r3, 800f366 <OV2640_init+0x26>
 800f354:	2300      	movs	r3, #0
		ov2640_config->ram_buffer[i] = 0;
 800f356:	4618      	mov	r0, r3
 800f358:	68d2      	ldr	r2, [r2, #12]
 800f35a:	54d0      	strb	r0, [r2, r3]
	// Take I2C (due to silicon bug of OV2640, it interferes if byte 0x30 transmitted on I2C bus)
	I2C_lock();

	// Clearing buffer
	uint32_t i;
	for(i=0; i<ov2640_config->ram_size; i++)
 800f35c:	6832      	ldr	r2, [r6, #0]
 800f35e:	6911      	ldr	r1, [r2, #16]
 800f360:	3301      	adds	r3, #1
 800f362:	4299      	cmp	r1, r3
 800f364:	d8f8      	bhi.n	800f358 <OV2640_init+0x18>
 800f366:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
		ov2640_config->ram_buffer[i] = 0;

	TRACE_INFO("CAM  > Init pins");
 800f36a:	48a6      	ldr	r0, [pc, #664]	; (800f604 <OV2640_init+0x2c4>)
 800f36c:	f8df 82ec 	ldr.w	r8, [pc, #748]	; 800f65c <OV2640_init+0x31c>
 800f370:	4fa5      	ldr	r7, [pc, #660]	; (800f608 <OV2640_init+0x2c8>)
	palSetPadMode(PORT(CAM_VSYNC), PIN(CAM_VSYNC), PAL_MODE_ALTERNATE(13));	// VSYNC -> PB7
	palSetPadMode(PORT(CAM_D2), PIN(CAM_D2), PAL_MODE_ALTERNATE(13));		// D0    -> PC6
	palSetPadMode(PORT(CAM_D3), PIN(CAM_D3), PAL_MODE_ALTERNATE(13));		// D1    -> PC7
	palSetPadMode(PORT(CAM_D4), PIN(CAM_D4), PAL_MODE_ALTERNATE(13));		// D2    -> PC8
	palSetPadMode(PORT(CAM_D5), PIN(CAM_D5), PAL_MODE_ALTERNATE(13));		// D3    -> PC9
	palSetPadMode(PORT(CAM_D6), PIN(CAM_D6), PAL_MODE_ALTERNATE(13));		// D4    -> PE4
 800f372:	f8df a2ec 	ldr.w	sl, [pc, #748]	; 800f660 <OV2640_init+0x320>
 800f376:	4ca5      	ldr	r4, [pc, #660]	; (800f60c <OV2640_init+0x2cc>)
	// Clearing buffer
	uint32_t i;
	for(i=0; i<ov2640_config->ram_size; i++)
		ov2640_config->ram_buffer[i] = 0;

	TRACE_INFO("CAM  > Init pins");
 800f378:	f7ff fdba 	bl	800eef0 <chMtxLock>
 800f37c:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 800f380:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800f384:	49a2      	ldr	r1, [pc, #648]	; (800f610 <OV2640_init+0x2d0>)
 800f386:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800f38a:	fb05 f303 	mul.w	r3, r5, r3
 800f38e:	fba8 0303 	umull	r0, r3, r8, r3
 800f392:	0b9b      	lsrs	r3, r3, #14
 800f394:	fba7 e003 	umull	lr, r0, r7, r3
 800f398:	fba8 e202 	umull	lr, r2, r8, r2
 800f39c:	0980      	lsrs	r0, r0, #6
 800f39e:	fb05 3310 	mls	r3, r5, r0, r3
 800f3a2:	0b92      	lsrs	r2, r2, #14
 800f3a4:	489b      	ldr	r0, [pc, #620]	; (800f614 <OV2640_init+0x2d4>)
 800f3a6:	f003 f99b 	bl	80126e0 <chprintf.constprop.35>
 800f3aa:	4a9b      	ldr	r2, [pc, #620]	; (800f618 <OV2640_init+0x2d8>)
 800f3ac:	499b      	ldr	r1, [pc, #620]	; (800f61c <OV2640_init+0x2dc>)
 800f3ae:	4899      	ldr	r0, [pc, #612]	; (800f614 <OV2640_init+0x2d4>)
 800f3b0:	f003 f996 	bl	80126e0 <chprintf.constprop.35>
 800f3b4:	f240 333a 	movw	r3, #826	; 0x33a
 800f3b8:	4a99      	ldr	r2, [pc, #612]	; (800f620 <OV2640_init+0x2e0>)
 800f3ba:	499a      	ldr	r1, [pc, #616]	; (800f624 <OV2640_init+0x2e4>)
 800f3bc:	4895      	ldr	r0, [pc, #596]	; (800f614 <OV2640_init+0x2d4>)
 800f3be:	f003 f98f 	bl	80126e0 <chprintf.constprop.35>
 800f3c2:	4999      	ldr	r1, [pc, #612]	; (800f628 <OV2640_init+0x2e8>)
 800f3c4:	4893      	ldr	r0, [pc, #588]	; (800f614 <OV2640_init+0x2d4>)
 800f3c6:	f003 f98b 	bl	80126e0 <chprintf.constprop.35>
 800f3ca:	4998      	ldr	r1, [pc, #608]	; (800f62c <OV2640_init+0x2ec>)
 800f3cc:	4891      	ldr	r0, [pc, #580]	; (800f614 <OV2640_init+0x2d4>)
 800f3ce:	f003 f987 	bl	80126e0 <chprintf.constprop.35>
 800f3d2:	4997      	ldr	r1, [pc, #604]	; (800f630 <OV2640_init+0x2f0>)
 800f3d4:	488f      	ldr	r0, [pc, #572]	; (800f614 <OV2640_init+0x2d4>)
 800f3d6:	f003 f983 	bl	80126e0 <chprintf.constprop.35>
 800f3da:	488a      	ldr	r0, [pc, #552]	; (800f604 <OV2640_init+0x2c4>)
 800f3dc:	f7ff fd28 	bl	800ee30 <chMtxUnlock>
  * Initializes GPIO (for DCMI)
  * The high speed clock supports communication by I2C (XCLK = 16MHz)
  */
void OV2640_InitGPIO(void)
{
	palSetPadMode(PORT(CAM_HREF), PIN(CAM_HREF), PAL_MODE_ALTERNATE(13));	// HSYNC -> PA4
 800f3e0:	f240 6282 	movw	r2, #1666	; 0x682
 800f3e4:	2110      	movs	r1, #16
 800f3e6:	4893      	ldr	r0, [pc, #588]	; (800f634 <OV2640_init+0x2f4>)
 800f3e8:	f7fc ffca 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_PCLK), PIN(CAM_PCLK), PAL_MODE_ALTERNATE(13));	// PCLK  -> PA6
 800f3ec:	f240 6282 	movw	r2, #1666	; 0x682
 800f3f0:	2140      	movs	r1, #64	; 0x40
 800f3f2:	4890      	ldr	r0, [pc, #576]	; (800f634 <OV2640_init+0x2f4>)
 800f3f4:	f7fc ffc4 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_VSYNC), PIN(CAM_VSYNC), PAL_MODE_ALTERNATE(13));	// VSYNC -> PB7
 800f3f8:	f240 6282 	movw	r2, #1666	; 0x682
 800f3fc:	2180      	movs	r1, #128	; 0x80
 800f3fe:	488e      	ldr	r0, [pc, #568]	; (800f638 <OV2640_init+0x2f8>)
 800f400:	f7fc ffbe 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D2), PIN(CAM_D2), PAL_MODE_ALTERNATE(13));		// D0    -> PC6
 800f404:	f240 6282 	movw	r2, #1666	; 0x682
 800f408:	2140      	movs	r1, #64	; 0x40
 800f40a:	488c      	ldr	r0, [pc, #560]	; (800f63c <OV2640_init+0x2fc>)
 800f40c:	f7fc ffb8 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D3), PIN(CAM_D3), PAL_MODE_ALTERNATE(13));		// D1    -> PC7
 800f410:	f240 6282 	movw	r2, #1666	; 0x682
 800f414:	2180      	movs	r1, #128	; 0x80
 800f416:	4889      	ldr	r0, [pc, #548]	; (800f63c <OV2640_init+0x2fc>)
 800f418:	f7fc ffb2 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D4), PIN(CAM_D4), PAL_MODE_ALTERNATE(13));		// D2    -> PC8
 800f41c:	f240 6282 	movw	r2, #1666	; 0x682
 800f420:	f44f 7180 	mov.w	r1, #256	; 0x100
 800f424:	4885      	ldr	r0, [pc, #532]	; (800f63c <OV2640_init+0x2fc>)
 800f426:	f7fc ffab 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D5), PIN(CAM_D5), PAL_MODE_ALTERNATE(13));		// D3    -> PC9
 800f42a:	f240 6282 	movw	r2, #1666	; 0x682
 800f42e:	f44f 7100 	mov.w	r1, #512	; 0x200
 800f432:	4882      	ldr	r0, [pc, #520]	; (800f63c <OV2640_init+0x2fc>)
 800f434:	f7fc ffa4 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D6), PIN(CAM_D6), PAL_MODE_ALTERNATE(13));		// D4    -> PE4
 800f438:	4650      	mov	r0, sl
 800f43a:	f240 6282 	movw	r2, #1666	; 0x682
 800f43e:	2110      	movs	r1, #16
 800f440:	f7fc ff9e 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D7), PIN(CAM_D7), PAL_MODE_ALTERNATE(13));		// D5    -> PB6
 800f444:	f240 6282 	movw	r2, #1666	; 0x682
 800f448:	2140      	movs	r1, #64	; 0x40
 800f44a:	487b      	ldr	r0, [pc, #492]	; (800f638 <OV2640_init+0x2f8>)
 800f44c:	f7fc ff98 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D8), PIN(CAM_D8), PAL_MODE_ALTERNATE(13));		// D6    -> PE5
 800f450:	4650      	mov	r0, sl
 800f452:	f240 6282 	movw	r2, #1666	; 0x682
 800f456:	2120      	movs	r1, #32
 800f458:	f7fc ff92 	bl	800c380 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D9), PIN(CAM_D9), PAL_MODE_ALTERNATE(13));		// D7    -> PE6
 800f45c:	4650      	mov	r0, sl
 800f45e:	f240 6282 	movw	r2, #1666	; 0x682
 800f462:	2140      	movs	r1, #64	; 0x40
 800f464:	f7fc ff8c 	bl	800c380 <_pal_lld_setgroupmode>

	palSetPadMode(PORT(CAM_EN), PIN(CAM_EN), PAL_MODE_OUTPUT_PUSHPULL);		// CAM_EN
 800f468:	2201      	movs	r2, #1
 800f46a:	2108      	movs	r1, #8
 800f46c:	4650      	mov	r0, sl
 800f46e:	f7fc ff87 	bl	800c380 <_pal_lld_setgroupmode>

	TRACE_INFO("CAM  > Init pins");
	OV2640_InitGPIO();

	// Power on OV2640
	TRACE_INFO("CAM  > Switch on");
 800f472:	4864      	ldr	r0, [pc, #400]	; (800f604 <OV2640_init+0x2c4>)
 800f474:	f7ff fd3c 	bl	800eef0 <chMtxLock>
 800f478:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 800f47c:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800f480:	4963      	ldr	r1, [pc, #396]	; (800f610 <OV2640_init+0x2d0>)
 800f482:	fb05 f303 	mul.w	r3, r5, r3
 800f486:	fba8 0303 	umull	r0, r3, r8, r3
 800f48a:	0b9b      	lsrs	r3, r3, #14
 800f48c:	fba7 e003 	umull	lr, r0, r7, r3
 800f490:	fba8 e202 	umull	lr, r2, r8, r2
 800f494:	0980      	lsrs	r0, r0, #6
 800f496:	fb05 3310 	mls	r3, r5, r0, r3
 800f49a:	0b92      	lsrs	r2, r2, #14
 800f49c:	485d      	ldr	r0, [pc, #372]	; (800f614 <OV2640_init+0x2d4>)
 800f49e:	f003 f91f 	bl	80126e0 <chprintf.constprop.35>
 800f4a2:	4a5d      	ldr	r2, [pc, #372]	; (800f618 <OV2640_init+0x2d8>)
 800f4a4:	495d      	ldr	r1, [pc, #372]	; (800f61c <OV2640_init+0x2dc>)
 800f4a6:	485b      	ldr	r0, [pc, #364]	; (800f614 <OV2640_init+0x2d4>)
 800f4a8:	f003 f91a 	bl	80126e0 <chprintf.constprop.35>
 800f4ac:	4a5c      	ldr	r2, [pc, #368]	; (800f620 <OV2640_init+0x2e0>)
 800f4ae:	495d      	ldr	r1, [pc, #372]	; (800f624 <OV2640_init+0x2e4>)
 800f4b0:	4858      	ldr	r0, [pc, #352]	; (800f614 <OV2640_init+0x2d4>)
 800f4b2:	f240 333e 	movw	r3, #830	; 0x33e
 800f4b6:	f003 f913 	bl	80126e0 <chprintf.constprop.35>
 800f4ba:	495b      	ldr	r1, [pc, #364]	; (800f628 <OV2640_init+0x2e8>)
 800f4bc:	4855      	ldr	r0, [pc, #340]	; (800f614 <OV2640_init+0x2d4>)
 800f4be:	f003 f90f 	bl	80126e0 <chprintf.constprop.35>
 800f4c2:	495f      	ldr	r1, [pc, #380]	; (800f640 <OV2640_init+0x300>)
 800f4c4:	4853      	ldr	r0, [pc, #332]	; (800f614 <OV2640_init+0x2d4>)
 800f4c6:	f003 f90b 	bl	80126e0 <chprintf.constprop.35>
 800f4ca:	4959      	ldr	r1, [pc, #356]	; (800f630 <OV2640_init+0x2f0>)
 800f4cc:	4851      	ldr	r0, [pc, #324]	; (800f614 <OV2640_init+0x2d4>)
 800f4ce:	f003 f907 	bl	80126e0 <chprintf.constprop.35>
 800f4d2:	484c      	ldr	r0, [pc, #304]	; (800f604 <OV2640_init+0x2c4>)
 800f4d4:	f7ff fcac 	bl	800ee30 <chMtxUnlock>
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 800f4d8:	2308      	movs	r3, #8
 800f4da:	f8aa 3018 	strh.w	r3, [sl, #24]

	// Send settings to OV2640
	TRACE_INFO("CAM  > Transmit config to camera");
 800f4de:	4849      	ldr	r0, [pc, #292]	; (800f604 <OV2640_init+0x2c4>)
 800f4e0:	f7ff fd06 	bl	800eef0 <chMtxLock>
 800f4e4:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 800f4e8:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800f4ec:	4948      	ldr	r1, [pc, #288]	; (800f610 <OV2640_init+0x2d0>)
 800f4ee:	4849      	ldr	r0, [pc, #292]	; (800f614 <OV2640_init+0x2d4>)
 800f4f0:	fb05 f303 	mul.w	r3, r5, r3
 800f4f4:	fba8 e303 	umull	lr, r3, r8, r3
 800f4f8:	0b9b      	lsrs	r3, r3, #14
 800f4fa:	fba7 e703 	umull	lr, r7, r7, r3
 800f4fe:	09bf      	lsrs	r7, r7, #6
 800f500:	fba8 e202 	umull	lr, r2, r8, r2
 800f504:	fb05 3317 	mls	r3, r5, r7, r3
 800f508:	0b92      	lsrs	r2, r2, #14
 800f50a:	f003 f8e9 	bl	80126e0 <chprintf.constprop.35>
 800f50e:	4a42      	ldr	r2, [pc, #264]	; (800f618 <OV2640_init+0x2d8>)
 800f510:	4942      	ldr	r1, [pc, #264]	; (800f61c <OV2640_init+0x2dc>)
 800f512:	4840      	ldr	r0, [pc, #256]	; (800f614 <OV2640_init+0x2d4>)
 800f514:	f003 f8e4 	bl	80126e0 <chprintf.constprop.35>
 800f518:	f240 3342 	movw	r3, #834	; 0x342
 800f51c:	4a40      	ldr	r2, [pc, #256]	; (800f620 <OV2640_init+0x2e0>)
 800f51e:	4941      	ldr	r1, [pc, #260]	; (800f624 <OV2640_init+0x2e4>)
 800f520:	483c      	ldr	r0, [pc, #240]	; (800f614 <OV2640_init+0x2d4>)
 800f522:	f003 f8dd 	bl	80126e0 <chprintf.constprop.35>
 800f526:	4940      	ldr	r1, [pc, #256]	; (800f628 <OV2640_init+0x2e8>)
 800f528:	483a      	ldr	r0, [pc, #232]	; (800f614 <OV2640_init+0x2d4>)
 800f52a:	f003 f8d9 	bl	80126e0 <chprintf.constprop.35>
 800f52e:	4945      	ldr	r1, [pc, #276]	; (800f644 <OV2640_init+0x304>)
 800f530:	4838      	ldr	r0, [pc, #224]	; (800f614 <OV2640_init+0x2d4>)
 800f532:	f003 f8d5 	bl	80126e0 <chprintf.constprop.35>
 800f536:	493e      	ldr	r1, [pc, #248]	; (800f630 <OV2640_init+0x2f0>)
 800f538:	4836      	ldr	r0, [pc, #216]	; (800f614 <OV2640_init+0x2d4>)
 800f53a:	f003 f8d1 	bl	80126e0 <chprintf.constprop.35>
 800f53e:	4831      	ldr	r0, [pc, #196]	; (800f604 <OV2640_init+0x2c4>)
 800f540:	f7ff fc76 	bl	800ee30 <chMtxUnlock>
}

void OV2640_TransmitConfig(void)
{
	// Set to page 1
	I2C_write8_locked(OV2640_I2C_ADR, 0xff, 0x01);
 800f544:	2101      	movs	r1, #1
 800f546:	20ff      	movs	r0, #255	; 0xff
 800f548:	f7ff f82a 	bl	800e5a0 <I2C_write8_locked.constprop.1>
	I2C_write8_locked(OV2640_I2C_ADR, 0x12, 0x80);
 800f54c:	2180      	movs	r1, #128	; 0x80
 800f54e:	2012      	movs	r0, #18
 800f550:	f7ff f826 	bl	800e5a0 <I2C_write8_locked.constprop.1>
	chThdSleepMilliseconds(50);
 800f554:	4628      	mov	r0, r5
 800f556:	f7ff fd9b 	bl	800f090 <chThdSleep>
 800f55a:	20ff      	movs	r0, #255	; 0xff
 800f55c:	2300      	movs	r3, #0
 800f55e:	e005      	b.n	800f56c <OV2640_init+0x22c>

	/* Write selected arrays to the camera to initialize it and set the
	 * desired output format. */
	for(uint32_t i=0; (ov2640_init_regs[i].reg != 0xff) || (ov2640_init_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);
 800f560:	4619      	mov	r1, r3
 800f562:	f7ff f81d 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f566:	78e3      	ldrb	r3, [r4, #3]
 800f568:	f814 0f02 	ldrb.w	r0, [r4, #2]!
	I2C_write8_locked(OV2640_I2C_ADR, 0x12, 0x80);
	chThdSleepMilliseconds(50);

	/* Write selected arrays to the camera to initialize it and set the
	 * desired output format. */
	for(uint32_t i=0; (ov2640_init_regs[i].reg != 0xff) || (ov2640_init_regs[i].val != 0xff); i++)
 800f56c:	28ff      	cmp	r0, #255	; 0xff
 800f56e:	d1f7      	bne.n	800f560 <OV2640_init+0x220>
 800f570:	2bff      	cmp	r3, #255	; 0xff
 800f572:	d1f5      	bne.n	800f560 <OV2640_init+0x220>
 800f574:	4d34      	ldr	r5, [pc, #208]	; (800f648 <OV2640_init+0x308>)
 800f576:	2400      	movs	r4, #0
 800f578:	e006      	b.n	800f588 <OV2640_init+0x248>
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);
 800f57a:	4621      	mov	r1, r4
 800f57c:	4618      	mov	r0, r3
 800f57e:	f7ff f80f 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f582:	78ec      	ldrb	r4, [r5, #3]
 800f584:	f815 3f02 	ldrb.w	r3, [r5, #2]!
	/* Write selected arrays to the camera to initialize it and set the
	 * desired output format. */
	for(uint32_t i=0; (ov2640_init_regs[i].reg != 0xff) || (ov2640_init_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
 800f588:	2bff      	cmp	r3, #255	; 0xff
 800f58a:	d1f6      	bne.n	800f57a <OV2640_init+0x23a>
 800f58c:	2cff      	cmp	r4, #255	; 0xff
 800f58e:	d1f4      	bne.n	800f57a <OV2640_init+0x23a>
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 800f590:	6833      	ldr	r3, [r6, #0]
 800f592:	7a1b      	ldrb	r3, [r3, #8]
 800f594:	2b04      	cmp	r3, #4
 800f596:	f200 8174 	bhi.w	800f882 <OV2640_init+0x542>
 800f59a:	e8df f013 	tbh	[pc, r3, lsl #1]
 800f59e:	013e      	.short	0x013e
 800f5a0:	014b0165 	.word	0x014b0165
 800f5a4:	00050158 	.word	0x00050158
 800f5a8:	4d28      	ldr	r5, [pc, #160]	; (800f64c <OV2640_init+0x30c>)
 800f5aa:	2050      	movs	r0, #80	; 0x50
 800f5ac:	2180      	movs	r1, #128	; 0x80
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_xga_regs[i].reg, ov2640_xga_regs[i].val);
			break;

		case RES_UXGA:
			for(uint32_t i=0; (ov2640_uxga_regs[i].reg != 0xff) || (ov2640_uxga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_uxga_regs[i].reg, ov2640_uxga_regs[i].val);
 800f5ae:	f7fe fff7 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f5b2:	78e9      	ldrb	r1, [r5, #3]
 800f5b4:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_xga_regs[i].reg != 0xff) || (ov2640_xga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_xga_regs[i].reg, ov2640_xga_regs[i].val);
			break;

		case RES_UXGA:
			for(uint32_t i=0; (ov2640_uxga_regs[i].reg != 0xff) || (ov2640_uxga_regs[i].val != 0xff); i++)
 800f5b8:	28ff      	cmp	r0, #255	; 0xff
 800f5ba:	d1f8      	bne.n	800f5ae <OV2640_init+0x26e>
 800f5bc:	29ff      	cmp	r1, #255	; 0xff
 800f5be:	d1f6      	bne.n	800f5ae <OV2640_init+0x26e>
 800f5c0:	4d23      	ldr	r5, [pc, #140]	; (800f650 <OV2640_init+0x310>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 800f5c2:	2100      	movs	r1, #0
 800f5c4:	e005      	b.n	800f5d2 <OV2640_init+0x292>
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
	}

	for(uint32_t i=0; (ov2640_format_change_preamble_regs[i].reg != 0xff) || (ov2640_format_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_format_change_preamble_regs[i].reg, ov2640_format_change_preamble_regs[i].val);
 800f5c6:	4620      	mov	r0, r4
 800f5c8:	f7fe ffea 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f5cc:	78e9      	ldrb	r1, [r5, #3]
 800f5ce:	f815 4f02 	ldrb.w	r4, [r5, #2]!
		default: // Default QVGA
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
	}

	for(uint32_t i=0; (ov2640_format_change_preamble_regs[i].reg != 0xff) || (ov2640_format_change_preamble_regs[i].val != 0xff); i++)
 800f5d2:	2cff      	cmp	r4, #255	; 0xff
 800f5d4:	d1f7      	bne.n	800f5c6 <OV2640_init+0x286>
 800f5d6:	29ff      	cmp	r1, #255	; 0xff
 800f5d8:	d1f5      	bne.n	800f5c6 <OV2640_init+0x286>
 800f5da:	4c1e      	ldr	r4, [pc, #120]	; (800f654 <OV2640_init+0x314>)
 800f5dc:	2000      	movs	r0, #0
 800f5de:	23da      	movs	r3, #218	; 0xda
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_format_change_preamble_regs[i].reg, ov2640_format_change_preamble_regs[i].val);
	for(uint32_t i=0; (ov2640_yuyv_regs[i].reg != 0xff) || (ov2640_yuyv_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_yuyv_regs[i].reg, ov2640_yuyv_regs[i].val);
 800f5e0:	4601      	mov	r1, r0
 800f5e2:	4618      	mov	r0, r3
 800f5e4:	f7fe ffdc 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f5e8:	78e0      	ldrb	r0, [r4, #3]
 800f5ea:	f814 3f02 	ldrb.w	r3, [r4, #2]!
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
	}

	for(uint32_t i=0; (ov2640_format_change_preamble_regs[i].reg != 0xff) || (ov2640_format_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_format_change_preamble_regs[i].reg, ov2640_format_change_preamble_regs[i].val);
	for(uint32_t i=0; (ov2640_yuyv_regs[i].reg != 0xff) || (ov2640_yuyv_regs[i].val != 0xff); i++)
 800f5ee:	2bff      	cmp	r3, #255	; 0xff
 800f5f0:	d1f6      	bne.n	800f5e0 <OV2640_init+0x2a0>
 800f5f2:	28ff      	cmp	r0, #255	; 0xff
 800f5f4:	d1f4      	bne.n	800f5e0 <OV2640_init+0x2a0>
 800f5f6:	4c18      	ldr	r4, [pc, #96]	; (800f658 <OV2640_init+0x318>)
 800f5f8:	2100      	movs	r1, #0
 800f5fa:	e038      	b.n	800f66e <OV2640_init+0x32e>
 800f5fc:	20027b40 	.word	0x20027b40
 800f600:	200278f8 	.word	0x200278f8
 800f604:	20027b2c 	.word	0x20027b2c
 800f608:	10624dd3 	.word	0x10624dd3
 800f60c:	08015db8 	.word	0x08015db8
 800f610:	08013c50 	.word	0x08013c50
 800f614:	20027e60 	.word	0x20027e60
 800f618:	08013cfc 	.word	0x08013cfc
 800f61c:	08013c5c 	.word	0x08013c5c
 800f620:	080143f4 	.word	0x080143f4
 800f624:	08013c78 	.word	0x08013c78
 800f628:	08013d00 	.word	0x08013d00
 800f62c:	08015f4c 	.word	0x08015f4c
 800f630:	08013cac 	.word	0x08013cac
 800f634:	40020000 	.word	0x40020000
 800f638:	40020400 	.word	0x40020400
 800f63c:	40020800 	.word	0x40020800
 800f640:	08015f60 	.word	0x08015f60
 800f644:	08015f74 	.word	0x08015f74
 800f648:	08016040 	.word	0x08016040
 800f64c:	08015f20 	.word	0x08015f20
 800f650:	08016004 	.word	0x08016004
 800f654:	08016020 	.word	0x08016020
 800f658:	0801600c 	.word	0x0801600c
 800f65c:	d1b71759 	.word	0xd1b71759
 800f660:	40021000 	.word	0x40021000
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_yuyv_regs[i].reg, ov2640_yuyv_regs[i].val);

	for(uint32_t i=0; (ov2640_jpeg_regs[i].reg != 0xff) || (ov2640_jpeg_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_jpeg_regs[i].reg, ov2640_jpeg_regs[i].val);
 800f664:	f7fe ff9c 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f668:	78e1      	ldrb	r1, [r4, #3]
 800f66a:	f814 0f02 	ldrb.w	r0, [r4, #2]!
	for(uint32_t i=0; (ov2640_format_change_preamble_regs[i].reg != 0xff) || (ov2640_format_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_format_change_preamble_regs[i].reg, ov2640_format_change_preamble_regs[i].val);
	for(uint32_t i=0; (ov2640_yuyv_regs[i].reg != 0xff) || (ov2640_yuyv_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_yuyv_regs[i].reg, ov2640_yuyv_regs[i].val);

	for(uint32_t i=0; (ov2640_jpeg_regs[i].reg != 0xff) || (ov2640_jpeg_regs[i].val != 0xff); i++)
 800f66e:	28ff      	cmp	r0, #255	; 0xff
 800f670:	d1f8      	bne.n	800f664 <OV2640_init+0x324>
 800f672:	29ff      	cmp	r1, #255	; 0xff
 800f674:	d1f6      	bne.n	800f664 <OV2640_init+0x324>
 800f676:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
	// Send settings to OV2640
	TRACE_INFO("CAM  > Transmit config to camera");
	OV2640_TransmitConfig();

	// DCMI DMA
	TRACE_INFO("CAM  > Init DMA");
 800f67a:	4888      	ldr	r0, [pc, #544]	; (800f89c <OV2640_init+0x55c>)
 800f67c:	4f88      	ldr	r7, [pc, #544]	; (800f8a0 <OV2640_init+0x560>)
 800f67e:	4c89      	ldr	r4, [pc, #548]	; (800f8a4 <OV2640_init+0x564>)
 800f680:	f7ff fc36 	bl	800eef0 <chMtxLock>
 800f684:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800f688:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800f68c:	4986      	ldr	r1, [pc, #536]	; (800f8a8 <OV2640_init+0x568>)
 800f68e:	4887      	ldr	r0, [pc, #540]	; (800f8ac <OV2640_init+0x56c>)
 800f690:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800f694:	fb05 f303 	mul.w	r3, r5, r3
 800f698:	fba7 e303 	umull	lr, r3, r7, r3
 800f69c:	0b9b      	lsrs	r3, r3, #14
 800f69e:	fba4 ce03 	umull	ip, lr, r4, r3
 800f6a2:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800f6a6:	fba7 c202 	umull	ip, r2, r7, r2
 800f6aa:	fb05 331e 	mls	r3, r5, lr, r3
 800f6ae:	0b92      	lsrs	r2, r2, #14
 800f6b0:	f003 f816 	bl	80126e0 <chprintf.constprop.35>
 800f6b4:	4a7e      	ldr	r2, [pc, #504]	; (800f8b0 <OV2640_init+0x570>)
 800f6b6:	497f      	ldr	r1, [pc, #508]	; (800f8b4 <OV2640_init+0x574>)
 800f6b8:	487c      	ldr	r0, [pc, #496]	; (800f8ac <OV2640_init+0x56c>)
 800f6ba:	f003 f811 	bl	80126e0 <chprintf.constprop.35>
 800f6be:	f240 3346 	movw	r3, #838	; 0x346
 800f6c2:	4a7d      	ldr	r2, [pc, #500]	; (800f8b8 <OV2640_init+0x578>)
 800f6c4:	497d      	ldr	r1, [pc, #500]	; (800f8bc <OV2640_init+0x57c>)
 800f6c6:	4879      	ldr	r0, [pc, #484]	; (800f8ac <OV2640_init+0x56c>)
 800f6c8:	f003 f80a 	bl	80126e0 <chprintf.constprop.35>
 800f6cc:	497c      	ldr	r1, [pc, #496]	; (800f8c0 <OV2640_init+0x580>)
 800f6ce:	4877      	ldr	r0, [pc, #476]	; (800f8ac <OV2640_init+0x56c>)
 800f6d0:	f003 f806 	bl	80126e0 <chprintf.constprop.35>
 800f6d4:	497b      	ldr	r1, [pc, #492]	; (800f8c4 <OV2640_init+0x584>)
 800f6d6:	4875      	ldr	r0, [pc, #468]	; (800f8ac <OV2640_init+0x56c>)
 800f6d8:	f003 f802 	bl	80126e0 <chprintf.constprop.35>
 800f6dc:	497a      	ldr	r1, [pc, #488]	; (800f8c8 <OV2640_init+0x588>)
 800f6de:	4873      	ldr	r0, [pc, #460]	; (800f8ac <OV2640_init+0x56c>)
 800f6e0:	f002 fffe 	bl	80126e0 <chprintf.constprop.35>
 800f6e4:	486d      	ldr	r0, [pc, #436]	; (800f89c <OV2640_init+0x55c>)
 800f6e6:	f7ff fba3 	bl	800ee30 <chMtxUnlock>
/**
  * Initializes DMA
  */
void OV2640_InitDMA(void)
{
	TRACE_INFO("CAM  > Available buffer %d byte", ov2640_config->ram_size);
 800f6ea:	486c      	ldr	r0, [pc, #432]	; (800f89c <OV2640_init+0x55c>)
 800f6ec:	f7ff fc00 	bl	800eef0 <chMtxLock>
 800f6f0:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800f6f4:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800f6f8:	496b      	ldr	r1, [pc, #428]	; (800f8a8 <OV2640_init+0x568>)
 800f6fa:	486c      	ldr	r0, [pc, #432]	; (800f8ac <OV2640_init+0x56c>)
 800f6fc:	fb05 f303 	mul.w	r3, r5, r3
 800f700:	fba7 e303 	umull	lr, r3, r7, r3
 800f704:	0b9b      	lsrs	r3, r3, #14
 800f706:	fba4 ce03 	umull	ip, lr, r4, r3
 800f70a:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800f70e:	fba7 c202 	umull	ip, r2, r7, r2
 800f712:	fb05 331e 	mls	r3, r5, lr, r3
 800f716:	0b92      	lsrs	r2, r2, #14
 800f718:	f002 ffe2 	bl	80126e0 <chprintf.constprop.35>
 800f71c:	4a64      	ldr	r2, [pc, #400]	; (800f8b0 <OV2640_init+0x570>)
 800f71e:	4965      	ldr	r1, [pc, #404]	; (800f8b4 <OV2640_init+0x574>)
 800f720:	4862      	ldr	r0, [pc, #392]	; (800f8ac <OV2640_init+0x56c>)
 800f722:	f002 ffdd 	bl	80126e0 <chprintf.constprop.35>
 800f726:	f240 23b1 	movw	r3, #689	; 0x2b1
 800f72a:	4a63      	ldr	r2, [pc, #396]	; (800f8b8 <OV2640_init+0x578>)
 800f72c:	4963      	ldr	r1, [pc, #396]	; (800f8bc <OV2640_init+0x57c>)
 800f72e:	485f      	ldr	r0, [pc, #380]	; (800f8ac <OV2640_init+0x56c>)
 800f730:	f002 ffd6 	bl	80126e0 <chprintf.constprop.35>
 800f734:	4962      	ldr	r1, [pc, #392]	; (800f8c0 <OV2640_init+0x580>)
 800f736:	485d      	ldr	r0, [pc, #372]	; (800f8ac <OV2640_init+0x56c>)
 800f738:	f002 ffd2 	bl	80126e0 <chprintf.constprop.35>
 800f73c:	6833      	ldr	r3, [r6, #0]
 800f73e:	4963      	ldr	r1, [pc, #396]	; (800f8cc <OV2640_init+0x58c>)
 800f740:	691a      	ldr	r2, [r3, #16]
 800f742:	485a      	ldr	r0, [pc, #360]	; (800f8ac <OV2640_init+0x56c>)
 800f744:	f002 ffcc 	bl	80126e0 <chprintf.constprop.35>
 800f748:	495f      	ldr	r1, [pc, #380]	; (800f8c8 <OV2640_init+0x588>)
 800f74a:	4858      	ldr	r0, [pc, #352]	; (800f8ac <OV2640_init+0x56c>)
 800f74c:	f002 ffc8 	bl	80126e0 <chprintf.constprop.35>
 800f750:	4852      	ldr	r0, [pc, #328]	; (800f89c <OV2640_init+0x55c>)
 800f752:	f7ff fb6d 	bl	800ee30 <chMtxUnlock>
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamAllocate(stream, 2, (stm32_dmaisr_t)OV2640_dma_avail, NULL);
 800f756:	2300      	movs	r3, #0
 800f758:	4a5d      	ldr	r2, [pc, #372]	; (800f8d0 <OV2640_init+0x590>)
 800f75a:	485e      	ldr	r0, [pc, #376]	; (800f8d4 <OV2640_init+0x594>)
 800f75c:	2102      	movs	r1, #2
 800f75e:	f7fd fa67 	bl	800cc30 <dmaStreamAllocate>
	dmaStreamSetPeripheral(stream, ((uint32_t*)DCMI_REG_DR_ADDRESS));
 800f762:	4b5d      	ldr	r3, [pc, #372]	; (800f8d8 <OV2640_init+0x598>)
 800f764:	4a5d      	ldr	r2, [pc, #372]	; (800f8dc <OV2640_init+0x59c>)
 800f766:	609a      	str	r2, [r3, #8]
	dmaStreamSetMemory0(stream, (uint32_t)ov2640_config->ram_buffer);
 800f768:	6832      	ldr	r2, [r6, #0]
	dmaStreamSetTransactionSize(stream, ov2640_config->ram_size / sizeof(uint32_t));
	dmaStreamSetMode(stream, STM32_DMA_CR_CHSEL(1) | STM32_DMA_CR_DIR_P2M |
 800f76a:	4e5d      	ldr	r6, [pc, #372]	; (800f8e0 <OV2640_init+0x5a0>)
{
	TRACE_INFO("CAM  > Available buffer %d byte", ov2640_config->ram_size);
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamAllocate(stream, 2, (stm32_dmaisr_t)OV2640_dma_avail, NULL);
	dmaStreamSetPeripheral(stream, ((uint32_t*)DCMI_REG_DR_ADDRESS));
	dmaStreamSetMemory0(stream, (uint32_t)ov2640_config->ram_buffer);
 800f76c:	68d1      	ldr	r1, [r2, #12]
 800f76e:	60d9      	str	r1, [r3, #12]
	dmaStreamSetTransactionSize(stream, ov2640_config->ram_size / sizeof(uint32_t));
 800f770:	6912      	ldr	r2, [r2, #16]
	// DCMI DMA
	TRACE_INFO("CAM  > Init DMA");
	OV2640_InitDMA();

	// DCMI Init
	TRACE_INFO("CAM  > Init DCMI");
 800f772:	484a      	ldr	r0, [pc, #296]	; (800f89c <OV2640_init+0x55c>)
	dmaStreamSetMode(stream, STM32_DMA_CR_CHSEL(1) | STM32_DMA_CR_DIR_P2M |
							 STM32_DMA_CR_MINC | STM32_DMA_CR_PSIZE_WORD |
							 STM32_DMA_CR_MSIZE_WORD | STM32_DMA_CR_MBURST_SINGLE |
							 STM32_DMA_CR_PBURST_SINGLE | STM32_DMA_CR_TEIE |
							 STM32_DMA_CR_PL(3));
	dmaStreamSetFIFO(stream, STM32_DMA_FCR_FTH_FULL);
 800f774:	2103      	movs	r1, #3
	TRACE_INFO("CAM  > Available buffer %d byte", ov2640_config->ram_size);
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamAllocate(stream, 2, (stm32_dmaisr_t)OV2640_dma_avail, NULL);
	dmaStreamSetPeripheral(stream, ((uint32_t*)DCMI_REG_DR_ADDRESS));
	dmaStreamSetMemory0(stream, (uint32_t)ov2640_config->ram_buffer);
	dmaStreamSetTransactionSize(stream, ov2640_config->ram_size / sizeof(uint32_t));
 800f776:	0892      	lsrs	r2, r2, #2
 800f778:	605a      	str	r2, [r3, #4]
	dmaStreamSetMode(stream, STM32_DMA_CR_CHSEL(1) | STM32_DMA_CR_DIR_P2M |
 800f77a:	601e      	str	r6, [r3, #0]
							 STM32_DMA_CR_MINC | STM32_DMA_CR_PSIZE_WORD |
							 STM32_DMA_CR_MSIZE_WORD | STM32_DMA_CR_MBURST_SINGLE |
							 STM32_DMA_CR_PBURST_SINGLE | STM32_DMA_CR_TEIE |
							 STM32_DMA_CR_PL(3));
	dmaStreamSetFIFO(stream, STM32_DMA_FCR_FTH_FULL);
 800f77c:	6159      	str	r1, [r3, #20]
	dmaStreamEnable(stream);
 800f77e:	681a      	ldr	r2, [r3, #0]
 800f780:	f042 0201 	orr.w	r2, r2, #1
 800f784:	601a      	str	r2, [r3, #0]
	// DCMI DMA
	TRACE_INFO("CAM  > Init DMA");
	OV2640_InitDMA();

	// DCMI Init
	TRACE_INFO("CAM  > Init DCMI");
 800f786:	f7ff fbb3 	bl	800eef0 <chMtxLock>
 800f78a:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800f78e:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800f792:	4945      	ldr	r1, [pc, #276]	; (800f8a8 <OV2640_init+0x568>)
 800f794:	4845      	ldr	r0, [pc, #276]	; (800f8ac <OV2640_init+0x56c>)
 800f796:	fb05 f303 	mul.w	r3, r5, r3
 800f79a:	fba7 6303 	umull	r6, r3, r7, r3
 800f79e:	0b9b      	lsrs	r3, r3, #14
 800f7a0:	fba4 6403 	umull	r6, r4, r4, r3
 800f7a4:	09a4      	lsrs	r4, r4, #6
 800f7a6:	fba7 6202 	umull	r6, r2, r7, r2
 800f7aa:	fb05 3314 	mls	r3, r5, r4, r3
 800f7ae:	0b92      	lsrs	r2, r2, #14
 800f7b0:	f002 ff96 	bl	80126e0 <chprintf.constprop.35>
 800f7b4:	4a3e      	ldr	r2, [pc, #248]	; (800f8b0 <OV2640_init+0x570>)
 800f7b6:	493f      	ldr	r1, [pc, #252]	; (800f8b4 <OV2640_init+0x574>)
 800f7b8:	483c      	ldr	r0, [pc, #240]	; (800f8ac <OV2640_init+0x56c>)
 800f7ba:	f002 ff91 	bl	80126e0 <chprintf.constprop.35>
 800f7be:	f240 334a 	movw	r3, #842	; 0x34a
 800f7c2:	4a3d      	ldr	r2, [pc, #244]	; (800f8b8 <OV2640_init+0x578>)
 800f7c4:	493d      	ldr	r1, [pc, #244]	; (800f8bc <OV2640_init+0x57c>)
 800f7c6:	4839      	ldr	r0, [pc, #228]	; (800f8ac <OV2640_init+0x56c>)
 800f7c8:	f002 ff8a 	bl	80126e0 <chprintf.constprop.35>
 800f7cc:	493c      	ldr	r1, [pc, #240]	; (800f8c0 <OV2640_init+0x580>)
 800f7ce:	4837      	ldr	r0, [pc, #220]	; (800f8ac <OV2640_init+0x56c>)
 800f7d0:	f002 ff86 	bl	80126e0 <chprintf.constprop.35>
 800f7d4:	4943      	ldr	r1, [pc, #268]	; (800f8e4 <OV2640_init+0x5a4>)
 800f7d6:	4835      	ldr	r0, [pc, #212]	; (800f8ac <OV2640_init+0x56c>)
 800f7d8:	f002 ff82 	bl	80126e0 <chprintf.constprop.35>
 800f7dc:	493a      	ldr	r1, [pc, #232]	; (800f8c8 <OV2640_init+0x588>)
 800f7de:	4833      	ldr	r0, [pc, #204]	; (800f8ac <OV2640_init+0x56c>)
 800f7e0:	f002 ff7e 	bl	80126e0 <chprintf.constprop.35>
 800f7e4:	482d      	ldr	r0, [pc, #180]	; (800f89c <OV2640_init+0x55c>)
 800f7e6:	f7ff fb23 	bl	800ee30 <chMtxUnlock>
  * Initializes DCMI
  */
void OV2640_InitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR |= RCC_AHB2Periph_DCMI;
 800f7ea:	493f      	ldr	r1, [pc, #252]	; (800f8e8 <OV2640_init+0x5a8>)
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 800f7ec:	4b3f      	ldr	r3, [pc, #252]	; (800f8ec <OV2640_init+0x5ac>)
  * Initializes DCMI
  */
void OV2640_InitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR |= RCC_AHB2Periph_DCMI;
 800f7ee:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 800f7f0:	f042 0201 	orr.w	r2, r2, #1
 800f7f4:	634a      	str	r2, [r1, #52]	; 0x34
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 800f7f6:	681a      	ldr	r2, [r3, #0]
 800f7f8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800f7fc:	f022 0201 	bic.w	r2, r2, #1

	// Configure DCMI
	DCMI->CR = DCMI_CaptureMode_SnapShot | DCMI_CR_JPEG | DCMI_CR_PCKPOL;
 800f800:	212a      	movs	r1, #42	; 0x2a
  */
void OV2640_InitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR |= RCC_AHB2Periph_DCMI;
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 800f802:	601a      	str	r2, [r3, #0]

	// Configure DCMI
	DCMI->CR = DCMI_CaptureMode_SnapShot | DCMI_CR_JPEG | DCMI_CR_PCKPOL;
 800f804:	6019      	str	r1, [r3, #0]

	// DCMI enable
	DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
 800f806:	681a      	ldr	r2, [r3, #0]
 800f808:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800f80c:	601a      	str	r2, [r3, #0]

	// DCMI Init
	TRACE_INFO("CAM  > Init DCMI");
	OV2640_InitDCMI();

	chThdSleepMilliseconds(3000);
 800f80e:	f64e 2060 	movw	r0, #60000	; 0xea60
}
 800f812:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

	// DCMI Init
	TRACE_INFO("CAM  > Init DCMI");
	OV2640_InitDCMI();

	chThdSleepMilliseconds(3000);
 800f816:	f7ff bc3b 	b.w	800f090 <chThdSleep>
 800f81a:	4d35      	ldr	r5, [pc, #212]	; (800f8f0 <OV2640_init+0x5b0>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 800f81c:	219b      	movs	r1, #155	; 0x9b
 800f81e:	2050      	movs	r0, #80	; 0x50
		case RES_QCIF:
			for(uint32_t i=0; (ov2640_qcif_regs[i].reg != 0xff) || (ov2640_qcif_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qcif_regs[i].reg, ov2640_qcif_regs[i].val);
 800f820:	f7fe febe 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f824:	78e9      	ldrb	r1, [r5, #3]
 800f826:	f815 0f02 	ldrb.w	r0, [r5, #2]!
	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
		case RES_QCIF:
			for(uint32_t i=0; (ov2640_qcif_regs[i].reg != 0xff) || (ov2640_qcif_regs[i].val != 0xff); i++)
 800f82a:	28ff      	cmp	r0, #255	; 0xff
 800f82c:	d1f8      	bne.n	800f820 <OV2640_init+0x4e0>
 800f82e:	29ff      	cmp	r1, #255	; 0xff
 800f830:	d1f6      	bne.n	800f820 <OV2640_init+0x4e0>
 800f832:	e6c5      	b.n	800f5c0 <OV2640_init+0x280>
 800f834:	4d2f      	ldr	r5, [pc, #188]	; (800f8f4 <OV2640_init+0x5b4>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 800f836:	2050      	movs	r0, #80	; 0x50
 800f838:	2180      	movs	r1, #128	; 0x80
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
			break;

		case RES_VGA:
			for(uint32_t i=0; (ov2640_vga_regs[i].reg != 0xff) || (ov2640_vga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_vga_regs[i].reg, ov2640_vga_regs[i].val);
 800f83a:	f7fe feb1 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f83e:	78e9      	ldrb	r1, [r5, #3]
 800f840:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
			break;

		case RES_VGA:
			for(uint32_t i=0; (ov2640_vga_regs[i].reg != 0xff) || (ov2640_vga_regs[i].val != 0xff); i++)
 800f844:	28ff      	cmp	r0, #255	; 0xff
 800f846:	d1f8      	bne.n	800f83a <OV2640_init+0x4fa>
 800f848:	29ff      	cmp	r1, #255	; 0xff
 800f84a:	d1f6      	bne.n	800f83a <OV2640_init+0x4fa>
 800f84c:	e6b8      	b.n	800f5c0 <OV2640_init+0x280>
 800f84e:	4d2a      	ldr	r5, [pc, #168]	; (800f8f8 <OV2640_init+0x5b8>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 800f850:	2050      	movs	r0, #80	; 0x50
 800f852:	2180      	movs	r1, #128	; 0x80
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_vga_regs[i].reg, ov2640_vga_regs[i].val);
			break;

		case RES_XGA:
			for(uint32_t i=0; (ov2640_xga_regs[i].reg != 0xff) || (ov2640_xga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_xga_regs[i].reg, ov2640_xga_regs[i].val);
 800f854:	f7fe fea4 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f858:	78e9      	ldrb	r1, [r5, #3]
 800f85a:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_vga_regs[i].reg != 0xff) || (ov2640_vga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_vga_regs[i].reg, ov2640_vga_regs[i].val);
			break;

		case RES_XGA:
			for(uint32_t i=0; (ov2640_xga_regs[i].reg != 0xff) || (ov2640_xga_regs[i].val != 0xff); i++)
 800f85e:	28ff      	cmp	r0, #255	; 0xff
 800f860:	d1f8      	bne.n	800f854 <OV2640_init+0x514>
 800f862:	29ff      	cmp	r1, #255	; 0xff
 800f864:	d1f6      	bne.n	800f854 <OV2640_init+0x514>
 800f866:	e6ab      	b.n	800f5c0 <OV2640_init+0x280>
 800f868:	4d24      	ldr	r5, [pc, #144]	; (800f8fc <OV2640_init+0x5bc>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 800f86a:	2192      	movs	r1, #146	; 0x92
 800f86c:	2050      	movs	r0, #80	; 0x50
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qcif_regs[i].reg, ov2640_qcif_regs[i].val);
			break;

		case RES_QVGA:
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
 800f86e:	f7fe fe97 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f872:	78e9      	ldrb	r1, [r5, #3]
 800f874:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_qcif_regs[i].reg != 0xff) || (ov2640_qcif_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qcif_regs[i].reg, ov2640_qcif_regs[i].val);
			break;

		case RES_QVGA:
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
 800f878:	28ff      	cmp	r0, #255	; 0xff
 800f87a:	d1f8      	bne.n	800f86e <OV2640_init+0x52e>
 800f87c:	29ff      	cmp	r1, #255	; 0xff
 800f87e:	d1f6      	bne.n	800f86e <OV2640_init+0x52e>
 800f880:	e69e      	b.n	800f5c0 <OV2640_init+0x280>
 800f882:	4d1e      	ldr	r5, [pc, #120]	; (800f8fc <OV2640_init+0x5bc>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 800f884:	2192      	movs	r1, #146	; 0x92
 800f886:	2050      	movs	r0, #80	; 0x50
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_uxga_regs[i].reg, ov2640_uxga_regs[i].val);
			break;

		default: // Default QVGA
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
 800f888:	f7fe fe8a 	bl	800e5a0 <I2C_write8_locked.constprop.1>
 800f88c:	78e9      	ldrb	r1, [r5, #3]
 800f88e:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_uxga_regs[i].reg != 0xff) || (ov2640_uxga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_uxga_regs[i].reg, ov2640_uxga_regs[i].val);
			break;

		default: // Default QVGA
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
 800f892:	28ff      	cmp	r0, #255	; 0xff
 800f894:	d1f8      	bne.n	800f888 <OV2640_init+0x548>
 800f896:	29ff      	cmp	r1, #255	; 0xff
 800f898:	d1f6      	bne.n	800f888 <OV2640_init+0x548>
 800f89a:	e691      	b.n	800f5c0 <OV2640_init+0x280>
 800f89c:	20027b2c 	.word	0x20027b2c
 800f8a0:	d1b71759 	.word	0xd1b71759
 800f8a4:	10624dd3 	.word	0x10624dd3
 800f8a8:	08013c50 	.word	0x08013c50
 800f8ac:	20027e60 	.word	0x20027e60
 800f8b0:	08013cfc 	.word	0x08013cfc
 800f8b4:	08013c5c 	.word	0x08013c5c
 800f8b8:	080143f4 	.word	0x080143f4
 800f8bc:	08013c78 	.word	0x08013c78
 800f8c0:	08013d00 	.word	0x08013d00
 800f8c4:	08015f98 	.word	0x08015f98
 800f8c8:	08013cac 	.word	0x08013cac
 800f8cc:	08015fa8 	.word	0x08015fa8
 800f8d0:	0800f271 	.word	0x0800f271
 800f8d4:	08014ff8 	.word	0x08014ff8
 800f8d8:	40026428 	.word	0x40026428
 800f8dc:	50050028 	.word	0x50050028
 800f8e0:	02035404 	.word	0x02035404
 800f8e4:	08015fc8 	.word	0x08015fc8
 800f8e8:	40023800 	.word	0x40023800
 800f8ec:	50050000 	.word	0x50050000
 800f8f0:	08015f10 	.word	0x08015f10
 800f8f4:	08015d88 	.word	0x08015d88
 800f8f8:	08015da8 	.word	0x08015da8
 800f8fc:	08015ff4 	.word	0x08015ff4

0800f900 <OV2640_getBuffer>:
{
	return OV2640_getBuffer(NULL) > ov2640_config->ram_size-3;
}

uint32_t OV2640_getBuffer(uint8_t** buffer) {
	*buffer = ov2640_config->ram_buffer;
 800f900:	4b07      	ldr	r3, [pc, #28]	; (800f920 <OV2640_getBuffer+0x20>)
 800f902:	681a      	ldr	r2, [r3, #0]
 800f904:	68d2      	ldr	r2, [r2, #12]
 800f906:	6002      	str	r2, [r0, #0]

	// Detect size
	uint32_t size = ov2640_config->ram_size;
 800f908:	681b      	ldr	r3, [r3, #0]
 800f90a:	6918      	ldr	r0, [r3, #16]
 800f90c:	68db      	ldr	r3, [r3, #12]
 800f90e:	4403      	add	r3, r0
 800f910:	e000      	b.n	800f914 <OV2640_getBuffer+0x14>
	while(!ov2640_config->ram_buffer[size-1])
		size--;
 800f912:	4608      	mov	r0, r1
uint32_t OV2640_getBuffer(uint8_t** buffer) {
	*buffer = ov2640_config->ram_buffer;

	// Detect size
	uint32_t size = ov2640_config->ram_size;
	while(!ov2640_config->ram_buffer[size-1])
 800f914:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 800f918:	1e41      	subs	r1, r0, #1
 800f91a:	2a00      	cmp	r2, #0
 800f91c:	d0f9      	beq.n	800f912 <OV2640_getBuffer+0x12>
		size--;

	return size;
}
 800f91e:	4770      	bx	lr
 800f920:	20027b40 	.word	0x20027b40
	...

0800f930 <OV2640_Snapshot2RAM>:

/**
  * Captures an image from the camera.
  */
bool OV2640_Snapshot2RAM(void)
{
 800f930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	palClearPad(PORT(LED_2YELLOW), PIN(LED_2YELLOW)); // Yellow LED shows when image is captured
 800f932:	4d25      	ldr	r5, [pc, #148]	; (800f9c8 <OV2640_Snapshot2RAM+0x98>)

	// Capture enable
	TRACE_INFO("CAM  > Capture image");
 800f934:	4f25      	ldr	r7, [pc, #148]	; (800f9cc <OV2640_Snapshot2RAM+0x9c>)
 800f936:	4c26      	ldr	r4, [pc, #152]	; (800f9d0 <OV2640_Snapshot2RAM+0xa0>)
/**
  * Captures an image from the camera.
  */
bool OV2640_Snapshot2RAM(void)
{
	palClearPad(PORT(LED_2YELLOW), PIN(LED_2YELLOW)); // Yellow LED shows when image is captured
 800f938:	f44f 7680 	mov.w	r6, #256	; 0x100

	// Capture enable
	TRACE_INFO("CAM  > Capture image");
 800f93c:	4638      	mov	r0, r7
/**
  * Captures an image from the camera.
  */
bool OV2640_Snapshot2RAM(void)
{
	palClearPad(PORT(LED_2YELLOW), PIN(LED_2YELLOW)); // Yellow LED shows when image is captured
 800f93e:	836e      	strh	r6, [r5, #26]

	// Capture enable
	TRACE_INFO("CAM  > Capture image");
 800f940:	f7ff fad6 	bl	800eef0 <chMtxLock>
 800f944:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800f948:	f8df e0b0 	ldr.w	lr, [pc, #176]	; 800f9fc <OV2640_Snapshot2RAM+0xcc>
 800f94c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800f94e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800f950:	4b20      	ldr	r3, [pc, #128]	; (800f9d4 <OV2640_Snapshot2RAM+0xa4>)
 800f952:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800f956:	fb00 f101 	mul.w	r1, r0, r1
 800f95a:	fbae c101 	umull	ip, r1, lr, r1
 800f95e:	0b89      	lsrs	r1, r1, #14
 800f960:	fba3 c301 	umull	ip, r3, r3, r1
 800f964:	fbae e202 	umull	lr, r2, lr, r2
 800f968:	099b      	lsrs	r3, r3, #6
 800f96a:	fb00 1313 	mls	r3, r0, r3, r1
 800f96e:	0b92      	lsrs	r2, r2, #14
 800f970:	4620      	mov	r0, r4
 800f972:	4919      	ldr	r1, [pc, #100]	; (800f9d8 <OV2640_Snapshot2RAM+0xa8>)
 800f974:	f002 feb4 	bl	80126e0 <chprintf.constprop.35>
 800f978:	4620      	mov	r0, r4
 800f97a:	4a18      	ldr	r2, [pc, #96]	; (800f9dc <OV2640_Snapshot2RAM+0xac>)
 800f97c:	4918      	ldr	r1, [pc, #96]	; (800f9e0 <OV2640_Snapshot2RAM+0xb0>)
 800f97e:	f002 feaf 	bl	80126e0 <chprintf.constprop.35>
 800f982:	f240 238b 	movw	r3, #651	; 0x28b
 800f986:	4a17      	ldr	r2, [pc, #92]	; (800f9e4 <OV2640_Snapshot2RAM+0xb4>)
 800f988:	4917      	ldr	r1, [pc, #92]	; (800f9e8 <OV2640_Snapshot2RAM+0xb8>)
 800f98a:	4620      	mov	r0, r4
 800f98c:	f002 fea8 	bl	80126e0 <chprintf.constprop.35>
 800f990:	4620      	mov	r0, r4
 800f992:	4916      	ldr	r1, [pc, #88]	; (800f9ec <OV2640_Snapshot2RAM+0xbc>)
 800f994:	f002 fea4 	bl	80126e0 <chprintf.constprop.35>
 800f998:	4620      	mov	r0, r4
 800f99a:	4915      	ldr	r1, [pc, #84]	; (800f9f0 <OV2640_Snapshot2RAM+0xc0>)
 800f99c:	f002 fea0 	bl	80126e0 <chprintf.constprop.35>
 800f9a0:	4914      	ldr	r1, [pc, #80]	; (800f9f4 <OV2640_Snapshot2RAM+0xc4>)
 800f9a2:	4620      	mov	r0, r4
 800f9a4:	f002 fe9c 	bl	80126e0 <chprintf.constprop.35>
 800f9a8:	4638      	mov	r0, r7
 800f9aa:	f7ff fa41 	bl	800ee30 <chMtxUnlock>
}

void OV2640_CaptureDCMI(void)
{
	// DCMI capture
	DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
 800f9ae:	4a12      	ldr	r2, [pc, #72]	; (800f9f8 <OV2640_Snapshot2RAM+0xc8>)
 800f9b0:	6813      	ldr	r3, [r2, #0]
 800f9b2:	f043 0301 	orr.w	r3, r3, #1
 800f9b6:	6013      	str	r3, [r2, #0]
	palClearPad(PORT(LED_2YELLOW), PIN(LED_2YELLOW)); // Yellow LED shows when image is captured

	// Capture enable
	TRACE_INFO("CAM  > Capture image");
	OV2640_CaptureDCMI();
	chThdSleepMilliseconds(1000);
 800f9b8:	f644 6020 	movw	r0, #20000	; 0x4e20
 800f9bc:	f7ff fb68 	bl	800f090 <chThdSleep>

	palSetPad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
 800f9c0:	832e      	strh	r6, [r5, #24]

	return true;
}
 800f9c2:	2001      	movs	r0, #1
 800f9c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f9c6:	bf00      	nop
 800f9c8:	40022000 	.word	0x40022000
 800f9cc:	20027b2c 	.word	0x20027b2c
 800f9d0:	20027e60 	.word	0x20027e60
 800f9d4:	10624dd3 	.word	0x10624dd3
 800f9d8:	08013c50 	.word	0x08013c50
 800f9dc:	08013cfc 	.word	0x08013cfc
 800f9e0:	08013c5c 	.word	0x08013c5c
 800f9e4:	080143f4 	.word	0x080143f4
 800f9e8:	08013c78 	.word	0x08013c78
 800f9ec:	08013d00 	.word	0x08013d00
 800f9f0:	08015fdc 	.word	0x08015fdc
 800f9f4:	08013cac 	.word	0x08013cac
 800f9f8:	50050000 	.word	0x50050000
 800f9fc:	d1b71759 	.word	0xd1b71759

0800fa00 <pac1720_getPowerCharge>:
		return val * fsp / 65536;
	else
		return 0; // PAC1720 not available (maybe Vcc too low)
}

int16_t pac1720_getPowerCharge(void) {
 800fa00:	b500      	push	{lr}
 800fa02:	b083      	sub	sp, #12
	int32_t fsp = FSV * FSC;
	uint16_t val;
	if(I2C_read16(PAC1720_ADDRESS, PAC1720_CH1_PWR_RAT_HIGH, &val))
 800fa04:	f10d 0206 	add.w	r2, sp, #6
 800fa08:	2115      	movs	r1, #21
 800fa0a:	204c      	movs	r0, #76	; 0x4c
 800fa0c:	f7fa fcc0 	bl	800a390 <I2C_read16>
 800fa10:	b130      	cbz	r0, 800fa20 <pac1720_getPowerCharge+0x20>
		return val * fsp / 65536;
 800fa12:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800fa16:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 800fa1a:	fb03 f000 	mul.w	r0, r3, r0
 800fa1e:	1400      	asrs	r0, r0, #16
	else
		return 0; // PAC1720 not available (maybe Vcc too low)
}
 800fa20:	b003      	add	sp, #12
 800fa22:	f85d fb04 	ldr.w	pc, [sp], #4
 800fa26:	bf00      	nop
	...

0800fa30 <pac1720_getPowerDischarge>:
static int32_t pac1720_charge;
static int32_t pac1720_discharge;
static int32_t pac1720_charge_counter;
static int32_t pac1720_discharge_counter;

int16_t pac1720_getPowerDischarge(void) {
 800fa30:	b500      	push	{lr}
 800fa32:	b083      	sub	sp, #12
	int32_t fsp = FSV * FSC;
	uint16_t val;
	if(I2C_read16(PAC1720_ADDRESS, PAC1720_CH2_PWR_RAT_HIGH, &val))
 800fa34:	f10d 0206 	add.w	r2, sp, #6
 800fa38:	2117      	movs	r1, #23
 800fa3a:	204c      	movs	r0, #76	; 0x4c
 800fa3c:	f7fa fca8 	bl	800a390 <I2C_read16>
 800fa40:	b130      	cbz	r0, 800fa50 <pac1720_getPowerDischarge+0x20>
		return val * fsp / 65536;
 800fa42:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800fa46:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
 800fa4a:	fb03 f000 	mul.w	r0, r3, r0
 800fa4e:	1400      	asrs	r0, r0, #16
	else
		return 0; // PAC1720 not available (maybe Vcc too low)
}
 800fa50:	b003      	add	sp, #12
 800fa52:	f85d fb04 	ldr.w	pc, [sp], #4
 800fa56:	bf00      	nop
	...

0800fa60 <pac1720_thd>:
	else
		return false; // PAC1720 not available (maybe Vcc too low)
}

THD_FUNCTION(pac1720_thd, arg)
{
 800fa60:	b580      	push	{r7, lr}
 800fa62:	4e0c      	ldr	r6, [pc, #48]	; (800fa94 <pac1720_thd+0x34>)
 800fa64:	4f0c      	ldr	r7, [pc, #48]	; (800fa98 <pac1720_thd+0x38>)
 800fa66:	4d0d      	ldr	r5, [pc, #52]	; (800fa9c <pac1720_thd+0x3c>)
 800fa68:	4c0d      	ldr	r4, [pc, #52]	; (800faa0 <pac1720_thd+0x40>)
	(void)arg;

	while(true)
	{
		pac1720_charge += pac1720_getPowerCharge();
 800fa6a:	f7ff ffc9 	bl	800fa00 <pac1720_getPowerCharge>
 800fa6e:	683b      	ldr	r3, [r7, #0]
 800fa70:	4418      	add	r0, r3
 800fa72:	6038      	str	r0, [r7, #0]
		pac1720_discharge += pac1720_getPowerDischarge();
 800fa74:	f7ff ffdc 	bl	800fa30 <pac1720_getPowerDischarge>
 800fa78:	6831      	ldr	r1, [r6, #0]
		pac1720_charge_counter++;
 800fa7a:	682a      	ldr	r2, [r5, #0]
		pac1720_discharge_counter++;
 800fa7c:	6823      	ldr	r3, [r4, #0]
	(void)arg;

	while(true)
	{
		pac1720_charge += pac1720_getPowerCharge();
		pac1720_discharge += pac1720_getPowerDischarge();
 800fa7e:	4401      	add	r1, r0
		pac1720_charge_counter++;
 800fa80:	3201      	adds	r2, #1
		pac1720_discharge_counter++;
 800fa82:	3301      	adds	r3, #1

		chThdSleepMilliseconds(100);
 800fa84:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
	(void)arg;

	while(true)
	{
		pac1720_charge += pac1720_getPowerCharge();
		pac1720_discharge += pac1720_getPowerDischarge();
 800fa88:	6031      	str	r1, [r6, #0]
		pac1720_charge_counter++;
 800fa8a:	602a      	str	r2, [r5, #0]
		pac1720_discharge_counter++;
 800fa8c:	6023      	str	r3, [r4, #0]

		chThdSleepMilliseconds(100);
 800fa8e:	f7ff faff 	bl	800f090 <chThdSleep>
 800fa92:	e7ea      	b.n	800fa6a <pac1720_thd+0xa>
 800fa94:	20027b48 	.word	0x20027b48
 800fa98:	20027b44 	.word	0x20027b44
 800fa9c:	20027b50 	.word	0x20027b50
 800faa0:	20027b4c 	.word	0x20027b4c
	...

0800fab0 <BME280_getHumidity>:

/**
  * Reads the relative humidity
  * @return rel. humidity in % * 10
  */
uint16_t BME280_getHumidity(bme280_t *handle) {
 800fab0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fab2:	4604      	mov	r4, r0
 800fab4:	b083      	sub	sp, #12
	int32_t adc_H;
	uint16_t tmp;
	I2C_read16(handle->address, BME280_REGISTER_HUMIDDATA, &tmp);
 800fab6:	f10d 0206 	add.w	r2, sp, #6
 800faba:	21fd      	movs	r1, #253	; 0xfd
 800fabc:	7800      	ldrb	r0, [r0, #0]
 800fabe:	f7fa fc67 	bl	800a390 <I2C_read16>
	adc_H = tmp;

	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));
 800fac2:	6863      	ldr	r3, [r4, #4]

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 800fac4:	f894 6024 	ldrb.w	r6, [r4, #36]	; 0x24
 800fac8:	f994 202a 	ldrsb.w	r2, [r4, #42]	; 0x2a
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800facc:	f9b4 c026 	ldrsh.w	ip, [r4, #38]	; 0x26
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 800fad0:	f9b4 1022 	ldrsh.w	r1, [r4, #34]	; 0x22
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800fad4:	f9b4 0028 	ldrsh.w	r0, [r4, #40]	; 0x28
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));

	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((int32_t)handle->calib.dig_H1)) >> 4));
 800fad8:	f894 5020 	ldrb.w	r5, [r4, #32]
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800fadc:	f8bd e006 	ldrh.w	lr, [sp, #6]
	I2C_read16(handle->address, BME280_REGISTER_HUMIDDATA, &tmp);
	adc_H = tmp;

	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));
 800fae0:	f5a3 3796 	sub.w	r7, r3, #76800	; 0x12c00

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 800fae4:	fb07 f606 	mul.w	r6, r7, r6
 800fae8:	fb07 f402 	mul.w	r4, r7, r2
 800faec:	12f6      	asrs	r6, r6, #11
 800faee:	f506 4600 	add.w	r6, r6, #32768	; 0x8000
 800faf2:	12a2      	asrs	r2, r4, #10
 800faf4:	fb02 f206 	mul.w	r2, r2, r6
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800faf8:	ea4f 530c 	mov.w	r3, ip, lsl #20
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 800fafc:	1292      	asrs	r2, r2, #10
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800fafe:	ebc3 338e 	rsb	r3, r3, lr, lsl #14
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 800fb02:	f502 1200 	add.w	r2, r2, #2097152	; 0x200000
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800fb06:	fb07 3310 	mls	r3, r7, r0, r3
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 800fb0a:	fb01 f202 	mul.w	r2, r1, r2
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800fb0e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 800fb12:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
 800fb16:	1392      	asrs	r2, r2, #14
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800fb18:	13db      	asrs	r3, r3, #15

	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
 800fb1a:	fb02 f303 	mul.w	r3, r2, r3
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));

	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((int32_t)handle->calib.dig_H1)) >> 4));
 800fb1e:	13d8      	asrs	r0, r3, #15
 800fb20:	fb00 f000 	mul.w	r0, r0, r0
 800fb24:	11c0      	asrs	r0, r0, #7
 800fb26:	fb05 f000 	mul.w	r0, r5, r0
 800fb2a:	eba3 1020 	sub.w	r0, r3, r0, asr #4

	v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r;
 800fb2e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
	v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r;
	float h = (v_x1_u32r>>12);
	return h / 102;
 800fb32:	f1b0 5fc8 	cmp.w	r0, #419430400	; 0x19000000
 800fb36:	bfa8      	it	ge
 800fb38:	f04f 50c8 	movge.w	r0, #419430400	; 0x19000000
 800fb3c:	1300      	asrs	r0, r0, #12
 800fb3e:	f7f1 f969 	bl	8000e14 <__aeabi_i2f>
 800fb42:	4904      	ldr	r1, [pc, #16]	; (800fb54 <BME280_getHumidity+0xa4>)
 800fb44:	f7f1 fa70 	bl	8001028 <__aeabi_fdiv>
 800fb48:	f7f1 fb9a 	bl	8001280 <__aeabi_f2uiz>
}
 800fb4c:	b280      	uxth	r0, r0
 800fb4e:	b003      	add	sp, #12
 800fb50:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800fb52:	bf00      	nop
 800fb54:	42cc0000 	.word	0x42cc0000
	...

0800fb60 <BME280_getTemperature>:
/**
  * Reads the temperature
  * @return Temperature in degC * 100
  */
int16_t BME280_getTemperature(bme280_t *handle)
{
 800fb60:	b570      	push	{r4, r5, r6, lr}
 800fb62:	4604      	mov	r4, r0
 800fb64:	b082      	sub	sp, #8
	int32_t var1, var2, adc_T;
	uint16_t tmp;

	I2C_read16(handle->address, BME280_REGISTER_TEMPDATA, &tmp);
 800fb66:	f10d 0206 	add.w	r2, sp, #6
 800fb6a:	21fa      	movs	r1, #250	; 0xfa
 800fb6c:	7800      	ldrb	r0, [r0, #0]
 800fb6e:	f7fa fc0f 	bl	800a390 <I2C_read16>
	adc_T = tmp;
	I2C_read8(handle->address, BME280_REGISTER_TEMPDATA+2, (uint8_t*)&tmp);
 800fb72:	f10d 0206 	add.w	r2, sp, #6
 800fb76:	7820      	ldrb	r0, [r4, #0]
{
	int32_t var1, var2, adc_T;
	uint16_t tmp;

	I2C_read16(handle->address, BME280_REGISTER_TEMPDATA, &tmp);
	adc_T = tmp;
 800fb78:	f8bd 6006 	ldrh.w	r6, [sp, #6]
	I2C_read8(handle->address, BME280_REGISTER_TEMPDATA+2, (uint8_t*)&tmp);
 800fb7c:	21fc      	movs	r1, #252	; 0xfc
 800fb7e:	f7fa fb9f 	bl	800a2c0 <I2C_read8>
	adc_T <<= 8;
	adc_T |= tmp & 0xFF;
 800fb82:	f89d 2006 	ldrb.w	r2, [sp, #6]
	adc_T >>= 4;

	var1 = ((((adc_T>>3) - ((int32_t)handle->calib.dig_T1 <<1))) * ((int32_t)handle->calib.dig_T2)) >> 11;
 800fb86:	8920      	ldrh	r0, [r4, #8]
	var2 = (((((adc_T>>4) - ((int32_t)handle->calib.dig_T1)) * ((adc_T>>4) - ((int32_t)handle->calib.dig_T1))) >> 12) * ((int32_t)handle->calib.dig_T3)) >> 14;

	handle->t_fine = var1 + var2;
 800fb88:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 800fb8c:	f9b4 500a 	ldrsh.w	r5, [r4, #10]

	I2C_read16(handle->address, BME280_REGISTER_TEMPDATA, &tmp);
	adc_T = tmp;
	I2C_read8(handle->address, BME280_REGISTER_TEMPDATA+2, (uint8_t*)&tmp);
	adc_T <<= 8;
	adc_T |= tmp & 0xFF;
 800fb90:	ea42 2306 	orr.w	r3, r2, r6, lsl #8
	adc_T >>= 4;

	var1 = ((((adc_T>>3) - ((int32_t)handle->calib.dig_T1 <<1))) * ((int32_t)handle->calib.dig_T2)) >> 11;
	var2 = (((((adc_T>>4) - ((int32_t)handle->calib.dig_T1)) * ((adc_T>>4) - ((int32_t)handle->calib.dig_T1))) >> 12) * ((int32_t)handle->calib.dig_T3)) >> 14;
 800fb94:	ebc0 2213 	rsb	r2, r0, r3, lsr #8

	handle->t_fine = var1 + var2;
 800fb98:	fb02 f202 	mul.w	r2, r2, r2
 800fb9c:	1312      	asrs	r2, r2, #12
 800fb9e:	0040      	lsls	r0, r0, #1
 800fba0:	ebc0 10d3 	rsb	r0, r0, r3, lsr #7
 800fba4:	fb01 f202 	mul.w	r2, r1, r2
 800fba8:	fb05 f000 	mul.w	r0, r5, r0
 800fbac:	1392      	asrs	r2, r2, #14
 800fbae:	eb02 23e0 	add.w	r3, r2, r0, asr #11

	return (handle->t_fine * 5 + 128) >> 8;
 800fbb2:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 800fbb6:	3080      	adds	r0, #128	; 0x80
}
 800fbb8:	f340 200f 	sbfx	r0, r0, #8, #16
	adc_T >>= 4;

	var1 = ((((adc_T>>3) - ((int32_t)handle->calib.dig_T1 <<1))) * ((int32_t)handle->calib.dig_T2)) >> 11;
	var2 = (((((adc_T>>4) - ((int32_t)handle->calib.dig_T1)) * ((adc_T>>4) - ((int32_t)handle->calib.dig_T1))) >> 12) * ((int32_t)handle->calib.dig_T3)) >> 14;

	handle->t_fine = var1 + var2;
 800fbbc:	6063      	str	r3, [r4, #4]

	return (handle->t_fine * 5 + 128) >> 8;
}
 800fbbe:	b002      	add	sp, #8
 800fbc0:	bd70      	pop	{r4, r5, r6, pc}
 800fbc2:	bf00      	nop
	...

0800fbd0 <BME280_Init>:

/**
  * Initializes BME280 and reads calibration data
  */
void BME280_Init(bme280_t *handle, uint8_t address)
{
 800fbd0:	b530      	push	{r4, r5, lr}
	uint8_t tmp1;
	uint8_t tmp2;

	handle->address = address;
 800fbd2:	4602      	mov	r2, r0

/**
  * Initializes BME280 and reads calibration data
  */
void BME280_Init(bme280_t *handle, uint8_t address)
{
 800fbd4:	b083      	sub	sp, #12
 800fbd6:	460c      	mov	r4, r1
 800fbd8:	4605      	mov	r5, r0
	uint8_t tmp1;
	uint8_t tmp2;

	handle->address = address;
 800fbda:	f802 1b08 	strb.w	r1, [r2], #8

	I2C_read16_LE(address, BME280_REGISTER_DIG_T1, &handle->calib.dig_T1);
 800fbde:	4608      	mov	r0, r1
 800fbe0:	2188      	movs	r1, #136	; 0x88
 800fbe2:	f7fa fbc5 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_T2, &handle->calib.dig_T2);
 800fbe6:	f105 020a 	add.w	r2, r5, #10
 800fbea:	4620      	mov	r0, r4
 800fbec:	218a      	movs	r1, #138	; 0x8a
 800fbee:	f7fa fbbf 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_T3, &handle->calib.dig_T3);
 800fbf2:	f105 020c 	add.w	r2, r5, #12
 800fbf6:	4620      	mov	r0, r4
 800fbf8:	218c      	movs	r1, #140	; 0x8c
 800fbfa:	f7fa fbb9 	bl	800a370 <I2C_read16_LE>

	I2C_read16_LE(address, BME280_REGISTER_DIG_P1, &handle->calib.dig_P1);
 800fbfe:	f105 020e 	add.w	r2, r5, #14
 800fc02:	4620      	mov	r0, r4
 800fc04:	218e      	movs	r1, #142	; 0x8e
 800fc06:	f7fa fbb3 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P2, &handle->calib.dig_P2);
 800fc0a:	f105 0210 	add.w	r2, r5, #16
 800fc0e:	4620      	mov	r0, r4
 800fc10:	2190      	movs	r1, #144	; 0x90
 800fc12:	f7fa fbad 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P3, &handle->calib.dig_P3);
 800fc16:	f105 0212 	add.w	r2, r5, #18
 800fc1a:	4620      	mov	r0, r4
 800fc1c:	2192      	movs	r1, #146	; 0x92
 800fc1e:	f7fa fba7 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P4, &handle->calib.dig_P4);
 800fc22:	f105 0214 	add.w	r2, r5, #20
 800fc26:	4620      	mov	r0, r4
 800fc28:	2194      	movs	r1, #148	; 0x94
 800fc2a:	f7fa fba1 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P5, &handle->calib.dig_P5);
 800fc2e:	f105 0216 	add.w	r2, r5, #22
 800fc32:	4620      	mov	r0, r4
 800fc34:	2196      	movs	r1, #150	; 0x96
 800fc36:	f7fa fb9b 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P6, &handle->calib.dig_P6);
 800fc3a:	f105 0218 	add.w	r2, r5, #24
 800fc3e:	4620      	mov	r0, r4
 800fc40:	2198      	movs	r1, #152	; 0x98
 800fc42:	f7fa fb95 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P7, &handle->calib.dig_P7);
 800fc46:	f105 021a 	add.w	r2, r5, #26
 800fc4a:	4620      	mov	r0, r4
 800fc4c:	219a      	movs	r1, #154	; 0x9a
 800fc4e:	f7fa fb8f 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P8, &handle->calib.dig_P8);
 800fc52:	f105 021c 	add.w	r2, r5, #28
 800fc56:	4620      	mov	r0, r4
 800fc58:	219c      	movs	r1, #156	; 0x9c
 800fc5a:	f7fa fb89 	bl	800a370 <I2C_read16_LE>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P9, &handle->calib.dig_P9);
 800fc5e:	f105 021e 	add.w	r2, r5, #30
 800fc62:	4620      	mov	r0, r4
 800fc64:	219e      	movs	r1, #158	; 0x9e
 800fc66:	f7fa fb83 	bl	800a370 <I2C_read16_LE>

	I2C_read8(address, BME280_REGISTER_DIG_H1, &handle->calib.dig_H1);
 800fc6a:	f105 0220 	add.w	r2, r5, #32
 800fc6e:	4620      	mov	r0, r4
 800fc70:	21a1      	movs	r1, #161	; 0xa1
 800fc72:	f7fa fb25 	bl	800a2c0 <I2C_read8>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_H2, &handle->calib.dig_H2);
 800fc76:	f105 0222 	add.w	r2, r5, #34	; 0x22
 800fc7a:	4620      	mov	r0, r4
 800fc7c:	21e1      	movs	r1, #225	; 0xe1
 800fc7e:	f7fa fb77 	bl	800a370 <I2C_read16_LE>
	I2C_read8(address, BME280_REGISTER_DIG_H3, &handle->calib.dig_H3);
 800fc82:	f105 0224 	add.w	r2, r5, #36	; 0x24
 800fc86:	4620      	mov	r0, r4
 800fc88:	21e3      	movs	r1, #227	; 0xe3
 800fc8a:	f7fa fb19 	bl	800a2c0 <I2C_read8>

	I2C_read8(address, BME280_REGISTER_DIG_H4, &tmp1);
 800fc8e:	f10d 0207 	add.w	r2, sp, #7
 800fc92:	4620      	mov	r0, r4
 800fc94:	21e4      	movs	r1, #228	; 0xe4
 800fc96:	f7fa fb13 	bl	800a2c0 <I2C_read8>
	I2C_read8(address, BME280_REGISTER_DIG_H5, &tmp2);
 800fc9a:	f10d 0206 	add.w	r2, sp, #6
 800fc9e:	4620      	mov	r0, r4
 800fca0:	21e5      	movs	r1, #229	; 0xe5
 800fca2:	f7fa fb0d 	bl	800a2c0 <I2C_read8>
	handle->calib.dig_H4 = (((int8_t)tmp1) << 4) | (tmp2 & 0x0F);
 800fca6:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800fcaa:	f99d 2007 	ldrsb.w	r2, [sp, #7]
 800fcae:	f003 030f 	and.w	r3, r3, #15
 800fcb2:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800fcb6:	84eb      	strh	r3, [r5, #38]	; 0x26

	I2C_read8(address, BME280_REGISTER_DIG_H6, &tmp1);
 800fcb8:	f10d 0207 	add.w	r2, sp, #7
 800fcbc:	4620      	mov	r0, r4
 800fcbe:	21e7      	movs	r1, #231	; 0xe7
 800fcc0:	f7fa fafe 	bl	800a2c0 <I2C_read8>
	I2C_read8(address, BME280_REGISTER_DIG_H5, &tmp2);
 800fcc4:	f10d 0206 	add.w	r2, sp, #6
 800fcc8:	4620      	mov	r0, r4
 800fcca:	21e5      	movs	r1, #229	; 0xe5
 800fccc:	f7fa faf8 	bl	800a2c0 <I2C_read8>
	handle->calib.dig_H5 = (((int8_t)tmp1) << 4) | (tmp2 >> 4 & 0x0F);
 800fcd0:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800fcd4:	f99d 2007 	ldrsb.w	r2, [sp, #7]
 800fcd8:	091b      	lsrs	r3, r3, #4
 800fcda:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800fcde:	852b      	strh	r3, [r5, #40]	; 0x28

	I2C_read8(address, BME280_REGISTER_DIG_H6, (uint8_t*)&handle->calib.dig_H6);
 800fce0:	f105 022a 	add.w	r2, r5, #42	; 0x2a
 800fce4:	4620      	mov	r0, r4
 800fce6:	21e7      	movs	r1, #231	; 0xe7
 800fce8:	f7fa faea 	bl	800a2c0 <I2C_read8>

	I2C_write8(address, BME280_REGISTER_CONTROLHUMID, 0x03); // Set before CONTROL (DS 5.4.3)
 800fcec:	4620      	mov	r0, r4
 800fcee:	2203      	movs	r2, #3
 800fcf0:	21f2      	movs	r1, #242	; 0xf2
 800fcf2:	f7fa fb05 	bl	800a300 <I2C_write8>
	I2C_write8(address, BME280_REGISTER_CONTROL, 0x3F);
 800fcf6:	223f      	movs	r2, #63	; 0x3f
 800fcf8:	21f4      	movs	r1, #244	; 0xf4
 800fcfa:	4620      	mov	r0, r4
 800fcfc:	f7fa fb00 	bl	800a300 <I2C_write8>
	chThdSleepMilliseconds(50); // Wait for BME280
 800fd00:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800fd04:	f7ff f9c4 	bl	800f090 <chThdSleep>

	BME280_getTemperature(handle); // Set t_fine
 800fd08:	4628      	mov	r0, r5
 800fd0a:	f7ff ff29 	bl	800fb60 <BME280_getTemperature>
}
 800fd0e:	b003      	add	sp, #12
 800fd10:	bd30      	pop	{r4, r5, pc}
 800fd12:	bf00      	nop
	...

0800fd20 <BME280_isAvailable>:
#include "bme280.h"
#include "pi2c.h"
#include <math.h>

bool BME280_isAvailable(uint8_t address)
{
 800fd20:	b500      	push	{lr}
 800fd22:	b083      	sub	sp, #12
	uint8_t val;
	if(I2C_read8(address, BME280_REGISTER_CHIPID, &val))
 800fd24:	f10d 0207 	add.w	r2, sp, #7
 800fd28:	21d0      	movs	r1, #208	; 0xd0
 800fd2a:	f7fa fac9 	bl	800a2c0 <I2C_read8>
 800fd2e:	b130      	cbz	r0, 800fd3e <BME280_isAvailable+0x1e>
		return val == 0x60;
 800fd30:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800fd34:	f1a0 0060 	sub.w	r0, r0, #96	; 0x60
 800fd38:	fab0 f080 	clz	r0, r0
 800fd3c:	0940      	lsrs	r0, r0, #5
	else
		return false;
}
 800fd3e:	b003      	add	sp, #12
 800fd40:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800fd50 <dBm2powerLvl>:
/**
  * Converts power level from dBm to Si4464 power level. The calculation
  * assumes Vcc = 2.6V and Si4464/Si4463 or Si4063.
  */
uint8_t dBm2powerLvl(int32_t dBm) {
	if(dBm < -35) {
 800fd50:	f110 0f23 	cmn.w	r0, #35	; 0x23
 800fd54:	db16      	blt.n	800fd84 <dBm2powerLvl+0x34>
		return 0;
	} else if(dBm < -7) {
 800fd56:	1dc2      	adds	r2, r0, #7
 800fd58:	db09      	blt.n	800fd6e <dBm2powerLvl+0x1e>
		return (uint8_t)((2*dBm+74)/15);
	} else if(dBm < 2) {
 800fd5a:	2801      	cmp	r0, #1
 800fd5c:	dd23      	ble.n	800fda6 <dBm2powerLvl+0x56>
		return (uint8_t)((2*dBm+26)/3);
	} else if(dBm < 8) {
 800fd5e:	2807      	cmp	r0, #7
 800fd60:	dd12      	ble.n	800fd88 <dBm2powerLvl+0x38>
		return (uint8_t)((5*dBm+20)/3);
	} else if(dBm < 13) {
 800fd62:	280c      	cmp	r0, #12
 800fd64:	dd1a      	ble.n	800fd9c <dBm2powerLvl+0x4c>
		return (uint8_t)(3*dBm-4);
	} else if(dBm < 18) {
 800fd66:	2811      	cmp	r0, #17
 800fd68:	dd26      	ble.n	800fdb8 <dBm2powerLvl+0x68>
		return (uint8_t)((92*dBm-1021)/5);
	} else {
		return 127;
 800fd6a:	207f      	movs	r0, #127	; 0x7f
	}
}
 800fd6c:	4770      	bx	lr
  */
uint8_t dBm2powerLvl(int32_t dBm) {
	if(dBm < -35) {
		return 0;
	} else if(dBm < -7) {
		return (uint8_t)((2*dBm+74)/15);
 800fd6e:	3025      	adds	r0, #37	; 0x25
 800fd70:	4a18      	ldr	r2, [pc, #96]	; (800fdd4 <dBm2powerLvl+0x84>)
 800fd72:	0043      	lsls	r3, r0, #1
 800fd74:	fb82 2003 	smull	r2, r0, r2, r3
 800fd78:	4418      	add	r0, r3
 800fd7a:	17db      	asrs	r3, r3, #31
 800fd7c:	ebc3 00e0 	rsb	r0, r3, r0, asr #3
 800fd80:	b2c0      	uxtb	r0, r0
 800fd82:	4770      	bx	lr
  * Converts power level from dBm to Si4464 power level. The calculation
  * assumes Vcc = 2.6V and Si4464/Si4463 or Si4063.
  */
uint8_t dBm2powerLvl(int32_t dBm) {
	if(dBm < -35) {
		return 0;
 800fd84:	2000      	movs	r0, #0
 800fd86:	4770      	bx	lr
	} else if(dBm < -7) {
		return (uint8_t)((2*dBm+74)/15);
	} else if(dBm < 2) {
		return (uint8_t)((2*dBm+26)/3);
	} else if(dBm < 8) {
		return (uint8_t)((5*dBm+20)/3);
 800fd88:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800fd8c:	4b12      	ldr	r3, [pc, #72]	; (800fdd8 <dBm2powerLvl+0x88>)
 800fd8e:	3014      	adds	r0, #20
 800fd90:	fb83 2300 	smull	r2, r3, r3, r0
 800fd94:	eba3 70e0 	sub.w	r0, r3, r0, asr #31
 800fd98:	b2c0      	uxtb	r0, r0
 800fd9a:	4770      	bx	lr
	} else if(dBm < 13) {
		return (uint8_t)(3*dBm-4);
 800fd9c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800fda0:	3804      	subs	r0, #4
 800fda2:	b2c0      	uxtb	r0, r0
 800fda4:	4770      	bx	lr
	if(dBm < -35) {
		return 0;
	} else if(dBm < -7) {
		return (uint8_t)((2*dBm+74)/15);
	} else if(dBm < 2) {
		return (uint8_t)((2*dBm+26)/3);
 800fda6:	300d      	adds	r0, #13
 800fda8:	4b0b      	ldr	r3, [pc, #44]	; (800fdd8 <dBm2powerLvl+0x88>)
 800fdaa:	0040      	lsls	r0, r0, #1
 800fdac:	fb83 2300 	smull	r2, r3, r3, r0
 800fdb0:	eba3 70e0 	sub.w	r0, r3, r0, asr #31
 800fdb4:	b2c0      	uxtb	r0, r0
 800fdb6:	4770      	bx	lr
	} else if(dBm < 8) {
		return (uint8_t)((5*dBm+20)/3);
	} else if(dBm < 13) {
		return (uint8_t)(3*dBm-4);
	} else if(dBm < 18) {
		return (uint8_t)((92*dBm-1021)/5);
 800fdb8:	235c      	movs	r3, #92	; 0x5c
 800fdba:	fb03 f000 	mul.w	r0, r3, r0
 800fdbe:	4a07      	ldr	r2, [pc, #28]	; (800fddc <dBm2powerLvl+0x8c>)
 800fdc0:	f46f 737f 	mvn.w	r3, #1020	; 0x3fc
 800fdc4:	18c3      	adds	r3, r0, r3
 800fdc6:	fb82 2003 	smull	r2, r0, r2, r3
 800fdca:	17db      	asrs	r3, r3, #31
 800fdcc:	ebc3 0060 	rsb	r0, r3, r0, asr #1
 800fdd0:	b2c0      	uxtb	r0, r0
 800fdd2:	4770      	bx	lr
 800fdd4:	88888889 	.word	0x88888889
 800fdd8:	55555556 	.word	0x55555556
 800fddc:	66666667 	.word	0x66666667

0800fde0 <Si4464_write>:
	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
	initialized[radio] = true;
}

void Si4464_write(radio_t radio, uint8_t* txData, uint32_t len) {
 800fde0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	// Transmit data by SPI
	uint8_t rxData[len];
 800fde4:	1dd3      	adds	r3, r2, #7
	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
	initialized[radio] = true;
}

void Si4464_write(radio_t radio, uint8_t* txData, uint32_t len) {
 800fde6:	b082      	sub	sp, #8
	// Transmit data by SPI
	uint8_t rxData[len];
 800fde8:	f023 0307 	bic.w	r3, r3, #7
	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
	initialized[radio] = true;
}

void Si4464_write(radio_t radio, uint8_t* txData, uint32_t len) {
 800fdec:	4606      	mov	r6, r0
 800fdee:	af00      	add	r7, sp, #0
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800fdf0:	4825      	ldr	r0, [pc, #148]	; (800fe88 <Si4464_write+0xa8>)
	// Transmit data by SPI
	uint8_t rxData[len];
 800fdf2:	ebad 0d03 	sub.w	sp, sp, r3
	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
	initialized[radio] = true;
}

void Si4464_write(radio_t radio, uint8_t* txData, uint32_t len) {
 800fdf6:	4614      	mov	r4, r2
 800fdf8:	4688      	mov	r8, r1
 800fdfa:	f7ff f879 	bl	800eef0 <chMtxLock>
	// Transmit data by SPI
	uint8_t rxData[len];
	
	// SPI transfer
	spiAcquireBus(&SPID2);
	spiStart(&SPID2, getSPIDriver(radio));
 800fdfe:	2e01      	cmp	r6, #1
	initialized[radio] = true;
}

void Si4464_write(radio_t radio, uint8_t* txData, uint32_t len) {
	// Transmit data by SPI
	uint8_t rxData[len];
 800fe00:	466d      	mov	r5, sp
	
	// SPI transfer
	spiAcquireBus(&SPID2);
	spiStart(&SPID2, getSPIDriver(radio));
 800fe02:	d03f      	beq.n	800fe84 <Si4464_write+0xa4>
 800fe04:	4921      	ldr	r1, [pc, #132]	; (800fe8c <Si4464_write+0xac>)
 800fe06:	4822      	ldr	r0, [pc, #136]	; (800fe90 <Si4464_write+0xb0>)
 800fe08:	f7fd f90a 	bl	800d020 <spiStart>
	spiSelect(&SPID2);
 800fe0c:	4820      	ldr	r0, [pc, #128]	; (800fe90 <Si4464_write+0xb0>)
 800fe0e:	f7fd f88f 	bl	800cf30 <spiSelect>
	spiExchange(&SPID2, len, txData, rxData);
 800fe12:	466a      	mov	r2, sp
 800fe14:	4641      	mov	r1, r8
 800fe16:	4620      	mov	r0, r4
 800fe18:	f002 fe8a 	bl	8012b30 <spiExchange.constprop.47>
	spiUnselect(&SPID2);
 800fe1c:	481c      	ldr	r0, [pc, #112]	; (800fe90 <Si4464_write+0xb0>)
 800fe1e:	f7fd f857 	bl	800ced0 <spiUnselect>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800fe22:	4819      	ldr	r0, [pc, #100]	; (800fe88 <Si4464_write+0xa8>)
 800fe24:	f7ff f804 	bl	800ee30 <chMtxUnlock>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
 800fe28:	2300      	movs	r3, #0
 800fe2a:	f88d 3001 	strb.w	r3, [sp, #1]
 800fe2e:	4a17      	ldr	r2, [pc, #92]	; (800fe8c <Si4464_write+0xac>)
 800fe30:	4b18      	ldr	r3, [pc, #96]	; (800fe94 <Si4464_write+0xb4>)
	// Temperature readout
	TRACE_INFO("SI %d > Transmitter temperature %d degC", radio, Si4464_getTemperature(radio));
	initialized[radio] = true;
}

void Si4464_write(radio_t radio, uint8_t* txData, uint32_t len) {
 800fe32:	f240 74cf 	movw	r4, #1999	; 0x7cf
 800fe36:	2e01      	cmp	r6, #1
 800fe38:	bf0c      	ite	eq
 800fe3a:	461e      	moveq	r6, r3
 800fe3c:	4616      	movne	r6, r2
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {

		// Request ACK by Si4464
		uint8_t rx_ready[] = {0x44};
 800fe3e:	f04f 0844 	mov.w	r8, #68	; 0x44
 800fe42:	e001      	b.n	800fe48 <Si4464_write+0x68>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {
 800fe44:	3c01      	subs	r4, #1
 800fe46:	d019      	beq.n	800fe7c <Si4464_write+0x9c>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800fe48:	480f      	ldr	r0, [pc, #60]	; (800fe88 <Si4464_write+0xa8>)

		// Request ACK by Si4464
		uint8_t rx_ready[] = {0x44};
 800fe4a:	f887 8004 	strb.w	r8, [r7, #4]
 800fe4e:	f7ff f84f 	bl	800eef0 <chMtxLock>

		// SPI transfer
		spiAcquireBus(&SPID2);
		spiStart(&SPID2, getSPIDriver(radio));
 800fe52:	4631      	mov	r1, r6
 800fe54:	480e      	ldr	r0, [pc, #56]	; (800fe90 <Si4464_write+0xb0>)
 800fe56:	f7fd f8e3 	bl	800d020 <spiStart>
		spiSelect(&SPID2);
 800fe5a:	480d      	ldr	r0, [pc, #52]	; (800fe90 <Si4464_write+0xb0>)
 800fe5c:	f7fd f868 	bl	800cf30 <spiSelect>
		spiExchange(&SPID2, 3, rx_ready, rxData);
 800fe60:	462a      	mov	r2, r5
 800fe62:	1d39      	adds	r1, r7, #4
 800fe64:	2003      	movs	r0, #3
 800fe66:	f002 fe63 	bl	8012b30 <spiExchange.constprop.47>
		spiUnselect(&SPID2);
 800fe6a:	4809      	ldr	r0, [pc, #36]	; (800fe90 <Si4464_write+0xb0>)
 800fe6c:	f7fd f830 	bl	800ced0 <spiUnselect>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800fe70:	4805      	ldr	r0, [pc, #20]	; (800fe88 <Si4464_write+0xa8>)
 800fe72:	f7fe ffdd 	bl	800ee30 <chMtxUnlock>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {
 800fe76:	786b      	ldrb	r3, [r5, #1]
 800fe78:	2bff      	cmp	r3, #255	; 0xff
 800fe7a:	d1e3      	bne.n	800fe44 <Si4464_write+0x64>
		spiSelect(&SPID2);
		spiExchange(&SPID2, 3, rx_ready, rxData);
		spiUnselect(&SPID2);
		spiReleaseBus(&SPID2);
	}
}
 800fe7c:	3708      	adds	r7, #8
 800fe7e:	46bd      	mov	sp, r7
 800fe80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	// Transmit data by SPI
	uint8_t rxData[len];
	
	// SPI transfer
	spiAcquireBus(&SPID2);
	spiStart(&SPID2, getSPIDriver(radio));
 800fe84:	4903      	ldr	r1, [pc, #12]	; (800fe94 <Si4464_write+0xb4>)
 800fe86:	e7be      	b.n	800fe06 <Si4464_write+0x26>
 800fe88:	200287a8 	.word	0x200287a8
 800fe8c:	08016030 	.word	0x08016030
 800fe90:	2002879c 	.word	0x2002879c
 800fe94:	08015d98 	.word	0x08015d98
	...

0800fea0 <ssdv_outbits.lto_priv.158>:
}

/*****************************************************************************/

static char ssdv_outbits(ssdv_t *s, uint16_t bits, uint8_t length)
{
 800fea0:	b470      	push	{r4, r5, r6}
	uint8_t b;
	
	if(length)
 800fea2:	2a00      	cmp	r2, #0
 800fea4:	d134      	bne.n	800ff10 <ssdv_outbits.lto_priv.158+0x70>
 800fea6:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
 800feaa:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
		s->out_len--;
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
		{
			s->outbits &= (1 << s->outlen) - 1;
 800feac:	2501      	movs	r5, #1
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
 800feae:	2b07      	cmp	r3, #7
	{
		b = s->outbits >> (s->outlen - 8);
 800feb0:	f1a3 0208 	sub.w	r2, r3, #8
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
 800feb4:	d926      	bls.n	800ff04 <ssdv_outbits.lto_priv.158+0x64>
 800feb6:	2900      	cmp	r1, #0
 800feb8:	d039      	beq.n	800ff2e <ssdv_outbits.lto_priv.158+0x8e>
	{
		b = s->outbits >> (s->outlen - 8);
 800feba:	6c43      	ldr	r3, [r0, #68]	; 0x44
		
		/* Put the byte into the output buffer */
		*(s->outp++) = b;
 800febc:	6b81      	ldr	r1, [r0, #56]	; 0x38
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
	{
		b = s->outbits >> (s->outlen - 8);
 800febe:	fa23 f202 	lsr.w	r2, r3, r2
 800fec2:	b2d2      	uxtb	r2, r2
		
		/* Put the byte into the output buffer */
		*(s->outp++) = b;
 800fec4:	1c4b      	adds	r3, r1, #1
 800fec6:	6383      	str	r3, [r0, #56]	; 0x38
 800fec8:	700a      	strb	r2, [r1, #0]
		s->outlen -= 8;
 800feca:	f890 4048 	ldrb.w	r4, [r0, #72]	; 0x48
		s->out_len--;
 800fece:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
 800fed0:	f890 6040 	ldrb.w	r6, [r0, #64]	; 0x40
	{
		b = s->outbits >> (s->outlen - 8);
		
		/* Put the byte into the output buffer */
		*(s->outp++) = b;
		s->outlen -= 8;
 800fed4:	f1a4 0308 	sub.w	r3, r4, #8
 800fed8:	b2db      	uxtb	r3, r3
		s->out_len--;
 800feda:	3901      	subs	r1, #1
	{
		b = s->outbits >> (s->outlen - 8);
		
		/* Put the byte into the output buffer */
		*(s->outp++) = b;
		s->outlen -= 8;
 800fedc:	f880 3048 	strb.w	r3, [r0, #72]	; 0x48
		s->out_len--;
 800fee0:	63c1      	str	r1, [r0, #60]	; 0x3c
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
 800fee2:	2e00      	cmp	r6, #0
 800fee4:	d0e3      	beq.n	800feae <ssdv_outbits.lto_priv.158+0xe>
 800fee6:	2aff      	cmp	r2, #255	; 0xff
 800fee8:	d1e1      	bne.n	800feae <ssdv_outbits.lto_priv.158+0xe>
		{
			s->outbits &= (1 << s->outlen) - 1;
 800feea:	6c42      	ldr	r2, [r0, #68]	; 0x44
			s->outlen += 8;
 800feec:	f880 4048 	strb.w	r4, [r0, #72]	; 0x48
		s->out_len--;
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
		{
			s->outbits &= (1 << s->outlen) - 1;
 800fef0:	fa05 f303 	lsl.w	r3, r5, r3
 800fef4:	3b01      	subs	r3, #1
 800fef6:	401a      	ands	r2, r3
			s->outlen += 8;
 800fef8:	4623      	mov	r3, r4
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
 800fefa:	2b07      	cmp	r3, #7
		s->out_len--;
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
		{
			s->outbits &= (1 << s->outlen) - 1;
 800fefc:	6442      	str	r2, [r0, #68]	; 0x44
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
	{
		b = s->outbits >> (s->outlen - 8);
 800fefe:	f1a3 0208 	sub.w	r2, r3, #8
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
 800ff02:	d8d8      	bhi.n	800feb6 <ssdv_outbits.lto_priv.158+0x16>
			s->outbits &= (1 << s->outlen) - 1;
			s->outlen += 8;
		}
	}
	
	return(s->out_len ? SSDV_OK : SSDV_BUFFER_FULL);
 800ff04:	2900      	cmp	r1, #0
 800ff06:	bf0c      	ite	eq
 800ff08:	2003      	moveq	r0, #3
 800ff0a:	2000      	movne	r0, #0
}
 800ff0c:	bc70      	pop	{r4, r5, r6}
 800ff0e:	4770      	bx	lr
	uint8_t b;
	
	if(length)
	{
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
 800ff10:	2501      	movs	r5, #1
 800ff12:	6c44      	ldr	r4, [r0, #68]	; 0x44
		s->outlen += length;
 800ff14:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
	uint8_t b;
	
	if(length)
	{
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
 800ff18:	4095      	lsls	r5, r2
 800ff1a:	3d01      	subs	r5, #1
 800ff1c:	4029      	ands	r1, r5
 800ff1e:	4094      	lsls	r4, r2
		s->outlen += length;
 800ff20:	4413      	add	r3, r2
	uint8_t b;
	
	if(length)
	{
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
 800ff22:	430c      	orrs	r4, r1
		s->outlen += length;
 800ff24:	b2db      	uxtb	r3, r3
	uint8_t b;
	
	if(length)
	{
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
 800ff26:	6444      	str	r4, [r0, #68]	; 0x44
		s->outlen += length;
 800ff28:	f880 3048 	strb.w	r3, [r0, #72]	; 0x48
 800ff2c:	e7bd      	b.n	800feaa <ssdv_outbits.lto_priv.158+0xa>
			s->outbits &= (1 << s->outlen) - 1;
			s->outlen += 8;
		}
	}
	
	return(s->out_len ? SSDV_OK : SSDV_BUFFER_FULL);
 800ff2e:	2003      	movs	r0, #3
}
 800ff30:	bc70      	pop	{r4, r5, r6}
 800ff32:	4770      	bx	lr
	...

0800ff40 <ssdv_outbits_sync.lto_priv.159>:

static char ssdv_outbits_sync(ssdv_t *s)
{
	uint8_t b = s->outlen % 8;
 800ff40:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
	if(b) return(ssdv_outbits(s, 0xFF, 8 - b));
 800ff44:	f012 0207 	ands.w	r2, r2, #7
 800ff48:	d101      	bne.n	800ff4e <ssdv_outbits_sync.lto_priv.159+0xe>
	return(SSDV_OK);
}
 800ff4a:	4610      	mov	r0, r2
 800ff4c:	4770      	bx	lr
}

static char ssdv_outbits_sync(ssdv_t *s)
{
	uint8_t b = s->outlen % 8;
	if(b) return(ssdv_outbits(s, 0xFF, 8 - b));
 800ff4e:	f1c2 0208 	rsb	r2, r2, #8
 800ff52:	b2d2      	uxtb	r2, r2
 800ff54:	21ff      	movs	r1, #255	; 0xff
 800ff56:	f7ff bfa3 	b.w	800fea0 <ssdv_outbits.lto_priv.158>
 800ff5a:	bf00      	nop
 800ff5c:	0000      	movs	r0, r0
	...

0800ff60 <log_error>:

static error_t error_log[ERRORLOG_SIZE];	// Error log ring memory
static uint8_t error_id;					// Incremental ID for ring memory

void log_error(char *file, uint16_t line)
{
 800ff60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if(error_id == ERRORLOG_SIZE)
 800ff64:	f8df 9074 	ldr.w	r9, [pc, #116]	; 800ffdc <log_error+0x7c>
 800ff68:	f899 8000 	ldrb.w	r8, [r9]
 800ff6c:	f1b8 0f19 	cmp.w	r8, #25
 800ff70:	d029      	beq.n	800ffc6 <log_error+0x66>
 800ff72:	4606      	mov	r6, r0
 800ff74:	460f      	mov	r7, r1
 800ff76:	4d15      	ldr	r5, [pc, #84]	; (800ffcc <log_error+0x6c>)
		return; // No memory left

	// Find file ID
	error_log[error_id].error = 1; // Assign default error file (if file not found)
 800ff78:	4815      	ldr	r0, [pc, #84]	; (800ffd0 <log_error+0x70>)
	for(uint8_t i=1; i<sizeof(fileIDs); i++)
 800ff7a:	2401      	movs	r4, #1
 800ff7c:	e003      	b.n	800ff86 <log_error+0x26>
 800ff7e:	3401      	adds	r4, #1
 800ff80:	f855 0f04 	ldr.w	r0, [r5, #4]!
 800ff84:	b2e4      	uxtb	r4, r4
		if(!strcmp(fileIDs[i], file)) {
 800ff86:	4631      	mov	r1, r6
 800ff88:	f7f1 fc26 	bl	80017d8 <strcmp>
 800ff8c:	2800      	cmp	r0, #0
 800ff8e:	d1f6      	bne.n	800ff7e <log_error+0x1e>
 800ff90:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
 800ff94:	490f      	ldr	r1, [pc, #60]	; (800ffd4 <log_error+0x74>)
 800ff96:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ff98:	480f      	ldr	r0, [pc, #60]	; (800ffd8 <log_error+0x78>)
 800ff9a:	f502 439c 	add.w	r3, r2, #19968	; 0x4e00
 800ff9e:	331f      	adds	r3, #31
 800ffa0:	fba0 2303 	umull	r2, r3, r0, r3
	error_log[error_id].error |= (line & 0x3FF);
 800ffa4:	3401      	adds	r4, #1
 800ffa6:	f3c7 0709 	ubfx	r7, r7, #0, #10
 800ffaa:	eb01 00c8 	add.w	r0, r1, r8, lsl #3

	error_id++; // Increment counter
 800ffae:	f108 0201 	add.w	r2, r8, #1
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
	error_log[error_id].error |= (line & 0x3FF);
 800ffb2:	ea47 2484 	orr.w	r4, r7, r4, lsl #10
		if(!strcmp(fileIDs[i], file)) {
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
 800ffb6:	0b9b      	lsrs	r3, r3, #14
	error_log[error_id].error |= (line & 0x3FF);

	error_id++; // Increment counter
 800ffb8:	f889 2000 	strb.w	r2, [r9]
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
	error_log[error_id].error |= (line & 0x3FF);
 800ffbc:	8084      	strh	r4, [r0, #4]
		if(!strcmp(fileIDs[i], file)) {
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
 800ffbe:	f841 3038 	str.w	r3, [r1, r8, lsl #3]
 800ffc2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800ffc6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800ffca:	bf00      	nop
 800ffcc:	0801605c 	.word	0x0801605c
 800ffd0:	08013c6c 	.word	0x08013c6c
 800ffd4:	20027c24 	.word	0x20027c24
 800ffd8:	d1b71759 	.word	0xd1b71759
 800ffdc:	20027b56 	.word	0x20027b56

0800ffe0 <ssdv_out_jpeg_int.lto_priv.160>:
	return(SSDV_OK);
}

static char ssdv_out_jpeg_int(ssdv_t *s, uint8_t rle, int value)
{
 800ffe0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ffe4:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 800ffe8:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
 800ffec:	b083      	sub	sp, #12
 800ffee:	4616      	mov	r6, r2
 800fff0:	4605      	mov	r5, r0
 800fff2:	460f      	mov	r7, r1
{
	*bits = value;
	
	/* Calculate the number of bits */
	if(value < 0) value = -value;
	for(*width = 0; value; value >>= 1) (*width)++;
 800fff4:	2b00      	cmp	r3, #0
 800fff6:	f000 809b 	beq.w	8010130 <ssdv_out_jpeg_int.lto_priv.160+0x150>
 800fffa:	2400      	movs	r4, #0
 800fffc:	3401      	adds	r4, #1
 800fffe:	105b      	asrs	r3, r3, #1
 8010000:	b2e4      	uxtb	r4, r4
 8010002:	d1fb      	bne.n	800fffc <ssdv_out_jpeg_int.lto_priv.160+0x1c>
 8010004:	f004 030f 	and.w	r3, r4, #15
	
	/* Fix negative values */
	if(*bits < 0) *bits = -*bits ^ ((1 << *width) - 1);
 8010008:	2e00      	cmp	r6, #0
 801000a:	f2c0 8089 	blt.w	8010120 <ssdv_out_jpeg_int.lto_priv.160+0x140>
 801000e:	46b0      	mov	r8, r6
{
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	dht = DDHT;
 8010010:	f895 2059 	ldrb.w	r2, [r5, #89]	; 0x59
 8010014:	f895 1056 	ldrb.w	r1, [r5, #86]	; 0x56
 8010018:	3200      	adds	r2, #0
 801001a:	bf18      	it	ne
 801001c:	2201      	movne	r2, #1
 801001e:	0052      	lsls	r2, r2, #1
 8010020:	2900      	cmp	r1, #0
 8010022:	bf18      	it	ne
 8010024:	3201      	addne	r2, #1
 8010026:	f502 729e 	add.w	r2, r2, #316	; 0x13c
	int intbits;
	uint8_t hufflen = 0, intlen;
	int r;
	
	jpeg_encode_int(value, &intbits, &intlen);
	r = jpeg_dht_lookup_symbol(s, (rle << 4) | (intlen & 0x0F), &huffbits, &hufflen);
 801002a:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
{
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	dht = DDHT;
 801002e:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
	int intbits;
	uint8_t hufflen = 0, intlen;
	int r;
	
	jpeg_encode_int(value, &intbits, &intlen);
	r = jpeg_dht_lookup_symbol(s, (rle << 4) | (intlen & 0x0F), &huffbits, &hufflen);
 8010032:	fa5f fe83 	uxtb.w	lr, r3
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
 8010036:	f102 0011 	add.w	r0, r2, #17
 801003a:	4691      	mov	r9, r2
	return(SSDV_ERROR);
}

static inline char jpeg_dht_lookup_symbol(ssdv_t *s, uint8_t symbol, uint16_t *bits, uint8_t *width)
{
	uint16_t code = 0;
 801003c:	2100      	movs	r1, #0
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 801003e:	2201      	movs	r2, #1
	{
		for(n = dht[cw]; n > 0; n--)
 8010040:	f819 3f01 	ldrb.w	r3, [r9, #1]!
 8010044:	b1b3      	cbz	r3, 8010074 <ssdv_out_jpeg_int.lto_priv.160+0x94>
		{
			if(*ss == symbol)
 8010046:	f890 c000 	ldrb.w	ip, [r0]
 801004a:	45f4      	cmp	ip, lr
 801004c:	d05a      	beq.n	8010104 <ssdv_out_jpeg_int.lto_priv.160+0x124>
 801004e:	f103 3cff 	add.w	ip, r3, #4294967295
 8010052:	fa5f fc8c 	uxtb.w	ip, ip
 8010056:	f10c 0c01 	add.w	ip, ip, #1
 801005a:	4484      	add	ip, r0
 801005c:	1c43      	adds	r3, r0, #1
 801005e:	e002      	b.n	8010066 <ssdv_out_jpeg_int.lto_priv.160+0x86>
 8010060:	7800      	ldrb	r0, [r0, #0]
 8010062:	4570      	cmp	r0, lr
 8010064:	d04e      	beq.n	8010104 <ssdv_out_jpeg_int.lto_priv.160+0x124>
				/* Found a match */
				*bits = code;
				*width = cw;
				return(SSDV_OK);
			}
			ss++; code++;
 8010066:	3101      	adds	r1, #1
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
	{
		for(n = dht[cw]; n > 0; n--)
 8010068:	459c      	cmp	ip, r3
				/* Found a match */
				*bits = code;
				*width = cw;
				return(SSDV_OK);
			}
			ss++; code++;
 801006a:	4618      	mov	r0, r3
 801006c:	b289      	uxth	r1, r1
 801006e:	f103 0301 	add.w	r3, r3, #1
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
	{
		for(n = dht[cw]; n > 0; n--)
 8010072:	d1f5      	bne.n	8010060 <ssdv_out_jpeg_int.lto_priv.160+0x80>
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 8010074:	3201      	adds	r2, #1
 8010076:	b2d2      	uxtb	r2, r2
				return(SSDV_OK);
			}
			ss++; code++;
		}
		
		code <<= 1;
 8010078:	0049      	lsls	r1, r1, #1
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 801007a:	2a11      	cmp	r2, #17
				return(SSDV_OK);
			}
			ss++; code++;
		}
		
		code <<= 1;
 801007c:	b289      	uxth	r1, r1
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 801007e:	d1df      	bne.n	8010040 <ssdv_out_jpeg_int.lto_priv.160+0x60>
	int r;
	
	jpeg_encode_int(value, &intbits, &intlen);
	r = jpeg_dht_lookup_symbol(s, (rle << 4) | (intlen & 0x0F), &huffbits, &hufflen);
	
	if(r != SSDV_OK) TRACE_ERROR("SSDV > jpeg_dht_lookup_symbol: %i (%i:%i)", r, value, rle);
 8010080:	482c      	ldr	r0, [pc, #176]	; (8010134 <ssdv_out_jpeg_int.lto_priv.160+0x154>)
 8010082:	f7fe ff35 	bl	800eef0 <chMtxLock>
 8010086:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 801008a:	f8df e0d4 	ldr.w	lr, [pc, #212]	; 8010160 <ssdv_out_jpeg_int.lto_priv.160+0x180>
 801008e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8010090:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8010092:	4b29      	ldr	r3, [pc, #164]	; (8010138 <ssdv_out_jpeg_int.lto_priv.160+0x158>)
 8010094:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010098:	fb00 f101 	mul.w	r1, r0, r1
 801009c:	fbae c101 	umull	ip, r1, lr, r1
 80100a0:	0b89      	lsrs	r1, r1, #14
 80100a2:	fba3 c301 	umull	ip, r3, r3, r1
 80100a6:	fbae e202 	umull	lr, r2, lr, r2
 80100aa:	099b      	lsrs	r3, r3, #6
 80100ac:	fb00 1313 	mls	r3, r0, r3, r1
 80100b0:	0b92      	lsrs	r2, r2, #14
 80100b2:	4922      	ldr	r1, [pc, #136]	; (801013c <ssdv_out_jpeg_int.lto_priv.160+0x15c>)
 80100b4:	4822      	ldr	r0, [pc, #136]	; (8010140 <ssdv_out_jpeg_int.lto_priv.160+0x160>)
 80100b6:	f002 fb13 	bl	80126e0 <chprintf.constprop.35>
 80100ba:	4a22      	ldr	r2, [pc, #136]	; (8010144 <ssdv_out_jpeg_int.lto_priv.160+0x164>)
 80100bc:	4922      	ldr	r1, [pc, #136]	; (8010148 <ssdv_out_jpeg_int.lto_priv.160+0x168>)
 80100be:	4820      	ldr	r0, [pc, #128]	; (8010140 <ssdv_out_jpeg_int.lto_priv.160+0x160>)
 80100c0:	f002 fb0e 	bl	80126e0 <chprintf.constprop.35>
 80100c4:	f44f 73b1 	mov.w	r3, #354	; 0x162
 80100c8:	4a20      	ldr	r2, [pc, #128]	; (801014c <ssdv_out_jpeg_int.lto_priv.160+0x16c>)
 80100ca:	4921      	ldr	r1, [pc, #132]	; (8010150 <ssdv_out_jpeg_int.lto_priv.160+0x170>)
 80100cc:	481c      	ldr	r0, [pc, #112]	; (8010140 <ssdv_out_jpeg_int.lto_priv.160+0x160>)
 80100ce:	f002 fb07 	bl	80126e0 <chprintf.constprop.35>
 80100d2:	4920      	ldr	r1, [pc, #128]	; (8010154 <ssdv_out_jpeg_int.lto_priv.160+0x174>)
 80100d4:	481a      	ldr	r0, [pc, #104]	; (8010140 <ssdv_out_jpeg_int.lto_priv.160+0x160>)
 80100d6:	f002 fb03 	bl	80126e0 <chprintf.constprop.35>
 80100da:	22ff      	movs	r2, #255	; 0xff
 80100dc:	4633      	mov	r3, r6
 80100de:	491e      	ldr	r1, [pc, #120]	; (8010158 <ssdv_out_jpeg_int.lto_priv.160+0x178>)
 80100e0:	9700      	str	r7, [sp, #0]
 80100e2:	4817      	ldr	r0, [pc, #92]	; (8010140 <ssdv_out_jpeg_int.lto_priv.160+0x160>)
 80100e4:	f002 fafc 	bl	80126e0 <chprintf.constprop.35>
 80100e8:	491c      	ldr	r1, [pc, #112]	; (801015c <ssdv_out_jpeg_int.lto_priv.160+0x17c>)
 80100ea:	4815      	ldr	r0, [pc, #84]	; (8010140 <ssdv_out_jpeg_int.lto_priv.160+0x160>)
 80100ec:	f002 faf8 	bl	80126e0 <chprintf.constprop.35>
 80100f0:	4810      	ldr	r0, [pc, #64]	; (8010134 <ssdv_out_jpeg_int.lto_priv.160+0x154>)
 80100f2:	f7fe fe9d 	bl	800ee30 <chMtxUnlock>
 80100f6:	f44f 71b1 	mov.w	r1, #354	; 0x162
 80100fa:	4814      	ldr	r0, [pc, #80]	; (801014c <ssdv_out_jpeg_int.lto_priv.160+0x16c>)
 80100fc:	f7ff ff30 	bl	800ff60 <log_error>
	return(SSDV_OK);
}

static char ssdv_out_jpeg_int(ssdv_t *s, uint8_t rle, int value)
{
	uint16_t huffbits = 0;
 8010100:	2100      	movs	r1, #0
	int intbits;
	uint8_t hufflen = 0, intlen;
 8010102:	460a      	mov	r2, r1
	jpeg_encode_int(value, &intbits, &intlen);
	r = jpeg_dht_lookup_symbol(s, (rle << 4) | (intlen & 0x0F), &huffbits, &hufflen);
	
	if(r != SSDV_OK) TRACE_ERROR("SSDV > jpeg_dht_lookup_symbol: %i (%i:%i)", r, value, rle);
	
	ssdv_outbits(s, huffbits, hufflen);
 8010104:	4628      	mov	r0, r5
 8010106:	f7ff fecb 	bl	800fea0 <ssdv_outbits.lto_priv.158>
	if(intlen) ssdv_outbits(s, intbits, intlen);
 801010a:	b12c      	cbz	r4, 8010118 <ssdv_out_jpeg_int.lto_priv.160+0x138>
 801010c:	4622      	mov	r2, r4
 801010e:	fa1f f188 	uxth.w	r1, r8
 8010112:	4628      	mov	r0, r5
 8010114:	f7ff fec4 	bl	800fea0 <ssdv_outbits.lto_priv.158>
	
	return(SSDV_OK);
}
 8010118:	2000      	movs	r0, #0
 801011a:	b003      	add	sp, #12
 801011c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	/* Calculate the number of bits */
	if(value < 0) value = -value;
	for(*width = 0; value; value >>= 1) (*width)++;
	
	/* Fix negative values */
	if(*bits < 0) *bits = -*bits ^ ((1 << *width) - 1);
 8010120:	2201      	movs	r2, #1
 8010122:	40a2      	lsls	r2, r4
 8010124:	3a01      	subs	r2, #1
 8010126:	f1c6 0800 	rsb	r8, r6, #0
 801012a:	ea82 0808 	eor.w	r8, r2, r8
 801012e:	e76f      	b.n	8010010 <ssdv_out_jpeg_int.lto_priv.160+0x30>
{
	*bits = value;
	
	/* Calculate the number of bits */
	if(value < 0) value = -value;
	for(*width = 0; value; value >>= 1) (*width)++;
 8010130:	461c      	mov	r4, r3
 8010132:	e769      	b.n	8010008 <ssdv_out_jpeg_int.lto_priv.160+0x28>
 8010134:	20027b2c 	.word	0x20027b2c
 8010138:	10624dd3 	.word	0x10624dd3
 801013c:	08013c50 	.word	0x08013c50
 8010140:	20027e60 	.word	0x20027e60
 8010144:	08013d9c 	.word	0x08013d9c
 8010148:	08013c5c 	.word	0x08013c5c
 801014c:	0801491f 	.word	0x0801491f
 8010150:	08013c78 	.word	0x08013c78
 8010154:	08013d00 	.word	0x08013d00
 8010158:	080160a4 	.word	0x080160a4
 801015c:	08013cac 	.word	0x08013cac
 8010160:	d1b71759 	.word	0xd1b71759
	...

08010170 <moduleERROR>:

static uint32_t pkt[ERRORLOG_SIZE+1];
static uint8_t pkt_base91[BASE91LEN(4*ERRORLOG_SIZE+4)];

THD_FUNCTION(moduleERROR, arg)
{
 8010170:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 8010174:	6b42      	ldr	r2, [r0, #52]	; 0x34

static uint32_t pkt[ERRORLOG_SIZE+1];
static uint8_t pkt_base91[BASE91LEN(4*ERRORLOG_SIZE+4)];

THD_FUNCTION(moduleERROR, arg)
{
 8010176:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
 801017a:	4606      	mov	r6, r0
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 801017c:	b15a      	cbz	r2, 8010196 <moduleERROR+0x26>
		chThdSleepMilliseconds(config->init_delay);
 801017e:	f644 6320 	movw	r3, #20000	; 0x4e20
 8010182:	fb03 f302 	mul.w	r3, r3, r2
 8010186:	48a2      	ldr	r0, [pc, #648]	; (8010410 <moduleERROR+0x2a0>)
 8010188:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 801018c:	fba0 3003 	umull	r3, r0, r0, r3
 8010190:	0980      	lsrs	r0, r0, #6
 8010192:	f7fe ff7d 	bl	800f090 <chThdSleep>
 8010196:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000

	// Print initialization message
	TRACE_INFO("ERR  > Startup module %s", config->name);
 801019a:	489e      	ldr	r0, [pc, #632]	; (8010414 <moduleERROR+0x2a4>)
 801019c:	4d9e      	ldr	r5, [pc, #632]	; (8010418 <moduleERROR+0x2a8>)
 801019e:	f8df 9270 	ldr.w	r9, [pc, #624]	; 8010410 <moduleERROR+0x2a0>
 80101a2:	f8df 82bc 	ldr.w	r8, [pc, #700]	; 8010460 <moduleERROR+0x2f0>
			{
				if(i > 0) // Calculate time difference
				{
					uint32_t tdiff = error_log[i].time-error_log[i-1].time; // Time difference to last error
					if(tdiff >= 0xFFFF) // Time overflow
						pkt[i+1] = 0xFFFF << 16;
 80101a6:	4c9d      	ldr	r4, [pc, #628]	; (801041c <moduleERROR+0x2ac>)
	// Execute Initial delay
	if(config->init_delay)
		chThdSleepMilliseconds(config->init_delay);

	// Print initialization message
	TRACE_INFO("ERR  > Startup module %s", config->name);
 80101a8:	f7fe fea2 	bl	800eef0 <chMtxLock>
 80101ac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80101ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80101b0:	499b      	ldr	r1, [pc, #620]	; (8010420 <moduleERROR+0x2b0>)
 80101b2:	489c      	ldr	r0, [pc, #624]	; (8010424 <moduleERROR+0x2b4>)
 80101b4:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
 80101b8:	fb0c fe03 	mul.w	lr, ip, r3
 80101bc:	fba5 3e0e 	umull	r3, lr, r5, lr
 80101c0:	ea4f 3e9e 	mov.w	lr, lr, lsr #14
 80101c4:	fba9 a30e 	umull	sl, r3, r9, lr
 80101c8:	fba5 a202 	umull	sl, r2, r5, r2
 80101cc:	099b      	lsrs	r3, r3, #6
 80101ce:	fb0c e313 	mls	r3, ip, r3, lr
 80101d2:	0b92      	lsrs	r2, r2, #14
 80101d4:	f002 fa84 	bl	80126e0 <chprintf.constprop.35>
 80101d8:	4a93      	ldr	r2, [pc, #588]	; (8010428 <moduleERROR+0x2b8>)
 80101da:	4994      	ldr	r1, [pc, #592]	; (801042c <moduleERROR+0x2bc>)
 80101dc:	4891      	ldr	r0, [pc, #580]	; (8010424 <moduleERROR+0x2b4>)
 80101de:	f002 fa7f 	bl	80126e0 <chprintf.constprop.35>
 80101e2:	235e      	movs	r3, #94	; 0x5e
 80101e4:	4a92      	ldr	r2, [pc, #584]	; (8010430 <moduleERROR+0x2c0>)
 80101e6:	4993      	ldr	r1, [pc, #588]	; (8010434 <moduleERROR+0x2c4>)
 80101e8:	488e      	ldr	r0, [pc, #568]	; (8010424 <moduleERROR+0x2b4>)
 80101ea:	f002 fa79 	bl	80126e0 <chprintf.constprop.35>
 80101ee:	4992      	ldr	r1, [pc, #584]	; (8010438 <moduleERROR+0x2c8>)
 80101f0:	488c      	ldr	r0, [pc, #560]	; (8010424 <moduleERROR+0x2b4>)
 80101f2:	f002 fa75 	bl	80126e0 <chprintf.constprop.35>
 80101f6:	4632      	mov	r2, r6
 80101f8:	4990      	ldr	r1, [pc, #576]	; (801043c <moduleERROR+0x2cc>)
 80101fa:	488a      	ldr	r0, [pc, #552]	; (8010424 <moduleERROR+0x2b4>)
 80101fc:	f002 fa70 	bl	80126e0 <chprintf.constprop.35>
 8010200:	498f      	ldr	r1, [pc, #572]	; (8010440 <moduleERROR+0x2d0>)
 8010202:	4888      	ldr	r0, [pc, #544]	; (8010424 <moduleERROR+0x2b4>)
 8010204:	f002 fa6c 	bl	80126e0 <chprintf.constprop.35>
 8010208:	4882      	ldr	r0, [pc, #520]	; (8010414 <moduleERROR+0x2a4>)
 801020a:	f7fe fe11 	bl	800ee30 <chMtxUnlock>
 801020e:	f106 033c 	add.w	r3, r6, #60	; 0x3c
 8010212:	6a7f      	ldr	r7, [r7, #36]	; 0x24
 8010214:	9303      	str	r3, [sp, #12]
 8010216:	f106 0324 	add.w	r3, r6, #36	; 0x24
 801021a:	9305      	str	r3, [sp, #20]
 801021c:	f106 0350 	add.w	r3, r6, #80	; 0x50
 8010220:	9306      	str	r3, [sp, #24]
 8010222:	f106 0358 	add.w	r3, r6, #88	; 0x58
 8010226:	9307      	str	r3, [sp, #28]
 8010228:	f106 0344 	add.w	r3, r6, #68	; 0x44
 801022c:	9304      	str	r3, [sp, #16]
 801022e:	f04f 4a80 	mov.w	sl, #1073741824	; 0x40000000

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("ERR  > Do module LOG cycle");
 8010232:	4878      	ldr	r0, [pc, #480]	; (8010414 <moduleERROR+0x2a4>)
 8010234:	f7fe fe5c 	bl	800eef0 <chMtxLock>
 8010238:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
 801023c:	f8da 0024 	ldr.w	r0, [sl, #36]	; 0x24
 8010240:	4977      	ldr	r1, [pc, #476]	; (8010420 <moduleERROR+0x2b0>)
 8010242:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
 8010246:	fb0e f000 	mul.w	r0, lr, r0
 801024a:	fba5 3000 	umull	r3, r0, r5, r0
 801024e:	0b80      	lsrs	r0, r0, #14
 8010250:	fba9 c300 	umull	ip, r3, r9, r0
 8010254:	fba5 c202 	umull	ip, r2, r5, r2
 8010258:	099b      	lsrs	r3, r3, #6
 801025a:	fb0e 0313 	mls	r3, lr, r3, r0
 801025e:	0b92      	lsrs	r2, r2, #14
 8010260:	4870      	ldr	r0, [pc, #448]	; (8010424 <moduleERROR+0x2b4>)
 8010262:	f002 fa3d 	bl	80126e0 <chprintf.constprop.35>
 8010266:	4a70      	ldr	r2, [pc, #448]	; (8010428 <moduleERROR+0x2b8>)
 8010268:	4970      	ldr	r1, [pc, #448]	; (801042c <moduleERROR+0x2bc>)
 801026a:	486e      	ldr	r0, [pc, #440]	; (8010424 <moduleERROR+0x2b4>)
 801026c:	f002 fa38 	bl	80126e0 <chprintf.constprop.35>
 8010270:	2363      	movs	r3, #99	; 0x63
 8010272:	4a6f      	ldr	r2, [pc, #444]	; (8010430 <moduleERROR+0x2c0>)
 8010274:	496f      	ldr	r1, [pc, #444]	; (8010434 <moduleERROR+0x2c4>)
 8010276:	486b      	ldr	r0, [pc, #428]	; (8010424 <moduleERROR+0x2b4>)
 8010278:	f002 fa32 	bl	80126e0 <chprintf.constprop.35>
 801027c:	496e      	ldr	r1, [pc, #440]	; (8010438 <moduleERROR+0x2c8>)
 801027e:	4869      	ldr	r0, [pc, #420]	; (8010424 <moduleERROR+0x2b4>)
 8010280:	f002 fa2e 	bl	80126e0 <chprintf.constprop.35>
 8010284:	496f      	ldr	r1, [pc, #444]	; (8010444 <moduleERROR+0x2d4>)
 8010286:	4867      	ldr	r0, [pc, #412]	; (8010424 <moduleERROR+0x2b4>)
 8010288:	f002 fa2a 	bl	80126e0 <chprintf.constprop.35>
 801028c:	496c      	ldr	r1, [pc, #432]	; (8010440 <moduleERROR+0x2d0>)
 801028e:	4865      	ldr	r0, [pc, #404]	; (8010424 <moduleERROR+0x2b4>)
 8010290:	f002 fa26 	bl	80126e0 <chprintf.constprop.35>
 8010294:	485f      	ldr	r0, [pc, #380]	; (8010414 <moduleERROR+0x2a4>)
 8010296:	f7fe fdcb 	bl	800ee30 <chMtxUnlock>
 801029a:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer
 801029e:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0

		if(!p_sleep(&config->sleep_config))
 80102a2:	9803      	ldr	r0, [sp, #12]
 80102a4:	f002 f864 	bl	8012370 <p_sleep>
 80102a8:	2800      	cmp	r0, #0
 80102aa:	d169      	bne.n	8010380 <moduleERROR+0x210>
 80102ac:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
		{
			// Encode message
			pkt[0] = ST2S(chVTGetSystemTimeX());
 80102b0:	4a65      	ldr	r2, [pc, #404]	; (8010448 <moduleERROR+0x2d8>)
			for(uint8_t i=0; i<error_id; i++)
 80102b2:	f898 a000 	ldrb.w	sl, [r8]
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		if(!p_sleep(&config->sleep_config))
		{
			// Encode message
			pkt[0] = ST2S(chVTGetSystemTimeX());
 80102b6:	f503 439c 	add.w	r3, r3, #19968	; 0x4e00
 80102ba:	331f      	adds	r3, #31
 80102bc:	fba5 1303 	umull	r1, r3, r5, r3
 80102c0:	0b9b      	lsrs	r3, r3, #14
 80102c2:	6013      	str	r3, [r2, #0]
			for(uint8_t i=0; i<error_id; i++)
 80102c4:	f1ba 0f00 	cmp.w	sl, #0
 80102c8:	d061      	beq.n	801038e <moduleERROR+0x21e>
 80102ca:	4694      	mov	ip, r2
 80102cc:	495f      	ldr	r1, [pc, #380]	; (801044c <moduleERROR+0x2dc>)
 80102ce:	f85c 3f04 	ldr.w	r3, [ip, #4]!
			{
				if(i > 0) // Calculate time difference
				{
					uint32_t tdiff = error_log[i].time-error_log[i-1].time; // Time difference to last error
					if(tdiff >= 0xFFFF) // Time overflow
 80102d2:	f64f 7bfe 	movw	fp, #65534	; 0xfffe
 80102d6:	46b6      	mov	lr, r6
 80102d8:	e002      	b.n	80102e0 <moduleERROR+0x170>
 80102da:	f8dc 3000 	ldr.w	r3, [ip]
 80102de:	3108      	adds	r1, #8
						pkt[i+1] = 0xFFFF << 16;
					else
						pkt[i+1] = tdiff << 16;
				}
				pkt[i+1] |= error_log[i].error;
 80102e0:	880a      	ldrh	r2, [r1, #0]

		if(!p_sleep(&config->sleep_config))
		{
			// Encode message
			pkt[0] = ST2S(chVTGetSystemTimeX());
			for(uint8_t i=0; i<error_id; i++)
 80102e2:	3001      	adds	r0, #1
 80102e4:	b2c0      	uxtb	r0, r0
					if(tdiff >= 0xFFFF) // Time overflow
						pkt[i+1] = 0xFFFF << 16;
					else
						pkt[i+1] = tdiff << 16;
				}
				pkt[i+1] |= error_log[i].error;
 80102e6:	4313      	orrs	r3, r2

		if(!p_sleep(&config->sleep_config))
		{
			// Encode message
			pkt[0] = ST2S(chVTGetSystemTimeX());
			for(uint8_t i=0; i<error_id; i++)
 80102e8:	4550      	cmp	r0, sl
					if(tdiff >= 0xFFFF) // Time overflow
						pkt[i+1] = 0xFFFF << 16;
					else
						pkt[i+1] = tdiff << 16;
				}
				pkt[i+1] |= error_log[i].error;
 80102ea:	f84c 3b04 	str.w	r3, [ip], #4

		if(!p_sleep(&config->sleep_config))
		{
			// Encode message
			pkt[0] = ST2S(chVTGetSystemTimeX());
			for(uint8_t i=0; i<error_id; i++)
 80102ee:	d04d      	beq.n	801038c <moduleERROR+0x21c>
			{
				if(i > 0) // Calculate time difference
 80102f0:	2800      	cmp	r0, #0
 80102f2:	d0f2      	beq.n	80102da <moduleERROR+0x16a>
				{
					uint32_t tdiff = error_log[i].time-error_log[i-1].time; // Time difference to last error
 80102f4:	684a      	ldr	r2, [r1, #4]
 80102f6:	f851 6c04 	ldr.w	r6, [r1, #-4]
					if(tdiff >= 0xFFFF) // Time overflow
						pkt[i+1] = 0xFFFF << 16;
 80102fa:	4b48      	ldr	r3, [pc, #288]	; (801041c <moduleERROR+0x2ac>)
			pkt[0] = ST2S(chVTGetSystemTimeX());
			for(uint8_t i=0; i<error_id; i++)
			{
				if(i > 0) // Calculate time difference
				{
					uint32_t tdiff = error_log[i].time-error_log[i-1].time; // Time difference to last error
 80102fc:	1b92      	subs	r2, r2, r6
					if(tdiff >= 0xFFFF) // Time overflow
 80102fe:	455a      	cmp	r2, fp
						pkt[i+1] = 0xFFFF << 16;
					else
						pkt[i+1] = tdiff << 16;
 8010300:	bf96      	itet	ls
 8010302:	0413      	lslls	r3, r2, #16
			{
				if(i > 0) // Calculate time difference
				{
					uint32_t tdiff = error_log[i].time-error_log[i-1].time; // Time difference to last error
					if(tdiff >= 0xFFFF) // Time overflow
						pkt[i+1] = 0xFFFF << 16;
 8010304:	f8cc 4000 	strhi.w	r4, [ip]
					else
						pkt[i+1] = tdiff << 16;
 8010308:	f8cc 3000 	strls.w	r3, [ip]
 801030c:	e7e7      	b.n	80102de <moduleERROR+0x16e>

					transmitOnRadio(&msg);
					break;

				default:
					TRACE_ERROR("ERR  > Unsupported protocol selected for module ERR");
 801030e:	4841      	ldr	r0, [pc, #260]	; (8010414 <moduleERROR+0x2a4>)
 8010310:	f7fe fdee 	bl	800eef0 <chMtxLock>
 8010314:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8010318:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 801031c:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 801031e:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8010320:	493f      	ldr	r1, [pc, #252]	; (8010420 <moduleERROR+0x2b0>)
 8010322:	fb03 f000 	mul.w	r0, r3, r0
 8010326:	fba5 e000 	umull	lr, r0, r5, r0
 801032a:	0b80      	lsrs	r0, r0, #14
 801032c:	fba9 ce00 	umull	ip, lr, r9, r0
 8010330:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8010334:	fba5 c202 	umull	ip, r2, r5, r2
 8010338:	fb03 031e 	mls	r3, r3, lr, r0
 801033c:	0b92      	lsrs	r2, r2, #14
 801033e:	4839      	ldr	r0, [pc, #228]	; (8010424 <moduleERROR+0x2b4>)
 8010340:	f002 f9ce 	bl	80126e0 <chprintf.constprop.35>
 8010344:	4a42      	ldr	r2, [pc, #264]	; (8010450 <moduleERROR+0x2e0>)
 8010346:	4939      	ldr	r1, [pc, #228]	; (801042c <moduleERROR+0x2bc>)
 8010348:	4836      	ldr	r0, [pc, #216]	; (8010424 <moduleERROR+0x2b4>)
 801034a:	f002 f9c9 	bl	80126e0 <chprintf.constprop.35>
 801034e:	238f      	movs	r3, #143	; 0x8f
 8010350:	4a37      	ldr	r2, [pc, #220]	; (8010430 <moduleERROR+0x2c0>)
 8010352:	4938      	ldr	r1, [pc, #224]	; (8010434 <moduleERROR+0x2c4>)
 8010354:	4833      	ldr	r0, [pc, #204]	; (8010424 <moduleERROR+0x2b4>)
 8010356:	f002 f9c3 	bl	80126e0 <chprintf.constprop.35>
 801035a:	4937      	ldr	r1, [pc, #220]	; (8010438 <moduleERROR+0x2c8>)
 801035c:	4831      	ldr	r0, [pc, #196]	; (8010424 <moduleERROR+0x2b4>)
 801035e:	f002 f9bf 	bl	80126e0 <chprintf.constprop.35>
 8010362:	493c      	ldr	r1, [pc, #240]	; (8010454 <moduleERROR+0x2e4>)
 8010364:	482f      	ldr	r0, [pc, #188]	; (8010424 <moduleERROR+0x2b4>)
 8010366:	f002 f9bb 	bl	80126e0 <chprintf.constprop.35>
 801036a:	4935      	ldr	r1, [pc, #212]	; (8010440 <moduleERROR+0x2d0>)
 801036c:	482d      	ldr	r0, [pc, #180]	; (8010424 <moduleERROR+0x2b4>)
 801036e:	f002 f9b7 	bl	80126e0 <chprintf.constprop.35>
 8010372:	4828      	ldr	r0, [pc, #160]	; (8010414 <moduleERROR+0x2a4>)
 8010374:	f7fe fd5c 	bl	800ee30 <chMtxUnlock>
 8010378:	218f      	movs	r1, #143	; 0x8f
 801037a:	482d      	ldr	r0, [pc, #180]	; (8010430 <moduleERROR+0x2c0>)
 801037c:	f7ff fdf0 	bl	800ff60 <log_error>
			}
		}

		time = waitForTrigger(time, &config->trigger);
 8010380:	4638      	mov	r0, r7
 8010382:	9904      	ldr	r1, [sp, #16]
 8010384:	f001 ffcc 	bl	8012320 <waitForTrigger>
 8010388:	4607      	mov	r7, r0
 801038a:	e750      	b.n	801022e <moduleERROR+0xbe>
 801038c:	4676      	mov	r6, lr
						pkt[i+1] = tdiff << 16;
				}
				pkt[i+1] |= error_log[i].error;
			}
			uint8_t size = error_id;
			error_id = 0;
 801038e:	f04f 0b00 	mov.w	fp, #0

			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
 8010392:	9805      	ldr	r0, [sp, #20]
						pkt[i+1] = tdiff << 16;
				}
				pkt[i+1] |= error_log[i].error;
			}
			uint8_t size = error_id;
			error_id = 0;
 8010394:	f888 b000 	strb.w	fp, [r8]

			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
 8010398:	f002 f86a 	bl	8012470 <getFrequency>
			msg.power = config->power;

			switch(config->protocol) {
 801039c:	f896 3030 	ldrb.w	r3, [r6, #48]	; 0x30
			uint8_t size = error_id;
			error_id = 0;

			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
			msg.power = config->power;
 80103a0:	f896 1020 	ldrb.w	r1, [r6, #32]
			}
			uint8_t size = error_id;
			error_id = 0;

			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
 80103a4:	908a      	str	r0, [sp, #552]	; 0x228
			msg.power = config->power;

			switch(config->protocol) {
 80103a6:	1e5a      	subs	r2, r3, #1
 80103a8:	2a01      	cmp	r2, #1
			uint8_t size = error_id;
			error_id = 0;

			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
			msg.power = config->power;
 80103aa:	f88d 122c 	strb.w	r1, [sp, #556]	; 0x22c

			switch(config->protocol) {
 80103ae:	d8ae      	bhi.n	801030e <moduleERROR+0x19e>
				case PROT_APRS_2GFSK:
				case PROT_APRS_AFSK:
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 80103b0:	2b01      	cmp	r3, #1
 80103b2:	4b29      	ldr	r3, [pc, #164]	; (8010458 <moduleERROR+0x2e8>)
					msg.afsk_config = &(config->afsk_config);
 80103b4:	9a06      	ldr	r2, [sp, #24]
 80103b6:	928e      	str	r2, [sp, #568]	; 0x238
			msg.power = config->power;

			switch(config->protocol) {
				case PROT_APRS_2GFSK:
				case PROT_APRS_AFSK:
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 80103b8:	bf14      	ite	ne
 80103ba:	2102      	movne	r1, #2
 80103bc:	2104      	moveq	r1, #4
					msg.afsk_config = &(config->afsk_config);
					msg.gfsk_config = &(config->gfsk_config);
 80103be:	928f      	str	r2, [sp, #572]	; 0x23c
			msg.power = config->power;

			switch(config->protocol) {
				case PROT_APRS_2GFSK:
				case PROT_APRS_AFSK:
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 80103c0:	f88d 122d 	strb.w	r1, [sp, #557]	; 0x22d
					msg.afsk_config = &(config->afsk_config);
					msg.gfsk_config = &(config->gfsk_config);

					// Deleting buffer
					for(uint8_t t=0; t<sizeof(pkt_base91); t++)
						pkt_base91[t] = 0;
 80103c4:	465a      	mov	r2, fp
 80103c6:	f103 0182 	add.w	r1, r3, #130	; 0x82
 80103ca:	f803 2f01 	strb.w	r2, [r3, #1]!
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
					msg.afsk_config = &(config->afsk_config);
					msg.gfsk_config = &(config->gfsk_config);

					// Deleting buffer
					for(uint8_t t=0; t<sizeof(pkt_base91); t++)
 80103ce:	428b      	cmp	r3, r1
 80103d0:	d1fb      	bne.n	80103ca <moduleERROR+0x25a>
						pkt_base91[t] = 0;

					base91_encode((uint8_t*)pkt, pkt_base91, 4*size+4);
 80103d2:	ea4f 028a 	mov.w	r2, sl, lsl #2
 80103d6:	3204      	adds	r2, #4
 80103d8:	4920      	ldr	r1, [pc, #128]	; (801045c <moduleERROR+0x2ec>)
 80103da:	481b      	ldr	r0, [pc, #108]	; (8010448 <moduleERROR+0x2d8>)
 80103dc:	f001 ff08 	bl	80121f0 <base91_encode>
					msg.bin_len = aprs_encode_experimental('E', msg.msg, msg.mod, &config->aprs_config, pkt_base91, strlen((char*)pkt_base91));
 80103e0:	481e      	ldr	r0, [pc, #120]	; (801045c <moduleERROR+0x2ec>)
 80103e2:	f7f1 fb65 	bl	8001ab0 <strlen>
 80103e6:	4b1d      	ldr	r3, [pc, #116]	; (801045c <moduleERROR+0x2ec>)
 80103e8:	f89d 222d 	ldrb.w	r2, [sp, #557]	; 0x22d
 80103ec:	9001      	str	r0, [sp, #4]
 80103ee:	a909      	add	r1, sp, #36	; 0x24
 80103f0:	9300      	str	r3, [sp, #0]
 80103f2:	2045      	movs	r0, #69	; 0x45
 80103f4:	9b07      	ldr	r3, [sp, #28]
 80103f6:	f7fa f953 	bl	800a6a0 <aprs_encode_experimental>
 80103fa:	9089      	str	r0, [sp, #548]	; 0x224

					transmitOnRadio(&msg);
 80103fc:	a809      	add	r0, sp, #36	; 0x24
 80103fe:	f001 f8b7 	bl	8011570 <transmitOnRadio>
				default:
					TRACE_ERROR("ERR  > Unsupported protocol selected for module ERR");
			}
		}

		time = waitForTrigger(time, &config->trigger);
 8010402:	4638      	mov	r0, r7
 8010404:	9904      	ldr	r1, [sp, #16]
 8010406:	f001 ff8b 	bl	8012320 <waitForTrigger>
 801040a:	4607      	mov	r7, r0
 801040c:	e70f      	b.n	801022e <moduleERROR+0xbe>
 801040e:	bf00      	nop
 8010410:	10624dd3 	.word	0x10624dd3
 8010414:	20027b2c 	.word	0x20027b2c
 8010418:	d1b71759 	.word	0xd1b71759
 801041c:	ffff0000 	.word	0xffff0000
 8010420:	08013c50 	.word	0x08013c50
 8010424:	20027e60 	.word	0x20027e60
 8010428:	08013cfc 	.word	0x08013cfc
 801042c:	08013c5c 	.word	0x08013c5c
 8010430:	080160d8 	.word	0x080160d8
 8010434:	08013c78 	.word	0x08013c78
 8010438:	08013d00 	.word	0x08013d00
 801043c:	080160e0 	.word	0x080160e0
 8010440:	08013cac 	.word	0x08013cac
 8010444:	080160fc 	.word	0x080160fc
 8010448:	20027bbc 	.word	0x20027bbc
 801044c:	20027c28 	.word	0x20027c28
 8010450:	08013d9c 	.word	0x08013d9c
 8010454:	08016118 	.word	0x08016118
 8010458:	20027d6b 	.word	0x20027d6b
 801045c:	20027d6c 	.word	0x20027d6c
 8010460:	20027b56 	.word	0x20027b56
	...

08010470 <moduleLOG>:
	
	return (yz << 8) | xz;
}

THD_FUNCTION(moduleLOG, arg)
{
 8010470:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 8010474:	6b42      	ldr	r2, [r0, #52]	; 0x34
	
	return (yz << 8) | xz;
}

THD_FUNCTION(moduleLOG, arg)
{
 8010476:	f5ad 7d21 	sub.w	sp, sp, #644	; 0x284
 801047a:	9009      	str	r0, [sp, #36]	; 0x24
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 801047c:	b15a      	cbz	r2, 8010496 <moduleLOG+0x26>
		chThdSleepMilliseconds(config->init_delay);
 801047e:	f644 6320 	movw	r3, #20000	; 0x4e20
 8010482:	fb03 f302 	mul.w	r3, r3, r2
 8010486:	4857      	ldr	r0, [pc, #348]	; (80105e4 <moduleLOG+0x174>)
 8010488:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 801048c:	fba0 3003 	umull	r3, r0, r0, r3
 8010490:	0980      	lsrs	r0, r0, #6
 8010492:	f7fe fdfd 	bl	800f090 <chThdSleep>
 8010496:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000

	// Print initialization message
	TRACE_INFO("LOG  > Startup module %s", config->name);
 801049a:	4853      	ldr	r0, [pc, #332]	; (80105e8 <moduleLOG+0x178>)
 801049c:	4f53      	ldr	r7, [pc, #332]	; (80105ec <moduleLOG+0x17c>)
 801049e:	f7fe fd27 	bl	800eef0 <chMtxLock>
 80104a2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80104a4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80104a6:	4b4f      	ldr	r3, [pc, #316]	; (80105e4 <moduleLOG+0x174>)
 80104a8:	4951      	ldr	r1, [pc, #324]	; (80105f0 <moduleLOG+0x180>)
 80104aa:	4852      	ldr	r0, [pc, #328]	; (80105f4 <moduleLOG+0x184>)
 80104ac:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 80104b0:	fb06 f404 	mul.w	r4, r6, r4
 80104b4:	fba7 e404 	umull	lr, r4, r7, r4
 80104b8:	0ba4      	lsrs	r4, r4, #14
 80104ba:	fba3 e304 	umull	lr, r3, r3, r4
 80104be:	fba7 7202 	umull	r7, r2, r7, r2
 80104c2:	099b      	lsrs	r3, r3, #6
 80104c4:	fb06 4313 	mls	r3, r6, r3, r4
 80104c8:	0b92      	lsrs	r2, r2, #14
 80104ca:	f002 f909 	bl	80126e0 <chprintf.constprop.35>
 80104ce:	4a4a      	ldr	r2, [pc, #296]	; (80105f8 <moduleLOG+0x188>)
 80104d0:	494a      	ldr	r1, [pc, #296]	; (80105fc <moduleLOG+0x18c>)
 80104d2:	4848      	ldr	r0, [pc, #288]	; (80105f4 <moduleLOG+0x184>)
 80104d4:	f002 f904 	bl	80126e0 <chprintf.constprop.35>
 80104d8:	2376      	movs	r3, #118	; 0x76
 80104da:	4a49      	ldr	r2, [pc, #292]	; (8010600 <moduleLOG+0x190>)
 80104dc:	4949      	ldr	r1, [pc, #292]	; (8010604 <moduleLOG+0x194>)
 80104de:	4845      	ldr	r0, [pc, #276]	; (80105f4 <moduleLOG+0x184>)
 80104e0:	f002 f8fe 	bl	80126e0 <chprintf.constprop.35>
 80104e4:	4948      	ldr	r1, [pc, #288]	; (8010608 <moduleLOG+0x198>)
 80104e6:	4843      	ldr	r0, [pc, #268]	; (80105f4 <moduleLOG+0x184>)
 80104e8:	f002 f8fa 	bl	80126e0 <chprintf.constprop.35>
 80104ec:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80104ee:	4947      	ldr	r1, [pc, #284]	; (801060c <moduleLOG+0x19c>)
 80104f0:	4840      	ldr	r0, [pc, #256]	; (80105f4 <moduleLOG+0x184>)
 80104f2:	4622      	mov	r2, r4
 80104f4:	f002 f8f4 	bl	80126e0 <chprintf.constprop.35>
 80104f8:	4945      	ldr	r1, [pc, #276]	; (8010610 <moduleLOG+0x1a0>)
 80104fa:	483e      	ldr	r0, [pc, #248]	; (80105f4 <moduleLOG+0x184>)
 80104fc:	f002 f8f0 	bl	80126e0 <chprintf.constprop.35>
 8010500:	4839      	ldr	r0, [pc, #228]	; (80105e8 <moduleLOG+0x178>)
 8010502:	f7fe fc95 	bl	800ee30 <chMtxUnlock>
 8010506:	4623      	mov	r3, r4
 8010508:	333c      	adds	r3, #60	; 0x3c
 801050a:	6a69      	ldr	r1, [r5, #36]	; 0x24
 801050c:	930b      	str	r3, [sp, #44]	; 0x2c
 801050e:	4623      	mov	r3, r4
 8010510:	3344      	adds	r3, #68	; 0x44
 8010512:	930a      	str	r3, [sp, #40]	; 0x28
 8010514:	4623      	mov	r3, r4
 8010516:	3324      	adds	r3, #36	; 0x24
 8010518:	930c      	str	r3, [sp, #48]	; 0x30
 801051a:	4623      	mov	r3, r4
 801051c:	3350      	adds	r3, #80	; 0x50
 801051e:	930d      	str	r3, [sp, #52]	; 0x34
 8010520:	4623      	mov	r3, r4
 8010522:	3358      	adds	r3, #88	; 0x58
 8010524:	930e      	str	r3, [sp, #56]	; 0x38
 8010526:	4623      	mov	r3, r4
 8010528:	336c      	adds	r3, #108	; 0x6c
 801052a:	9108      	str	r1, [sp, #32]
 801052c:	930f      	str	r3, [sp, #60]	; 0x3c
 801052e:	e004      	b.n	801053a <moduleLOG+0xca>
				default:
					TRACE_ERROR("LOG  > Unsupported protocol selected for module LOG");
			}
		}

		time = waitForTrigger(time, &config->trigger);
 8010530:	9808      	ldr	r0, [sp, #32]
 8010532:	990a      	ldr	r1, [sp, #40]	; 0x28
 8010534:	f001 fef4 	bl	8012320 <waitForTrigger>
 8010538:	9008      	str	r0, [sp, #32]
 801053a:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
	TRACE_INFO("LOG  > Startup module %s", config->name);

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("LOG  > Do module LOG cycle");
 801053e:	482a      	ldr	r0, [pc, #168]	; (80105e8 <moduleLOG+0x178>)
 8010540:	4d2a      	ldr	r5, [pc, #168]	; (80105ec <moduleLOG+0x17c>)
 8010542:	f7fe fcd5 	bl	800eef0 <chMtxLock>
 8010546:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8010548:	6a61      	ldr	r1, [r4, #36]	; 0x24
 801054a:	4b26      	ldr	r3, [pc, #152]	; (80105e4 <moduleLOG+0x174>)
 801054c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010550:	fb00 f101 	mul.w	r1, r0, r1
 8010554:	fba5 6101 	umull	r6, r1, r5, r1
 8010558:	0b89      	lsrs	r1, r1, #14
 801055a:	fba3 6301 	umull	r6, r3, r3, r1
 801055e:	fba5 5202 	umull	r5, r2, r5, r2
 8010562:	099b      	lsrs	r3, r3, #6
 8010564:	fb00 1313 	mls	r3, r0, r3, r1
 8010568:	0b92      	lsrs	r2, r2, #14
 801056a:	4921      	ldr	r1, [pc, #132]	; (80105f0 <moduleLOG+0x180>)
 801056c:	4821      	ldr	r0, [pc, #132]	; (80105f4 <moduleLOG+0x184>)
 801056e:	f002 f8b7 	bl	80126e0 <chprintf.constprop.35>
 8010572:	4a21      	ldr	r2, [pc, #132]	; (80105f8 <moduleLOG+0x188>)
 8010574:	4921      	ldr	r1, [pc, #132]	; (80105fc <moduleLOG+0x18c>)
 8010576:	481f      	ldr	r0, [pc, #124]	; (80105f4 <moduleLOG+0x184>)
 8010578:	f002 f8b2 	bl	80126e0 <chprintf.constprop.35>
 801057c:	237b      	movs	r3, #123	; 0x7b
 801057e:	4a20      	ldr	r2, [pc, #128]	; (8010600 <moduleLOG+0x190>)
 8010580:	4920      	ldr	r1, [pc, #128]	; (8010604 <moduleLOG+0x194>)
 8010582:	481c      	ldr	r0, [pc, #112]	; (80105f4 <moduleLOG+0x184>)
 8010584:	f002 f8ac 	bl	80126e0 <chprintf.constprop.35>
 8010588:	491f      	ldr	r1, [pc, #124]	; (8010608 <moduleLOG+0x198>)
 801058a:	481a      	ldr	r0, [pc, #104]	; (80105f4 <moduleLOG+0x184>)
 801058c:	f002 f8a8 	bl	80126e0 <chprintf.constprop.35>
 8010590:	4920      	ldr	r1, [pc, #128]	; (8010614 <moduleLOG+0x1a4>)
 8010592:	4818      	ldr	r0, [pc, #96]	; (80105f4 <moduleLOG+0x184>)
 8010594:	f002 f8a4 	bl	80126e0 <chprintf.constprop.35>
 8010598:	491d      	ldr	r1, [pc, #116]	; (8010610 <moduleLOG+0x1a0>)
 801059a:	4816      	ldr	r0, [pc, #88]	; (80105f4 <moduleLOG+0x184>)
 801059c:	f002 f8a0 	bl	80126e0 <chprintf.constprop.35>
 80105a0:	4811      	ldr	r0, [pc, #68]	; (80105e8 <moduleLOG+0x178>)
 80105a2:	f7fe fc45 	bl	800ee30 <chMtxUnlock>
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer
 80105a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80105a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80105aa:	f8c2 31b0 	str.w	r3, [r2, #432]	; 0x1b0

		if(!p_sleep(&config->sleep_config))
 80105ae:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80105b0:	f001 fede 	bl	8012370 <p_sleep>
 80105b4:	2800      	cmp	r0, #0
 80105b6:	d1bb      	bne.n	8010530 <moduleLOG+0xc0>
		{
			// Get log from memory
			logTrackPoint_t log;
			getLogTrackPoints(&log, nextLogEntryCounter++, 1);
 80105b8:	4b17      	ldr	r3, [pc, #92]	; (8010618 <moduleLOG+0x1a8>)

			// Encode absolute time
			pkt[0] = log.time >> 16;
 80105ba:	4918      	ldr	r1, [pc, #96]	; (801061c <moduleLOG+0x1ac>)

		if(!p_sleep(&config->sleep_config))
		{
			// Get log from memory
			logTrackPoint_t log;
			getLogTrackPoints(&log, nextLogEntryCounter++, 1);
 80105bc:	681a      	ldr	r2, [r3, #0]
    return TRUE;
}

int flashRead(flashaddr_t address, char* buffer, size_t size)
{
    memcpy(buffer, (char*)address, size);
 80105be:	f3c2 030d 	ubfx	r3, r2, #0, #14
 80105c2:	f503 0300 	add.w	r3, r3, #8388608	; 0x800000
 80105c6:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
 80105ca:	011b      	lsls	r3, r3, #4
			pkt[0] = log.time >> 16;
			pkt[1] = log.time & 0xFFFF;
			uint32_t rel_time = log.time;

			// Encode log points
			for(uint32_t i=0,z=0; i<LOG_TRANSMISSION_TIME; i++,z++)
 80105cc:	4604      	mov	r4, r0
 80105ce:	681f      	ldr	r7, [r3, #0]
			logTrackPoint_t log;
			getLogTrackPoints(&log, nextLogEntryCounter++, 1);

			// Encode absolute time
			pkt[0] = log.time >> 16;
			pkt[1] = log.time & 0xFFFF;
 80105d0:	4b12      	ldr	r3, [pc, #72]	; (801061c <moduleLOG+0x1ac>)
 80105d2:	805f      	strh	r7, [r3, #2]
			// Get log from memory
			logTrackPoint_t log;
			getLogTrackPoints(&log, nextLogEntryCounter++, 1);

			// Encode absolute time
			pkt[0] = log.time >> 16;
 80105d4:	0c3b      	lsrs	r3, r7, #16
 80105d6:	800b      	strh	r3, [r1, #0]
			pkt[1] = log.time & 0xFFFF;
 80105d8:	f244 0301 	movw	r3, #16385	; 0x4001

		if(!p_sleep(&config->sleep_config))
		{
			// Get log from memory
			logTrackPoint_t log;
			getLogTrackPoints(&log, nextLogEntryCounter++, 1);
 80105dc:	3201      	adds	r2, #1

			// Encode absolute time
			pkt[0] = log.time >> 16;
			pkt[1] = log.time & 0xFFFF;
 80105de:	469b      	mov	fp, r3
 80105e0:	e057      	b.n	8010692 <moduleLOG+0x222>
 80105e2:	bf00      	nop
 80105e4:	10624dd3 	.word	0x10624dd3
 80105e8:	20027b2c 	.word	0x20027b2c
 80105ec:	d1b71759 	.word	0xd1b71759
 80105f0:	08013c50 	.word	0x08013c50
 80105f4:	20027e60 	.word	0x20027e60
 80105f8:	08013cfc 	.word	0x08013cfc
 80105fc:	08013c5c 	.word	0x08013c5c
 8010600:	08016154 	.word	0x08016154
 8010604:	08013c78 	.word	0x08013c78
 8010608:	08013d00 	.word	0x08013d00
 801060c:	0801615c 	.word	0x0801615c
 8010610:	08013cac 	.word	0x08013cac
 8010614:	08016178 	.word	0x08016178
 8010618:	20027df0 	.word	0x20027df0
 801061c:	20027b58 	.word	0x20027b58
  */
uint8_t lookupNL(double lat)
{
	// FIXME: Change this mess to a real lookup table
	double a = fabs(lat);
	if     (a < 10.47047130) return 59;
 8010620:	203b      	movs	r0, #59	; 0x3b

	double dlat[] = {6.0, 360.0/59.0};
	uint8_t yz = floor(256 * fmod(lat, dlat[cprFormat]) / dlat[cprFormat] + 0.5);
	double rlat = dlat[cprFormat] * (yz / 256 + floor(lat / dlat[cprFormat]));
	uint8_t nl = lookupNL(rlat);
	double dlon = nl-cprFormat > 0 ? 360.0 / (nl-cprFormat) : 360.0;
 8010622:	1b00      	subs	r0, r0, r4
 8010624:	f000 80ff 	beq.w	8010826 <moduleLOG+0x3b6>
 8010628:	f7ef ffac 	bl	8000584 <__aeabi_i2d>
 801062c:	4602      	mov	r2, r0
 801062e:	460b      	mov	r3, r1
 8010630:	2000      	movs	r0, #0
 8010632:	49c3      	ldr	r1, [pc, #780]	; (8010940 <moduleLOG+0x4d0>)
 8010634:	f7f0 f936 	bl	80008a4 <__aeabi_ddiv>
 8010638:	4606      	mov	r6, r0
 801063a:	460f      	mov	r7, r1
	uint8_t xz = floor(256 * fmod(lon, dlon) / dlon + 0.5);
 801063c:	463b      	mov	r3, r7
 801063e:	4632      	mov	r2, r6
 8010640:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8010644:	f002 fe44 	bl	80132d0 <fmod>
 8010648:	2200      	movs	r2, #0
 801064a:	4bbe      	ldr	r3, [pc, #760]	; (8010944 <moduleLOG+0x4d4>)
 801064c:	f7f0 f800 	bl	8000650 <__aeabi_dmul>
 8010650:	463b      	mov	r3, r7
 8010652:	4632      	mov	r2, r6
 8010654:	f7f0 f926 	bl	80008a4 <__aeabi_ddiv>
 8010658:	2200      	movs	r2, #0
 801065a:	4bbb      	ldr	r3, [pc, #748]	; (8010948 <moduleLOG+0x4d8>)
 801065c:	f7ef fe46 	bl	80002ec <__adddf3>
 8010660:	f002 fdae 	bl	80131c0 <floor>
				}

				TRACE_INFO("LOG  > Encode log ID=%d", (nextLogEntryCounter-1) % (LOG_FLASH_SIZE / sizeof(logTrackPoint_t)));

				pkt[i*3+2] = log.time - rel_time; // Time difference to last log point
				pkt[i*3+3] = cpr_encode(i%2, log.gps_lat/10000000.0, log.gps_lon/10000000.0);
 8010664:	f7f0 faac 	bl	8000bc0 <__aeabi_d2uiz>
 8010668:	9b06      	ldr	r3, [sp, #24]
 801066a:	4ab8      	ldr	r2, [pc, #736]	; (801094c <moduleLOG+0x4dc>)
 801066c:	9903      	ldr	r1, [sp, #12]
				pkt[i*3+4] = log.gps_alt; // Altitude in meters				
 801066e:	9c02      	ldr	r4, [sp, #8]
				}

				TRACE_INFO("LOG  > Encode log ID=%d", (nextLogEntryCounter-1) % (LOG_FLASH_SIZE / sizeof(logTrackPoint_t)));

				pkt[i*3+2] = log.time - rel_time; // Time difference to last log point
				pkt[i*3+3] = cpr_encode(i%2, log.gps_lat/10000000.0, log.gps_lon/10000000.0);
 8010670:	021b      	lsls	r3, r3, #8
 8010672:	b2c0      	uxtb	r0, r0
 8010674:	4303      	orrs	r3, r0
 8010676:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
				pkt[i*3+4] = log.gps_alt; // Altitude in meters				
 801067a:	3504      	adds	r5, #4
 801067c:	4613      	mov	r3, r2
 801067e:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8010682:	f823 2015 	strh.w	r2, [r3, r5, lsl #1]
 8010686:	4657      	mov	r7, sl
			pkt[0] = log.time >> 16;
			pkt[1] = log.time & 0xFFFF;
			uint32_t rel_time = log.time;

			// Encode log points
			for(uint32_t i=0,z=0; i<LOG_TRANSMISSION_TIME; i++,z++)
 8010688:	2c0f      	cmp	r4, #15
 801068a:	f200 80d8 	bhi.w	801083e <moduleLOG+0x3ce>
 801068e:	4bb0      	ldr	r3, [pc, #704]	; (8010950 <moduleLOG+0x4e0>)
 8010690:	681a      	ldr	r2, [r3, #0]
			{
				getLogTrackPoints(&log, nextLogEntryCounter++, 1); // Read log point
 8010692:	49af      	ldr	r1, [pc, #700]	; (8010950 <moduleLOG+0x4e0>)
 8010694:	f3c2 030d 	ubfx	r3, r2, #0, #14
 8010698:	f503 0300 	add.w	r3, r3, #8388608	; 0x800000
 801069c:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
 80106a0:	011b      	lsls	r3, r3, #4
 80106a2:	3201      	adds	r2, #1

				if(z == LOG_FLASH_SIZE / sizeof(logTrackPoint_t)) // No entry in log memory
 80106a4:	f1bb 0b01 	subs.w	fp, fp, #1
			uint32_t rel_time = log.time;

			// Encode log points
			for(uint32_t i=0,z=0; i<LOG_TRANSMISSION_TIME; i++,z++)
			{
				getLogTrackPoints(&log, nextLogEntryCounter++, 1); // Read log point
 80106a8:	600a      	str	r2, [r1, #0]
 80106aa:	f8d3 a000 	ldr.w	sl, [r3]

				if(z == LOG_FLASH_SIZE / sizeof(logTrackPoint_t)) // No entry in log memory
 80106ae:	f000 80c6 	beq.w	801083e <moduleLOG+0x3ce>
					break;

				if(log.time == 0xFFFFFFFF) { // Log entry invalid (not set)
 80106b2:	f1ba 3fff 	cmp.w	sl, #4294967295
 80106b6:	d0e7      	beq.n	8010688 <moduleLOG+0x218>
 80106b8:	f8d3 8004 	ldr.w	r8, [r3, #4]
 80106bc:	689e      	ldr	r6, [r3, #8]
					i--;
					continue;
				}

				TRACE_INFO("LOG  > Encode log ID=%d", (nextLogEntryCounter-1) % (LOG_FLASH_SIZE / sizeof(logTrackPoint_t)));
 80106be:	48a5      	ldr	r0, [pc, #660]	; (8010954 <moduleLOG+0x4e4>)
 80106c0:	68db      	ldr	r3, [r3, #12]
 80106c2:	9307      	str	r3, [sp, #28]
 80106c4:	f7fe fc14 	bl	800eef0 <chMtxLock>
 80106c8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80106cc:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
 80106d0:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80106d2:	6a55      	ldr	r5, [r2, #36]	; 0x24
 80106d4:	f8df c2c4 	ldr.w	ip, [pc, #708]	; 801099c <moduleLOG+0x52c>
 80106d8:	4a9f      	ldr	r2, [pc, #636]	; (8010958 <moduleLOG+0x4e8>)
 80106da:	49a0      	ldr	r1, [pc, #640]	; (801095c <moduleLOG+0x4ec>)
 80106dc:	48a0      	ldr	r0, [pc, #640]	; (8010960 <moduleLOG+0x4f0>)
 80106de:	fb0e f505 	mul.w	r5, lr, r5
 80106e2:	fbac 9505 	umull	r9, r5, ip, r5
 80106e6:	0bad      	lsrs	r5, r5, #14
 80106e8:	fba2 9205 	umull	r9, r2, r2, r5
 80106ec:	fbac 3c03 	umull	r3, ip, ip, r3
 80106f0:	0993      	lsrs	r3, r2, #6
 80106f2:	fb0e 5313 	mls	r3, lr, r3, r5
 80106f6:	ea4f 329c 	mov.w	r2, ip, lsr #14
 80106fa:	f001 fff1 	bl	80126e0 <chprintf.constprop.35>
 80106fe:	4a99      	ldr	r2, [pc, #612]	; (8010964 <moduleLOG+0x4f4>)
 8010700:	4999      	ldr	r1, [pc, #612]	; (8010968 <moduleLOG+0x4f8>)
 8010702:	4897      	ldr	r0, [pc, #604]	; (8010960 <moduleLOG+0x4f0>)
 8010704:	f001 ffec 	bl	80126e0 <chprintf.constprop.35>
 8010708:	2396      	movs	r3, #150	; 0x96
 801070a:	4a98      	ldr	r2, [pc, #608]	; (801096c <moduleLOG+0x4fc>)
 801070c:	4998      	ldr	r1, [pc, #608]	; (8010970 <moduleLOG+0x500>)
 801070e:	4894      	ldr	r0, [pc, #592]	; (8010960 <moduleLOG+0x4f0>)
 8010710:	f001 ffe6 	bl	80126e0 <chprintf.constprop.35>
 8010714:	4997      	ldr	r1, [pc, #604]	; (8010974 <moduleLOG+0x504>)
 8010716:	4892      	ldr	r0, [pc, #584]	; (8010960 <moduleLOG+0x4f0>)
 8010718:	f001 ffe2 	bl	80126e0 <chprintf.constprop.35>
 801071c:	4b8c      	ldr	r3, [pc, #560]	; (8010950 <moduleLOG+0x4e0>)
 801071e:	4996      	ldr	r1, [pc, #600]	; (8010978 <moduleLOG+0x508>)
 8010720:	681a      	ldr	r2, [r3, #0]
 8010722:	488f      	ldr	r0, [pc, #572]	; (8010960 <moduleLOG+0x4f0>)
 8010724:	3a01      	subs	r2, #1
 8010726:	f3c2 020d 	ubfx	r2, r2, #0, #14
 801072a:	f001 ffd9 	bl	80126e0 <chprintf.constprop.35>
 801072e:	4993      	ldr	r1, [pc, #588]	; (801097c <moduleLOG+0x50c>)
 8010730:	488b      	ldr	r0, [pc, #556]	; (8010960 <moduleLOG+0x4f0>)
 8010732:	f001 ffd5 	bl	80126e0 <chprintf.constprop.35>

				pkt[i*3+2] = log.time - rel_time; // Time difference to last log point
 8010736:	eb04 0544 	add.w	r5, r4, r4, lsl #1
				if(log.time == 0xFFFFFFFF) { // Log entry invalid (not set)
					i--;
					continue;
				}

				TRACE_INFO("LOG  > Encode log ID=%d", (nextLogEntryCounter-1) % (LOG_FLASH_SIZE / sizeof(logTrackPoint_t)));
 801073a:	4886      	ldr	r0, [pc, #536]	; (8010954 <moduleLOG+0x4e4>)
 801073c:	f7fe fb78 	bl	800ee30 <chMtxUnlock>

				pkt[i*3+2] = log.time - rel_time; // Time difference to last log point
 8010740:	1cab      	adds	r3, r5, #2
 8010742:	4a82      	ldr	r2, [pc, #520]	; (801094c <moduleLOG+0x4dc>)
 8010744:	ebc7 070a 	rsb	r7, r7, sl
				pkt[i*3+3] = cpr_encode(i%2, log.gps_lat/10000000.0, log.gps_lon/10000000.0);
 8010748:	4640      	mov	r0, r8
					continue;
				}

				TRACE_INFO("LOG  > Encode log ID=%d", (nextLogEntryCounter-1) % (LOG_FLASH_SIZE / sizeof(logTrackPoint_t)));

				pkt[i*3+2] = log.time - rel_time; // Time difference to last log point
 801074a:	f822 7013 	strh.w	r7, [r2, r3, lsl #1]
				pkt[i*3+3] = cpr_encode(i%2, log.gps_lat/10000000.0, log.gps_lon/10000000.0);
 801074e:	f7ef ff19 	bl	8000584 <__aeabi_i2d>
 8010752:	a375      	add	r3, pc, #468	; (adr r3, 8010928 <moduleLOG+0x4b8>)
 8010754:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010758:	f7f0 f8a4 	bl	80008a4 <__aeabi_ddiv>
 801075c:	4680      	mov	r8, r0
 801075e:	4630      	mov	r0, r6
 8010760:	4689      	mov	r9, r1
 8010762:	f7ef ff0f 	bl	8000584 <__aeabi_i2d>
 8010766:	a370      	add	r3, pc, #448	; (adr r3, 8010928 <moduleLOG+0x4b8>)
 8010768:	e9d3 2300 	ldrd	r2, r3, [r3]
 801076c:	f7f0 f89a 	bl	80008a4 <__aeabi_ddiv>
 8010770:	1cee      	adds	r6, r5, #3
 8010772:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8010776:	9603      	str	r6, [sp, #12]
  * See ICAO DO-260B for more details
  */
uint16_t cpr_encode(bool cprFormat, double lat, double lon)
{
	// Convert coordinates
	if(lat < 0)
 8010778:	2200      	movs	r2, #0
				}

				TRACE_INFO("LOG  > Encode log ID=%d", (nextLogEntryCounter-1) % (LOG_FLASH_SIZE / sizeof(logTrackPoint_t)));

				pkt[i*3+2] = log.time - rel_time; // Time difference to last log point
				pkt[i*3+3] = cpr_encode(i%2, log.gps_lat/10000000.0, log.gps_lon/10000000.0);
 801077a:	1c66      	adds	r6, r4, #1
  * See ICAO DO-260B for more details
  */
uint16_t cpr_encode(bool cprFormat, double lat, double lon)
{
	// Convert coordinates
	if(lat < 0)
 801077c:	2300      	movs	r3, #0
 801077e:	4640      	mov	r0, r8
 8010780:	4649      	mov	r1, r9
				}

				TRACE_INFO("LOG  > Encode log ID=%d", (nextLogEntryCounter-1) % (LOG_FLASH_SIZE / sizeof(logTrackPoint_t)));

				pkt[i*3+2] = log.time - rel_time; // Time difference to last log point
				pkt[i*3+3] = cpr_encode(i%2, log.gps_lat/10000000.0, log.gps_lon/10000000.0);
 8010782:	9602      	str	r6, [sp, #8]
 8010784:	f004 0401 	and.w	r4, r4, #1
  * See ICAO DO-260B for more details
  */
uint16_t cpr_encode(bool cprFormat, double lat, double lon)
{
	// Convert coordinates
	if(lat < 0)
 8010788:	f7f0 f9da 	bl	8000b40 <__aeabi_dcmplt>
 801078c:	2800      	cmp	r0, #0
 801078e:	d14d      	bne.n	801082c <moduleLOG+0x3bc>
		lat += 360; // Southern hemisphere is shown as 270-360 degree

	double dlat[] = {6.0, 360.0/59.0};
 8010790:	4b7b      	ldr	r3, [pc, #492]	; (8010980 <moduleLOG+0x510>)
 8010792:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8010794:	ae18      	add	r6, sp, #96	; 0x60
 8010796:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
	uint8_t yz = floor(256 * fmod(lat, dlat[cprFormat]) / dlat[cprFormat] + 0.5);
 801079a:	eb06 03c4 	add.w	r3, r6, r4, lsl #3
 801079e:	e9d3 6700 	ldrd	r6, r7, [r3]
 80107a2:	4640      	mov	r0, r8
 80107a4:	4632      	mov	r2, r6
 80107a6:	463b      	mov	r3, r7
 80107a8:	4649      	mov	r1, r9
 80107aa:	f002 fd91 	bl	80132d0 <fmod>
 80107ae:	2200      	movs	r2, #0
 80107b0:	4b64      	ldr	r3, [pc, #400]	; (8010944 <moduleLOG+0x4d4>)
 80107b2:	f7ef ff4d 	bl	8000650 <__aeabi_dmul>
 80107b6:	4632      	mov	r2, r6
 80107b8:	463b      	mov	r3, r7
 80107ba:	f7f0 f873 	bl	80008a4 <__aeabi_ddiv>
 80107be:	2200      	movs	r2, #0
 80107c0:	4b61      	ldr	r3, [pc, #388]	; (8010948 <moduleLOG+0x4d8>)
 80107c2:	f7ef fd93 	bl	80002ec <__adddf3>
 80107c6:	f002 fcfb 	bl	80131c0 <floor>
	double rlat = dlat[cprFormat] * (yz / 256 + floor(lat / dlat[cprFormat]));
 80107ca:	f7f0 f9f9 	bl	8000bc0 <__aeabi_d2uiz>
 80107ce:	b2c1      	uxtb	r1, r0
 80107d0:	4632      	mov	r2, r6
 80107d2:	463b      	mov	r3, r7
 80107d4:	9106      	str	r1, [sp, #24]
 80107d6:	4640      	mov	r0, r8
 80107d8:	4649      	mov	r1, r9
 80107da:	f7f0 f863 	bl	80008a4 <__aeabi_ddiv>
 80107de:	f002 fcef 	bl	80131c0 <floor>
  * See ICAO DO-260B for more details
  */
uint8_t lookupNL(double lat)
{
	// FIXME: Change this mess to a real lookup table
	double a = fabs(lat);
 80107e2:	2200      	movs	r2, #0
 80107e4:	2300      	movs	r3, #0
 80107e6:	f7ef fd81 	bl	80002ec <__adddf3>
 80107ea:	4632      	mov	r2, r6
 80107ec:	463b      	mov	r3, r7
 80107ee:	f7ef ff2f 	bl	8000650 <__aeabi_dmul>
 80107f2:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
	if     (a < 10.47047130) return 59;
 80107f6:	4631      	mov	r1, r6
 80107f8:	a34d      	add	r3, pc, #308	; (adr r3, 8010930 <moduleLOG+0x4c0>)
 80107fa:	e9d3 2300 	ldrd	r2, r3, [r3]
  * See ICAO DO-260B for more details
  */
uint8_t lookupNL(double lat)
{
	// FIXME: Change this mess to a real lookup table
	double a = fabs(lat);
 80107fe:	4607      	mov	r7, r0
	if     (a < 10.47047130) return 59;
 8010800:	f7f0 f99e 	bl	8000b40 <__aeabi_dcmplt>
 8010804:	2800      	cmp	r0, #0
 8010806:	f47f af0b 	bne.w	8010620 <moduleLOG+0x1b0>
	else if(a < 14.82817437) return 58;
 801080a:	4638      	mov	r0, r7
 801080c:	4631      	mov	r1, r6
 801080e:	a34a      	add	r3, pc, #296	; (adr r3, 8010938 <moduleLOG+0x4c8>)
 8010810:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010814:	f7f0 f994 	bl	8000b40 <__aeabi_dcmplt>
 8010818:	2800      	cmp	r0, #0
 801081a:	f000 80c1 	beq.w	80109a0 <moduleLOG+0x530>
 801081e:	203a      	movs	r0, #58	; 0x3a

	double dlat[] = {6.0, 360.0/59.0};
	uint8_t yz = floor(256 * fmod(lat, dlat[cprFormat]) / dlat[cprFormat] + 0.5);
	double rlat = dlat[cprFormat] * (yz / 256 + floor(lat / dlat[cprFormat]));
	uint8_t nl = lookupNL(rlat);
	double dlon = nl-cprFormat > 0 ? 360.0 / (nl-cprFormat) : 360.0;
 8010820:	1b00      	subs	r0, r0, r4
 8010822:	f47f af01 	bne.w	8010628 <moduleLOG+0x1b8>
 8010826:	2600      	movs	r6, #0
 8010828:	4f45      	ldr	r7, [pc, #276]	; (8010940 <moduleLOG+0x4d0>)
 801082a:	e707      	b.n	801063c <moduleLOG+0x1cc>
  */
uint16_t cpr_encode(bool cprFormat, double lat, double lon)
{
	// Convert coordinates
	if(lat < 0)
		lat += 360; // Southern hemisphere is shown as 270-360 degree
 801082c:	4640      	mov	r0, r8
 801082e:	4649      	mov	r1, r9
 8010830:	2200      	movs	r2, #0
 8010832:	4b43      	ldr	r3, [pc, #268]	; (8010940 <moduleLOG+0x4d0>)
 8010834:	f7ef fd5a 	bl	80002ec <__adddf3>
 8010838:	4680      	mov	r8, r0
 801083a:	4689      	mov	r9, r1
 801083c:	e7a8      	b.n	8010790 <moduleLOG+0x320>
				rel_time = log.time; // Set absolute time for next log point
			}

			// Encode radio message
			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
 801083e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8010840:	f001 fe16 	bl	8012470 <getFrequency>
			msg.power = config->power;

			switch(config->protocol) {
 8010844:	9a09      	ldr	r2, [sp, #36]	; 0x24
				rel_time = log.time; // Set absolute time for next log point
			}

			// Encode radio message
			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
 8010846:	9099      	str	r0, [sp, #612]	; 0x264
			msg.power = config->power;

			switch(config->protocol) {
 8010848:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
			}

			// Encode radio message
			radioMSG_t msg;
			msg.freq = getFrequency(&config->frequency);
			msg.power = config->power;
 801084c:	f892 1020 	ldrb.w	r1, [r2, #32]
 8010850:	f88d 1268 	strb.w	r1, [sp, #616]	; 0x268

			switch(config->protocol) {
 8010854:	1e5a      	subs	r2, r3, #1
 8010856:	2a01      	cmp	r2, #1
 8010858:	f200 80b7 	bhi.w	80109ca <moduleLOG+0x55a>
				case PROT_APRS_2GFSK:
				case PROT_APRS_AFSK:
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
					msg.afsk_config = &(config->afsk_config);
 801085c:	990d      	ldr	r1, [sp, #52]	; 0x34
 801085e:	919d      	str	r1, [sp, #628]	; 0x274
			msg.power = config->power;

			switch(config->protocol) {
				case PROT_APRS_2GFSK:
				case PROT_APRS_AFSK:
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8010860:	2b01      	cmp	r3, #1
 8010862:	4b48      	ldr	r3, [pc, #288]	; (8010984 <moduleLOG+0x514>)
					msg.afsk_config = &(config->afsk_config);
					msg.gfsk_config = &(config->gfsk_config);
 8010864:	919e      	str	r1, [sp, #632]	; 0x278

			switch(config->protocol) {
				case PROT_APRS_2GFSK:
				case PROT_APRS_AFSK:
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
					msg.afsk_config = &(config->afsk_config);
 8010866:	460a      	mov	r2, r1
			msg.power = config->power;

			switch(config->protocol) {
				case PROT_APRS_2GFSK:
				case PROT_APRS_AFSK:
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8010868:	bf14      	ite	ne
 801086a:	2202      	movne	r2, #2
 801086c:	2204      	moveq	r2, #4
 801086e:	f88d 2269 	strb.w	r2, [sp, #617]	; 0x269
 8010872:	f103 017d 	add.w	r1, r3, #125	; 0x7d
					msg.afsk_config = &(config->afsk_config);
					msg.gfsk_config = &(config->gfsk_config);

					// Deleting buffer
					for(uint16_t t=0; t<sizeof(pkt_base91); t++)
						pkt_base91[t] = 0;
 8010876:	2200      	movs	r2, #0
 8010878:	f803 2f01 	strb.w	r2, [r3, #1]!
					msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
					msg.afsk_config = &(config->afsk_config);
					msg.gfsk_config = &(config->gfsk_config);

					// Deleting buffer
					for(uint16_t t=0; t<sizeof(pkt_base91); t++)
 801087c:	4299      	cmp	r1, r3
 801087e:	d1fb      	bne.n	8010878 <moduleLOG+0x408>
						pkt_base91[t] = 0;

					base91_encode((uint8_t*)pkt, pkt_base91, sizeof(pkt));
 8010880:	2264      	movs	r2, #100	; 0x64
 8010882:	4941      	ldr	r1, [pc, #260]	; (8010988 <moduleLOG+0x518>)
 8010884:	4831      	ldr	r0, [pc, #196]	; (801094c <moduleLOG+0x4dc>)

	ax25_send_byte(&packet, ':');
	ax25_send_string(&packet, text);
	ax25_send_byte(&packet, '{');

	chsnprintf(temp, sizeof(temp), "%d", ++msg_id);
 8010886:	4d41      	ldr	r5, [pc, #260]	; (801098c <moduleLOG+0x51c>)
 8010888:	f001 fcb2 	bl	80121f0 <base91_encode>
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	// Encode APRS header
	char temp[10];
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 801088c:	9909      	ldr	r1, [sp, #36]	; 0x24
					msg.bin_len = aprs_encode_message(msg.msg, msg.mod, &config->aprs_config, APRS_DEST_CALLSIGN, (char*)pkt_base91);
 801088e:	f89d 0269 	ldrb.w	r0, [sp, #617]	; 0x269
 8010892:	f8b1 307c 	ldrh.w	r3, [r1, #124]	; 0x7c
 8010896:	f891 2068 	ldrb.w	r2, [r1, #104]	; 0x68
 801089a:	9300      	str	r3, [sp, #0]
 * Transmit message packet
 */
uint32_t aprs_encode_message(uint8_t* message, mod_t mod, const aprs_config_t *config, const char *receiver, const char *text)
{
	ax25_t packet;
	packet.data = message;
 801089c:	ab18      	add	r3, sp, #96	; 0x60
 801089e:	9315      	str	r3, [sp, #84]	; 0x54
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	// Encode APRS header
	char temp[10];
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 80108a0:	990e      	ldr	r1, [sp, #56]	; 0x38
 80108a2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
uint32_t aprs_encode_message(uint8_t* message, mod_t mod, const aprs_config_t *config, const char *receiver, const char *text)
{
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;
 80108a4:	f88d 005e 	strb.w	r0, [sp, #94]	; 0x5e
 */
uint32_t aprs_encode_message(uint8_t* message, mod_t mod, const aprs_config_t *config, const char *receiver, const char *text)
{
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 80108a8:	f44f 7400 	mov.w	r4, #512	; 0x200
	packet.mod = mod;

	// Encode APRS header
	char temp[10];
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 80108ac:	a814      	add	r0, sp, #80	; 0x50
 */
uint32_t aprs_encode_message(uint8_t* message, mod_t mod, const aprs_config_t *config, const char *receiver, const char *text)
{
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 80108ae:	f8ad 405a 	strh.w	r4, [sp, #90]	; 0x5a
	packet.mod = mod;

	// Encode APRS header
	char temp[10];
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 80108b2:	f7fd fb45 	bl	800df40 <ax25_send_header.constprop.16>
	}
}

void ax25_send_byte(ax25_t *packet, char byte)
{
	send_byte(packet, byte);
 80108b6:	a814      	add	r0, sp, #80	; 0x50
 80108b8:	213a      	movs	r1, #58	; 0x3a
 80108ba:	f7f9 fe51 	bl	800a560 <send_byte.lto_priv.112>
	ax25_send_byte(&packet, ':');

	chsnprintf(temp, sizeof(temp), "%-9s", receiver);
 80108be:	4b34      	ldr	r3, [pc, #208]	; (8010990 <moduleLOG+0x520>)
 80108c0:	4a34      	ldr	r2, [pc, #208]	; (8010994 <moduleLOG+0x524>)
 80108c2:	210a      	movs	r1, #10
 80108c4:	a811      	add	r0, sp, #68	; 0x44
 80108c6:	f7fb fcb3 	bl	800c230 <chsnprintf>
	ax25_send_string(&packet, temp);
 80108ca:	a911      	add	r1, sp, #68	; 0x44
 80108cc:	a814      	add	r0, sp, #80	; 0x50
 80108ce:	f7f9 fed7 	bl	800a680 <ax25_send_string>
 80108d2:	a814      	add	r0, sp, #80	; 0x50
 80108d4:	213a      	movs	r1, #58	; 0x3a
 80108d6:	f7f9 fe43 	bl	800a560 <send_byte.lto_priv.112>

	ax25_send_byte(&packet, ':');
	ax25_send_string(&packet, text);
 80108da:	a814      	add	r0, sp, #80	; 0x50
 80108dc:	492a      	ldr	r1, [pc, #168]	; (8010988 <moduleLOG+0x518>)
 80108de:	f7f9 fecf 	bl	800a680 <ax25_send_string>
 80108e2:	a814      	add	r0, sp, #80	; 0x50
 80108e4:	217b      	movs	r1, #123	; 0x7b
 80108e6:	f7f9 fe3b 	bl	800a560 <send_byte.lto_priv.112>
	ax25_send_byte(&packet, '{');

	chsnprintf(temp, sizeof(temp), "%d", ++msg_id);
 80108ea:	4b28      	ldr	r3, [pc, #160]	; (801098c <moduleLOG+0x51c>)
 80108ec:	4a2a      	ldr	r2, [pc, #168]	; (8010998 <moduleLOG+0x528>)
 80108ee:	881c      	ldrh	r4, [r3, #0]
 80108f0:	3401      	adds	r4, #1
 80108f2:	b2a4      	uxth	r4, r4
 80108f4:	4623      	mov	r3, r4
 80108f6:	210a      	movs	r1, #10
 80108f8:	a811      	add	r0, sp, #68	; 0x44
 80108fa:	802c      	strh	r4, [r5, #0]
 80108fc:	f7fb fc98 	bl	800c230 <chsnprintf>
	ax25_send_string(&packet, temp);
 8010900:	a911      	add	r1, sp, #68	; 0x44
 8010902:	a814      	add	r0, sp, #80	; 0x50
 8010904:	f7f9 febc 	bl	800a680 <ax25_send_string>

	// Send footer
	ax25_send_footer(&packet);
 8010908:	a814      	add	r0, sp, #80	; 0x50
 801090a:	f7f9 fe79 	bl	800a600 <ax25_send_footer>
	scramble(&packet);
 801090e:	a814      	add	r0, sp, #80	; 0x50
 8010910:	f7f9 fdb6 	bl	800a480 <scramble>
	nrzi_encode(&packet);
 8010914:	a814      	add	r0, sp, #80	; 0x50
 8010916:	f7f9 fd83 	bl	800a420 <nrzi_encode>

	return packet.size;
 801091a:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
 801091e:	9398      	str	r3, [sp, #608]	; 0x260

					transmitOnRadio(&msg);
 8010920:	a818      	add	r0, sp, #96	; 0x60
 8010922:	f000 fe25 	bl	8011570 <transmitOnRadio>
 8010926:	e603      	b.n	8010530 <moduleLOG+0xc0>
 8010928:	00000000 	.word	0x00000000
 801092c:	416312d0 	.word	0x416312d0
 8010930:	9d3e69c8 	.word	0x9d3e69c8
 8010934:	4024f0e1 	.word	0x4024f0e1
 8010938:	78951220 	.word	0x78951220
 801093c:	402da806 	.word	0x402da806
 8010940:	40768000 	.word	0x40768000
 8010944:	40700000 	.word	0x40700000
 8010948:	3fe00000 	.word	0x3fe00000
 801094c:	20027b58 	.word	0x20027b58
 8010950:	20027df0 	.word	0x20027df0
 8010954:	20027b2c 	.word	0x20027b2c
 8010958:	10624dd3 	.word	0x10624dd3
 801095c:	08013c50 	.word	0x08013c50
 8010960:	20027e60 	.word	0x20027e60
 8010964:	08013cfc 	.word	0x08013cfc
 8010968:	08013c5c 	.word	0x08013c5c
 801096c:	08016154 	.word	0x08016154
 8010970:	08013c78 	.word	0x08013c78
 8010974:	08013d00 	.word	0x08013d00
 8010978:	08016194 	.word	0x08016194
 801097c:	08013cac 	.word	0x08013cac
 8010980:	08013c08 	.word	0x08013c08
 8010984:	20027ceb 	.word	0x20027ceb
 8010988:	20027cec 	.word	0x20027cec
 801098c:	20027b54 	.word	0x20027b54
 8010990:	08015b68 	.word	0x08015b68
 8010994:	080161ac 	.word	0x080161ac
 8010998:	08015410 	.word	0x08015410
 801099c:	d1b71759 	.word	0xd1b71759
{
	// FIXME: Change this mess to a real lookup table
	double a = fabs(lat);
	if     (a < 10.47047130) return 59;
	else if(a < 14.82817437) return 58;
	else if(a < 18.18626357) return 57;
 80109a0:	4638      	mov	r0, r7
 80109a2:	4631      	mov	r1, r6
 80109a4:	a390      	add	r3, pc, #576	; (adr r3, 8010be8 <moduleLOG+0x778>)
 80109a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80109aa:	f7f0 f8c9 	bl	8000b40 <__aeabi_dcmplt>
 80109ae:	b108      	cbz	r0, 80109b4 <moduleLOG+0x544>
 80109b0:	2039      	movs	r0, #57	; 0x39
 80109b2:	e636      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 21.02939493) return 56;
 80109b4:	4638      	mov	r0, r7
 80109b6:	4631      	mov	r1, r6
 80109b8:	a38d      	add	r3, pc, #564	; (adr r3, 8010bf0 <moduleLOG+0x780>)
 80109ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 80109be:	f7f0 f8bf 	bl	8000b40 <__aeabi_dcmplt>
 80109c2:	2800      	cmp	r0, #0
 80109c4:	d03c      	beq.n	8010a40 <moduleLOG+0x5d0>
 80109c6:	2038      	movs	r0, #56	; 0x38
 80109c8:	e62b      	b.n	8010622 <moduleLOG+0x1b2>

					transmitOnRadio(&msg);
					break;

				default:
					TRACE_ERROR("LOG  > Unsupported protocol selected for module LOG");
 80109ca:	48b5      	ldr	r0, [pc, #724]	; (8010ca0 <moduleLOG+0x830>)
 80109cc:	4cb5      	ldr	r4, [pc, #724]	; (8010ca4 <moduleLOG+0x834>)
 80109ce:	f7fe fa8f 	bl	800eef0 <chMtxLock>
 80109d2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80109d6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80109da:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80109dc:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80109de:	4bb2      	ldr	r3, [pc, #712]	; (8010ca8 <moduleLOG+0x838>)
 80109e0:	fb00 f101 	mul.w	r1, r0, r1
 80109e4:	fba4 5101 	umull	r5, r1, r4, r1
 80109e8:	0b89      	lsrs	r1, r1, #14
 80109ea:	fba3 5301 	umull	r5, r3, r3, r1
 80109ee:	fba4 4202 	umull	r4, r2, r4, r2
 80109f2:	099b      	lsrs	r3, r3, #6
 80109f4:	fb00 1313 	mls	r3, r0, r3, r1
 80109f8:	0b92      	lsrs	r2, r2, #14
 80109fa:	49ac      	ldr	r1, [pc, #688]	; (8010cac <moduleLOG+0x83c>)
 80109fc:	48ac      	ldr	r0, [pc, #688]	; (8010cb0 <moduleLOG+0x840>)
 80109fe:	f001 fe6f 	bl	80126e0 <chprintf.constprop.35>
 8010a02:	4aac      	ldr	r2, [pc, #688]	; (8010cb4 <moduleLOG+0x844>)
 8010a04:	49ac      	ldr	r1, [pc, #688]	; (8010cb8 <moduleLOG+0x848>)
 8010a06:	48aa      	ldr	r0, [pc, #680]	; (8010cb0 <moduleLOG+0x840>)
 8010a08:	f001 fe6a 	bl	80126e0 <chprintf.constprop.35>
 8010a0c:	23b6      	movs	r3, #182	; 0xb6
 8010a0e:	4aab      	ldr	r2, [pc, #684]	; (8010cbc <moduleLOG+0x84c>)
 8010a10:	49ab      	ldr	r1, [pc, #684]	; (8010cc0 <moduleLOG+0x850>)
 8010a12:	48a7      	ldr	r0, [pc, #668]	; (8010cb0 <moduleLOG+0x840>)
 8010a14:	f001 fe64 	bl	80126e0 <chprintf.constprop.35>
 8010a18:	49aa      	ldr	r1, [pc, #680]	; (8010cc4 <moduleLOG+0x854>)
 8010a1a:	48a5      	ldr	r0, [pc, #660]	; (8010cb0 <moduleLOG+0x840>)
 8010a1c:	f001 fe60 	bl	80126e0 <chprintf.constprop.35>
 8010a20:	49a9      	ldr	r1, [pc, #676]	; (8010cc8 <moduleLOG+0x858>)
 8010a22:	48a3      	ldr	r0, [pc, #652]	; (8010cb0 <moduleLOG+0x840>)
 8010a24:	f001 fe5c 	bl	80126e0 <chprintf.constprop.35>
 8010a28:	49a8      	ldr	r1, [pc, #672]	; (8010ccc <moduleLOG+0x85c>)
 8010a2a:	48a1      	ldr	r0, [pc, #644]	; (8010cb0 <moduleLOG+0x840>)
 8010a2c:	f001 fe58 	bl	80126e0 <chprintf.constprop.35>
 8010a30:	489b      	ldr	r0, [pc, #620]	; (8010ca0 <moduleLOG+0x830>)
 8010a32:	f7fe f9fd 	bl	800ee30 <chMtxUnlock>
 8010a36:	21b6      	movs	r1, #182	; 0xb6
 8010a38:	48a0      	ldr	r0, [pc, #640]	; (8010cbc <moduleLOG+0x84c>)
 8010a3a:	f7ff fa91 	bl	800ff60 <log_error>
 8010a3e:	e577      	b.n	8010530 <moduleLOG+0xc0>
	double a = fabs(lat);
	if     (a < 10.47047130) return 59;
	else if(a < 14.82817437) return 58;
	else if(a < 18.18626357) return 57;
	else if(a < 21.02939493) return 56;
	else if(a < 23.54504487) return 55;
 8010a40:	4638      	mov	r0, r7
 8010a42:	4631      	mov	r1, r6
 8010a44:	a36c      	add	r3, pc, #432	; (adr r3, 8010bf8 <moduleLOG+0x788>)
 8010a46:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010a4a:	f7f0 f879 	bl	8000b40 <__aeabi_dcmplt>
 8010a4e:	b108      	cbz	r0, 8010a54 <moduleLOG+0x5e4>
 8010a50:	2037      	movs	r0, #55	; 0x37
 8010a52:	e5e6      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 25.82924707) return 54;
 8010a54:	4638      	mov	r0, r7
 8010a56:	4631      	mov	r1, r6
 8010a58:	a369      	add	r3, pc, #420	; (adr r3, 8010c00 <moduleLOG+0x790>)
 8010a5a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010a5e:	f7f0 f86f 	bl	8000b40 <__aeabi_dcmplt>
 8010a62:	b108      	cbz	r0, 8010a68 <moduleLOG+0x5f8>
 8010a64:	2036      	movs	r0, #54	; 0x36
 8010a66:	e5dc      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 27.93898710) return 53;
 8010a68:	4638      	mov	r0, r7
 8010a6a:	4631      	mov	r1, r6
 8010a6c:	a366      	add	r3, pc, #408	; (adr r3, 8010c08 <moduleLOG+0x798>)
 8010a6e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010a72:	f7f0 f865 	bl	8000b40 <__aeabi_dcmplt>
 8010a76:	b108      	cbz	r0, 8010a7c <moduleLOG+0x60c>
 8010a78:	2035      	movs	r0, #53	; 0x35
 8010a7a:	e5d2      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 29.91135686) return 52;
 8010a7c:	4638      	mov	r0, r7
 8010a7e:	4631      	mov	r1, r6
 8010a80:	a363      	add	r3, pc, #396	; (adr r3, 8010c10 <moduleLOG+0x7a0>)
 8010a82:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010a86:	f7f0 f85b 	bl	8000b40 <__aeabi_dcmplt>
 8010a8a:	b108      	cbz	r0, 8010a90 <moduleLOG+0x620>
 8010a8c:	2034      	movs	r0, #52	; 0x34
 8010a8e:	e5c8      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 31.77209708) return 51;
 8010a90:	4638      	mov	r0, r7
 8010a92:	4631      	mov	r1, r6
 8010a94:	a360      	add	r3, pc, #384	; (adr r3, 8010c18 <moduleLOG+0x7a8>)
 8010a96:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010a9a:	f7f0 f851 	bl	8000b40 <__aeabi_dcmplt>
 8010a9e:	b108      	cbz	r0, 8010aa4 <moduleLOG+0x634>
 8010aa0:	2033      	movs	r0, #51	; 0x33
 8010aa2:	e5be      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 33.53993436) return 50;
 8010aa4:	4638      	mov	r0, r7
 8010aa6:	4631      	mov	r1, r6
 8010aa8:	a35d      	add	r3, pc, #372	; (adr r3, 8010c20 <moduleLOG+0x7b0>)
 8010aaa:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010aae:	f7f0 f847 	bl	8000b40 <__aeabi_dcmplt>
 8010ab2:	b108      	cbz	r0, 8010ab8 <moduleLOG+0x648>
 8010ab4:	2032      	movs	r0, #50	; 0x32
 8010ab6:	e5b4      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 35.22899598) return 49;
 8010ab8:	4638      	mov	r0, r7
 8010aba:	4631      	mov	r1, r6
 8010abc:	a35a      	add	r3, pc, #360	; (adr r3, 8010c28 <moduleLOG+0x7b8>)
 8010abe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010ac2:	f7f0 f83d 	bl	8000b40 <__aeabi_dcmplt>
 8010ac6:	b108      	cbz	r0, 8010acc <moduleLOG+0x65c>
 8010ac8:	2031      	movs	r0, #49	; 0x31
 8010aca:	e5aa      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 36.85025108) return 48;
 8010acc:	4638      	mov	r0, r7
 8010ace:	4631      	mov	r1, r6
 8010ad0:	a357      	add	r3, pc, #348	; (adr r3, 8010c30 <moduleLOG+0x7c0>)
 8010ad2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010ad6:	f7f0 f833 	bl	8000b40 <__aeabi_dcmplt>
 8010ada:	b108      	cbz	r0, 8010ae0 <moduleLOG+0x670>
 8010adc:	2030      	movs	r0, #48	; 0x30
 8010ade:	e5a0      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 38.41241892) return 47;
 8010ae0:	4638      	mov	r0, r7
 8010ae2:	4631      	mov	r1, r6
 8010ae4:	a354      	add	r3, pc, #336	; (adr r3, 8010c38 <moduleLOG+0x7c8>)
 8010ae6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010aea:	f7f0 f829 	bl	8000b40 <__aeabi_dcmplt>
 8010aee:	b108      	cbz	r0, 8010af4 <moduleLOG+0x684>
 8010af0:	202f      	movs	r0, #47	; 0x2f
 8010af2:	e596      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 39.92256684) return 46;
 8010af4:	4638      	mov	r0, r7
 8010af6:	4631      	mov	r1, r6
 8010af8:	a351      	add	r3, pc, #324	; (adr r3, 8010c40 <moduleLOG+0x7d0>)
 8010afa:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010afe:	f7f0 f81f 	bl	8000b40 <__aeabi_dcmplt>
 8010b02:	b108      	cbz	r0, 8010b08 <moduleLOG+0x698>
 8010b04:	202e      	movs	r0, #46	; 0x2e
 8010b06:	e58c      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 41.38651832) return 45;
 8010b08:	4638      	mov	r0, r7
 8010b0a:	4631      	mov	r1, r6
 8010b0c:	a34e      	add	r3, pc, #312	; (adr r3, 8010c48 <moduleLOG+0x7d8>)
 8010b0e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b12:	f7f0 f815 	bl	8000b40 <__aeabi_dcmplt>
 8010b16:	b108      	cbz	r0, 8010b1c <moduleLOG+0x6ac>
 8010b18:	202d      	movs	r0, #45	; 0x2d
 8010b1a:	e582      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 42.80914012) return 44;
 8010b1c:	4638      	mov	r0, r7
 8010b1e:	4631      	mov	r1, r6
 8010b20:	a34b      	add	r3, pc, #300	; (adr r3, 8010c50 <moduleLOG+0x7e0>)
 8010b22:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b26:	f7f0 f80b 	bl	8000b40 <__aeabi_dcmplt>
 8010b2a:	b108      	cbz	r0, 8010b30 <moduleLOG+0x6c0>
 8010b2c:	202c      	movs	r0, #44	; 0x2c
 8010b2e:	e578      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 44.19454951) return 43;
 8010b30:	4638      	mov	r0, r7
 8010b32:	4631      	mov	r1, r6
 8010b34:	a348      	add	r3, pc, #288	; (adr r3, 8010c58 <moduleLOG+0x7e8>)
 8010b36:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b3a:	f7f0 f801 	bl	8000b40 <__aeabi_dcmplt>
 8010b3e:	b108      	cbz	r0, 8010b44 <moduleLOG+0x6d4>
 8010b40:	202b      	movs	r0, #43	; 0x2b
 8010b42:	e56e      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 45.54626723) return 42;
 8010b44:	4638      	mov	r0, r7
 8010b46:	4631      	mov	r1, r6
 8010b48:	a345      	add	r3, pc, #276	; (adr r3, 8010c60 <moduleLOG+0x7f0>)
 8010b4a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b4e:	f7ef fff7 	bl	8000b40 <__aeabi_dcmplt>
 8010b52:	b108      	cbz	r0, 8010b58 <moduleLOG+0x6e8>
 8010b54:	202a      	movs	r0, #42	; 0x2a
 8010b56:	e564      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 46.86733252) return 41;
 8010b58:	4638      	mov	r0, r7
 8010b5a:	4631      	mov	r1, r6
 8010b5c:	a342      	add	r3, pc, #264	; (adr r3, 8010c68 <moduleLOG+0x7f8>)
 8010b5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b62:	f7ef ffed 	bl	8000b40 <__aeabi_dcmplt>
 8010b66:	b108      	cbz	r0, 8010b6c <moduleLOG+0x6fc>
 8010b68:	2029      	movs	r0, #41	; 0x29
 8010b6a:	e55a      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 48.16039128) return 40;
 8010b6c:	4638      	mov	r0, r7
 8010b6e:	4631      	mov	r1, r6
 8010b70:	a33f      	add	r3, pc, #252	; (adr r3, 8010c70 <moduleLOG+0x800>)
 8010b72:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b76:	f7ef ffe3 	bl	8000b40 <__aeabi_dcmplt>
 8010b7a:	b108      	cbz	r0, 8010b80 <moduleLOG+0x710>
 8010b7c:	2028      	movs	r0, #40	; 0x28
 8010b7e:	e550      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 49.42776439) return 39;
 8010b80:	4638      	mov	r0, r7
 8010b82:	4631      	mov	r1, r6
 8010b84:	a33c      	add	r3, pc, #240	; (adr r3, 8010c78 <moduleLOG+0x808>)
 8010b86:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b8a:	f7ef ffd9 	bl	8000b40 <__aeabi_dcmplt>
 8010b8e:	b108      	cbz	r0, 8010b94 <moduleLOG+0x724>
 8010b90:	2027      	movs	r0, #39	; 0x27
 8010b92:	e546      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 50.67150166) return 38;
 8010b94:	4638      	mov	r0, r7
 8010b96:	4631      	mov	r1, r6
 8010b98:	a339      	add	r3, pc, #228	; (adr r3, 8010c80 <moduleLOG+0x810>)
 8010b9a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010b9e:	f7ef ffcf 	bl	8000b40 <__aeabi_dcmplt>
 8010ba2:	b108      	cbz	r0, 8010ba8 <moduleLOG+0x738>
 8010ba4:	2026      	movs	r0, #38	; 0x26
 8010ba6:	e53c      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 51.89342469) return 37;
 8010ba8:	4638      	mov	r0, r7
 8010baa:	4631      	mov	r1, r6
 8010bac:	a336      	add	r3, pc, #216	; (adr r3, 8010c88 <moduleLOG+0x818>)
 8010bae:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010bb2:	f7ef ffc5 	bl	8000b40 <__aeabi_dcmplt>
 8010bb6:	b108      	cbz	r0, 8010bbc <moduleLOG+0x74c>
 8010bb8:	2025      	movs	r0, #37	; 0x25
 8010bba:	e532      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 53.09516153) return 36;
 8010bbc:	4638      	mov	r0, r7
 8010bbe:	4631      	mov	r1, r6
 8010bc0:	a333      	add	r3, pc, #204	; (adr r3, 8010c90 <moduleLOG+0x820>)
 8010bc2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010bc6:	f7ef ffbb 	bl	8000b40 <__aeabi_dcmplt>
 8010bca:	b108      	cbz	r0, 8010bd0 <moduleLOG+0x760>
 8010bcc:	2024      	movs	r0, #36	; 0x24
 8010bce:	e528      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 54.27817472) return 35;
 8010bd0:	4638      	mov	r0, r7
 8010bd2:	4631      	mov	r1, r6
 8010bd4:	a330      	add	r3, pc, #192	; (adr r3, 8010c98 <moduleLOG+0x828>)
 8010bd6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010bda:	f7ef ffb1 	bl	8000b40 <__aeabi_dcmplt>
 8010bde:	2800      	cmp	r0, #0
 8010be0:	d076      	beq.n	8010cd0 <moduleLOG+0x860>
 8010be2:	2023      	movs	r0, #35	; 0x23
 8010be4:	e51d      	b.n	8010622 <moduleLOG+0x1b2>
 8010be6:	bf00      	nop
 8010be8:	f8259612 	.word	0xf8259612
 8010bec:	40322fae 	.word	0x40322fae
 8010bf0:	6d1704a9 	.word	0x6d1704a9
 8010bf4:	40350786 	.word	0x40350786
 8010bf8:	0f8380a9 	.word	0x0f8380a9
 8010bfc:	40378b88 	.word	0x40378b88
 8010c00:	8935f42e 	.word	0x8935f42e
 8010c04:	4039d449 	.word	0x4039d449
 8010c08:	7565ddaa 	.word	0x7565ddaa
 8010c0c:	403bf061 	.word	0x403bf061
 8010c10:	aee4af6d 	.word	0xaee4af6d
 8010c14:	403de94e 	.word	0x403de94e
 8010c18:	277befe6 	.word	0x277befe6
 8010c1c:	403fc5a8 	.word	0x403fc5a8
 8010c20:	91b117e5 	.word	0x91b117e5
 8010c24:	4040c51c 	.word	0x4040c51c
 8010c28:	bd8281fb 	.word	0xbd8281fb
 8010c2c:	40419d4f 	.word	0x40419d4f
 8010c30:	0702fe8d 	.word	0x0702fe8d
 8010c34:	40426cd5 	.word	0x40426cd5
 8010c38:	24a6d369 	.word	0x24a6d369
 8010c3c:	404334ca 	.word	0x404334ca
 8010c40:	ab931648 	.word	0xab931648
 8010c44:	4043f616 	.word	0x4043f616
 8010c48:	6eabda39 	.word	0x6eabda39
 8010c4c:	4044b179 	.word	0x4044b179
 8010c50:	e748a409 	.word	0xe748a409
 8010c54:	40456791 	.word	0x40456791
 8010c58:	ff937390 	.word	0xff937390
 8010c5c:	404618e6 	.word	0x404618e6
 8010c60:	15a7dcfe 	.word	0x15a7dcfe
 8010c64:	4046c5ec 	.word	0x4046c5ec
 8010c68:	c0841421 	.word	0xc0841421
 8010c6c:	40476f04 	.word	0x40476f04
 8010c70:	b39314f0 	.word	0xb39314f0
 8010c74:	40481487 	.word	0x40481487
 8010c78:	fbc8b8c1 	.word	0xfbc8b8c1
 8010c7c:	4048b6c0 	.word	0x4048b6c0
 8010c80:	c4327471 	.word	0xc4327471
 8010c84:	404955f3 	.word	0x404955f3
 8010c88:	bd807e96 	.word	0xbd807e96
 8010c8c:	4049f25b 	.word	0x4049f25b
 8010c90:	40c597fa 	.word	0x40c597fa
 8010c94:	404a8c2e 	.word	0x404a8c2e
 8010c98:	3aae7cab 	.word	0x3aae7cab
 8010c9c:	404b239b 	.word	0x404b239b
 8010ca0:	20027b2c 	.word	0x20027b2c
 8010ca4:	d1b71759 	.word	0xd1b71759
 8010ca8:	10624dd3 	.word	0x10624dd3
 8010cac:	08013c50 	.word	0x08013c50
 8010cb0:	20027e60 	.word	0x20027e60
 8010cb4:	08013d9c 	.word	0x08013d9c
 8010cb8:	08013c5c 	.word	0x08013c5c
 8010cbc:	08016154 	.word	0x08016154
 8010cc0:	08013c78 	.word	0x08013c78
 8010cc4:	08013d00 	.word	0x08013d00
 8010cc8:	080161b4 	.word	0x080161b4
 8010ccc:	08013cac 	.word	0x08013cac
	else if(a < 55.44378444) return 34;
 8010cd0:	4638      	mov	r0, r7
 8010cd2:	4631      	mov	r1, r6
 8010cd4:	a3ac      	add	r3, pc, #688	; (adr r3, 8010f88 <moduleLOG+0xb18>)
 8010cd6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010cda:	f7ef ff31 	bl	8000b40 <__aeabi_dcmplt>
 8010cde:	b108      	cbz	r0, 8010ce4 <moduleLOG+0x874>
 8010ce0:	2022      	movs	r0, #34	; 0x22
 8010ce2:	e49e      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 56.59318756) return 33;
 8010ce4:	4638      	mov	r0, r7
 8010ce6:	4631      	mov	r1, r6
 8010ce8:	a3a9      	add	r3, pc, #676	; (adr r3, 8010f90 <moduleLOG+0xb20>)
 8010cea:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010cee:	f7ef ff27 	bl	8000b40 <__aeabi_dcmplt>
 8010cf2:	b108      	cbz	r0, 8010cf8 <moduleLOG+0x888>
 8010cf4:	2021      	movs	r0, #33	; 0x21
 8010cf6:	e494      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 57.72747354) return 31;
 8010cf8:	4638      	mov	r0, r7
 8010cfa:	4631      	mov	r1, r6
 8010cfc:	a3a6      	add	r3, pc, #664	; (adr r3, 8010f98 <moduleLOG+0xb28>)
 8010cfe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d02:	f7ef ff1d 	bl	8000b40 <__aeabi_dcmplt>
 8010d06:	b108      	cbz	r0, 8010d0c <moduleLOG+0x89c>
 8010d08:	201f      	movs	r0, #31
 8010d0a:	e48a      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 58.84763776) return 30;
 8010d0c:	4638      	mov	r0, r7
 8010d0e:	4631      	mov	r1, r6
 8010d10:	a3a3      	add	r3, pc, #652	; (adr r3, 8010fa0 <moduleLOG+0xb30>)
 8010d12:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d16:	f7ef ff13 	bl	8000b40 <__aeabi_dcmplt>
 8010d1a:	b108      	cbz	r0, 8010d20 <moduleLOG+0x8b0>
	else if(a < 59.95459277) return 30;
 8010d1c:	201e      	movs	r0, #30
 8010d1e:	e480      	b.n	8010622 <moduleLOG+0x1b2>
 8010d20:	4638      	mov	r0, r7
 8010d22:	4631      	mov	r1, r6
 8010d24:	a3a0      	add	r3, pc, #640	; (adr r3, 8010fa8 <moduleLOG+0xb38>)
 8010d26:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d2a:	f7ef ff09 	bl	8000b40 <__aeabi_dcmplt>
 8010d2e:	2800      	cmp	r0, #0
 8010d30:	d1f4      	bne.n	8010d1c <moduleLOG+0x8ac>
	else if(a < 61.04917774) return 29;
 8010d32:	4638      	mov	r0, r7
 8010d34:	4631      	mov	r1, r6
 8010d36:	a39e      	add	r3, pc, #632	; (adr r3, 8010fb0 <moduleLOG+0xb40>)
 8010d38:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d3c:	f7ef ff00 	bl	8000b40 <__aeabi_dcmplt>
 8010d40:	b108      	cbz	r0, 8010d46 <moduleLOG+0x8d6>
 8010d42:	201d      	movs	r0, #29
 8010d44:	e46d      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 62.13216659) return 28;
 8010d46:	4638      	mov	r0, r7
 8010d48:	4631      	mov	r1, r6
 8010d4a:	a39b      	add	r3, pc, #620	; (adr r3, 8010fb8 <moduleLOG+0xb48>)
 8010d4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d50:	f7ef fef6 	bl	8000b40 <__aeabi_dcmplt>
 8010d54:	b108      	cbz	r0, 8010d5a <moduleLOG+0x8ea>
 8010d56:	201c      	movs	r0, #28
 8010d58:	e463      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 63.20427479) return 27;
 8010d5a:	4638      	mov	r0, r7
 8010d5c:	4631      	mov	r1, r6
 8010d5e:	a398      	add	r3, pc, #608	; (adr r3, 8010fc0 <moduleLOG+0xb50>)
 8010d60:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d64:	f7ef feec 	bl	8000b40 <__aeabi_dcmplt>
 8010d68:	b108      	cbz	r0, 8010d6e <moduleLOG+0x8fe>
 8010d6a:	201b      	movs	r0, #27
 8010d6c:	e459      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 64.26616523) return 26;
 8010d6e:	4638      	mov	r0, r7
 8010d70:	4631      	mov	r1, r6
 8010d72:	a395      	add	r3, pc, #596	; (adr r3, 8010fc8 <moduleLOG+0xb58>)
 8010d74:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d78:	f7ef fee2 	bl	8000b40 <__aeabi_dcmplt>
 8010d7c:	b108      	cbz	r0, 8010d82 <moduleLOG+0x912>
 8010d7e:	201a      	movs	r0, #26
 8010d80:	e44f      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 65.31845310) return 25;
 8010d82:	4638      	mov	r0, r7
 8010d84:	4631      	mov	r1, r6
 8010d86:	a392      	add	r3, pc, #584	; (adr r3, 8010fd0 <moduleLOG+0xb60>)
 8010d88:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010d8c:	f7ef fed8 	bl	8000b40 <__aeabi_dcmplt>
 8010d90:	b108      	cbz	r0, 8010d96 <moduleLOG+0x926>
 8010d92:	2019      	movs	r0, #25
 8010d94:	e445      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 66.36171008) return 24;
 8010d96:	4638      	mov	r0, r7
 8010d98:	4631      	mov	r1, r6
 8010d9a:	a38f      	add	r3, pc, #572	; (adr r3, 8010fd8 <moduleLOG+0xb68>)
 8010d9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010da0:	f7ef fece 	bl	8000b40 <__aeabi_dcmplt>
 8010da4:	b108      	cbz	r0, 8010daa <moduleLOG+0x93a>
 8010da6:	2018      	movs	r0, #24
 8010da8:	e43b      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 67.39646774) return 23;
 8010daa:	4638      	mov	r0, r7
 8010dac:	4631      	mov	r1, r6
 8010dae:	a38c      	add	r3, pc, #560	; (adr r3, 8010fe0 <moduleLOG+0xb70>)
 8010db0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010db4:	f7ef fec4 	bl	8000b40 <__aeabi_dcmplt>
 8010db8:	b108      	cbz	r0, 8010dbe <moduleLOG+0x94e>
 8010dba:	2017      	movs	r0, #23
 8010dbc:	e431      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 68.42322022) return 22;
 8010dbe:	4638      	mov	r0, r7
 8010dc0:	4631      	mov	r1, r6
 8010dc2:	a389      	add	r3, pc, #548	; (adr r3, 8010fe8 <moduleLOG+0xb78>)
 8010dc4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010dc8:	f7ef feba 	bl	8000b40 <__aeabi_dcmplt>
 8010dcc:	b108      	cbz	r0, 8010dd2 <moduleLOG+0x962>
 8010dce:	2016      	movs	r0, #22
 8010dd0:	e427      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 69.44242631) return 21;
 8010dd2:	4638      	mov	r0, r7
 8010dd4:	4631      	mov	r1, r6
 8010dd6:	a386      	add	r3, pc, #536	; (adr r3, 8010ff0 <moduleLOG+0xb80>)
 8010dd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010ddc:	f7ef feb0 	bl	8000b40 <__aeabi_dcmplt>
 8010de0:	b108      	cbz	r0, 8010de6 <moduleLOG+0x976>
 8010de2:	2015      	movs	r0, #21
 8010de4:	e41d      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 70.45451075) return 20;
 8010de6:	4638      	mov	r0, r7
 8010de8:	4631      	mov	r1, r6
 8010dea:	a383      	add	r3, pc, #524	; (adr r3, 8010ff8 <moduleLOG+0xb88>)
 8010dec:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010df0:	f7ef fea6 	bl	8000b40 <__aeabi_dcmplt>
 8010df4:	b108      	cbz	r0, 8010dfa <moduleLOG+0x98a>
 8010df6:	2014      	movs	r0, #20
 8010df8:	e413      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 71.45986473) return 19;
 8010dfa:	4638      	mov	r0, r7
 8010dfc:	4631      	mov	r1, r6
 8010dfe:	a380      	add	r3, pc, #512	; (adr r3, 8011000 <moduleLOG+0xb90>)
 8010e00:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010e04:	f7ef fe9c 	bl	8000b40 <__aeabi_dcmplt>
 8010e08:	b108      	cbz	r0, 8010e0e <moduleLOG+0x99e>
 8010e0a:	2013      	movs	r0, #19
 8010e0c:	e409      	b.n	8010622 <moduleLOG+0x1b2>
	else if(a < 72.45884545) return 18;
 8010e0e:	4638      	mov	r0, r7
 8010e10:	4631      	mov	r1, r6
 8010e12:	a37d      	add	r3, pc, #500	; (adr r3, 8011008 <moduleLOG+0xb98>)
 8010e14:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010e18:	f7ef fe92 	bl	8000b40 <__aeabi_dcmplt>
 8010e1c:	b110      	cbz	r0, 8010e24 <moduleLOG+0x9b4>
 8010e1e:	2012      	movs	r0, #18
 8010e20:	f7ff bbff 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 73.45177442) return 17;
 8010e24:	4638      	mov	r0, r7
 8010e26:	4631      	mov	r1, r6
 8010e28:	a379      	add	r3, pc, #484	; (adr r3, 8011010 <moduleLOG+0xba0>)
 8010e2a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010e2e:	f7ef fe87 	bl	8000b40 <__aeabi_dcmplt>
 8010e32:	b110      	cbz	r0, 8010e3a <moduleLOG+0x9ca>
 8010e34:	2011      	movs	r0, #17
 8010e36:	f7ff bbf4 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 74.43893416) return 16;
 8010e3a:	4638      	mov	r0, r7
 8010e3c:	4631      	mov	r1, r6
 8010e3e:	a376      	add	r3, pc, #472	; (adr r3, 8011018 <moduleLOG+0xba8>)
 8010e40:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010e44:	f7ef fe7c 	bl	8000b40 <__aeabi_dcmplt>
 8010e48:	b110      	cbz	r0, 8010e50 <moduleLOG+0x9e0>
 8010e4a:	2010      	movs	r0, #16
 8010e4c:	f7ff bbe9 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 75.42056257) return 15;
 8010e50:	4638      	mov	r0, r7
 8010e52:	4631      	mov	r1, r6
 8010e54:	a372      	add	r3, pc, #456	; (adr r3, 8011020 <moduleLOG+0xbb0>)
 8010e56:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010e5a:	f7ef fe71 	bl	8000b40 <__aeabi_dcmplt>
 8010e5e:	b110      	cbz	r0, 8010e66 <moduleLOG+0x9f6>
 8010e60:	200f      	movs	r0, #15
 8010e62:	f7ff bbde 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 76.39684391) return 14;
 8010e66:	4638      	mov	r0, r7
 8010e68:	4631      	mov	r1, r6
 8010e6a:	a36f      	add	r3, pc, #444	; (adr r3, 8011028 <moduleLOG+0xbb8>)
 8010e6c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010e70:	f7ef fe66 	bl	8000b40 <__aeabi_dcmplt>
 8010e74:	b110      	cbz	r0, 8010e7c <moduleLOG+0xa0c>
 8010e76:	200e      	movs	r0, #14
 8010e78:	f7ff bbd3 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 77.36789461) return 13;
 8010e7c:	4638      	mov	r0, r7
 8010e7e:	4631      	mov	r1, r6
 8010e80:	a36b      	add	r3, pc, #428	; (adr r3, 8011030 <moduleLOG+0xbc0>)
 8010e82:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010e86:	f7ef fe5b 	bl	8000b40 <__aeabi_dcmplt>
 8010e8a:	b110      	cbz	r0, 8010e92 <moduleLOG+0xa22>
 8010e8c:	200d      	movs	r0, #13
 8010e8e:	f7ff bbc8 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 78.33374083) return 12;
 8010e92:	4638      	mov	r0, r7
 8010e94:	4631      	mov	r1, r6
 8010e96:	a368      	add	r3, pc, #416	; (adr r3, 8011038 <moduleLOG+0xbc8>)
 8010e98:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010e9c:	f7ef fe50 	bl	8000b40 <__aeabi_dcmplt>
 8010ea0:	b110      	cbz	r0, 8010ea8 <moduleLOG+0xa38>
 8010ea2:	200c      	movs	r0, #12
 8010ea4:	f7ff bbbd 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 79.29428225) return 11;
 8010ea8:	4638      	mov	r0, r7
 8010eaa:	4631      	mov	r1, r6
 8010eac:	a364      	add	r3, pc, #400	; (adr r3, 8011040 <moduleLOG+0xbd0>)
 8010eae:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010eb2:	f7ef fe45 	bl	8000b40 <__aeabi_dcmplt>
 8010eb6:	b110      	cbz	r0, 8010ebe <moduleLOG+0xa4e>
 8010eb8:	200b      	movs	r0, #11
 8010eba:	f7ff bbb2 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 80.24923213) return 10;
 8010ebe:	4638      	mov	r0, r7
 8010ec0:	4631      	mov	r1, r6
 8010ec2:	a361      	add	r3, pc, #388	; (adr r3, 8011048 <moduleLOG+0xbd8>)
 8010ec4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010ec8:	f7ef fe3a 	bl	8000b40 <__aeabi_dcmplt>
 8010ecc:	b110      	cbz	r0, 8010ed4 <moduleLOG+0xa64>
 8010ece:	200a      	movs	r0, #10
 8010ed0:	f7ff bba7 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 81.19801349) return 9;
 8010ed4:	4638      	mov	r0, r7
 8010ed6:	4631      	mov	r1, r6
 8010ed8:	a35d      	add	r3, pc, #372	; (adr r3, 8011050 <moduleLOG+0xbe0>)
 8010eda:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010ede:	f7ef fe2f 	bl	8000b40 <__aeabi_dcmplt>
 8010ee2:	b110      	cbz	r0, 8010eea <moduleLOG+0xa7a>
 8010ee4:	2009      	movs	r0, #9
 8010ee6:	f7ff bb9c 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 82.13956981) return 8;
 8010eea:	4638      	mov	r0, r7
 8010eec:	4631      	mov	r1, r6
 8010eee:	a35a      	add	r3, pc, #360	; (adr r3, 8011058 <moduleLOG+0xbe8>)
 8010ef0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010ef4:	f7ef fe24 	bl	8000b40 <__aeabi_dcmplt>
 8010ef8:	b110      	cbz	r0, 8010f00 <moduleLOG+0xa90>
 8010efa:	2008      	movs	r0, #8
 8010efc:	f7ff bb91 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 83.07199445) return 7;
 8010f00:	4638      	mov	r0, r7
 8010f02:	4631      	mov	r1, r6
 8010f04:	a356      	add	r3, pc, #344	; (adr r3, 8011060 <moduleLOG+0xbf0>)
 8010f06:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010f0a:	f7ef fe19 	bl	8000b40 <__aeabi_dcmplt>
 8010f0e:	b110      	cbz	r0, 8010f16 <moduleLOG+0xaa6>
 8010f10:	2007      	movs	r0, #7
 8010f12:	f7ff bb86 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 83.99173563) return 6;
 8010f16:	4638      	mov	r0, r7
 8010f18:	4631      	mov	r1, r6
 8010f1a:	a353      	add	r3, pc, #332	; (adr r3, 8011068 <moduleLOG+0xbf8>)
 8010f1c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010f20:	f7ef fe0e 	bl	8000b40 <__aeabi_dcmplt>
 8010f24:	b110      	cbz	r0, 8010f2c <moduleLOG+0xabc>
 8010f26:	2006      	movs	r0, #6
 8010f28:	f7ff bb7b 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 84.89166191) return 5;
 8010f2c:	4638      	mov	r0, r7
 8010f2e:	4631      	mov	r1, r6
 8010f30:	a34f      	add	r3, pc, #316	; (adr r3, 8011070 <moduleLOG+0xc00>)
 8010f32:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010f36:	f7ef fe03 	bl	8000b40 <__aeabi_dcmplt>
 8010f3a:	b110      	cbz	r0, 8010f42 <moduleLOG+0xad2>
 8010f3c:	2005      	movs	r0, #5
 8010f3e:	f7ff bb70 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 85.75541621) return 4;
 8010f42:	4638      	mov	r0, r7
 8010f44:	4631      	mov	r1, r6
 8010f46:	a34c      	add	r3, pc, #304	; (adr r3, 8011078 <moduleLOG+0xc08>)
 8010f48:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010f4c:	f7ef fdf8 	bl	8000b40 <__aeabi_dcmplt>
 8010f50:	b110      	cbz	r0, 8010f58 <moduleLOG+0xae8>
 8010f52:	2004      	movs	r0, #4
 8010f54:	f7ff bb65 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 86.53536998) return 3;
 8010f58:	4638      	mov	r0, r7
 8010f5a:	4631      	mov	r1, r6
 8010f5c:	a348      	add	r3, pc, #288	; (adr r3, 8011080 <moduleLOG+0xc10>)
 8010f5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010f62:	f7ef fded 	bl	8000b40 <__aeabi_dcmplt>
 8010f66:	b110      	cbz	r0, 8010f6e <moduleLOG+0xafe>
 8010f68:	2003      	movs	r0, #3
 8010f6a:	f7ff bb5a 	b.w	8010622 <moduleLOG+0x1b2>
	else if(a < 87.00000000) return 2;
 8010f6e:	4638      	mov	r0, r7
 8010f70:	4631      	mov	r1, r6
 8010f72:	a345      	add	r3, pc, #276	; (adr r3, 8011088 <moduleLOG+0xc18>)
 8010f74:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010f78:	f7ef fde2 	bl	8000b40 <__aeabi_dcmplt>
 8010f7c:	2800      	cmp	r0, #0
 8010f7e:	bf14      	ite	ne
 8010f80:	2002      	movne	r0, #2
 8010f82:	2001      	moveq	r0, #1
 8010f84:	f7ff bb4d 	b.w	8010622 <moduleLOG+0x1b2>
 8010f88:	edb42308 	.word	0xedb42308
 8010f8c:	404bb8cd 	.word	0x404bb8cd
 8010f90:	91e94c09 	.word	0x91e94c09
 8010f94:	404c4bed 	.word	0x404c4bed
 8010f98:	da5b80af 	.word	0xda5b80af
 8010f9c:	404cdd1d 	.word	0x404cdd1d
 8010fa0:	64e50700 	.word	0x64e50700
 8010fa4:	404d6c7f 	.word	0x404d6c7f
 8010fa8:	188c12f3 	.word	0x188c12f3
 8010fac:	404dfa30 	.word	0x404dfa30
 8010fb0:	74c87edf 	.word	0x74c87edf
 8010fb4:	404e864b 	.word	0x404e864b
 8010fb8:	d5b6d640 	.word	0xd5b6d640
 8010fbc:	404f10ea 	.word	0x404f10ea
 8010fc0:	ad233940 	.word	0xad233940
 8010fc4:	404f9a25 	.word	0x404f9a25
 8010fc8:	d9e38bab 	.word	0xd9e38bab
 8010fcc:	40501108 	.word	0x40501108
 8010fd0:	891c73d4 	.word	0x891c73d4
 8010fd4:	40505461 	.word	0x40505461
 8010fd8:	42090ef2 	.word	0x42090ef2
 8010fdc:	40509726 	.word	0x40509726
 8010fe0:	ba3a4e05 	.word	0xba3a4e05
 8010fe4:	4050d95f 	.word	0x4050d95f
 8010fe8:	0a42f9fb 	.word	0x0a42f9fb
 8010fec:	40511b16 	.word	0x40511b16
 8010ff0:	b67115c2 	.word	0xb67115c2
 8010ff4:	40515c50 	.word	0x40515c50
 8010ff8:	b441bb8c 	.word	0xb441bb8c
 8010ffc:	40519d16 	.word	0x40519d16
 8011000:	6c79fbc5 	.word	0x6c79fbc5
 8011004:	4051dd6e 	.word	0x4051dd6e
 8011008:	b94e6ac7 	.word	0xb94e6ac7
 801100c:	40521d5d 	.word	0x40521d5d
 8011010:	df41c471 	.word	0xdf41c471
 8011014:	40525ce9 	.word	0x40525ce9
 8011018:	7f4d9306 	.word	0x7f4d9306
 801101c:	40529c17 	.word	0x40529c17
 8011020:	7f450497 	.word	0x7f450497
 8011024:	4052daea 	.word	0x4052daea
 8011028:	e3ffc446 	.word	0xe3ffc446
 801102c:	40531965 	.word	0x40531965
 8011030:	95d594c7 	.word	0x95d594c7
 8011034:	4053578b 	.word	0x4053578b
 8011038:	027f8c27 	.word	0x027f8c27
 801103c:	4053955c 	.word	0x4053955c
 8011040:	8537e2c5 	.word	0x8537e2c5
 8011044:	4053d2d5 	.word	0x4053d2d5
 8011048:	6b51dd98 	.word	0x6b51dd98
 801104c:	40540ff3 	.word	0x40540ff3
 8011050:	40c5ede0 	.word	0x40c5ede0
 8011054:	40544cac 	.word	0x40544cac
 8011058:	b6365d5f 	.word	0xb6365d5f
 801105c:	405488ee 	.word	0x405488ee
 8011060:	8e9c0f96 	.word	0x8e9c0f96
 8011064:	4054c49b 	.word	0x4054c49b
 8011068:	98b84830 	.word	0x98b84830
 801106c:	4054ff78 	.word	0x4054ff78
 8011070:	fd1da27d 	.word	0xfd1da27d
 8011074:	40553910 	.word	0x40553910
 8011078:	bd3b345f 	.word	0xbd3b345f
 801107c:	40557058 	.word	0x40557058
 8011080:	8072d70d 	.word	0x8072d70d
 8011084:	4055a243 	.word	0x4055a243
 8011088:	00000000 	.word	0x00000000
 801108c:	4055c000 	.word	0x4055c000

08011090 <Vector11C>:
  * Fast interrupt handler for AFSK (1200baud) modulation. It has has the
  * highest priority in order to provide an accurate low jitter modulation.
  */
CH_FAST_IRQ_HANDLER(STM32_TIM7_HANDLER)
{
	if(tim_msg->mod == MOD_AFSK) {
 8011090:	4b4d      	ldr	r3, [pc, #308]	; (80111c8 <Vector11C+0x138>)
 8011092:	681a      	ldr	r2, [r3, #0]
 8011094:	f892 3209 	ldrb.w	r3, [r2, #521]	; 0x209
 8011098:	2b04      	cmp	r3, #4
/**
  * Fast interrupt handler for AFSK (1200baud) modulation. It has has the
  * highest priority in order to provide an accurate low jitter modulation.
  */
CH_FAST_IRQ_HANDLER(STM32_TIM7_HANDLER)
{
 801109a:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(tim_msg->mod == MOD_AFSK) {
 801109c:	d007      	beq.n	80110ae <Vector11C+0x1e>
			//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
			current_sample_in_baud = 0;
			packet_pos++;
		}

	} else if(tim_msg->mod == MOD_2GFSK) {
 801109e:	2b02      	cmp	r3, #2
 80110a0:	d035      	beq.n	801110e <Vector11C+0x7e>

		//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));

	}

	TIM7->SR &= ~STM32_TIM_SR_UIF;						// Reset interrupt flag
 80110a2:	4a4a      	ldr	r2, [pc, #296]	; (80111cc <Vector11C+0x13c>)
 80110a4:	6913      	ldr	r3, [r2, #16]
 80110a6:	f023 0301 	bic.w	r3, r3, #1
 80110aa:	6113      	str	r3, [r2, #16]
 80110ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
  */
CH_FAST_IRQ_HANDLER(STM32_TIM7_HANDLER)
{
	if(tim_msg->mod == MOD_AFSK) {

		if(packet_pos == tim_msg->bin_len) { // Packet transmission finished
 80110ae:	4d48      	ldr	r5, [pc, #288]	; (80111d0 <Vector11C+0x140>)
 80110b0:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 80110b4:	6828      	ldr	r0, [r5, #0]
 80110b6:	4283      	cmp	r3, r0
 80110b8:	d050      	beq.n	801115c <Vector11C+0xcc>
			TIM7->CR1 &= ~STM32_TIM_CR1_CEN;	// Disable timer
			TIM7->SR &= ~STM32_TIM_SR_UIF;		// Reset interrupt flag
			return;
		}

		if(current_sample_in_baud == 0) {
 80110ba:	4c46      	ldr	r4, [pc, #280]	; (80111d4 <Vector11C+0x144>)
 80110bc:	6821      	ldr	r1, [r4, #0]
 80110be:	2900      	cmp	r1, #0
 80110c0:	d045      	beq.n	801114e <Vector11C+0xbe>
 80110c2:	4b45      	ldr	r3, [pc, #276]	; (80111d8 <Vector11C+0x148>)
 80110c4:	781b      	ldrb	r3, [r3, #0]
		}

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
 80110c6:	4e45      	ldr	r6, [pc, #276]	; (80111dc <Vector11C+0x14c>)
		MOD_GPIO_SET(tim_radio, (phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 80110c8:	4f45      	ldr	r7, [pc, #276]	; (80111e0 <Vector11C+0x150>)
		}

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
 80110ca:	6832      	ldr	r2, [r6, #0]
		MOD_GPIO_SET(tim_radio, (phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 80110cc:	683f      	ldr	r7, [r7, #0]
				current_byte = current_byte / 2;
			}
		}

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;
 80110ce:	f013 0f01 	tst.w	r3, #1
 80110d2:	f240 4ec3 	movw	lr, #1219	; 0x4c3
 80110d6:	f640 03bb 	movw	r3, #2235	; 0x8bb
 80110da:	bf18      	it	ne
 80110dc:	4673      	movne	r3, lr

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
 80110de:	4413      	add	r3, r2
		MOD_GPIO_SET(tim_radio, (phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 80110e0:	2f01      	cmp	r7, #1
		}

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
 80110e2:	6033      	str	r3, [r6, #0]
		MOD_GPIO_SET(tim_radio, (phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 80110e4:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80110e8:	d047      	beq.n	801117a <Vector11C+0xea>
 80110ea:	f013 0f01 	tst.w	r3, #1
 80110ee:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80110f2:	f003 0308 	and.w	r3, r3, #8
 80110f6:	bf14      	ite	ne
 80110f8:	2200      	movne	r2, #0
 80110fa:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 80110fe:	4e39      	ldr	r6, [pc, #228]	; (80111e4 <Vector11C+0x154>)
 8011100:	4313      	orrs	r3, r2
 8011102:	61b3      	str	r3, [r6, #24]

		current_sample_in_baud++;
 8011104:	3101      	adds	r1, #1

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
 8011106:	296b      	cmp	r1, #107	; 0x6b
 8011108:	d032      	beq.n	8011170 <Vector11C+0xe0>
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
		MOD_GPIO_SET(tim_radio, (phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)

		current_sample_in_baud++;
 801110a:	6021      	str	r1, [r4, #0]
 801110c:	e7c9      	b.n	80110a2 <Vector11C+0x12>
			packet_pos++;
		}

	} else if(tim_msg->mod == MOD_2GFSK) {

		if(gfsk_bit >= tim_msg->bin_len) { // Packet transmission finished
 801110e:	4836      	ldr	r0, [pc, #216]	; (80111e8 <Vector11C+0x158>)
 8011110:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 8011114:	6801      	ldr	r1, [r0, #0]
 8011116:	428b      	cmp	r3, r1
 8011118:	d920      	bls.n	801115c <Vector11C+0xcc>
			TIM7->CR1 &= ~STM32_TIM_CR1_CEN;	// Disable timer
			TIM7->SR &= ~STM32_TIM_SR_UIF;		// Reset interrupt flag
			return;
		}

		if((gfsk_bit & 7) == 0) { // Load up next byte
 801111a:	074b      	lsls	r3, r1, #29
 801111c:	d13b      	bne.n	8011196 <Vector11C+0x106>
			current_byte = tim_msg->msg[gfsk_bit >> 3];
 801111e:	08cb      	lsrs	r3, r1, #3
 8011120:	4c2d      	ldr	r4, [pc, #180]	; (80111d8 <Vector11C+0x148>)
 8011122:	5cd3      	ldrb	r3, [r2, r3]
 8011124:	7023      	strb	r3, [r4, #0]
		} else {
			current_byte = current_byte / 2; // Load next bit
		}

		MOD_GPIO_SET(tim_radio, current_byte & 0x1);
 8011126:	4a2e      	ldr	r2, [pc, #184]	; (80111e0 <Vector11C+0x150>)
 8011128:	6812      	ldr	r2, [r2, #0]
 801112a:	2a01      	cmp	r2, #1
 801112c:	d03d      	beq.n	80111aa <Vector11C+0x11a>
 801112e:	f013 0f01 	tst.w	r3, #1
 8011132:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8011136:	f003 0308 	and.w	r3, r3, #8
 801113a:	bf14      	ite	ne
 801113c:	2200      	movne	r2, #0
 801113e:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 8011142:	4c28      	ldr	r4, [pc, #160]	; (80111e4 <Vector11C+0x154>)
 8011144:	4313      	orrs	r3, r2
 8011146:	61a3      	str	r3, [r4, #24]
		gfsk_bit++;
 8011148:	3101      	adds	r1, #1
 801114a:	6001      	str	r1, [r0, #0]
 801114c:	e7a9      	b.n	80110a2 <Vector11C+0x12>
			TIM7->SR &= ~STM32_TIM_SR_UIF;		// Reset interrupt flag
			return;
		}

		if(current_sample_in_baud == 0) {
			if((packet_pos & 7) == 0) { // Load up next byte
 801114e:	0746      	lsls	r6, r0, #29
 8011150:	d126      	bne.n	80111a0 <Vector11C+0x110>
				current_byte = tim_msg->msg[packet_pos >> 3];
 8011152:	08c3      	lsrs	r3, r0, #3
 8011154:	4e20      	ldr	r6, [pc, #128]	; (80111d8 <Vector11C+0x148>)
 8011156:	5cd3      	ldrb	r3, [r2, r3]
 8011158:	7033      	strb	r3, [r6, #0]
 801115a:	e7b4      	b.n	80110c6 <Vector11C+0x36>
		}

	} else if(tim_msg->mod == MOD_2GFSK) {

		if(gfsk_bit >= tim_msg->bin_len) { // Packet transmission finished
			TIM7->CR1 &= ~STM32_TIM_CR1_CEN;	// Disable timer
 801115c:	4b1b      	ldr	r3, [pc, #108]	; (80111cc <Vector11C+0x13c>)
 801115e:	681a      	ldr	r2, [r3, #0]
 8011160:	f022 0201 	bic.w	r2, r2, #1
 8011164:	601a      	str	r2, [r3, #0]
			TIM7->SR &= ~STM32_TIM_SR_UIF;		// Reset interrupt flag
 8011166:	691a      	ldr	r2, [r3, #16]
 8011168:	f022 0201 	bic.w	r2, r2, #1
 801116c:	611a      	str	r2, [r3, #16]
 801116e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		current_sample_in_baud++;

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
			//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
			current_sample_in_baud = 0;
			packet_pos++;
 8011170:	3001      	adds	r0, #1

		current_sample_in_baud++;

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
			//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
			current_sample_in_baud = 0;
 8011172:	2300      	movs	r3, #0
			packet_pos++;
 8011174:	6028      	str	r0, [r5, #0]

		current_sample_in_baud++;

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
			//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
			current_sample_in_baud = 0;
 8011176:	6023      	str	r3, [r4, #0]
 8011178:	e793      	b.n	80110a2 <Vector11C+0x12>

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
		MOD_GPIO_SET(tim_radio, (phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 801117a:	f013 0f01 	tst.w	r3, #1
 801117e:	ea4f 3343 	mov.w	r3, r3, lsl #13
 8011182:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8011186:	bf14      	ite	ne
 8011188:	2200      	movne	r2, #0
 801118a:	f04f 5200 	moveq.w	r2, #536870912	; 0x20000000
 801118e:	4e17      	ldr	r6, [pc, #92]	; (80111ec <Vector11C+0x15c>)
 8011190:	4313      	orrs	r3, r2
 8011192:	61b3      	str	r3, [r6, #24]
 8011194:	e7b6      	b.n	8011104 <Vector11C+0x74>
		}

		if((gfsk_bit & 7) == 0) { // Load up next byte
			current_byte = tim_msg->msg[gfsk_bit >> 3];
		} else {
			current_byte = current_byte / 2; // Load next bit
 8011196:	4a10      	ldr	r2, [pc, #64]	; (80111d8 <Vector11C+0x148>)
 8011198:	7813      	ldrb	r3, [r2, #0]
 801119a:	085b      	lsrs	r3, r3, #1
 801119c:	7013      	strb	r3, [r2, #0]
 801119e:	e7c2      	b.n	8011126 <Vector11C+0x96>

		if(current_sample_in_baud == 0) {
			if((packet_pos & 7) == 0) { // Load up next byte
				current_byte = tim_msg->msg[packet_pos >> 3];
			} else { // Load up next bit
				current_byte = current_byte / 2;
 80111a0:	4a0d      	ldr	r2, [pc, #52]	; (80111d8 <Vector11C+0x148>)
 80111a2:	7813      	ldrb	r3, [r2, #0]
 80111a4:	085b      	lsrs	r3, r3, #1
 80111a6:	7013      	strb	r3, [r2, #0]
 80111a8:	e78d      	b.n	80110c6 <Vector11C+0x36>
			current_byte = tim_msg->msg[gfsk_bit >> 3];
		} else {
			current_byte = current_byte / 2; // Load next bit
		}

		MOD_GPIO_SET(tim_radio, current_byte & 0x1);
 80111aa:	f013 0f01 	tst.w	r3, #1
 80111ae:	ea4f 3343 	mov.w	r3, r3, lsl #13
 80111b2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80111b6:	bf14      	ite	ne
 80111b8:	2200      	movne	r2, #0
 80111ba:	f04f 5200 	moveq.w	r2, #536870912	; 0x20000000
 80111be:	4c0b      	ldr	r4, [pc, #44]	; (80111ec <Vector11C+0x15c>)
 80111c0:	4313      	orrs	r3, r2
 80111c2:	61a3      	str	r3, [r4, #24]
 80111c4:	e7c0      	b.n	8011148 <Vector11C+0xb8>
 80111c6:	bf00      	nop
 80111c8:	20027e10 	.word	0x20027e10
 80111cc:	40001400 	.word	0x40001400
 80111d0:	20027df8 	.word	0x20027df8
 80111d4:	20027e04 	.word	0x20027e04
 80111d8:	20027e00 	.word	0x20027e00
 80111dc:	20027e38 	.word	0x20027e38
 80111e0:	20027e0c 	.word	0x20027e0c
 80111e4:	40021800 	.word	0x40021800
 80111e8:	20027dfc 	.word	0x20027dfc
 80111ec:	40020c00 	.word	0x40020c00

080111f0 <serial_cb>:
static uint32_t txj;		// Bytecounter
static radio_t fsk_radio;	// Current radio
static radioMSG_t *fsk_msg;	// Current message
static virtual_timer_t vt;

static void serial_cb(void *arg) {
 80111f0:	b570      	push	{r4, r5, r6, lr}
	(void)arg;

	switch(txs)
 80111f2:	4a6a      	ldr	r2, [pc, #424]	; (801139c <serial_cb+0x1ac>)
 80111f4:	7811      	ldrb	r1, [r2, #0]
 80111f6:	1f8b      	subs	r3, r1, #6
 80111f8:	2b03      	cmp	r3, #3
 80111fa:	f200 8092 	bhi.w	8011322 <serial_cb+0x132>
 80111fe:	e8df f003 	tbb	[pc, r3]
 8011202:	7057      	.short	0x7057
 8011204:	0236      	.short	0x0236
				txs = 9;
			}
			break;

		case 9:
			if(fsk_msg->fsk_config->stopbits == 2)
 8011206:	4c66      	ldr	r4, [pc, #408]	; (80113a0 <serial_cb+0x1b0>)
 8011208:	6823      	ldr	r3, [r4, #0]
 801120a:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 801120e:	785b      	ldrb	r3, [r3, #1]
 8011210:	2b02      	cmp	r3, #2
 8011212:	f000 80a6 	beq.w	8011362 <serial_cb+0x172>
				MOD_GPIO_SET(fsk_radio, HIGH); // Stop Bit
			txs = 7;
 8011216:	2307      	movs	r3, #7
 8011218:	7013      	strb	r3, [r2, #0]
 801121a:	2320      	movs	r3, #32
 801121c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8011220:	f7fd fd4e 	bl	800ecc0 <_dbg_check_lock_from_isr>
	}

	// Reload timer
	if(txs) {
		chSysLockFromISR();
		uint32_t delay = US2ST(1000000/fsk_msg->fsk_config->baud);
 8011224:	6823      	ldr	r3, [r4, #0]
 8011226:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 801122a:	889c      	ldrh	r4, [r3, #4]
 801122c:	f7fd fb10 	bl	800e850 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 8011230:	485c      	ldr	r0, [pc, #368]	; (80113a4 <serial_cb+0x1b4>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8011232:	68c3      	ldr	r3, [r0, #12]
 8011234:	b10b      	cbz	r3, 801123a <serial_cb+0x4a>
    chVTDoResetI(vtp);
 8011236:	f7fd fc13 	bl	800ea60 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 801123a:	f644 6220 	movw	r2, #20000	; 0x4e20
 801123e:	4b5a      	ldr	r3, [pc, #360]	; (80113a8 <serial_cb+0x1b8>)
 8011240:	fb93 f3f4 	sdiv	r3, r3, r4
 8011244:	fb02 f303 	mul.w	r3, r2, r3
 8011248:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
 801124c:	4957      	ldr	r1, [pc, #348]	; (80113ac <serial_cb+0x1bc>)
 801124e:	4a58      	ldr	r2, [pc, #352]	; (80113b0 <serial_cb+0x1c0>)
 8011250:	4854      	ldr	r0, [pc, #336]	; (80113a4 <serial_cb+0x1b4>)
 8011252:	f203 233f 	addw	r3, r3, #575	; 0x23f
 8011256:	fba1 3103 	umull	r3, r1, r1, r3
 801125a:	0c89      	lsrs	r1, r1, #18
 801125c:	2300      	movs	r3, #0
 801125e:	f7fd fc47 	bl	800eaf0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8011262:	f7fd fd15 	bl	800ec90 <_dbg_check_unlock_from_isr>
 8011266:	2300      	movs	r3, #0
 8011268:	f383 8811 	msr	BASEPRI, r3
 801126c:	bd70      	pop	{r4, r5, r6, pc}
				MOD_GPIO_SET(fsk_radio, HIGH);
			}
			break;

		case 8:
			if(txi < fsk_msg->fsk_config->bits) {
 801126e:	4c4c      	ldr	r4, [pc, #304]	; (80113a0 <serial_cb+0x1b0>)
 8011270:	4950      	ldr	r1, [pc, #320]	; (80113b4 <serial_cb+0x1c4>)
 8011272:	6820      	ldr	r0, [r4, #0]
 8011274:	680b      	ldr	r3, [r1, #0]
 8011276:	f8d0 0210 	ldr.w	r0, [r0, #528]	; 0x210
 801127a:	7800      	ldrb	r0, [r0, #0]
 801127c:	4298      	cmp	r0, r3
 801127e:	d961      	bls.n	8011344 <serial_cb+0x154>
				txi++;
				MOD_GPIO_SET(fsk_radio, txc & 1);
 8011280:	4a4d      	ldr	r2, [pc, #308]	; (80113b8 <serial_cb+0x1c8>)
 8011282:	6812      	ldr	r2, [r2, #0]
			}
			break;

		case 8:
			if(txi < fsk_msg->fsk_config->bits) {
				txi++;
 8011284:	3301      	adds	r3, #1
				MOD_GPIO_SET(fsk_radio, txc & 1);
 8011286:	2a01      	cmp	r2, #1
			}
			break;

		case 8:
			if(txi < fsk_msg->fsk_config->bits) {
				txi++;
 8011288:	600b      	str	r3, [r1, #0]
				MOD_GPIO_SET(fsk_radio, txc & 1);
 801128a:	4a4c      	ldr	r2, [pc, #304]	; (80113bc <serial_cb+0x1cc>)
 801128c:	d074      	beq.n	8011378 <serial_cb+0x188>
 801128e:	7813      	ldrb	r3, [r2, #0]
 8011290:	4d4b      	ldr	r5, [pc, #300]	; (80113c0 <serial_cb+0x1d0>)
 8011292:	f013 0f01 	tst.w	r3, #1
 8011296:	ea4f 01c3 	mov.w	r1, r3, lsl #3
 801129a:	bf14      	ite	ne
 801129c:	2000      	movne	r0, #0
 801129e:	f44f 2000 	moveq.w	r0, #524288	; 0x80000
 80112a2:	f001 0108 	and.w	r1, r1, #8
 80112a6:	4301      	orrs	r1, r0
 80112a8:	61a9      	str	r1, [r5, #24]
				txc = txc >> 1;
 80112aa:	085b      	lsrs	r3, r3, #1
 80112ac:	7013      	strb	r3, [r2, #0]
 80112ae:	e7b4      	b.n	801121a <serial_cb+0x2a>

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 80112b0:	4c3b      	ldr	r4, [pc, #236]	; (80113a0 <serial_cb+0x1b0>)
	(void)arg;

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
 80112b2:	4e44      	ldr	r6, [pc, #272]	; (80113c4 <serial_cb+0x1d4>)
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 80112b4:	6823      	ldr	r3, [r4, #0]
 80112b6:	4d44      	ldr	r5, [pc, #272]	; (80113c8 <serial_cb+0x1d8>)
 80112b8:	f8d3 1210 	ldr.w	r1, [r3, #528]	; 0x210
	(void)arg;

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
 80112bc:	6830      	ldr	r0, [r6, #0]
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 80112be:	884b      	ldrh	r3, [r1, #2]
 80112c0:	8889      	ldrh	r1, [r1, #4]
 80112c2:	fb01 f303 	mul.w	r3, r1, r3
 80112c6:	fb85 5103 	smull	r5, r1, r5, r3
 80112ca:	17db      	asrs	r3, r3, #31
 80112cc:	ebc3 13a1 	rsb	r3, r3, r1, asr #6
	(void)arg;

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
 80112d0:	1c41      	adds	r1, r0, #1
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 80112d2:	4299      	cmp	r1, r3
	(void)arg;

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
 80112d4:	6031      	str	r1, [r6, #0]
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 80112d6:	d9a0      	bls.n	801121a <serial_cb+0x2a>
				txj = 0;
 80112d8:	2100      	movs	r1, #0
				txs = 7;
 80112da:	2307      	movs	r3, #7
	switch(txs)
	{
		case 6: // TX-delay
			txj++;
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
				txj = 0;
 80112dc:	6031      	str	r1, [r6, #0]
				txs = 7;
 80112de:	7013      	strb	r3, [r2, #0]
 80112e0:	e79b      	b.n	801121a <serial_cb+0x2a>
			}
			break;

		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
 80112e2:	4c2f      	ldr	r4, [pc, #188]	; (80113a0 <serial_cb+0x1b0>)
 80112e4:	4937      	ldr	r1, [pc, #220]	; (80113c4 <serial_cb+0x1d4>)
 80112e6:	6820      	ldr	r0, [r4, #0]
 80112e8:	680b      	ldr	r3, [r1, #0]
 80112ea:	f8d0 5200 	ldr.w	r5, [r0, #512]	; 0x200
 80112ee:	ebb3 0fd5 	cmp.w	r3, r5, lsr #3
 80112f2:	d219      	bcs.n	8011328 <serial_cb+0x138>
				txc = fsk_msg->msg[txj]; // Select char
				txj++;
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
 80112f4:	4d30      	ldr	r5, [pc, #192]	; (80113b8 <serial_cb+0x1c8>)
			}
			break;

		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
				txc = fsk_msg->msg[txj]; // Select char
 80112f6:	5cc0      	ldrb	r0, [r0, r3]
				txj++;
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
 80112f8:	682d      	ldr	r5, [r5, #0]
			}
			break;

		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
				txc = fsk_msg->msg[txj]; // Select char
 80112fa:	4e30      	ldr	r6, [pc, #192]	; (80113bc <serial_cb+0x1cc>)
				txj++;
 80112fc:	3301      	adds	r3, #1
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
 80112fe:	2d01      	cmp	r5, #1
			break;

		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
				txc = fsk_msg->msg[txj]; // Select char
				txj++;
 8011300:	600b      	str	r3, [r1, #0]
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
 8011302:	bf0c      	ite	eq
 8011304:	4b31      	ldreq	r3, [pc, #196]	; (80113cc <serial_cb+0x1dc>)
 8011306:	4b2e      	ldrne	r3, [pc, #184]	; (80113c0 <serial_cb+0x1d0>)
			}
			break;

		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
				txc = fsk_msg->msg[txj]; // Select char
 8011308:	7030      	strb	r0, [r6, #0]
				txj++;
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
 801130a:	bf0c      	ite	eq
 801130c:	f04f 5100 	moveq.w	r1, #536870912	; 0x20000000
 8011310:	f44f 2100 	movne.w	r1, #524288	; 0x80000
 8011314:	6199      	str	r1, [r3, #24]
				txi = 0;
 8011316:	4927      	ldr	r1, [pc, #156]	; (80113b4 <serial_cb+0x1c4>)
 8011318:	2000      	movs	r0, #0
				txs = 8;
 801131a:	2308      	movs	r3, #8
		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
				txc = fsk_msg->msg[txj]; // Select char
				txj++;
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
				txi = 0;
 801131c:	6008      	str	r0, [r1, #0]
				txs = 8;
 801131e:	7013      	strb	r3, [r2, #0]
 8011320:	e77b      	b.n	801121a <serial_cb+0x2a>
				MOD_GPIO_SET(fsk_radio, HIGH); // Stop Bit
			txs = 7;
	}

	// Reload timer
	if(txs) {
 8011322:	2900      	cmp	r1, #0
 8011324:	d137      	bne.n	8011396 <serial_cb+0x1a6>
 8011326:	bd70      	pop	{r4, r5, r6, pc}
				txi = 0;
				txs = 8;
			} else {
				txj = 0;
				txs = 0; // Finished to transmit string
				MOD_GPIO_SET(fsk_radio, HIGH);
 8011328:	4b23      	ldr	r3, [pc, #140]	; (80113b8 <serial_cb+0x1c8>)
 801132a:	6818      	ldr	r0, [r3, #0]
				txj++;
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
				txi = 0;
				txs = 8;
			} else {
				txj = 0;
 801132c:	2300      	movs	r3, #0
				txs = 0; // Finished to transmit string
				MOD_GPIO_SET(fsk_radio, HIGH);
 801132e:	2801      	cmp	r0, #1
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
				txi = 0;
				txs = 8;
			} else {
				txj = 0;
				txs = 0; // Finished to transmit string
 8011330:	7013      	strb	r3, [r2, #0]
				txj++;
				MOD_GPIO_SET(fsk_radio, LOW); // Start Bit (Synchronizing)
				txi = 0;
				txs = 8;
			} else {
				txj = 0;
 8011332:	600b      	str	r3, [r1, #0]
				txs = 0; // Finished to transmit string
				MOD_GPIO_SET(fsk_radio, HIGH);
 8011334:	bf0b      	itete	eq
 8011336:	4b25      	ldreq	r3, [pc, #148]	; (80113cc <serial_cb+0x1dc>)
 8011338:	4b21      	ldrne	r3, [pc, #132]	; (80113c0 <serial_cb+0x1d0>)
 801133a:	f44f 5200 	moveq.w	r2, #8192	; 0x2000
 801133e:	2208      	movne	r2, #8
 8011340:	619a      	str	r2, [r3, #24]
 8011342:	bd70      	pop	{r4, r5, r6, pc}
			if(txi < fsk_msg->fsk_config->bits) {
				txi++;
				MOD_GPIO_SET(fsk_radio, txc & 1);
				txc = txc >> 1;
			} else {
				MOD_GPIO_SET(fsk_radio, HIGH); // Stop Bit
 8011344:	4b1c      	ldr	r3, [pc, #112]	; (80113b8 <serial_cb+0x1c8>)
 8011346:	681b      	ldr	r3, [r3, #0]
 8011348:	2b01      	cmp	r3, #1
 801134a:	bf0b      	itete	eq
 801134c:	4b1f      	ldreq	r3, [pc, #124]	; (80113cc <serial_cb+0x1dc>)
 801134e:	4b1c      	ldrne	r3, [pc, #112]	; (80113c0 <serial_cb+0x1d0>)
 8011350:	f44f 5000 	moveq.w	r0, #8192	; 0x2000
 8011354:	2008      	movne	r0, #8
 8011356:	6198      	str	r0, [r3, #24]
				txi = 0;
 8011358:	2000      	movs	r0, #0
				txs = 9;
 801135a:	2309      	movs	r3, #9
				txi++;
				MOD_GPIO_SET(fsk_radio, txc & 1);
				txc = txc >> 1;
			} else {
				MOD_GPIO_SET(fsk_radio, HIGH); // Stop Bit
				txi = 0;
 801135c:	6008      	str	r0, [r1, #0]
				txs = 9;
 801135e:	7013      	strb	r3, [r2, #0]
 8011360:	e75b      	b.n	801121a <serial_cb+0x2a>
			}
			break;

		case 9:
			if(fsk_msg->fsk_config->stopbits == 2)
				MOD_GPIO_SET(fsk_radio, HIGH); // Stop Bit
 8011362:	4b15      	ldr	r3, [pc, #84]	; (80113b8 <serial_cb+0x1c8>)
 8011364:	681b      	ldr	r3, [r3, #0]
 8011366:	2b01      	cmp	r3, #1
 8011368:	bf0b      	itete	eq
 801136a:	4b18      	ldreq	r3, [pc, #96]	; (80113cc <serial_cb+0x1dc>)
 801136c:	4b14      	ldrne	r3, [pc, #80]	; (80113c0 <serial_cb+0x1d0>)
 801136e:	f44f 5100 	moveq.w	r1, #8192	; 0x2000
 8011372:	2108      	movne	r1, #8
 8011374:	6199      	str	r1, [r3, #24]
 8011376:	e74e      	b.n	8011216 <serial_cb+0x26>
			break;

		case 8:
			if(txi < fsk_msg->fsk_config->bits) {
				txi++;
				MOD_GPIO_SET(fsk_radio, txc & 1);
 8011378:	7813      	ldrb	r3, [r2, #0]
 801137a:	4d14      	ldr	r5, [pc, #80]	; (80113cc <serial_cb+0x1dc>)
 801137c:	f013 0f01 	tst.w	r3, #1
 8011380:	ea4f 3143 	mov.w	r1, r3, lsl #13
 8011384:	bf14      	ite	ne
 8011386:	2000      	movne	r0, #0
 8011388:	f04f 5000 	moveq.w	r0, #536870912	; 0x20000000
 801138c:	f401 5100 	and.w	r1, r1, #8192	; 0x2000
 8011390:	4301      	orrs	r1, r0
 8011392:	61a9      	str	r1, [r5, #24]
 8011394:	e789      	b.n	80112aa <serial_cb+0xba>
 8011396:	4c02      	ldr	r4, [pc, #8]	; (80113a0 <serial_cb+0x1b0>)
 8011398:	e73f      	b.n	801121a <serial_cb+0x2a>
 801139a:	bf00      	nop
 801139c:	20027e20 	.word	0x20027e20
 80113a0:	20027e1c 	.word	0x20027e1c
 80113a4:	20027e24 	.word	0x20027e24
 80113a8:	000f4240 	.word	0x000f4240
 80113ac:	431bde83 	.word	0x431bde83
 80113b0:	080111f1 	.word	0x080111f1
 80113b4:	20027df4 	.word	0x20027df4
 80113b8:	20027e08 	.word	0x20027e08
 80113bc:	20027e21 	.word	0x20027e21
 80113c0:	40021800 	.word	0x40021800
 80113c4:	20027e14 	.word	0x20027e14
 80113c8:	10624dd3 	.word	0x10624dd3
 80113cc:	40020c00 	.word	0x40020c00

080113d0 <getAPRSRegionFrequency2m>:
/**
  * Returns APRS region specific frequency determined by GPS location. It will
  * use the APRS default frequency set in the config file if no GPS fix has
  * been received.
  */
uint32_t getAPRSRegionFrequency2m(void) {
 80113d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80113d2:	4b36      	ldr	r3, [pc, #216]	; (80114ac <getAPRSRegionFrequency2m+0xdc>)
	// Use this frequency for the rest of the world (unset regions, 144.800 MHz)
	uint32_t freq = APRS_FREQ_OTHER;

	// Position unknown
	if(!point->gps_lat && !point->gps_lon)
		freq = 0; // Use default frequency set in config file
 80113d4:	4c36      	ldr	r4, [pc, #216]	; (80114b0 <getAPRSRegionFrequency2m+0xe0>)
 80113d6:	681b      	ldr	r3, [r3, #0]

	// Use this frequency for the rest of the world (unset regions, 144.800 MHz)
	uint32_t freq = APRS_FREQ_OTHER;

	// Position unknown
	if(!point->gps_lat && !point->gps_lon)
 80113d8:	691d      	ldr	r5, [r3, #16]
 80113da:	695e      	ldr	r6, [r3, #20]
 80113dc:	b915      	cbnz	r5, 80113e4 <getAPRSRegionFrequency2m+0x14>
		freq = 0; // Use default frequency set in config file
 80113de:	2e00      	cmp	r6, #0
 80113e0:	bf08      	it	eq
 80113e2:	2400      	moveq	r4, #0
  * Determines if point is located in America
  * @param lat Latitude in deg*10000000
  * @param lat Longitude in deg*10000000
  */
bool isPointInAmerica(int32_t lat, int32_t lon) {
	return isPointInPolygon(america, sizeof(america)/sizeof(america[0]), lat, lon);
 80113e4:	4633      	mov	r3, r6
 80113e6:	462a      	mov	r2, r5
 80113e8:	211b      	movs	r1, #27
 80113ea:	4832      	ldr	r0, [pc, #200]	; (80114b4 <getAPRSRegionFrequency2m+0xe4>)
	
	// America 144.390 MHz
	if(isPointInAmerica(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_AMERICA;
 80113ec:	4f32      	ldr	r7, [pc, #200]	; (80114b8 <getAPRSRegionFrequency2m+0xe8>)
 80113ee:	f000 febf 	bl	8012170 <isPointInPolygon>
}
bool isPointInChina(int32_t lat, int32_t lon) {
	return isPointInPolygon(china, sizeof(china)/sizeof(china[0]), lat, lon);
 80113f2:	4633      	mov	r3, r6
 80113f4:	2800      	cmp	r0, #0
 80113f6:	bf18      	it	ne
 80113f8:	463c      	movne	r4, r7
 80113fa:	462a      	mov	r2, r5
 80113fc:	2183      	movs	r1, #131	; 0x83
 80113fe:	482f      	ldr	r0, [pc, #188]	; (80114bc <getAPRSRegionFrequency2m+0xec>)
 8011400:	f000 feb6 	bl	8012170 <isPointInPolygon>

	// China 144.640 MHz
	if(isPointInChina(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_CHINA;
 8011404:	4a2e      	ldr	r2, [pc, #184]	; (80114c0 <getAPRSRegionFrequency2m+0xf0>)
}
bool isPointInJapan(int32_t lat, int32_t lon) {
	return isPointInPolygon(japan, sizeof(japan)/sizeof(japan[0]), lat, lon);
 8011406:	4633      	mov	r3, r6
 8011408:	2800      	cmp	r0, #0
 801140a:	bf18      	it	ne
 801140c:	4614      	movne	r4, r2
 801140e:	210f      	movs	r1, #15
 8011410:	462a      	mov	r2, r5
 8011412:	482c      	ldr	r0, [pc, #176]	; (80114c4 <getAPRSRegionFrequency2m+0xf4>)
 8011414:	f000 feac 	bl	8012170 <isPointInPolygon>

	// Japan 144.660 MHz
	if(isPointInJapan(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_JAPAN;
 8011418:	4a2b      	ldr	r2, [pc, #172]	; (80114c8 <getAPRSRegionFrequency2m+0xf8>)
}
bool isPointInSouthkorea(int32_t lat, int32_t lon) {
	return isPointInPolygon(southkorea, sizeof(southkorea)/sizeof(southkorea[0]), lat, lon);
 801141a:	4633      	mov	r3, r6
 801141c:	2800      	cmp	r0, #0
 801141e:	bf18      	it	ne
 8011420:	4614      	movne	r4, r2
 8011422:	210a      	movs	r1, #10
 8011424:	462a      	mov	r2, r5
 8011426:	4829      	ldr	r0, [pc, #164]	; (80114cc <getAPRSRegionFrequency2m+0xfc>)
 8011428:	f000 fea2 	bl	8012170 <isPointInPolygon>

	// Southkorea 144.620 MHz
	if(isPointInSouthkorea(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_SOUTHKOREA;
 801142c:	4a28      	ldr	r2, [pc, #160]	; (80114d0 <getAPRSRegionFrequency2m+0x100>)
}
bool isPointInSoutheastAsia(int32_t lat, int32_t lon) {
	return isPointInPolygon(southeastAsia, sizeof(southeastAsia)/sizeof(southeastAsia[0]), lat, lon);
 801142e:	4633      	mov	r3, r6
 8011430:	2800      	cmp	r0, #0
 8011432:	bf18      	it	ne
 8011434:	4614      	movne	r4, r2
 8011436:	2124      	movs	r1, #36	; 0x24
 8011438:	462a      	mov	r2, r5
 801143a:	4826      	ldr	r0, [pc, #152]	; (80114d4 <getAPRSRegionFrequency2m+0x104>)
 801143c:	f000 fe98 	bl	8012170 <isPointInPolygon>
}
bool isPointInAustralia(int32_t lat, int32_t lon) {
	return isPointInPolygon(australia, sizeof(australia)/sizeof(australia[0]), lat, lon);
 8011440:	4633      	mov	r3, r6

	// Southkorea 144.620 MHz
	if(isPointInSoutheastAsia(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_SOUTHEASTASIA;
 8011442:	2800      	cmp	r0, #0
 8011444:	bf18      	it	ne
 8011446:	463c      	movne	r4, r7
 8011448:	462a      	mov	r2, r5
 801144a:	211c      	movs	r1, #28
 801144c:	4822      	ldr	r0, [pc, #136]	; (80114d8 <getAPRSRegionFrequency2m+0x108>)
 801144e:	f000 fe8f 	bl	8012170 <isPointInPolygon>

	// Australia 145.175 MHz
	if(isPointInAustralia(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_AUSTRALIA;
 8011452:	4a22      	ldr	r2, [pc, #136]	; (80114dc <getAPRSRegionFrequency2m+0x10c>)
}
bool isPointInNewZealand(int32_t lat, int32_t lon) {
	return isPointInPolygon(newzealand, sizeof(newzealand)/sizeof(newzealand[0]), lat, lon)
 8011454:	4633      	mov	r3, r6
 8011456:	2800      	cmp	r0, #0
 8011458:	bf18      	it	ne
 801145a:	4614      	movne	r4, r2
 801145c:	2110      	movs	r1, #16
 801145e:	462a      	mov	r2, r5
 8011460:	481f      	ldr	r0, [pc, #124]	; (80114e0 <getAPRSRegionFrequency2m+0x110>)
 8011462:	f000 fe85 	bl	8012170 <isPointInPolygon>
		|| isPointInPolygon(newzealand2, sizeof(newzealand2)/sizeof(newzealand2[0]), lat, lon);
 8011466:	b9f8      	cbnz	r0, 80114a8 <getAPRSRegionFrequency2m+0xd8>
 8011468:	4633      	mov	r3, r6
 801146a:	462a      	mov	r2, r5
 801146c:	2104      	movs	r1, #4
 801146e:	481d      	ldr	r0, [pc, #116]	; (80114e4 <getAPRSRegionFrequency2m+0x114>)
 8011470:	f000 fe7e 	bl	8012170 <isPointInPolygon>

	// Australia 144.575 MHz
	if(isPointInNewZealand(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_NEWZEALAND;
 8011474:	4b1c      	ldr	r3, [pc, #112]	; (80114e8 <getAPRSRegionFrequency2m+0x118>)
 8011476:	2800      	cmp	r0, #0
 8011478:	bf18      	it	ne
 801147a:	461c      	movne	r4, r3
}
bool isPointInArgentina(int32_t lat, int32_t lon) { // Also includes Uruguay and Paraguay
	return isPointInPolygon(argentina, sizeof(argentina)/sizeof(argentina[0]), lat, lon);
 801147c:	4633      	mov	r3, r6
 801147e:	462a      	mov	r2, r5
 8011480:	2182      	movs	r1, #130	; 0x82
 8011482:	481a      	ldr	r0, [pc, #104]	; (80114ec <getAPRSRegionFrequency2m+0x11c>)
 8011484:	f000 fe74 	bl	8012170 <isPointInPolygon>

	// Argentina/Paraguay/Uruguay 144.930 MHz
	if(isPointInArgentina(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_ARGENTINA;
 8011488:	4919      	ldr	r1, [pc, #100]	; (80114f0 <getAPRSRegionFrequency2m+0x120>)
}
bool isPointInBrazil(int32_t lat, int32_t lon) {
	return isPointInPolygon(brazil, sizeof(brazil)/sizeof(brazil[0]), lat, lon);
 801148a:	4633      	mov	r3, r6
 801148c:	2800      	cmp	r0, #0
 801148e:	bf18      	it	ne
 8011490:	460c      	movne	r4, r1
 8011492:	462a      	mov	r2, r5
 8011494:	219e      	movs	r1, #158	; 0x9e
 8011496:	4817      	ldr	r0, [pc, #92]	; (80114f4 <getAPRSRegionFrequency2m+0x124>)
 8011498:	f000 fe6a 	bl	8012170 <isPointInPolygon>

	// Brazil 145.575 MHz
	if(isPointInBrazil(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_BRAZIL;
 801149c:	4b16      	ldr	r3, [pc, #88]	; (80114f8 <getAPRSRegionFrequency2m+0x128>)

	return freq;
}
 801149e:	2800      	cmp	r0, #0
 80114a0:	bf0c      	ite	eq
 80114a2:	4620      	moveq	r0, r4
 80114a4:	4618      	movne	r0, r3
 80114a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if(isPointInAustralia(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_AUSTRALIA;

	// Australia 144.575 MHz
	if(isPointInNewZealand(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_NEWZEALAND;
 80114a8:	4c0f      	ldr	r4, [pc, #60]	; (80114e8 <getAPRSRegionFrequency2m+0x118>)
 80114aa:	e7e7      	b.n	801147c <getAPRSRegionFrequency2m+0xac>
 80114ac:	20027e3c 	.word	0x20027e3c
 80114b0:	08a17900 	.word	0x08a17900
 80114b4:	0801733c 	.word	0x0801733c
 80114b8:	089b3770 	.word	0x089b3770
 80114bc:	0801693c 	.word	0x0801693c
 80114c0:	089f0800 	.word	0x089f0800
 80114c4:	08016234 	.word	0x08016234
 80114c8:	089f5620 	.word	0x089f5620
 80114cc:	08017414 	.word	0x08017414
 80114d0:	089eb9e0 	.word	0x089eb9e0
 80114d4:	0801679c 	.word	0x0801679c
 80114d8:	0801725c 	.word	0x0801725c
 80114dc:	08a731d8 	.word	0x08a731d8
 80114e0:	080168bc 	.word	0x080168bc
 80114e4:	08016214 	.word	0x08016214
 80114e8:	089e0a18 	.word	0x089e0a18
 80114ec:	08016d54 	.word	0x08016d54
 80114f0:	08a374d0 	.word	0x08a374d0
 80114f4:	080162ac 	.word	0x080162ac
 80114f8:	08ad4c58 	.word	0x08ad4c58
 80114fc:	00000000 	.word	0x00000000

08011500 <flashSectorSize.part.1.lto_priv.168>:

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
        return 16 * 1024;
    else if (sector == 4)
 8011500:	2804      	cmp	r0, #4
 8011502:	d006      	beq.n	8011512 <flashSectorSize.part.1.lto_priv.168+0x12>
        return 64 * 1024;
    else if (sector >= 5 && sector <= 11)
 8011504:	3805      	subs	r0, #5
        return 128 * 1024;
    return 0;
 8011506:	2806      	cmp	r0, #6
 8011508:	bf94      	ite	ls
 801150a:	f44f 3000 	movls.w	r0, #131072	; 0x20000
 801150e:	2000      	movhi	r0, #0
 8011510:	4770      	bx	lr
size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
        return 16 * 1024;
    else if (sector == 4)
        return 64 * 1024;
 8011512:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    else if (sector >= 5 && sector <= 11)
        return 128 * 1024;
    return 0;
}
 8011516:	4770      	bx	lr
	...

08011520 <flashSectorAt>:
{
    return flashSectorBegin(sector + 1);
}

flashsector_t flashSectorAt(flashaddr_t address)
{
 8011520:	b538      	push	{r3, r4, r5, lr}
    flashsector_t sector = 0;
 8011522:	2400      	movs	r4, #0
    return address;
}

flashaddr_t flashSectorEnd(flashsector_t sector)
{
    return flashSectorBegin(sector + 1);
 8011524:	1c63      	adds	r3, r4, #1
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8011526:	f013 01ff 	ands.w	r1, r3, #255	; 0xff
{
    return flashSectorBegin(sector + 1);
}

flashsector_t flashSectorAt(flashaddr_t address)
{
 801152a:	4605      	mov	r5, r0
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 801152c:	d01a      	beq.n	8011564 <flashSectorAt+0x44>
 801152e:	460b      	mov	r3, r1
 8011530:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    {
        --sector;
 8011534:	3b01      	subs	r3, #1
 8011536:	b2db      	uxtb	r3, r3
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8011538:	2b03      	cmp	r3, #3
 801153a:	4618      	mov	r0, r3
 801153c:	d907      	bls.n	801154e <flashSectorAt+0x2e>
 801153e:	f7ff ffdf 	bl	8011500 <flashSectorSize.part.1.lto_priv.168>
flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
 8011542:	3b01      	subs	r3, #1
 8011544:	b2db      	uxtb	r3, r3
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8011546:	2b03      	cmp	r3, #3
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 8011548:	4402      	add	r2, r0
 801154a:	4618      	mov	r0, r3
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 801154c:	d8f7      	bhi.n	801153e <flashSectorAt+0x1e>
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 801154e:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8011552:	2b00      	cmp	r3, #0
 8011554:	d1ee      	bne.n	8011534 <flashSectorAt+0x14>
}

flashsector_t flashSectorAt(flashaddr_t address)
{
    flashsector_t sector = 0;
    while (address >= flashSectorEnd(sector))
 8011556:	4295      	cmp	r5, r2
 8011558:	d308      	bcc.n	801156c <flashSectorAt+0x4c>
    return address;
}

flashaddr_t flashSectorEnd(flashsector_t sector)
{
    return flashSectorBegin(sector + 1);
 801155a:	460c      	mov	r4, r1
 801155c:	1c63      	adds	r3, r4, #1
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 801155e:	f013 01ff 	ands.w	r1, r3, #255	; 0xff
 8011562:	d1e4      	bne.n	801152e <flashSectorAt+0xe>
    return 0;
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
 8011564:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
}

flashsector_t flashSectorAt(flashaddr_t address)
{
    flashsector_t sector = 0;
    while (address >= flashSectorEnd(sector))
 8011568:	4295      	cmp	r5, r2
 801156a:	d2f6      	bcs.n	801155a <flashSectorAt+0x3a>
        ++sector;
    return sector;
}
 801156c:	4620      	mov	r0, r4
 801156e:	bd38      	pop	{r3, r4, r5, pc}

08011570 <transmitOnRadio>:
}

/**
  * Sends radio message into message box. This method will return false if message box is full.
  */
bool transmitOnRadio(radioMSG_t *msg) {
 8011570:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011574:	4604      	mov	r4, r0
 8011576:	b086      	sub	sp, #24
	// Lock radio
	chMtxLock(&radio_mtx);
 8011578:	48b4      	ldr	r0, [pc, #720]	; (801184c <transmitOnRadio+0x2dc>)
 801157a:	f7fd fcb9 	bl	800eef0 <chMtxLock>

	// Determine suitable radio
	radio_t radio = 0;
	if(inRadio1band(msg->freq)) {
 801157e:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
 8011582:	4bb3      	ldr	r3, [pc, #716]	; (8011850 <transmitOnRadio+0x2e0>)
 8011584:	49b3      	ldr	r1, [pc, #716]	; (8011854 <transmitOnRadio+0x2e4>)
 8011586:	4413      	add	r3, r2
 8011588:	428b      	cmp	r3, r1
 801158a:	d969      	bls.n	8011660 <transmitOnRadio+0xf0>
		radio = RADIO_2M;
	} else if(inRadio2band(msg->freq)) {
 801158c:	4bb2      	ldr	r3, [pc, #712]	; (8011858 <transmitOnRadio+0x2e8>)
 801158e:	f501 0174 	add.w	r1, r1, #15990784	; 0xf40000
 8011592:	f501 5110 	add.w	r1, r1, #9216	; 0x2400
 8011596:	4413      	add	r3, r2
 8011598:	428b      	cmp	r3, r1
 801159a:	f240 80c6 	bls.w	801172a <transmitOnRadio+0x1ba>
		radioShutdown(radio); // Shutdown radio for reinitialization
		chMtxUnlock(&interference_mtx); // Heavy interference finished (HF)

	} else { // Error

		TRACE_ERROR("RAD  > No radio available for this frequency, %d.%03d MHz, %d dBm (%d), %s, %d bits",
 801159e:	48af      	ldr	r0, [pc, #700]	; (801185c <transmitOnRadio+0x2ec>)
 80115a0:	4eaf      	ldr	r6, [pc, #700]	; (8011860 <transmitOnRadio+0x2f0>)
 80115a2:	f7fd fca5 	bl	800eef0 <chMtxLock>
 80115a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80115aa:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 80115ae:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80115b0:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 80115b2:	4bac      	ldr	r3, [pc, #688]	; (8011864 <transmitOnRadio+0x2f4>)
 80115b4:	49ac      	ldr	r1, [pc, #688]	; (8011868 <transmitOnRadio+0x2f8>)
 80115b6:	48ad      	ldr	r0, [pc, #692]	; (801186c <transmitOnRadio+0x2fc>)
 80115b8:	fb07 f505 	mul.w	r5, r7, r5
 80115bc:	fba3 e505 	umull	lr, r5, r3, r5
 80115c0:	0bad      	lsrs	r5, r5, #14
 80115c2:	fba3 3202 	umull	r3, r2, r3, r2
 80115c6:	fba6 e305 	umull	lr, r3, r6, r5
 80115ca:	099b      	lsrs	r3, r3, #6
 80115cc:	fb07 5313 	mls	r3, r7, r3, r5
 80115d0:	0b92      	lsrs	r2, r2, #14
 80115d2:	f001 f885 	bl	80126e0 <chprintf.constprop.35>
 80115d6:	4aa6      	ldr	r2, [pc, #664]	; (8011870 <transmitOnRadio+0x300>)
 80115d8:	49a6      	ldr	r1, [pc, #664]	; (8011874 <transmitOnRadio+0x304>)
 80115da:	48a4      	ldr	r0, [pc, #656]	; (801186c <transmitOnRadio+0x2fc>)
 80115dc:	f001 f880 	bl	80126e0 <chprintf.constprop.35>
 80115e0:	f240 1373 	movw	r3, #371	; 0x173
 80115e4:	4aa4      	ldr	r2, [pc, #656]	; (8011878 <transmitOnRadio+0x308>)
 80115e6:	49a5      	ldr	r1, [pc, #660]	; (801187c <transmitOnRadio+0x30c>)
 80115e8:	48a0      	ldr	r0, [pc, #640]	; (801186c <transmitOnRadio+0x2fc>)
 80115ea:	f001 f879 	bl	80126e0 <chprintf.constprop.35>
 80115ee:	49a4      	ldr	r1, [pc, #656]	; (8011880 <transmitOnRadio+0x310>)
 80115f0:	489e      	ldr	r0, [pc, #632]	; (801186c <transmitOnRadio+0x2fc>)
 80115f2:	f001 f875 	bl	80126e0 <chprintf.constprop.35>
 80115f6:	f994 5208 	ldrsb.w	r5, [r4, #520]	; 0x208
 80115fa:	f8d4 7204 	ldr.w	r7, [r4, #516]	; 0x204
 80115fe:	4628      	mov	r0, r5
 8011600:	f7fe fba6 	bl	800fd50 <dBm2powerLvl>
 8011604:	4b9f      	ldr	r3, [pc, #636]	; (8011884 <transmitOnRadio+0x314>)
 8011606:	4aa0      	ldr	r2, [pc, #640]	; (8011888 <transmitOnRadio+0x318>)
 8011608:	9002      	str	r0, [sp, #8]
 801160a:	fba3 1307 	umull	r1, r3, r3, r7
 801160e:	0c9b      	lsrs	r3, r3, #18
 8011610:	fb02 7213 	mls	r2, r2, r3, r7
 8011614:	489d      	ldr	r0, [pc, #628]	; (801188c <transmitOnRadio+0x31c>)
 8011616:	f894 7209 	ldrb.w	r7, [r4, #521]	; 0x209
 801161a:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
 801161e:	f850 0027 	ldr.w	r0, [r0, r7, lsl #2]
 8011622:	9003      	str	r0, [sp, #12]
 8011624:	fba6 4202 	umull	r4, r2, r6, r2
 8011628:	0992      	lsrs	r2, r2, #6
 801162a:	9200      	str	r2, [sp, #0]
 801162c:	9104      	str	r1, [sp, #16]
 801162e:	2200      	movs	r2, #0
 8011630:	4997      	ldr	r1, [pc, #604]	; (8011890 <transmitOnRadio+0x320>)
 8011632:	9501      	str	r5, [sp, #4]
 8011634:	488d      	ldr	r0, [pc, #564]	; (801186c <transmitOnRadio+0x2fc>)
 8011636:	f001 f853 	bl	80126e0 <chprintf.constprop.35>
 801163a:	4996      	ldr	r1, [pc, #600]	; (8011894 <transmitOnRadio+0x324>)
 801163c:	488b      	ldr	r0, [pc, #556]	; (801186c <transmitOnRadio+0x2fc>)
 801163e:	f001 f84f 	bl	80126e0 <chprintf.constprop.35>
 8011642:	4886      	ldr	r0, [pc, #536]	; (801185c <transmitOnRadio+0x2ec>)
 8011644:	f7fd fbf4 	bl	800ee30 <chMtxUnlock>
 8011648:	f240 1173 	movw	r1, #371	; 0x173
 801164c:	488a      	ldr	r0, [pc, #552]	; (8011878 <transmitOnRadio+0x308>)
 801164e:	f7fe fc87 	bl	800ff60 <log_error>
		);

	}

	// Unlock radio
	chMtxUnlock(&radio_mtx);
 8011652:	487e      	ldr	r0, [pc, #504]	; (801184c <transmitOnRadio+0x2dc>)
 8011654:	f7fd fbec 	bl	800ee30 <chMtxUnlock>

	return true;
}
 8011658:	2001      	movs	r0, #1
 801165a:	b006      	add	sp, #24
 801165c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	chMtxLock(&radio_mtx);

	// Determine suitable radio
	radio_t radio = 0;
	if(inRadio1band(msg->freq)) {
		radio = RADIO_2M;
 8011660:	2501      	movs	r5, #1
	}

	if(radio) { // Radio found

		// Lock interference mutex
		chMtxLock(&interference_mtx);
 8011662:	488d      	ldr	r0, [pc, #564]	; (8011898 <transmitOnRadio+0x328>)

		TRACE_INFO(	"RAD  > Transmit radio %d, %d.%03d MHz, %d dBm (%d), %s, %d bits",
 8011664:	4e7e      	ldr	r6, [pc, #504]	; (8011860 <transmitOnRadio+0x2f0>)
	}

	if(radio) { // Radio found

		// Lock interference mutex
		chMtxLock(&interference_mtx);
 8011666:	f7fd fc43 	bl	800eef0 <chMtxLock>

		TRACE_INFO(	"RAD  > Transmit radio %d, %d.%03d MHz, %d dBm (%d), %s, %d bits",
 801166a:	487c      	ldr	r0, [pc, #496]	; (801185c <transmitOnRadio+0x2ec>)
 801166c:	f7fd fc40 	bl	800eef0 <chMtxLock>
 8011670:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8011674:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8011678:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801167a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 801167c:	4b79      	ldr	r3, [pc, #484]	; (8011864 <transmitOnRadio+0x2f4>)
 801167e:	497a      	ldr	r1, [pc, #488]	; (8011868 <transmitOnRadio+0x2f8>)
 8011680:	fb07 f000 	mul.w	r0, r7, r0
 8011684:	fba3 e000 	umull	lr, r0, r3, r0
 8011688:	0b80      	lsrs	r0, r0, #14
 801168a:	fba3 3202 	umull	r3, r2, r3, r2
 801168e:	fba6 e300 	umull	lr, r3, r6, r0
 8011692:	099b      	lsrs	r3, r3, #6
 8011694:	fb07 0313 	mls	r3, r7, r3, r0
 8011698:	0b92      	lsrs	r2, r2, #14
 801169a:	4874      	ldr	r0, [pc, #464]	; (801186c <transmitOnRadio+0x2fc>)
 801169c:	f001 f820 	bl	80126e0 <chprintf.constprop.35>
 80116a0:	4a7e      	ldr	r2, [pc, #504]	; (801189c <transmitOnRadio+0x32c>)
 80116a2:	4974      	ldr	r1, [pc, #464]	; (8011874 <transmitOnRadio+0x304>)
 80116a4:	4871      	ldr	r0, [pc, #452]	; (801186c <transmitOnRadio+0x2fc>)
 80116a6:	f001 f81b 	bl	80126e0 <chprintf.constprop.35>
 80116aa:	f240 1351 	movw	r3, #337	; 0x151
 80116ae:	4a72      	ldr	r2, [pc, #456]	; (8011878 <transmitOnRadio+0x308>)
 80116b0:	4972      	ldr	r1, [pc, #456]	; (801187c <transmitOnRadio+0x30c>)
 80116b2:	486e      	ldr	r0, [pc, #440]	; (801186c <transmitOnRadio+0x2fc>)
 80116b4:	f001 f814 	bl	80126e0 <chprintf.constprop.35>
 80116b8:	4971      	ldr	r1, [pc, #452]	; (8011880 <transmitOnRadio+0x310>)
 80116ba:	486c      	ldr	r0, [pc, #432]	; (801186c <transmitOnRadio+0x2fc>)
 80116bc:	f001 f810 	bl	80126e0 <chprintf.constprop.35>
 80116c0:	f994 7208 	ldrsb.w	r7, [r4, #520]	; 0x208
 80116c4:	f8d4 8204 	ldr.w	r8, [r4, #516]	; 0x204
 80116c8:	4638      	mov	r0, r7
 80116ca:	f7fe fb41 	bl	800fd50 <dBm2powerLvl>
 80116ce:	4b6d      	ldr	r3, [pc, #436]	; (8011884 <transmitOnRadio+0x314>)
 80116d0:	4a6d      	ldr	r2, [pc, #436]	; (8011888 <transmitOnRadio+0x318>)
 80116d2:	9002      	str	r0, [sp, #8]
 80116d4:	fba3 1308 	umull	r1, r3, r3, r8
 80116d8:	0c9b      	lsrs	r3, r3, #18
 80116da:	f894 0209 	ldrb.w	r0, [r4, #521]	; 0x209
 80116de:	496b      	ldr	r1, [pc, #428]	; (801188c <transmitOnRadio+0x31c>)
 80116e0:	9701      	str	r7, [sp, #4]
 80116e2:	fb02 8213 	mls	r2, r2, r3, r8
 80116e6:	fba6 6202 	umull	r6, r2, r6, r2
 80116ea:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 80116ee:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
 80116f2:	9104      	str	r1, [sp, #16]
 80116f4:	0992      	lsrs	r2, r2, #6
 80116f6:	9200      	str	r2, [sp, #0]
 80116f8:	9003      	str	r0, [sp, #12]
 80116fa:	462a      	mov	r2, r5
 80116fc:	4968      	ldr	r1, [pc, #416]	; (80118a0 <transmitOnRadio+0x330>)
 80116fe:	485b      	ldr	r0, [pc, #364]	; (801186c <transmitOnRadio+0x2fc>)
 8011700:	f000 ffee 	bl	80126e0 <chprintf.constprop.35>
 8011704:	4963      	ldr	r1, [pc, #396]	; (8011894 <transmitOnRadio+0x324>)
 8011706:	4859      	ldr	r0, [pc, #356]	; (801186c <transmitOnRadio+0x2fc>)
 8011708:	f000 ffea 	bl	80126e0 <chprintf.constprop.35>
 801170c:	4853      	ldr	r0, [pc, #332]	; (801185c <transmitOnRadio+0x2ec>)
 801170e:	f7fd fb8f 	bl	800ee30 <chMtxUnlock>
					radio, msg->freq/1000000, (msg->freq%1000000)/1000, msg->power,
					dBm2powerLvl(msg->power), VAL2MOULATION(msg->mod), msg->bin_len
		);
		
		switch(msg->mod) {
 8011712:	f894 3209 	ldrb.w	r3, [r4, #521]	; 0x209
 8011716:	2b04      	cmp	r3, #4
 8011718:	f200 811c 	bhi.w	8011954 <transmitOnRadio+0x3e4>
 801171c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8011720:	01680043 	.word	0x01680043
 8011724:	011c00da 	.word	0x011c00da
 8011728:	0007      	.short	0x0007
	// Determine suitable radio
	radio_t radio = 0;
	if(inRadio1band(msg->freq)) {
		radio = RADIO_2M;
	} else if(inRadio2band(msg->freq)) {
		radio = RADIO_70CM;
 801172a:	2502      	movs	r5, #2
 801172c:	e799      	b.n	8011662 <transmitOnRadio+0xf2>
		return 127;
	}
}

bool isRadioInitialized(radio_t radio) {
	return initialized[radio];
 801172e:	4e5d      	ldr	r6, [pc, #372]	; (80118a4 <transmitOnRadio+0x334>)
				break;
			case MOD_2GFSK:
				send2GFSK(radio, msg);
				break;
			case MOD_AFSK:
				if(!isRadioInitialized(radio))
 8011730:	5d77      	ldrb	r7, [r6, r5]
 8011732:	2f00      	cmp	r7, #0
 8011734:	f000 81d5 	beq.w	8011ae2 <transmitOnRadio+0x572>
static radioMSG_t *tim_msg;
static radio_t tim_radio;
static uint32_t gfsk_bit = 0;

void sendAFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
 8011738:	4a5b      	ldr	r2, [pc, #364]	; (80118a8 <transmitOnRadio+0x338>)
	tim_radio = radio;
 801173a:	4b5c      	ldr	r3, [pc, #368]	; (80118ac <transmitOnRadio+0x33c>)
static radioMSG_t *tim_msg;
static radio_t tim_radio;
static uint32_t gfsk_bit = 0;

void sendAFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
 801173c:	6014      	str	r4, [r2, #0]
	tim_radio = radio;

	phase_delta = PHASE_DELTA_1200;
	phase = 0;
	packet_pos = 0;
 801173e:	4f5c      	ldr	r7, [pc, #368]	; (80118b0 <transmitOnRadio+0x340>)
	current_sample_in_baud = 0;
 8011740:	495c      	ldr	r1, [pc, #368]	; (80118b4 <transmitOnRadio+0x344>)
	current_byte = 0;
 8011742:	4a5d      	ldr	r2, [pc, #372]	; (80118b8 <transmitOnRadio+0x348>)
void sendAFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
	tim_radio = radio;

	phase_delta = PHASE_DELTA_1200;
	phase = 0;
 8011744:	f8df e180 	ldr.w	lr, [pc, #384]	; 80118c8 <transmitOnRadio+0x358>
static radio_t tim_radio;
static uint32_t gfsk_bit = 0;

void sendAFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
	tim_radio = radio;
 8011748:	601d      	str	r5, [r3, #0]
	packet_pos = 0;
	current_sample_in_baud = 0;
	current_byte = 0;

	uint32_t initial_interval = 100; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 801174a:	485c      	ldr	r0, [pc, #368]	; (80118bc <transmitOnRadio+0x34c>)
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 801174c:	4c5c      	ldr	r4, [pc, #368]	; (80118c0 <transmitOnRadio+0x350>)
void sendAFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
	tim_radio = radio;

	phase_delta = PHASE_DELTA_1200;
	phase = 0;
 801174e:	2300      	movs	r3, #0
	packet_pos = 0;
 8011750:	603b      	str	r3, [r7, #0]
	current_sample_in_baud = 0;
 8011752:	600b      	str	r3, [r1, #0]
void sendAFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
	tim_radio = radio;

	phase_delta = PHASE_DELTA_1200;
	phase = 0;
 8011754:	f8ce 3000 	str.w	r3, [lr]
	packet_pos = 0;
	current_sample_in_baud = 0;
	current_byte = 0;
 8011758:	7013      	strb	r3, [r2, #0]

	uint32_t initial_interval = 100; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 801175a:	6c02      	ldr	r2, [r0, #64]	; 0x40

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 801175c:	4b59      	ldr	r3, [pc, #356]	; (80118c4 <transmitOnRadio+0x354>)
 801175e:	f042 0220 	orr.w	r2, r2, #32
 8011762:	6402      	str	r2, [r0, #64]	; 0x40
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8011764:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
	TIM7->PSC = 1;
 8011768:	2201      	movs	r2, #1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 801176a:	2710      	movs	r7, #16
	current_byte = 0;

	uint32_t initial_interval = 100; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 801176c:	2064      	movs	r0, #100	; 0x64
 801176e:	f883 7337 	strb.w	r7, [r3, #823]	; 0x337
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8011772:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8011776:	6059      	str	r1, [r3, #4]
 8011778:	62e0      	str	r0, [r4, #44]	; 0x2c
	TIM7->PSC = 1;
 801177a:	62a2      	str	r2, [r4, #40]	; 0x28
	TIM7->CR1 &= ~STM32_TIM_CR1_ARPE; /* ARR register is NOT buffered, allows to update timer's period on-fly. */
 801177c:	6823      	ldr	r3, [r4, #0]
 801177e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8011782:	6023      	str	r3, [r4, #0]
	TIM7->DIER |= STM32_TIM_DIER_UIE; /* Interrupt enable */
 8011784:	68e3      	ldr	r3, [r4, #12]
 8011786:	4313      	orrs	r3, r2
 8011788:	60e3      	str	r3, [r4, #12]
	TIM7->CR1 |= STM32_TIM_CR1_CEN; /* Counter enable */
 801178a:	6823      	ldr	r3, [r4, #0]
 801178c:	4313      	orrs	r3, r2
 801178e:	6023      	str	r3, [r4, #0]

	// Block execution while timer is running
	while(TIM7->CR1 & STM32_TIM_CR1_CEN)
 8011790:	6823      	ldr	r3, [r4, #0]
 8011792:	07da      	lsls	r2, r3, #31
 8011794:	f140 811d 	bpl.w	80119d2 <transmitOnRadio+0x462>
		chThdSleepMilliseconds(10);
 8011798:	20c8      	movs	r0, #200	; 0xc8
 801179a:	f7fd fc79 	bl	800f090 <chThdSleep>
	TIM7->CR1 &= ~STM32_TIM_CR1_ARPE; /* ARR register is NOT buffered, allows to update timer's period on-fly. */
	TIM7->DIER |= STM32_TIM_DIER_UIE; /* Interrupt enable */
	TIM7->CR1 |= STM32_TIM_CR1_CEN; /* Counter enable */

	// Block execution while timer is running
	while(TIM7->CR1 & STM32_TIM_CR1_CEN)
 801179e:	6823      	ldr	r3, [r4, #0]
 80117a0:	07db      	lsls	r3, r3, #31
 80117a2:	d4f9      	bmi.n	8011798 <transmitOnRadio+0x228>
 80117a4:	e115      	b.n	80119d2 <transmitOnRadio+0x462>
 80117a6:	4e3f      	ldr	r6, [pc, #252]	; (80118a4 <transmitOnRadio+0x334>)
				if(!isRadioInitialized(radio))
					initAFSK(radio, msg);
				sendAFSK(radio, msg);
				break;
			case MOD_OOK:
				if(!isRadioInitialized(radio))
 80117a8:	5d77      	ldrb	r7, [r6, r5]
 80117aa:	2f00      	cmp	r7, #0
 80117ac:	f000 818c 	beq.w	8011ac8 <transmitOnRadio+0x558>
 80117b0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  */
void sendOOK(radio_t radio, radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
 80117b4:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 80117b8:	6a50      	ldr	r0, [r2, #36]	; 0x24
 80117ba:	2b00      	cmp	r3, #0
 80117bc:	f000 8109 	beq.w	80119d2 <transmitOnRadio+0x462>
		MOD_GPIO_SET(radio, (msg->msg[bit/8] >> (bit%8)) & 0x1);
 80117c0:	f8df 8108 	ldr.w	r8, [pc, #264]	; 80118cc <transmitOnRadio+0x35c>
 80117c4:	f8df 9108 	ldr.w	r9, [pc, #264]	; 80118d0 <transmitOnRadio+0x360>
		bit++;

		time = chThdSleepUntilWindowed(time, time + MS2ST(1200 / msg->ook_config->speed));
 80117c8:	4f25      	ldr	r7, [pc, #148]	; (8011860 <transmitOnRadio+0x2f0>)
  */
void sendOOK(radio_t radio, radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
 80117ca:	f04f 0a00 	mov.w	sl, #0
 80117ce:	e026      	b.n	801181e <transmitOnRadio+0x2ae>
		MOD_GPIO_SET(radio, (msg->msg[bit/8] >> (bit%8)) & 0x1);
 80117d0:	f013 0f01 	tst.w	r3, #1
 80117d4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80117d8:	f003 0308 	and.w	r3, r3, #8
 80117dc:	bf0c      	ite	eq
 80117de:	f44f 2200 	moveq.w	r2, #524288	; 0x80000
 80117e2:	2200      	movne	r2, #0
 80117e4:	4313      	orrs	r3, r2
 80117e6:	f8c8 3018 	str.w	r3, [r8, #24]
		bit++;

		time = chThdSleepUntilWindowed(time, time + MS2ST(1200 / msg->ook_config->speed));
 80117ea:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
 80117ee:	f644 6320 	movw	r3, #20000	; 0x4e20
 80117f2:	7811      	ldrb	r1, [r2, #0]
 80117f4:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 80117f8:	fb92 f1f1 	sdiv	r1, r2, r1
 80117fc:	fb03 f101 	mul.w	r1, r3, r1
 8011800:	f201 31e7 	addw	r1, r1, #999	; 0x3e7
 8011804:	fba7 3101 	umull	r3, r1, r7, r1
 8011808:	eb00 1191 	add.w	r1, r0, r1, lsr #6
 801180c:	f7fd fc08 	bl	800f020 <chThdSleepUntilWindowed>
  */
void sendOOK(radio_t radio, radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
 8011810:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
		MOD_GPIO_SET(radio, (msg->msg[bit/8] >> (bit%8)) & 0x1);
		bit++;
 8011814:	f10a 0a01 	add.w	sl, sl, #1
  */
void sendOOK(radio_t radio, radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
 8011818:	459a      	cmp	sl, r3
 801181a:	f080 80da 	bcs.w	80119d2 <transmitOnRadio+0x462>
		MOD_GPIO_SET(radio, (msg->msg[bit/8] >> (bit%8)) & 0x1);
 801181e:	ea4f 02da 	mov.w	r2, sl, lsr #3
 8011822:	f00a 0307 	and.w	r3, sl, #7
 8011826:	5ca2      	ldrb	r2, [r4, r2]
 8011828:	2d01      	cmp	r5, #1
 801182a:	fa42 f303 	asr.w	r3, r2, r3
 801182e:	d1cf      	bne.n	80117d0 <transmitOnRadio+0x260>
 8011830:	f013 0f01 	tst.w	r3, #1
 8011834:	ea4f 3343 	mov.w	r3, r3, lsl #13
 8011838:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801183c:	bf0c      	ite	eq
 801183e:	f04f 5200 	moveq.w	r2, #536870912	; 0x20000000
 8011842:	2200      	movne	r2, #0
 8011844:	4313      	orrs	r3, r2
 8011846:	f8c9 3018 	str.w	r3, [r9, #24]
 801184a:	e7ce      	b.n	80117ea <transmitOnRadio+0x27a>
 801184c:	20005f18 	.word	0x20005f18
 8011850:	f76abc00 	.word	0xf76abc00
 8011854:	003d0900 	.word	0x003d0900
 8011858:	e65eb880 	.word	0xe65eb880
 801185c:	20027b2c 	.word	0x20027b2c
 8011860:	10624dd3 	.word	0x10624dd3
 8011864:	d1b71759 	.word	0xd1b71759
 8011868:	08013c50 	.word	0x08013c50
 801186c:	20027e60 	.word	0x20027e60
 8011870:	08013d9c 	.word	0x08013d9c
 8011874:	08013c5c 	.word	0x08013c5c
 8011878:	08016204 	.word	0x08016204
 801187c:	08013c78 	.word	0x08013c78
 8011880:	08013d00 	.word	0x08013d00
 8011884:	431bde83 	.word	0x431bde83
 8011888:	000f4240 	.word	0x000f4240
 801188c:	08017248 	.word	0x08017248
 8011890:	08017190 	.word	0x08017190
 8011894:	08013cac 	.word	0x08013cac
 8011898:	20027770 	.word	0x20027770
 801189c:	08013cfc 	.word	0x08013cfc
 80118a0:	080171e4 	.word	0x080171e4
 80118a4:	20027e18 	.word	0x20027e18
 80118a8:	20027e10 	.word	0x20027e10
 80118ac:	20027e0c 	.word	0x20027e0c
 80118b0:	20027df8 	.word	0x20027df8
 80118b4:	20027e04 	.word	0x20027e04
 80118b8:	20027e00 	.word	0x20027e00
 80118bc:	40023800 	.word	0x40023800
 80118c0:	40001400 	.word	0x40001400
 80118c4:	e000e100 	.word	0xe000e100
 80118c8:	20027e38 	.word	0x20027e38
 80118cc:	40021800 	.word	0x40021800
 80118d0:	40020c00 	.word	0x40020c00
	while(txs)
		chThdSleepMilliseconds(1);		// Wait for routine to finish
}

void send2GFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
 80118d4:	4989      	ldr	r1, [pc, #548]	; (8011afc <transmitOnRadio+0x58c>)
	tim_radio = radio;
	gfsk_bit = 0;
 80118d6:	4a8a      	ldr	r2, [pc, #552]	; (8011b00 <transmitOnRadio+0x590>)
	current_byte = 0;
 80118d8:	4b8a      	ldr	r3, [pc, #552]	; (8011b04 <transmitOnRadio+0x594>)
		chThdSleepMilliseconds(1);		// Wait for routine to finish
}

void send2GFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
	tim_radio = radio;
 80118da:	4f8b      	ldr	r7, [pc, #556]	; (8011b08 <transmitOnRadio+0x598>)
	while(txs)
		chThdSleepMilliseconds(1);		// Wait for routine to finish
}

void send2GFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
 80118dc:	600c      	str	r4, [r1, #0]
	tim_radio = radio;
	gfsk_bit = 0;
 80118de:	2600      	movs	r6, #0
	current_byte = 0;

	// Initialize radio and tune
	Si4464_Init(radio, MOD_2GFSK);
 80118e0:	2102      	movs	r1, #2
 80118e2:	4628      	mov	r0, r5
}

void send2GFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
	tim_radio = radio;
	gfsk_bit = 0;
 80118e4:	6016      	str	r6, [r2, #0]
	current_byte = 0;
 80118e6:	701e      	strb	r6, [r3, #0]
		chThdSleepMilliseconds(1);		// Wait for routine to finish
}

void send2GFSK(radio_t radio, radioMSG_t *msg) {
	tim_msg = msg;
	tim_radio = radio;
 80118e8:	603d      	str	r5, [r7, #0]
	gfsk_bit = 0;
	current_byte = 0;

	// Initialize radio and tune
	Si4464_Init(radio, MOD_2GFSK);
 80118ea:	f7f8 f991 	bl	8009c10 <Si4464_Init>
	radioTune(radio, msg->freq, 0, msg->power, 0);
 80118ee:	4632      	mov	r2, r6
 80118f0:	f994 3208 	ldrsb.w	r3, [r4, #520]	; 0x208
 80118f4:	f8d4 1204 	ldr.w	r1, [r4, #516]	; 0x204
	chThdSleepMilliseconds(30);

	uint32_t initial_interval = 1355; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 80118f8:	4c84      	ldr	r4, [pc, #528]	; (8011b0c <transmitOnRadio+0x59c>)
	gfsk_bit = 0;
	current_byte = 0;

	// Initialize radio and tune
	Si4464_Init(radio, MOD_2GFSK);
	radioTune(radio, msg->freq, 0, msg->power, 0);
 80118fa:	4628      	mov	r0, r5
 80118fc:	f7fc f848 	bl	800d990 <radioTune.constprop.18>
	chThdSleepMilliseconds(30);
 8011900:	f44f 7016 	mov.w	r0, #600	; 0x258
 8011904:	f7fd fbc4 	bl	800f090 <chThdSleep>

	uint32_t initial_interval = 1355; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 8011908:	4881      	ldr	r0, [pc, #516]	; (8011b10 <transmitOnRadio+0x5a0>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 801190a:	4b82      	ldr	r3, [pc, #520]	; (8011b14 <transmitOnRadio+0x5a4>)
 801190c:	6c02      	ldr	r2, [r0, #64]	; 0x40
 801190e:	f042 0220 	orr.w	r2, r2, #32
 8011912:	6402      	str	r2, [r0, #64]	; 0x40
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8011914:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
	TIM7->PSC = 1;
 8011918:	2201      	movs	r2, #1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 801191a:	2710      	movs	r7, #16
	chThdSleepMilliseconds(30);

	uint32_t initial_interval = 1355; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 801191c:	f240 564b 	movw	r6, #1355	; 0x54b
 8011920:	f883 7337 	strb.w	r7, [r3, #823]	; 0x337
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8011924:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8011928:	6059      	str	r1, [r3, #4]
 801192a:	62e6      	str	r6, [r4, #44]	; 0x2c
	TIM7->PSC = 1;
 801192c:	62a2      	str	r2, [r4, #40]	; 0x28
	TIM7->CR1 &= ~STM32_TIM_CR1_ARPE; /* ARR register is NOT buffered, allows to update timer's period on-fly. */
 801192e:	6823      	ldr	r3, [r4, #0]
 8011930:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8011934:	6023      	str	r3, [r4, #0]
	TIM7->DIER |= STM32_TIM_DIER_UIE; /* Interrupt enable */
 8011936:	68e3      	ldr	r3, [r4, #12]
 8011938:	4313      	orrs	r3, r2
 801193a:	60e3      	str	r3, [r4, #12]
	TIM7->CR1 |= STM32_TIM_CR1_CEN; /* Counter enable */
 801193c:	6823      	ldr	r3, [r4, #0]
 801193e:	4313      	orrs	r3, r2
 8011940:	6023      	str	r3, [r4, #0]

	// Block execution while timer is running
	while(TIM7->CR1 & STM32_TIM_CR1_CEN)
 8011942:	6823      	ldr	r3, [r4, #0]
 8011944:	07d8      	lsls	r0, r3, #31
 8011946:	d505      	bpl.n	8011954 <transmitOnRadio+0x3e4>
		chThdSleepMilliseconds(10);
 8011948:	20c8      	movs	r0, #200	; 0xc8
 801194a:	f7fd fba1 	bl	800f090 <chThdSleep>
	TIM7->CR1 &= ~STM32_TIM_CR1_ARPE; /* ARR register is NOT buffered, allows to update timer's period on-fly. */
	TIM7->DIER |= STM32_TIM_DIER_UIE; /* Interrupt enable */
	TIM7->CR1 |= STM32_TIM_CR1_CEN; /* Counter enable */

	// Block execution while timer is running
	while(TIM7->CR1 & STM32_TIM_CR1_CEN)
 801194e:	6823      	ldr	r3, [r4, #0]
 8011950:	07d9      	lsls	r1, r3, #31
 8011952:	d4f9      	bmi.n	8011948 <transmitOnRadio+0x3d8>
 8011954:	4e70      	ldr	r6, [pc, #448]	; (8011b18 <transmitOnRadio+0x5a8>)
 8011956:	e03c      	b.n	80119d2 <transmitOnRadio+0x462>
				if(!isRadioInitialized(radio))
					initOOK(radio, msg);
				sendOOK(radio, msg);
				break;
			case MOD_DOMINOEX16:
				TRACE_ERROR("RAD  > Unimplemented modulation DominoEX16"); // TODO: Implement this
 8011958:	4870      	ldr	r0, [pc, #448]	; (8011b1c <transmitOnRadio+0x5ac>)
 801195a:	4f71      	ldr	r7, [pc, #452]	; (8011b20 <transmitOnRadio+0x5b0>)
 801195c:	4e6e      	ldr	r6, [pc, #440]	; (8011b18 <transmitOnRadio+0x5a8>)
 801195e:	f7fd fac7 	bl	800eef0 <chMtxLock>
 8011962:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8011966:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 801196a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801196c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 801196e:	4b6d      	ldr	r3, [pc, #436]	; (8011b24 <transmitOnRadio+0x5b4>)
 8011970:	496d      	ldr	r1, [pc, #436]	; (8011b28 <transmitOnRadio+0x5b8>)
 8011972:	fb04 f000 	mul.w	r0, r4, r0
 8011976:	fba7 e000 	umull	lr, r0, r7, r0
 801197a:	0b80      	lsrs	r0, r0, #14
 801197c:	fba3 e300 	umull	lr, r3, r3, r0
 8011980:	fba7 7202 	umull	r7, r2, r7, r2
 8011984:	099b      	lsrs	r3, r3, #6
 8011986:	fb04 0313 	mls	r3, r4, r3, r0
 801198a:	0b92      	lsrs	r2, r2, #14
 801198c:	4867      	ldr	r0, [pc, #412]	; (8011b2c <transmitOnRadio+0x5bc>)
 801198e:	f000 fea7 	bl	80126e0 <chprintf.constprop.35>
 8011992:	4a67      	ldr	r2, [pc, #412]	; (8011b30 <transmitOnRadio+0x5c0>)
 8011994:	4967      	ldr	r1, [pc, #412]	; (8011b34 <transmitOnRadio+0x5c4>)
 8011996:	4865      	ldr	r0, [pc, #404]	; (8011b2c <transmitOnRadio+0x5bc>)
 8011998:	f000 fea2 	bl	80126e0 <chprintf.constprop.35>
 801199c:	f240 1367 	movw	r3, #359	; 0x167
 80119a0:	4a65      	ldr	r2, [pc, #404]	; (8011b38 <transmitOnRadio+0x5c8>)
 80119a2:	4966      	ldr	r1, [pc, #408]	; (8011b3c <transmitOnRadio+0x5cc>)
 80119a4:	4861      	ldr	r0, [pc, #388]	; (8011b2c <transmitOnRadio+0x5bc>)
 80119a6:	f000 fe9b 	bl	80126e0 <chprintf.constprop.35>
 80119aa:	4965      	ldr	r1, [pc, #404]	; (8011b40 <transmitOnRadio+0x5d0>)
 80119ac:	485f      	ldr	r0, [pc, #380]	; (8011b2c <transmitOnRadio+0x5bc>)
 80119ae:	f000 fe97 	bl	80126e0 <chprintf.constprop.35>
 80119b2:	4964      	ldr	r1, [pc, #400]	; (8011b44 <transmitOnRadio+0x5d4>)
 80119b4:	485d      	ldr	r0, [pc, #372]	; (8011b2c <transmitOnRadio+0x5bc>)
 80119b6:	f000 fe93 	bl	80126e0 <chprintf.constprop.35>
 80119ba:	4963      	ldr	r1, [pc, #396]	; (8011b48 <transmitOnRadio+0x5d8>)
 80119bc:	485b      	ldr	r0, [pc, #364]	; (8011b2c <transmitOnRadio+0x5bc>)
 80119be:	f000 fe8f 	bl	80126e0 <chprintf.constprop.35>
 80119c2:	4856      	ldr	r0, [pc, #344]	; (8011b1c <transmitOnRadio+0x5ac>)
 80119c4:	f7fd fa34 	bl	800ee30 <chMtxUnlock>
 80119c8:	f240 1167 	movw	r1, #359	; 0x167
 80119cc:	485a      	ldr	r0, [pc, #360]	; (8011b38 <transmitOnRadio+0x5c8>)
 80119ce:	f7fe fac7 	bl	800ff60 <log_error>
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 80119d2:	2d01      	cmp	r5, #1
 80119d4:	d053      	beq.n	8011a7e <transmitOnRadio+0x50e>
 80119d6:	495d      	ldr	r1, [pc, #372]	; (8011b4c <transmitOnRadio+0x5dc>)
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 80119d8:	4b5d      	ldr	r3, [pc, #372]	; (8011b50 <transmitOnRadio+0x5e0>)
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 80119da:	2040      	movs	r0, #64	; 0x40
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 80119dc:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 80119e0:	6188      	str	r0, [r1, #24]
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 80119e2:	619a      	str	r2, [r3, #24]
	initialized[radio] = false;
 80119e4:	2300      	movs	r3, #0
				break;
		}

		radioShutdown(radio); // Shutdown radio for reinitialization
		chMtxUnlock(&interference_mtx); // Heavy interference finished (HF)
 80119e6:	485b      	ldr	r0, [pc, #364]	; (8011b54 <transmitOnRadio+0x5e4>)
 80119e8:	5573      	strb	r3, [r6, r5]
 80119ea:	f7fd fa21 	bl	800ee30 <chMtxUnlock>
 80119ee:	e630      	b.n	8011652 <transmitOnRadio+0xe2>
		return 127;
	}
}

bool isRadioInitialized(radio_t radio) {
	return initialized[radio];
 80119f0:	4e49      	ldr	r6, [pc, #292]	; (8011b18 <transmitOnRadio+0x5a8>)
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 80119f2:	f8df 8178 	ldr.w	r8, [pc, #376]	; 8011b6c <transmitOnRadio+0x5fc>
					dBm2powerLvl(msg->power), VAL2MOULATION(msg->mod), msg->bin_len
		);
		
		switch(msg->mod) {
			case MOD_2FSK:
				if(!isRadioInitialized(radio))
 80119f6:	5d73      	ldrb	r3, [r6, r5]
 80119f8:	2b00      	cmp	r3, #0
 80119fa:	d04c      	beq.n	8011a96 <transmitOnRadio+0x526>
	radioTune(radio, msg->freq, msg->fsk_config->shift, msg->power, 0);
}

void send2FSK(radio_t radio, radioMSG_t *msg) {
	// Prepare serial machine states
	txs = 6;
 80119fc:	4f56      	ldr	r7, [pc, #344]	; (8011b58 <transmitOnRadio+0x5e8>)
	txc = 0;
 80119fe:	f8df e180 	ldr.w	lr, [pc, #384]	; 8011b80 <transmitOnRadio+0x610>
	txi = 0;
 8011a02:	4856      	ldr	r0, [pc, #344]	; (8011b5c <transmitOnRadio+0x5ec>)
	txj = 0;
 8011a04:	4956      	ldr	r1, [pc, #344]	; (8011b60 <transmitOnRadio+0x5f0>)
	fsk_msg = msg;
 8011a06:	4a57      	ldr	r2, [pc, #348]	; (8011b64 <transmitOnRadio+0x5f4>)
	radioTune(radio, msg->freq, msg->fsk_config->shift, msg->power, 0);
}

void send2FSK(radio_t radio, radioMSG_t *msg) {
	// Prepare serial machine states
	txs = 6;
 8011a08:	2306      	movs	r3, #6
 8011a0a:	703b      	strb	r3, [r7, #0]
	txc = 0;
 8011a0c:	2300      	movs	r3, #0
 8011a0e:	f88e 3000 	strb.w	r3, [lr]
	txi = 0;
 8011a12:	6003      	str	r3, [r0, #0]
	txj = 0;
 8011a14:	600b      	str	r3, [r1, #0]
	fsk_msg = msg;
	fsk_radio = radio;
 8011a16:	4b54      	ldr	r3, [pc, #336]	; (8011b68 <transmitOnRadio+0x5f8>)
	// Prepare serial machine states
	txs = 6;
	txc = 0;
	txi = 0;
	txj = 0;
	fsk_msg = msg;
 8011a18:	6014      	str	r4, [r2, #0]
	fsk_radio = radio;
 8011a1a:	601d      	str	r5, [r3, #0]
 8011a1c:	2320      	movs	r3, #32
 8011a1e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8011a22:	f7fd f9ad 	bl	800ed80 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8011a26:	f7fc ff13 	bl	800e850 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8011a2a:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8011a2e:	b113      	cbz	r3, 8011a36 <transmitOnRadio+0x4c6>
    chVTDoResetI(vtp);
 8011a30:	484e      	ldr	r0, [pc, #312]	; (8011b6c <transmitOnRadio+0x5fc>)
 8011a32:	f7fd f815 	bl	800ea60 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8011a36:	2300      	movs	r3, #0
 8011a38:	4a4d      	ldr	r2, [pc, #308]	; (8011b70 <transmitOnRadio+0x600>)
 8011a3a:	484c      	ldr	r0, [pc, #304]	; (8011b6c <transmitOnRadio+0x5fc>)
 8011a3c:	2101      	movs	r1, #1
 8011a3e:	f7fd f857 	bl	800eaf0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8011a42:	f7fd f98d 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8011a46:	4b4b      	ldr	r3, [pc, #300]	; (8011b74 <transmitOnRadio+0x604>)
 8011a48:	681a      	ldr	r2, [r3, #0]
 8011a4a:	429a      	cmp	r2, r3
 8011a4c:	d004      	beq.n	8011a58 <transmitOnRadio+0x4e8>
 8011a4e:	6999      	ldr	r1, [r3, #24]
 8011a50:	6893      	ldr	r3, [r2, #8]
 8011a52:	688a      	ldr	r2, [r1, #8]
 8011a54:	429a      	cmp	r2, r3
 8011a56:	d31b      	bcc.n	8011a90 <transmitOnRadio+0x520>
 8011a58:	2300      	movs	r3, #0
 8011a5a:	f383 8811 	msr	BASEPRI, r3

	// Modulate
	chVTSet(&vt, 1, serial_cb, NULL);	// Start timer
	while(txs)
 8011a5e:	783b      	ldrb	r3, [r7, #0]
 8011a60:	2b00      	cmp	r3, #0
 8011a62:	d0b6      	beq.n	80119d2 <transmitOnRadio+0x462>
		chThdSleepMilliseconds(1);		// Wait for routine to finish
 8011a64:	2014      	movs	r0, #20
 8011a66:	f7fd fb13 	bl	800f090 <chThdSleep>
	fsk_msg = msg;
	fsk_radio = radio;

	// Modulate
	chVTSet(&vt, 1, serial_cb, NULL);	// Start timer
	while(txs)
 8011a6a:	783b      	ldrb	r3, [r7, #0]
 8011a6c:	2b00      	cmp	r3, #0
 8011a6e:	d0b0      	beq.n	80119d2 <transmitOnRadio+0x462>
		chThdSleepMilliseconds(1);		// Wait for routine to finish
 8011a70:	2014      	movs	r0, #20
 8011a72:	f7fd fb0d 	bl	800f090 <chThdSleep>
	fsk_msg = msg;
	fsk_radio = radio;

	// Modulate
	chVTSet(&vt, 1, serial_cb, NULL);	// Start timer
	while(txs)
 8011a76:	783b      	ldrb	r3, [r7, #0]
 8011a78:	2b00      	cmp	r3, #0
 8011a7a:	d1f3      	bne.n	8011a64 <transmitOnRadio+0x4f4>
 8011a7c:	e7a9      	b.n	80119d2 <transmitOnRadio+0x462>
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 8011a7e:	493e      	ldr	r1, [pc, #248]	; (8011b78 <transmitOnRadio+0x608>)
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 8011a80:	4b33      	ldr	r3, [pc, #204]	; (8011b50 <transmitOnRadio+0x5e0>)
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 8011a82:	f44f 4000 	mov.w	r0, #32768	; 0x8000
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 8011a86:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(radio, change_state_command, 2);
}

void radioShutdown(radio_t radio) {
	RADIO_SDN_SET(radio, true);	// Power down chip
 8011a8a:	6188      	str	r0, [r1, #24]
	RF_GPIO1_SET(radio, false);	// Set GPIO1 low
 8011a8c:	619a      	str	r2, [r3, #24]
 8011a8e:	e7a9      	b.n	80119e4 <transmitOnRadio+0x474>
 8011a90:	483a      	ldr	r0, [pc, #232]	; (8011b7c <transmitOnRadio+0x60c>)
 8011a92:	f7fc fe65 	bl	800e760 <chSysHalt>
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 8011a96:	f8c8 300c 	str.w	r3, [r8, #12]
void init2FSK(radio_t radio, radioMSG_t *msg) {
	// Initialize virtual timer
	chVTObjectInit(&vt);

	// Initialize radio and tune
	Si4464_Init(radio, MOD_2FSK);
 8011a9a:	4628      	mov	r0, r5
 8011a9c:	2101      	movs	r1, #1
 8011a9e:	f7f8 f8b7 	bl	8009c10 <Si4464_Init>
	MOD_GPIO_SET(radio, HIGH);
 8011aa2:	2d01      	cmp	r5, #1
 8011aa4:	bf0b      	itete	eq
 8011aa6:	4b2a      	ldreq	r3, [pc, #168]	; (8011b50 <transmitOnRadio+0x5e0>)
 8011aa8:	4b28      	ldrne	r3, [pc, #160]	; (8011b4c <transmitOnRadio+0x5dc>)
 8011aaa:	f44f 5200 	moveq.w	r2, #8192	; 0x2000
 8011aae:	2208      	movne	r2, #8
 8011ab0:	619a      	str	r2, [r3, #24]
	radioTune(radio, msg->freq, msg->fsk_config->shift, msg->power, 0);
 8011ab2:	f8d4 2210 	ldr.w	r2, [r4, #528]	; 0x210
 8011ab6:	f994 3208 	ldrsb.w	r3, [r4, #520]	; 0x208
 8011aba:	88d2      	ldrh	r2, [r2, #6]
 8011abc:	f8d4 1204 	ldr.w	r1, [r4, #516]	; 0x204
 8011ac0:	4628      	mov	r0, r5
 8011ac2:	f7fb ff65 	bl	800d990 <radioTune.constprop.18>
 8011ac6:	e799      	b.n	80119fc <transmitOnRadio+0x48c>
	TIM7->SR &= ~STM32_TIM_SR_UIF;						// Reset interrupt flag
}

void initOOK(radio_t radio, radioMSG_t *msg) {
	// Initialize radio and tune
	Si4464_Init(radio, MOD_OOK);
 8011ac8:	4639      	mov	r1, r7
 8011aca:	4628      	mov	r0, r5
 8011acc:	f7f8 f8a0 	bl	8009c10 <Si4464_Init>
	radioTune(radio, msg->freq, 0, msg->power, 0);
 8011ad0:	463a      	mov	r2, r7
 8011ad2:	f994 3208 	ldrsb.w	r3, [r4, #520]	; 0x208
 8011ad6:	f8d4 1204 	ldr.w	r1, [r4, #516]	; 0x204
 8011ada:	4628      	mov	r0, r5
 8011adc:	f7fb ff58 	bl	800d990 <radioTune.constprop.18>
 8011ae0:	e666      	b.n	80117b0 <transmitOnRadio+0x240>

mutex_t radio_mtx;                             // Radio mutex

void initAFSK(radio_t radio, radioMSG_t *msg) {
	// Initialize radio and tune
	Si4464_Init(radio, MOD_AFSK);
 8011ae2:	4628      	mov	r0, r5
 8011ae4:	2104      	movs	r1, #4
 8011ae6:	f7f8 f893 	bl	8009c10 <Si4464_Init>
	radioTune(radio, msg->freq, 0, msg->power, 0);
 8011aea:	463a      	mov	r2, r7
 8011aec:	f994 3208 	ldrsb.w	r3, [r4, #520]	; 0x208
 8011af0:	f8d4 1204 	ldr.w	r1, [r4, #516]	; 0x204
 8011af4:	4628      	mov	r0, r5
 8011af6:	f7fb ff4b 	bl	800d990 <radioTune.constprop.18>
 8011afa:	e61d      	b.n	8011738 <transmitOnRadio+0x1c8>
 8011afc:	20027e10 	.word	0x20027e10
 8011b00:	20027dfc 	.word	0x20027dfc
 8011b04:	20027e00 	.word	0x20027e00
 8011b08:	20027e0c 	.word	0x20027e0c
 8011b0c:	40001400 	.word	0x40001400
 8011b10:	40023800 	.word	0x40023800
 8011b14:	e000e100 	.word	0xe000e100
 8011b18:	20027e18 	.word	0x20027e18
 8011b1c:	20027b2c 	.word	0x20027b2c
 8011b20:	d1b71759 	.word	0xd1b71759
 8011b24:	10624dd3 	.word	0x10624dd3
 8011b28:	08013c50 	.word	0x08013c50
 8011b2c:	20027e60 	.word	0x20027e60
 8011b30:	08013d9c 	.word	0x08013d9c
 8011b34:	08013c5c 	.word	0x08013c5c
 8011b38:	08016204 	.word	0x08016204
 8011b3c:	08013c78 	.word	0x08013c78
 8011b40:	08013d00 	.word	0x08013d00
 8011b44:	08017164 	.word	0x08017164
 8011b48:	08013cac 	.word	0x08013cac
 8011b4c:	40021800 	.word	0x40021800
 8011b50:	40020c00 	.word	0x40020c00
 8011b54:	20027770 	.word	0x20027770
 8011b58:	20027e20 	.word	0x20027e20
 8011b5c:	20027df4 	.word	0x20027df4
 8011b60:	20027e14 	.word	0x20027e14
 8011b64:	20027e1c 	.word	0x20027e1c
 8011b68:	20027e08 	.word	0x20027e08
 8011b6c:	20027e24 	.word	0x20027e24
 8011b70:	080111f1 	.word	0x080111f1
 8011b74:	20027edc 	.word	0x20027edc
 8011b78:	40021000 	.word	0x40021000
 8011b7c:	08017464 	.word	0x08017464
 8011b80:	20027e21 	.word	0x20027e21
	...

08011b90 <led_cb.lto_priv.115>:
  * LED blinking routine
  * RED LED blinks: One or more modules crashed (software watchdog) INFO: Due to hardware bug, the LED cannot be used (pin = OSC_OUT => must be left floating)
  * GREEN LED blinks: I'm alive! (STM32 crashed if not blinking)
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
 8011b90:	b510      	push	{r4, lr}
	// Switch LEDs
	palWritePad(PORT(LED_3GREEN), PIN(LED_3GREEN), (bool)led_sw);	// Show I'M ALIVE
 8011b92:	b348      	cbz	r0, 8011be8 <led_cb.lto_priv.115+0x58>
 8011b94:	4a1a      	ldr	r2, [pc, #104]	; (8011c00 <led_cb.lto_priv.115+0x70>)
	if(error) {
 8011b96:	4b1b      	ldr	r3, [pc, #108]	; (8011c04 <led_cb.lto_priv.115+0x74>)
  * GREEN LED blinks: I'm alive! (STM32 crashed if not blinking)
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
	// Switch LEDs
	palWritePad(PORT(LED_3GREEN), PIN(LED_3GREEN), (bool)led_sw);	// Show I'M ALIVE
 8011b98:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8011b9c:	6191      	str	r1, [r2, #24]
	if(error) {
 8011b9e:	781b      	ldrb	r3, [r3, #0]
 8011ba0:	b9f3      	cbnz	r3, 8011be0 <led_cb.lto_priv.115+0x50>
		palWritePad(PORT(LED_1RED), PIN(LED_1RED), (bool)led_sw);	// Show error
	} else {
		palSetPad(PORT(LED_1RED), PIN(LED_1RED));	// Shut off error
 8011ba2:	4b19      	ldr	r3, [pc, #100]	; (8011c08 <led_cb.lto_priv.115+0x78>)
 8011ba4:	2202      	movs	r2, #2
 8011ba6:	831a      	strh	r2, [r3, #24]
	}

	led_sw = (void*)!led_sw; // Set next state
 8011ba8:	fab0 f480 	clz	r4, r0
 8011bac:	0964      	lsrs	r4, r4, #5
 8011bae:	2320      	movs	r3, #32
 8011bb0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8011bb4:	f7fd f884 	bl	800ecc0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8011bb8:	f7fc fe4a 	bl	800e850 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 8011bbc:	4813      	ldr	r0, [pc, #76]	; (8011c0c <led_cb.lto_priv.115+0x7c>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8011bbe:	68c3      	ldr	r3, [r0, #12]
 8011bc0:	b10b      	cbz	r3, 8011bc6 <led_cb.lto_priv.115+0x36>
    chVTDoResetI(vtp);
 8011bc2:	f7fc ff4d 	bl	800ea60 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8011bc6:	4623      	mov	r3, r4
 8011bc8:	4a11      	ldr	r2, [pc, #68]	; (8011c10 <led_cb.lto_priv.115+0x80>)
 8011bca:	4810      	ldr	r0, [pc, #64]	; (8011c0c <led_cb.lto_priv.115+0x7c>)
 8011bcc:	f242 7110 	movw	r1, #10000	; 0x2710
 8011bd0:	f7fc ff8e 	bl	800eaf0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8011bd4:	f7fd f85c 	bl	800ec90 <_dbg_check_unlock_from_isr>
 8011bd8:	2300      	movs	r3, #0
 8011bda:	f383 8811 	msr	BASEPRI, r3
 8011bde:	bd10      	pop	{r4, pc}
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
	// Switch LEDs
	palWritePad(PORT(LED_3GREEN), PIN(LED_3GREEN), (bool)led_sw);	// Show I'M ALIVE
	if(error) {
 8011be0:	2202      	movs	r2, #2
		palWritePad(PORT(LED_1RED), PIN(LED_1RED), (bool)led_sw);	// Show error
 8011be2:	4b09      	ldr	r3, [pc, #36]	; (8011c08 <led_cb.lto_priv.115+0x78>)
 8011be4:	619a      	str	r2, [r3, #24]
 8011be6:	e7df      	b.n	8011ba8 <led_cb.lto_priv.115+0x18>
  * GREEN LED blinks: I'm alive! (STM32 crashed if not blinking)
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
	// Switch LEDs
	palWritePad(PORT(LED_3GREEN), PIN(LED_3GREEN), (bool)led_sw);	// Show I'M ALIVE
 8011be8:	4a05      	ldr	r2, [pc, #20]	; (8011c00 <led_cb.lto_priv.115+0x70>)
	if(error) {
 8011bea:	4b06      	ldr	r3, [pc, #24]	; (8011c04 <led_cb.lto_priv.115+0x74>)
  * GREEN LED blinks: I'm alive! (STM32 crashed if not blinking)
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
	// Switch LEDs
	palWritePad(PORT(LED_3GREEN), PIN(LED_3GREEN), (bool)led_sw);	// Show I'M ALIVE
 8011bec:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 8011bf0:	6191      	str	r1, [r2, #24]
	if(error) {
 8011bf2:	781b      	ldrb	r3, [r3, #0]
 8011bf4:	2b00      	cmp	r3, #0
 8011bf6:	d0d4      	beq.n	8011ba2 <led_cb.lto_priv.115+0x12>
 8011bf8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8011bfc:	e7f1      	b.n	8011be2 <led_cb.lto_priv.115+0x52>
 8011bfe:	bf00      	nop
 8011c00:	40020800 	.word	0x40020800
 8011c04:	20005f10 	.word	0x20005f10
 8011c08:	40021c00 	.word	0x40021c00
 8011c0c:	20027784 	.word	0x20027784
 8011c10:	08011b91 	.word	0x08011b91
	...

08011c20 <sync_window.part.3.lto_priv.156>:
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8011c20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
 8011c24:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1))
 8011c26:	f100 0730 	add.w	r7, r0, #48	; 0x30
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
 8011c2a:	4605      	mov	r5, r0
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
 8011c2c:	4622      	mov	r2, r4
 8011c2e:	7840      	ldrb	r0, [r0, #1]
 8011c30:	4639      	mov	r1, r7
 8011c32:	2301      	movs	r3, #1
 8011c34:	f7fa f914 	bl	800be60 <disk_write>
 8011c38:	b9c0      	cbnz	r0, 8011c6c <sync_window.part.3.lto_priv.156+0x4c>
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8011c3a:	6a2a      	ldr	r2, [r5, #32]
 8011c3c:	69ab      	ldr	r3, [r5, #24]

	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
 8011c3e:	7128      	strb	r0, [r5, #4]
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8011c40:	1aa2      	subs	r2, r4, r2
 8011c42:	429a      	cmp	r2, r3
 8011c44:	4680      	mov	r8, r0
 8011c46:	d20e      	bcs.n	8011c66 <sync_window.part.3.lto_priv.156+0x46>
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8011c48:	78ee      	ldrb	r6, [r5, #3]
 8011c4a:	2e01      	cmp	r6, #1
 8011c4c:	d801      	bhi.n	8011c52 <sync_window.part.3.lto_priv.156+0x32>
 8011c4e:	e00a      	b.n	8011c66 <sync_window.part.3.lto_priv.156+0x46>
 8011c50:	69ab      	ldr	r3, [r5, #24]
				wsect += fs->fsize;
				disk_write(fs->drv, fs->win, wsect, 1);
 8011c52:	7868      	ldrb	r0, [r5, #1]
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
				wsect += fs->fsize;
 8011c54:	441c      	add	r4, r3
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8011c56:	3e01      	subs	r6, #1
				wsect += fs->fsize;
				disk_write(fs->drv, fs->win, wsect, 1);
 8011c58:	4622      	mov	r2, r4
 8011c5a:	2301      	movs	r3, #1
 8011c5c:	4639      	mov	r1, r7
 8011c5e:	f7fa f8ff 	bl	800be60 <disk_write>
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8011c62:	2e01      	cmp	r6, #1
 8011c64:	d1f4      	bne.n	8011c50 <sync_window.part.3.lto_priv.156+0x30>
				disk_write(fs->drv, fs->win, wsect, 1);
			}
		}
	}
	return FR_OK;
}
 8011c66:	4640      	mov	r0, r8
 8011c68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
 8011c6c:	f04f 0801 	mov.w	r8, #1
				disk_write(fs->drv, fs->win, wsect, 1);
			}
		}
	}
	return FR_OK;
}
 8011c70:	4640      	mov	r0, r8
 8011c72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8011c76:	bf00      	nop
	...

08011c80 <get_ldnumber.lto_priv.113>:
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;


	if (*path) {	/* If the pointer is not a null */
 8011c80:	6801      	ldr	r1, [r0, #0]
 8011c82:	b1f1      	cbz	r1, 8011cc2 <get_ldnumber.lto_priv.113+0x42>

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8011c84:	b410      	push	{r4}
	UINT i;
	int vol = -1;


	if (*path) {	/* If the pointer is not a null */
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8011c86:	780c      	ldrb	r4, [r1, #0]
 8011c88:	2c20      	cmp	r4, #32
 8011c8a:	d909      	bls.n	8011ca0 <get_ldnumber.lto_priv.113+0x20>
 8011c8c:	2c3a      	cmp	r4, #58	; 0x3a
 8011c8e:	d014      	beq.n	8011cba <get_ldnumber.lto_priv.113+0x3a>
 8011c90:	460a      	mov	r2, r1
 8011c92:	e001      	b.n	8011c98 <get_ldnumber.lto_priv.113+0x18>
 8011c94:	2b3a      	cmp	r3, #58	; 0x3a
 8011c96:	d006      	beq.n	8011ca6 <get_ldnumber.lto_priv.113+0x26>
 8011c98:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8011c9c:	2b20      	cmp	r3, #32
 8011c9e:	d8f9      	bhi.n	8011c94 <get_ldnumber.lto_priv.113+0x14>
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 8011ca0:	2000      	movs	r0, #0
#endif
	}
	return vol;
}
 8011ca2:	bc10      	pop	{r4}
 8011ca4:	4770      	bx	lr
	if (*path) {	/* If the pointer is not a null */
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8011ca6:	3101      	adds	r1, #1
 8011ca8:	428a      	cmp	r2, r1
 8011caa:	d106      	bne.n	8011cba <get_ldnumber.lto_priv.113+0x3a>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8011cac:	2c30      	cmp	r4, #48	; 0x30
 8011cae:	d104      	bne.n	8011cba <get_ldnumber.lto_priv.113+0x3a>
					vol = (int)i;
					*path = ++tt;
 8011cb0:	3201      	adds	r2, #1
 8011cb2:	6002      	str	r2, [r0, #0]
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8011cb4:	bc10      	pop	{r4}

	if (*path) {	/* If the pointer is not a null */
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
 8011cb6:	2000      	movs	r0, #0
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8011cb8:	4770      	bx	lr
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 8011cba:	f04f 30ff 	mov.w	r0, #4294967295
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8011cbe:	bc10      	pop	{r4}
 8011cc0:	4770      	bx	lr
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 8011cc2:	f04f 30ff 	mov.w	r0, #4294967295
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 8011cc6:	4770      	bx	lr
	...

08011cd0 <move_window.lto_priv.151>:
static
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
 8011cd0:	b538      	push	{r3, r4, r5, lr}
	if (sector != fs->winsect) {	/* Changed current window */
 8011cd2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8011cd4:	428b      	cmp	r3, r1
 8011cd6:	d012      	beq.n	8011cfe <move_window.lto_priv.151+0x2e>
{
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8011cd8:	7903      	ldrb	r3, [r0, #4]
 8011cda:	4604      	mov	r4, r0
 8011cdc:	460d      	mov	r5, r1
 8011cde:	b943      	cbnz	r3, 8011cf2 <move_window.lto_priv.151+0x22>
	if (sector != fs->winsect) {	/* Changed current window */
#if !_FS_READONLY
		if (sync_window(fs) != FR_OK)
			return FR_DISK_ERR;
#endif
		if (disk_read(fs->drv, fs->win, sector, 1))
 8011ce0:	462a      	mov	r2, r5
 8011ce2:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8011ce6:	7860      	ldrb	r0, [r4, #1]
 8011ce8:	f000 fd12 	bl	8012710 <disk_read.constprop.33>
 8011cec:	b928      	cbnz	r0, 8011cfa <move_window.lto_priv.151+0x2a>
			return FR_DISK_ERR;
		fs->winsect = sector;
 8011cee:	62e5      	str	r5, [r4, #44]	; 0x2c
 8011cf0:	bd38      	pop	{r3, r4, r5, pc}
 8011cf2:	f7ff ff95 	bl	8011c20 <sync_window.part.3.lto_priv.156>
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
	if (sector != fs->winsect) {	/* Changed current window */
#if !_FS_READONLY
		if (sync_window(fs) != FR_OK)
 8011cf6:	2800      	cmp	r0, #0
 8011cf8:	d0f2      	beq.n	8011ce0 <move_window.lto_priv.151+0x10>
			return FR_DISK_ERR;
 8011cfa:	2001      	movs	r0, #1
 8011cfc:	bd38      	pop	{r3, r4, r5, pc}
		if (disk_read(fs->drv, fs->win, sector, 1))
			return FR_DISK_ERR;
		fs->winsect = sector;
	}

	return FR_OK;
 8011cfe:	2000      	movs	r0, #0
}
 8011d00:	bd38      	pop	{r3, r4, r5, pc}
 8011d02:	bf00      	nop
	...

08011d10 <put_fat.part.8.lto_priv.154>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

FRESULT put_fat (
 8011d10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
 8011d14:	f890 9000 	ldrb.w	r9, [r0]
 8011d18:	f1b9 0f02 	cmp.w	r9, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

FRESULT put_fat (
 8011d1c:	4604      	mov	r4, r0
 8011d1e:	460d      	mov	r5, r1
 8011d20:	4617      	mov	r7, r2

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
 8011d22:	d051      	beq.n	8011dc8 <put_fat.part.8.lto_priv.154+0xb8>
 8011d24:	f1b9 0f03 	cmp.w	r9, #3
 8011d28:	d02d      	beq.n	8011d86 <put_fat.part.8.lto_priv.154+0x76>
 8011d2a:	f1b9 0f01 	cmp.w	r9, #1
 8011d2e:	d005      	beq.n	8011d3c <put_fat.part.8.lto_priv.154+0x2c>
			val |= LD_DWORD(p) & 0xF0000000;
			ST_DWORD(p, val);
			break;

		default :
			res = FR_INT_ERR;
 8011d30:	2602      	movs	r6, #2
		}
		fs->wflag = 1;
 8011d32:	2301      	movs	r3, #1
 8011d34:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
 8011d36:	4630      	mov	r0, r6
 8011d38:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8011d3c:	6a01      	ldr	r1, [r0, #32]
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8011d3e:	eb05 0855 	add.w	r8, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8011d42:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 8011d46:	f7ff ffc3 	bl	8011cd0 <move_window.lto_priv.151>
			if (res != FR_OK) break;
 8011d4a:	4606      	mov	r6, r0
 8011d4c:	2800      	cmp	r0, #0
 8011d4e:	d1f0      	bne.n	8011d32 <put_fat.part.8.lto_priv.154+0x22>
			p = &fs->win[bc % SS(fs)];
 8011d50:	f3c8 0308 	ubfx	r3, r8, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8011d54:	07ea      	lsls	r2, r5, #31
 8011d56:	4423      	add	r3, r4
			bc++;
 8011d58:	f108 0801 	add.w	r8, r8, #1
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8011d5c:	d54a      	bpl.n	8011df4 <put_fat.part.8.lto_priv.154+0xe4>
 8011d5e:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 8011d62:	f002 020f 	and.w	r2, r2, #15
 8011d66:	ea42 1207 	orr.w	r2, r2, r7, lsl #4
 8011d6a:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8011d6e:	6a21      	ldr	r1, [r4, #32]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
 8011d70:	f884 9004 	strb.w	r9, [r4, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8011d74:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 8011d78:	4620      	mov	r0, r4
 8011d7a:	f7ff ffa9 	bl	8011cd0 <move_window.lto_priv.151>
			if (res != FR_OK) break;
 8011d7e:	2800      	cmp	r0, #0
 8011d80:	d051      	beq.n	8011e26 <put_fat.part.8.lto_priv.154+0x116>
 8011d82:	4606      	mov	r6, r0
 8011d84:	e7d5      	b.n	8011d32 <put_fat.part.8.lto_priv.154+0x22>
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8011d86:	6a01      	ldr	r1, [r0, #32]
 8011d88:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
 8011d8c:	f7ff ffa0 	bl	8011cd0 <move_window.lto_priv.151>
			if (res != FR_OK) break;
 8011d90:	4606      	mov	r6, r0
 8011d92:	2800      	cmp	r0, #0
 8011d94:	d1cd      	bne.n	8011d32 <put_fat.part.8.lto_priv.154+0x22>
			p = &fs->win[clst * 4 % SS(fs)];
 8011d96:	00ad      	lsls	r5, r5, #2
 8011d98:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 8011d9c:	f105 0330 	add.w	r3, r5, #48	; 0x30
 8011da0:	4423      	add	r3, r4
			val |= LD_DWORD(p) & 0xF0000000;
 8011da2:	4425      	add	r5, r4
 8011da4:	78da      	ldrb	r2, [r3, #3]
 8011da6:	0612      	lsls	r2, r2, #24
 8011da8:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 8011dac:	4317      	orrs	r7, r2
			ST_DWORD(p, val);
 8011dae:	1238      	asrs	r0, r7, #8
 8011db0:	0c39      	lsrs	r1, r7, #16
 8011db2:	0e3a      	lsrs	r2, r7, #24
 8011db4:	f885 7030 	strb.w	r7, [r5, #48]	; 0x30
 8011db8:	7058      	strb	r0, [r3, #1]
 8011dba:	7099      	strb	r1, [r3, #2]
 8011dbc:	70da      	strb	r2, [r3, #3]
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
 8011dbe:	2301      	movs	r3, #1
 8011dc0:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
 8011dc2:	4630      	mov	r0, r6
 8011dc4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8011dc8:	6a01      	ldr	r1, [r0, #32]
 8011dca:	eb01 2115 	add.w	r1, r1, r5, lsr #8
 8011dce:	f7ff ff7f 	bl	8011cd0 <move_window.lto_priv.151>
			if (res != FR_OK) break;
 8011dd2:	4606      	mov	r6, r0
 8011dd4:	2800      	cmp	r0, #0
 8011dd6:	d1ac      	bne.n	8011d32 <put_fat.part.8.lto_priv.154+0x22>
			p = &fs->win[clst * 2 % SS(fs)];
 8011dd8:	006d      	lsls	r5, r5, #1
 8011dda:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
 8011dde:	1962      	adds	r2, r4, r5
 8011de0:	123b      	asrs	r3, r7, #8
 8011de2:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
 8011de6:	2301      	movs	r3, #1

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
 8011de8:	f882 7030 	strb.w	r7, [r2, #48]	; 0x30
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
 8011dec:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
 8011dee:	4630      	mov	r0, r6
 8011df0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8011df4:	f883 7030 	strb.w	r7, [r3, #48]	; 0x30
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8011df8:	6a21      	ldr	r1, [r4, #32]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
 8011dfa:	f884 9004 	strb.w	r9, [r4, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8011dfe:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 8011e02:	4620      	mov	r0, r4
 8011e04:	f7ff ff64 	bl	8011cd0 <move_window.lto_priv.151>
			if (res != FR_OK) break;
 8011e08:	2800      	cmp	r0, #0
 8011e0a:	d1ba      	bne.n	8011d82 <put_fat.part.8.lto_priv.154+0x72>
			p = &fs->win[bc % SS(fs)];
 8011e0c:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8011e10:	44a0      	add	r8, r4
 8011e12:	f3c7 2703 	ubfx	r7, r7, #8, #4
 8011e16:	f898 2030 	ldrb.w	r2, [r8, #48]	; 0x30
 8011e1a:	f022 020f 	bic.w	r2, r2, #15
 8011e1e:	4317      	orrs	r7, r2
 8011e20:	f888 7030 	strb.w	r7, [r8, #48]	; 0x30
 8011e24:	e785      	b.n	8011d32 <put_fat.part.8.lto_priv.154+0x22>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
 8011e26:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8011e2a:	44a0      	add	r8, r4
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8011e2c:	f3c7 1707 	ubfx	r7, r7, #4, #8
 8011e30:	e7f6      	b.n	8011e20 <put_fat.part.8.lto_priv.154+0x110>
 8011e32:	bf00      	nop
	...

08011e40 <get_fat.part.6.lto_priv.114>:
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 8011e40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;

	switch (fs->fs_type) {
 8011e42:	7803      	ldrb	r3, [r0, #0]
 8011e44:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
 8011e46:	4607      	mov	r7, r0
 8011e48:	460c      	mov	r4, r1


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;

	switch (fs->fs_type) {
 8011e4a:	d02c      	beq.n	8011ea6 <get_fat.part.6.lto_priv.114+0x66>
 8011e4c:	2b03      	cmp	r3, #3
 8011e4e:	d00e      	beq.n	8011e6e <get_fat.part.6.lto_priv.114+0x2e>
 8011e50:	2b01      	cmp	r3, #1
 8011e52:	d001      	beq.n	8011e58 <get_fat.part.6.lto_priv.114+0x18>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;

	default:
		return 1;
 8011e54:	2001      	movs	r0, #1
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
 8011e56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8011e58:	6a01      	ldr	r1, [r0, #32]
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
 8011e5a:	eb04 0554 	add.w	r5, r4, r4, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8011e5e:	eb01 2155 	add.w	r1, r1, r5, lsr #9
 8011e62:	f7ff ff35 	bl	8011cd0 <move_window.lto_priv.151>
 8011e66:	b380      	cbz	r0, 8011eca <get_fat.part.6.lto_priv.114+0x8a>

	default:
		return 1;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 8011e68:	f04f 30ff 	mov.w	r0, #4294967295
 8011e6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 8011e6e:	6a01      	ldr	r1, [r0, #32]
 8011e70:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 8011e74:	f7ff ff2c 	bl	8011cd0 <move_window.lto_priv.151>
 8011e78:	2800      	cmp	r0, #0
 8011e7a:	d1f5      	bne.n	8011e68 <get_fat.part.6.lto_priv.114+0x28>
		p = &fs->win[clst * 4 % SS(fs)];
 8011e7c:	00a3      	lsls	r3, r4, #2
 8011e7e:	f403 74fe 	and.w	r4, r3, #508	; 0x1fc
 8011e82:	f104 0330 	add.w	r3, r4, #48	; 0x30
 8011e86:	443b      	add	r3, r7
		return LD_DWORD(p) & 0x0FFFFFFF;
 8011e88:	443c      	add	r4, r7
 8011e8a:	789a      	ldrb	r2, [r3, #2]
 8011e8c:	78d9      	ldrb	r1, [r3, #3]
 8011e8e:	7858      	ldrb	r0, [r3, #1]
 8011e90:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8011e94:	0412      	lsls	r2, r2, #16
 8011e96:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8011e9a:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 8011e9e:	4318      	orrs	r0, r3
 8011ea0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 8011ea4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return clst & 1 ? wc >> 4 : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 8011ea6:	6a01      	ldr	r1, [r0, #32]
 8011ea8:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 8011eac:	f7ff ff10 	bl	8011cd0 <move_window.lto_priv.151>
 8011eb0:	2800      	cmp	r0, #0
 8011eb2:	d1d9      	bne.n	8011e68 <get_fat.part.6.lto_priv.114+0x28>
		p = &fs->win[clst * 2 % SS(fs)];
 8011eb4:	0064      	lsls	r4, r4, #1
 8011eb6:	f404 72ff 	and.w	r2, r4, #510	; 0x1fe
		return LD_WORD(p);
 8011eba:	18bb      	adds	r3, r7, r2
 8011ebc:	f893 0031 	ldrb.w	r0, [r3, #49]	; 0x31
 8011ec0:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8011ec4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8011ec8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 8011eca:	f3c5 0308 	ubfx	r3, r5, #0, #9
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8011ece:	6a39      	ldr	r1, [r7, #32]

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 8011ed0:	1c6e      	adds	r6, r5, #1
 8011ed2:	443b      	add	r3, r7
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8011ed4:	eb01 2156 	add.w	r1, r1, r6, lsr #9
 8011ed8:	4638      	mov	r0, r7

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 8011eda:	f893 5030 	ldrb.w	r5, [r3, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8011ede:	f7ff fef7 	bl	8011cd0 <move_window.lto_priv.151>
 8011ee2:	2800      	cmp	r0, #0
 8011ee4:	d1c0      	bne.n	8011e68 <get_fat.part.6.lto_priv.114+0x28>
		wc |= fs->win[bc % SS(fs)] << 8;
 8011ee6:	f3c6 0608 	ubfx	r6, r6, #0, #9
 8011eea:	19bb      	adds	r3, r7, r6
 8011eec:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		return clst & 1 ? wc >> 4 : (wc & 0xFFF);
 8011ef0:	07e3      	lsls	r3, r4, #31
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
 8011ef2:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
		return clst & 1 ? wc >> 4 : (wc & 0xFFF);
 8011ef6:	bf4c      	ite	mi
 8011ef8:	0900      	lsrmi	r0, r0, #4
 8011efa:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 8011efe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08011f00 <create_chain.lto_priv.155>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
 8011f00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011f02:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
 8011f04:	460f      	mov	r7, r1
 8011f06:	b9e9      	cbnz	r1, 8011f44 <create_chain.lto_priv.155+0x44>
		scl = fs->last_clust;			/* Get suggested start point */
 8011f08:	68c6      	ldr	r6, [r0, #12]
 8011f0a:	6943      	ldr	r3, [r0, #20]
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8011f0c:	bb56      	cbnz	r6, 8011f64 <create_chain.lto_priv.155+0x64>
 8011f0e:	2601      	movs	r6, #1
 8011f10:	4634      	mov	r4, r6
 8011f12:	e00f      	b.n	8011f34 <create_chain.lto_priv.155+0x34>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 8011f14:	2e01      	cmp	r6, #1
 8011f16:	d929      	bls.n	8011f6c <create_chain.lto_priv.155+0x6c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8011f18:	2b02      	cmp	r3, #2
 8011f1a:	d911      	bls.n	8011f40 <create_chain.lto_priv.155+0x40>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
 8011f1c:	2402      	movs	r4, #2
 8011f1e:	4621      	mov	r1, r4
 8011f20:	f7ff ff8e 	bl	8011e40 <get_fat.part.6.lto_priv.114>
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
 8011f24:	b348      	cbz	r0, 8011f7a <create_chain.lto_priv.155+0x7a>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 8011f26:	1c41      	adds	r1, r0, #1
 8011f28:	d024      	beq.n	8011f74 <create_chain.lto_priv.155+0x74>
 8011f2a:	2801      	cmp	r0, #1
 8011f2c:	d008      	beq.n	8011f40 <create_chain.lto_priv.155+0x40>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
 8011f2e:	42a6      	cmp	r6, r4
 8011f30:	d01c      	beq.n	8011f6c <create_chain.lto_priv.155+0x6c>
 8011f32:	696b      	ldr	r3, [r5, #20]
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
 8011f34:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
 8011f36:	429c      	cmp	r4, r3
 8011f38:	4628      	mov	r0, r5
 8011f3a:	d2eb      	bcs.n	8011f14 <create_chain.lto_priv.155+0x14>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8011f3c:	2c01      	cmp	r4, #1
 8011f3e:	d8ee      	bhi.n	8011f1e <create_chain.lto_priv.155+0x1e>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 8011f40:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
 8011f42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8011f44:	2901      	cmp	r1, #1
 8011f46:	d9fb      	bls.n	8011f40 <create_chain.lto_priv.155+0x40>
 8011f48:	6943      	ldr	r3, [r0, #20]
 8011f4a:	4299      	cmp	r1, r3
 8011f4c:	d2f8      	bcs.n	8011f40 <create_chain.lto_priv.155+0x40>
 8011f4e:	f7ff ff77 	bl	8011e40 <get_fat.part.6.lto_priv.114>
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* Invalid value */
 8011f52:	2801      	cmp	r0, #1
 8011f54:	d9f4      	bls.n	8011f40 <create_chain.lto_priv.155+0x40>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8011f56:	1c44      	adds	r4, r0, #1
 8011f58:	d00c      	beq.n	8011f74 <create_chain.lto_priv.155+0x74>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8011f5a:	696b      	ldr	r3, [r5, #20]
 8011f5c:	4283      	cmp	r3, r0
 8011f5e:	d8f0      	bhi.n	8011f42 <create_chain.lto_priv.155+0x42>
 8011f60:	463e      	mov	r6, r7
 8011f62:	e7d5      	b.n	8011f10 <create_chain.lto_priv.155+0x10>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8011f64:	429e      	cmp	r6, r3
 8011f66:	bf28      	it	cs
 8011f68:	2601      	movcs	r6, #1
 8011f6a:	e7d1      	b.n	8011f10 <create_chain.lto_priv.155+0x10>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 8011f6c:	2000      	movs	r0, #0
 8011f6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 8011f70:	2801      	cmp	r0, #1
 8011f72:	d1e5      	bne.n	8011f40 <create_chain.lto_priv.155+0x40>
 8011f74:	f04f 30ff 	mov.w	r0, #4294967295
 8011f78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8011f7a:	696b      	ldr	r3, [r5, #20]
 8011f7c:	42a3      	cmp	r3, r4
 8011f7e:	d9df      	bls.n	8011f40 <create_chain.lto_priv.155+0x40>
 8011f80:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 8011f84:	4621      	mov	r1, r4
 8011f86:	4628      	mov	r0, r5
 8011f88:	f7ff fec2 	bl	8011d10 <put_fat.part.8.lto_priv.154>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
 8011f8c:	2800      	cmp	r0, #0
 8011f8e:	d1ef      	bne.n	8011f70 <create_chain.lto_priv.155+0x70>
 8011f90:	b15f      	cbz	r7, 8011faa <create_chain.lto_priv.155+0xaa>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8011f92:	2f01      	cmp	r7, #1
 8011f94:	d9d4      	bls.n	8011f40 <create_chain.lto_priv.155+0x40>
 8011f96:	696b      	ldr	r3, [r5, #20]
 8011f98:	429f      	cmp	r7, r3
 8011f9a:	d2d1      	bcs.n	8011f40 <create_chain.lto_priv.155+0x40>
 8011f9c:	4639      	mov	r1, r7
 8011f9e:	4622      	mov	r2, r4
 8011fa0:	4628      	mov	r0, r5
 8011fa2:	f7ff feb5 	bl	8011d10 <put_fat.part.8.lto_priv.154>

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
 8011fa6:	2800      	cmp	r0, #0
 8011fa8:	d1e2      	bne.n	8011f70 <create_chain.lto_priv.155+0x70>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
 8011faa:	692b      	ldr	r3, [r5, #16]
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
 8011fac:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
 8011fae:	1c5a      	adds	r2, r3, #1
 8011fb0:	d007      	beq.n	8011fc2 <create_chain.lto_priv.155+0xc2>
			fs->free_clust--;
			fs->fsi_flag |= 1;
 8011fb2:	796a      	ldrb	r2, [r5, #5]
 8011fb4:	f042 0201 	orr.w	r2, r2, #1
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
 8011fb8:	3b01      	subs	r3, #1
			fs->fsi_flag |= 1;
 8011fba:	716a      	strb	r2, [r5, #5]
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
 8011fbc:	612b      	str	r3, [r5, #16]
			fs->fsi_flag |= 1;
 8011fbe:	4620      	mov	r0, r4
 8011fc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
 8011fc2:	4620      	mov	r0, r4
 8011fc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8011fc6:	bf00      	nop
	...

08011fd0 <dir_next.lto_priv.153>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8011fd0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DWORD clst;
	UINT i;


	i = dp->index + 1;
 8011fd4:	88c4      	ldrh	r4, [r0, #6]
 8011fd6:	3401      	adds	r4, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 8011fd8:	b2a3      	uxth	r3, r4
 8011fda:	b913      	cbnz	r3, 8011fe2 <dir_next.lto_priv.153+0x12>
		return FR_NO_FILE;
 8011fdc:	2004      	movs	r0, #4
 8011fde:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	DWORD clst;
	UINT i;


	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
 8011fe2:	6903      	ldr	r3, [r0, #16]
 8011fe4:	2b00      	cmp	r3, #0
 8011fe6:	d0f9      	beq.n	8011fdc <dir_next.lto_priv.153+0xc>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
 8011fe8:	f014 070f 	ands.w	r7, r4, #15
 8011fec:	460e      	mov	r6, r1
 8011fee:	4605      	mov	r5, r0
 8011ff0:	d008      	beq.n	8012004 <dir_next.lto_priv.153+0x34>
 8011ff2:	6800      	ldr	r0, [r0, #0]
				dp->sect = clust2sect(dp->fs, clst);
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
 8011ff4:	80ec      	strh	r4, [r5, #6]
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */
 8011ff6:	3030      	adds	r0, #48	; 0x30
 8011ff8:	eb00 1047 	add.w	r0, r0, r7, lsl #5
 8011ffc:	6168      	str	r0, [r5, #20]

	return FR_OK;
 8011ffe:	2000      	movs	r0, #0
 8012000:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */

		if (!dp->clust) {		/* Static table */
 8012004:	68c1      	ldr	r1, [r0, #12]
	i = dp->index + 1;
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */
 8012006:	3301      	adds	r3, #1
 8012008:	6103      	str	r3, [r0, #16]

		if (!dp->clust) {		/* Static table */
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 801200a:	6800      	ldr	r0, [r0, #0]
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */

		if (!dp->clust) {		/* Static table */
 801200c:	b161      	cbz	r1, 8012028 <dir_next.lto_priv.153+0x58>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
 801200e:	7883      	ldrb	r3, [r0, #2]
 8012010:	3b01      	subs	r3, #1
 8012012:	ea13 1814 	ands.w	r8, r3, r4, lsr #4
 8012016:	d1ed      	bne.n	8011ff4 <dir_next.lto_priv.153+0x24>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8012018:	2901      	cmp	r1, #1
 801201a:	d902      	bls.n	8012022 <dir_next.lto_priv.153+0x52>
 801201c:	6943      	ldr	r3, [r0, #20]
 801201e:	4299      	cmp	r1, r3
 8012020:	d306      	bcc.n	8012030 <dir_next.lto_priv.153+0x60>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
 8012022:	2002      	movs	r0, #2
 8012024:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
		dp->sect++;					/* Next sector */

		if (!dp->clust) {		/* Static table */
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 8012028:	8903      	ldrh	r3, [r0, #8]
 801202a:	429c      	cmp	r4, r3
 801202c:	d2d6      	bcs.n	8011fdc <dir_next.lto_priv.153+0xc>
 801202e:	e7e1      	b.n	8011ff4 <dir_next.lto_priv.153+0x24>
 8012030:	f7ff ff06 	bl	8011e40 <get_fat.part.6.lto_priv.114>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
 8012034:	2801      	cmp	r0, #1
 8012036:	4681      	mov	r9, r0
 8012038:	d9f3      	bls.n	8012022 <dir_next.lto_priv.153+0x52>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 801203a:	f1b0 3fff 	cmp.w	r0, #4294967295
 801203e:	d01c      	beq.n	801207a <dir_next.lto_priv.153+0xaa>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
 8012040:	6828      	ldr	r0, [r5, #0]
 8012042:	6942      	ldr	r2, [r0, #20]
 8012044:	454a      	cmp	r2, r9
 8012046:	d90e      	bls.n	8012066 <dir_next.lto_priv.153+0x96>
 8012048:	f1a9 0602 	sub.w	r6, r9, #2
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 801204c:	3a02      	subs	r2, #2
 801204e:	4296      	cmp	r6, r2
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
 8012050:	f8c5 900c 	str.w	r9, [r5, #12]
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8012054:	d204      	bcs.n	8012060 <dir_next.lto_priv.153+0x90>
	return clst * fs->csize + fs->database;
 8012056:	f890 8002 	ldrb.w	r8, [r0, #2]
 801205a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 801205c:	fb06 3808 	mla	r8, r6, r8, r3
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
				dp->sect = clust2sect(dp->fs, clst);
 8012060:	f8c5 8010 	str.w	r8, [r5, #16]
 8012064:	e7c6      	b.n	8011ff4 <dir_next.lto_priv.153+0x24>
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
#if !_FS_READONLY
					UINT c;
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
 8012066:	2e00      	cmp	r6, #0
 8012068:	d0b8      	beq.n	8011fdc <dir_next.lto_priv.153+0xc>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
 801206a:	68e9      	ldr	r1, [r5, #12]
 801206c:	f7ff ff48 	bl	8011f00 <create_chain.lto_priv.155>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8012070:	4681      	mov	r9, r0
 8012072:	b928      	cbnz	r0, 8012080 <dir_next.lto_priv.153+0xb0>
 8012074:	2007      	movs	r0, #7

	dp->index = (WORD)i;	/* Current index */
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */

	return FR_OK;
}
 8012076:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 801207a:	2001      	movs	r0, #1
 801207c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if !_FS_READONLY
					UINT c;
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
 8012080:	2801      	cmp	r0, #1
 8012082:	d0ce      	beq.n	8012022 <dir_next.lto_priv.153+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8012084:	f1b0 3fff 	cmp.w	r0, #4294967295
 8012088:	d0f7      	beq.n	801207a <dir_next.lto_priv.153+0xaa>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 801208a:	682b      	ldr	r3, [r5, #0]
{
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 801208c:	791a      	ldrb	r2, [r3, #4]
 801208e:	2a00      	cmp	r2, #0
 8012090:	d130      	bne.n	80120f4 <dir_next.lto_priv.153+0x124>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
 8012092:	f103 0230 	add.w	r2, r3, #48	; 0x30
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 8012096:	2100      	movs	r1, #0
 8012098:	f503 730c 	add.w	r3, r3, #560	; 0x230
 801209c:	f802 1b01 	strb.w	r1, [r2], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80120a0:	429a      	cmp	r2, r3
 80120a2:	d1fb      	bne.n	801209c <dir_next.lto_priv.153+0xcc>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 80120a4:	682b      	ldr	r3, [r5, #0]
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80120a6:	695a      	ldr	r2, [r3, #20]
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 80120a8:	f1a9 0602 	sub.w	r6, r9, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80120ac:	3a02      	subs	r2, #2
 80120ae:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
 80120b0:	bf3b      	ittet	cc
 80120b2:	6a9a      	ldrcc	r2, [r3, #40]	; 0x28
 80120b4:	7899      	ldrbcc	r1, [r3, #2]
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 80120b6:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
 80120b8:	fb06 2201 	mlacc	r2, r6, r1, r2
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 80120bc:	62da      	str	r2, [r3, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80120be:	f04f 0a00 	mov.w	sl, #0
						dp->fs->wflag = 1;
 80120c2:	f04f 0b01 	mov.w	fp, #1
 80120c6:	e004      	b.n	80120d2 <dir_next.lto_priv.153+0x102>
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
 80120c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80120ca:	3201      	adds	r2, #1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80120cc:	f10a 0a01 	add.w	sl, sl, #1
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
 80120d0:	62da      	str	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 80120d2:	789a      	ldrb	r2, [r3, #2]
 80120d4:	4592      	cmp	sl, r2
 80120d6:	4618      	mov	r0, r3
 80120d8:	d213      	bcs.n	8012102 <dir_next.lto_priv.153+0x132>
						dp->fs->wflag = 1;
 80120da:	f883 b004 	strb.w	fp, [r3, #4]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 80120de:	682b      	ldr	r3, [r5, #0]
{
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80120e0:	791a      	ldrb	r2, [r3, #4]
 80120e2:	2a00      	cmp	r2, #0
 80120e4:	d0f0      	beq.n	80120c8 <dir_next.lto_priv.153+0xf8>
 80120e6:	4618      	mov	r0, r3
 80120e8:	f7ff fd9a 	bl	8011c20 <sync_window.part.3.lto_priv.156>
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 80120ec:	2800      	cmp	r0, #0
 80120ee:	d1c4      	bne.n	801207a <dir_next.lto_priv.153+0xaa>
 80120f0:	682b      	ldr	r3, [r5, #0]
 80120f2:	e7e9      	b.n	80120c8 <dir_next.lto_priv.153+0xf8>
 80120f4:	4618      	mov	r0, r3
 80120f6:	f7ff fd93 	bl	8011c20 <sync_window.part.3.lto_priv.156>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 80120fa:	2800      	cmp	r0, #0
 80120fc:	d1bd      	bne.n	801207a <dir_next.lto_priv.153+0xaa>
 80120fe:	682b      	ldr	r3, [r5, #0]
 8012100:	e7c7      	b.n	8012092 <dir_next.lto_priv.153+0xc2>
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
 8012102:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012104:	6942      	ldr	r2, [r0, #20]
 8012106:	ebca 0303 	rsb	r3, sl, r3
 801210a:	62c3      	str	r3, [r0, #44]	; 0x2c
 801210c:	e79e      	b.n	801204c <dir_next.lto_priv.153+0x7c>
 801210e:	bf00      	nop

08012110 <check_fs.lto_priv.152>:
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8012110:	2200      	movs	r2, #0
 8012112:	f04f 33ff 	mov.w	r3, #4294967295
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 8012116:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8012118:	7102      	strb	r2, [r0, #4]
 801211a:	62c3      	str	r3, [r0, #44]	; 0x2c
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 801211c:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
 801211e:	f7ff fdd7 	bl	8011cd0 <move_window.lto_priv.151>
 8012122:	b108      	cbz	r0, 8012128 <check_fs.lto_priv.152+0x18>
		return 3;
 8012124:	2003      	movs	r0, #3
 8012126:	bd10      	pop	{r4, pc}

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
 8012128:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
 801212c:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
 8012130:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8012134:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8012138:	4293      	cmp	r3, r2
 801213a:	d001      	beq.n	8012140 <check_fs.lto_priv.152+0x30>
		return 2;
 801213c:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
 801213e:	bd10      	pop	{r4, pc}
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
 8012140:	f8d4 3066 	ldr.w	r3, [r4, #102]	; 0x66
 8012144:	4a06      	ldr	r2, [pc, #24]	; (8012160 <check_fs.lto_priv.152+0x50>)
 8012146:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 801214a:	4293      	cmp	r3, r2
 801214c:	d0f7      	beq.n	801213e <check_fs.lto_priv.152+0x2e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 801214e:	f8d4 3082 	ldr.w	r3, [r4, #130]	; 0x82
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
		return 3;
 8012152:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8012156:	1a98      	subs	r0, r3, r2
 8012158:	bf18      	it	ne
 801215a:	2001      	movne	r0, #1
 801215c:	bd10      	pop	{r4, pc}
 801215e:	bf00      	nop
 8012160:	00544146 	.word	0x00544146
	...

08012170 <isPointInPolygon>:
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 8012170:	b3b9      	cbz	r1, 80121e2 <isPointInPolygon+0x72>
  * Determines is location is located in polygon
  * @param poly Polygon
  * @param lat Latitude
  * @param lat Longitude
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
 8012172:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8012176:	4684      	mov	ip, r0
 8012178:	f101 38ff 	add.w	r8, r1, #4294967295
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 801217c:	2400      	movs	r4, #0
 801217e:	4620      	mov	r0, r4
 8012180:	f85c 6038 	ldr.w	r6, [ip, r8, lsl #3]
 8012184:	46e6      	mov	lr, ip
 8012186:	e01d      	b.n	80121c4 <isPointInPolygon+0x54>
		if((((poly[i].lat <= lat) && (lat < poly[j].lat)) || ((poly[j].lat <= lat) && (lat < poly[i].lat))) && (lon < (poly[j].lon - poly[i].lon) * (lat - poly[i].lat) / (poly[j].lat - poly[i].lat) + poly[i].lon))
 8012188:	42b2      	cmp	r2, r6
 801218a:	da13      	bge.n	80121b4 <isPointInPolygon+0x44>
 801218c:	eb0c 08c8 	add.w	r8, ip, r8, lsl #3
 8012190:	1b57      	subs	r7, r2, r5
 8012192:	f8d8 9004 	ldr.w	r9, [r8, #4]
 8012196:	f8de 8004 	ldr.w	r8, [lr, #4]
 801219a:	ebc8 0909 	rsb	r9, r8, r9
 801219e:	1b76      	subs	r6, r6, r5
 80121a0:	fb07 f709 	mul.w	r7, r7, r9
 80121a4:	fb97 f6f6 	sdiv	r6, r7, r6
 80121a8:	4446      	add	r6, r8
 80121aa:	429e      	cmp	r6, r3
			c = !c;
 80121ac:	bfc4      	itt	gt
 80121ae:	f080 0001 	eorgt.w	r0, r0, #1
 80121b2:	b2c0      	uxtbgt	r0, r0
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 80121b4:	1c67      	adds	r7, r4, #1
 80121b6:	42b9      	cmp	r1, r7
 80121b8:	f10e 0e08 	add.w	lr, lr, #8
		if((((poly[i].lat <= lat) && (lat < poly[j].lat)) || ((poly[j].lat <= lat) && (lat < poly[i].lat))) && (lon < (poly[j].lon - poly[i].lon) * (lat - poly[i].lat) / (poly[j].lat - poly[i].lat) + poly[i].lon))
 80121bc:	462e      	mov	r6, r5
 80121be:	46a0      	mov	r8, r4
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 80121c0:	d00d      	beq.n	80121de <isPointInPolygon+0x6e>
 80121c2:	463c      	mov	r4, r7
		if((((poly[i].lat <= lat) && (lat < poly[j].lat)) || ((poly[j].lat <= lat) && (lat < poly[i].lat))) && (lon < (poly[j].lon - poly[i].lon) * (lat - poly[i].lat) / (poly[j].lat - poly[i].lat) + poly[i].lon))
 80121c4:	f85c 5034 	ldr.w	r5, [ip, r4, lsl #3]
 80121c8:	4295      	cmp	r5, r2
 80121ca:	dddd      	ble.n	8012188 <isPointInPolygon+0x18>
 80121cc:	42b2      	cmp	r2, r6
 80121ce:	dadd      	bge.n	801218c <isPointInPolygon+0x1c>
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 80121d0:	1c67      	adds	r7, r4, #1
 80121d2:	42b9      	cmp	r1, r7
 80121d4:	f10e 0e08 	add.w	lr, lr, #8
		if((((poly[i].lat <= lat) && (lat < poly[j].lat)) || ((poly[j].lat <= lat) && (lat < poly[i].lat))) && (lon < (poly[j].lon - poly[i].lon) * (lat - poly[i].lat) / (poly[j].lat - poly[i].lat) + poly[i].lon))
 80121d8:	462e      	mov	r6, r5
 80121da:	46a0      	mov	r8, r4
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 80121dc:	d1f1      	bne.n	80121c2 <isPointInPolygon+0x52>
 80121de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  * @param poly Polygon
  * @param lat Latitude
  * @param lat Longitude
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
 80121e2:	4608      	mov	r0, r1
			c = !c;
		j = i;
	}

	return c;
}
 80121e4:	4770      	bx	lr
 80121e6:	bf00      	nop
	...

080121f0 <base91_encode>:
	b->val = -1;

	return n;
}

void base91_encode(const uint8_t *in, uint8_t *out, uint16_t input_length) {
 80121f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80121f4:	0113      	lsls	r3, r2, #4
 80121f6:	4c47      	ldr	r4, [pc, #284]	; (8012314 <base91_encode+0x124>)
 80121f8:	331a      	adds	r3, #26
 80121fa:	fb84 5403 	smull	r5, r4, r4, r3
 80121fe:	17db      	asrs	r3, r3, #31
 8012200:	ebc3 03a4 	rsb	r3, r3, r4, asr #2
 8012204:	468b      	mov	fp, r1
	base91_t handle;

	uint32_t ototal = 0;
	for(uint32_t i=0; i<(uint32_t)BASE91LEN(input_length); i++)
		out[i] = 0;
 8012206:	2400      	movs	r4, #0
 8012208:	4419      	add	r1, r3
 801220a:	465b      	mov	r3, fp
 801220c:	f803 4b01 	strb.w	r4, [r3], #1

void base91_encode(const uint8_t *in, uint8_t *out, uint16_t input_length) {
	base91_t handle;

	uint32_t ototal = 0;
	for(uint32_t i=0; i<(uint32_t)BASE91LEN(input_length); i++)
 8012210:	4299      	cmp	r1, r3
 8012212:	d1fb      	bne.n	801220c <base91_encode+0x1c>


void basE91_init(base91_t *b)
{
	b->queue = 0;
	b->nbits = 0;
 8012214:	2600      	movs	r6, #0
 8012216:	2700      	movs	r7, #0
 8012218:	4402      	add	r2, r0



void basE91_init(base91_t *b)
{
	b->queue = 0;
 801221a:	4634      	mov	r4, r6
 801221c:	463d      	mov	r5, r7

size_t basE91_encode(base91_t *b, const void *i, size_t len, void *o)
{
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;
 801221e:	f04f 0a00 	mov.w	sl, #0
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8012222:	f8df e0f8 	ldr.w	lr, [pc, #248]	; 801231c <base91_encode+0x12c>
 8012226:	e024      	b.n	8012272 <base91_encode+0x82>
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;

			if (val > 88) {
				b->queue >>= 13;
 8012228:	4645      	mov	r5, r8
				b->nbits -= 13;
 801222a:	f1b6 0805 	subs.w	r8, r6, #5
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;

			if (val > 88) {
				b->queue >>= 13;
 801222e:	4664      	mov	r4, ip
				b->nbits -= 13;
 8012230:	f147 39ff 	adc.w	r9, r7, #4294967295
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8012234:	fba3 670e 	umull	r6, r7, r3, lr
			ob[n++] = b91_table[val / 91];
 8012238:	fbae 1c03 	umull	r1, ip, lr, r3
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 801223c:	1bde      	subs	r6, r3, r7
 801223e:	eb07 0656 	add.w	r6, r7, r6, lsr #1
			ob[n++] = b91_table[val / 91];
 8012242:	ebcc 0703 	rsb	r7, ip, r3
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8012246:	09b6      	lsrs	r6, r6, #6
			ob[n++] = b91_table[val / 91];
 8012248:	eb0c 0c57 	add.w	ip, ip, r7, lsr #1
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 801224c:	275b      	movs	r7, #91	; 0x5b
 801224e:	fb07 3316 	mls	r3, r7, r6, r3
 8012252:	4931      	ldr	r1, [pc, #196]	; (8012318 <base91_encode+0x128>)
			ob[n++] = b91_table[val / 91];
 8012254:	ea4f 1c9c 	mov.w	ip, ip, lsr #6
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8012258:	f10a 0601 	add.w	r6, sl, #1
 801225c:	5ccf      	ldrb	r7, [r1, r3]
			ob[n++] = b91_table[val / 91];
 801225e:	f811 300c 	ldrb.w	r3, [r1, ip]
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8012262:	f80b 700a 	strb.w	r7, [fp, sl]
			ob[n++] = b91_table[val / 91];
 8012266:	f80b 3006 	strb.w	r3, [fp, r6]
 801226a:	f10a 0a02 	add.w	sl, sl, #2
	b->val = -1;

	return n;
}

void base91_encode(const uint8_t *in, uint8_t *out, uint16_t input_length) {
 801226e:	4646      	mov	r6, r8
 8012270:	464f      	mov	r7, r9
{
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
 8012272:	4282      	cmp	r2, r0
 8012274:	d028      	beq.n	80122c8 <base91_encode+0xd8>
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
 8012276:	f116 0808 	adds.w	r8, r6, #8
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
 801227a:	f810 3b01 	ldrb.w	r3, [r0], #1
		b->nbits += 8;
 801227e:	f147 0900 	adc.w	r9, r7, #0
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
 8012282:	40b3      	lsls	r3, r6
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
 8012284:	f1b9 0f00 	cmp.w	r9, #0
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
 8012288:	ea44 0403 	orr.w	r4, r4, r3
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
 801228c:	bf08      	it	eq
 801228e:	f1b8 0f0e 	cmpeq.w	r8, #14
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
 8012292:	ea45 75e3 	orr.w	r5, r5, r3, asr #31
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;
 8012296:	f3c4 030c 	ubfx	r3, r4, #0, #13
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
 801229a:	d3e8      	bcc.n	801226e <base91_encode+0x7e>
			uint32_t val = b->queue & 8191;

			if (val > 88) {
				b->queue >>= 13;
 801229c:	ea4f 3c54 	mov.w	ip, r4, lsr #13
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;

			if (val > 88) {
 80122a0:	2b58      	cmp	r3, #88	; 0x58
				b->queue >>= 13;
 80122a2:	ea4f 3855 	mov.w	r8, r5, lsr #13
 80122a6:	ea4c 4cc5 	orr.w	ip, ip, r5, lsl #19
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;

			if (val > 88) {
 80122aa:	d8bd      	bhi.n	8012228 <base91_encode+0x38>
				b->queue >>= 13;
				b->nbits -= 13;
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
 80122ac:	f1b6 0806 	subs.w	r8, r6, #6
			if (val > 88) {
				b->queue >>= 13;
				b->nbits -= 13;
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
 80122b0:	ea4f 3694 	mov.w	r6, r4, lsr #14
 80122b4:	ea46 4685 	orr.w	r6, r6, r5, lsl #18
				b->nbits -= 14;
 80122b8:	f147 39ff 	adc.w	r9, r7, #4294967295
			if (val > 88) {
				b->queue >>= 13;
				b->nbits -= 13;
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
 80122bc:	0baf      	lsrs	r7, r5, #14

			if (val > 88) {
				b->queue >>= 13;
				b->nbits -= 13;
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
 80122be:	f3c4 030d 	ubfx	r3, r4, #0, #14
				b->queue >>= 14;
 80122c2:	463d      	mov	r5, r7
 80122c4:	4634      	mov	r4, r6
 80122c6:	e7b5      	b.n	8012234 <base91_encode+0x44>
size_t basE91_encode_end(base91_t *b, void *o)
{
	uint8_t *ob = o;
	size_t n = 0;

	if (b->nbits) {
 80122c8:	ea56 0307 	orrs.w	r3, r6, r7
 80122cc:	d01a      	beq.n	8012304 <base91_encode+0x114>
		ob[n++] = b91_table[b->queue % 91];
 80122ce:	225b      	movs	r2, #91	; 0x5b
 80122d0:	2300      	movs	r3, #0
 80122d2:	4620      	mov	r0, r4
 80122d4:	4629      	mov	r1, r5
 80122d6:	f7ef f843 	bl	8001360 <__aeabi_uldivmod>
 80122da:	f8df 803c 	ldr.w	r8, [pc, #60]	; 8012318 <base91_encode+0x128>
		if (b->nbits > 7 || b->queue > 90)
 80122de:	2f00      	cmp	r7, #0
{
	uint8_t *ob = o;
	size_t n = 0;

	if (b->nbits) {
		ob[n++] = b91_table[b->queue % 91];
 80122e0:	f818 3002 	ldrb.w	r3, [r8, r2]
 80122e4:	f80b 300a 	strb.w	r3, [fp, sl]
		if (b->nbits > 7 || b->queue > 90)
 80122e8:	bf08      	it	eq
 80122ea:	2e08      	cmpeq	r6, #8
	for(uint32_t i=0; i<(uint32_t)BASE91LEN(input_length); i++)
		out[i] = 0;

	basE91_init(&handle);
	ototal += basE91_encode(&handle, in, input_length, out);
	ototal += basE91_encode_end(&handle, out + ototal);
 80122ec:	44da      	add	sl, fp
	uint8_t *ob = o;
	size_t n = 0;

	if (b->nbits) {
		ob[n++] = b91_table[b->queue % 91];
		if (b->nbits > 7 || b->queue > 90)
 80122ee:	d30b      	bcc.n	8012308 <base91_encode+0x118>
			ob[n++] = b91_table[b->queue / 91];
 80122f0:	2300      	movs	r3, #0
 80122f2:	4620      	mov	r0, r4
 80122f4:	4629      	mov	r1, r5
 80122f6:	225b      	movs	r2, #91	; 0x5b
 80122f8:	f7ef f832 	bl	8001360 <__aeabi_uldivmod>
 80122fc:	f818 3000 	ldrb.w	r3, [r8, r0]
 8012300:	f88a 3001 	strb.w	r3, [sl, #1]
 8012304:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint8_t *ob = o;
	size_t n = 0;

	if (b->nbits) {
		ob[n++] = b91_table[b->queue % 91];
		if (b->nbits > 7 || b->queue > 90)
 8012308:	2d00      	cmp	r5, #0
 801230a:	bf08      	it	eq
 801230c:	2c5b      	cmpeq	r4, #91	; 0x5b
 801230e:	d2ef      	bcs.n	80122f0 <base91_encode+0x100>
 8012310:	e7f8      	b.n	8012304 <base91_encode+0x114>
 8012312:	bf00      	nop
 8012314:	4ec4ec4f 	.word	0x4ec4ec4f
 8012318:	08017490 	.word	0x08017490
 801231c:	68168169 	.word	0x68168169

08012320 <waitForTrigger>:
	}
	return false;
}

systime_t waitForTrigger(systime_t prev, trigger_config_t *config)
{
 8012320:	b538      	push	{r3, r4, r5, lr}
	switch(config->type)
 8012322:	780b      	ldrb	r3, [r1, #0]
 8012324:	2b03      	cmp	r3, #3
 8012326:	d812      	bhi.n	801234e <waitForTrigger+0x2e>
 8012328:	e8df f003 	tbb	[pc, r3]
 801232c:	1115021f 	.word	0x1115021f
	{
		case TRIG_EVENT: // Wait for new tracking point
			switch(config->event)
 8012330:	7a0b      	ldrb	r3, [r1, #8]
 8012332:	b1cb      	cbz	r3, 8012368 <waitForTrigger+0x48>
 8012334:	2b01      	cmp	r3, #1
 8012336:	d10e      	bne.n	8012356 <waitForTrigger+0x36>
 8012338:	4c0c      	ldr	r4, [pc, #48]	; (801236c <waitForTrigger+0x4c>)
	}
}

void waitForNewTrackPoint(void)
{
	uint32_t old_id = getLastTrackPoint()->id;
 801233a:	6823      	ldr	r3, [r4, #0]
 801233c:	681d      	ldr	r5, [r3, #0]
	while(old_id == getLastTrackPoint()->id)
		chThdSleepMilliseconds(1000);
 801233e:	f644 6020 	movw	r0, #20000	; 0x4e20
 8012342:	f7fc fea5 	bl	800f090 <chThdSleep>
}

void waitForNewTrackPoint(void)
{
	uint32_t old_id = getLastTrackPoint()->id;
	while(old_id == getLastTrackPoint()->id)
 8012346:	6823      	ldr	r3, [r4, #0]
 8012348:	681b      	ldr	r3, [r3, #0]
 801234a:	429d      	cmp	r5, r3
 801234c:	d0f7      	beq.n	801233e <waitForTrigger+0x1e>
 801234e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8012352:	6a58      	ldr	r0, [r3, #36]	; 0x24
		case TRIG_ONCE: // No trigger defined
			while(1); // Assert
	}

	return chVTGetSystemTimeX();
}
 8012354:	bd38      	pop	{r3, r4, r5, pc}
				case NO_EVENT: // No event defined
					while(1); // Assert
			}
		
		case TRIG_TIMEOUT: // Wait for specified timeout
			return chThdSleepUntilWindowed(prev, prev + S2ST(config->timeout));
 8012356:	684b      	ldr	r3, [r1, #4]
 8012358:	f644 6120 	movw	r1, #20000	; 0x4e20
 801235c:	fb01 0103 	mla	r1, r1, r3, r0
		case TRIG_ONCE: // No trigger defined
			while(1); // Assert
	}

	return chVTGetSystemTimeX();
}
 8012360:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				case NO_EVENT: // No event defined
					while(1); // Assert
			}
		
		case TRIG_TIMEOUT: // Wait for specified timeout
			return chThdSleepUntilWindowed(prev, prev + S2ST(config->timeout));
 8012364:	f7fc be5c 	b.w	800f020 <chThdSleepUntilWindowed>
 8012368:	e7fe      	b.n	8012368 <waitForTrigger+0x48>
 801236a:	e7fe      	b.n	801236a <waitForTrigger+0x4a>
 801236c:	20027e3c 	.word	0x20027e3c

08012370 <p_sleep>:
/**
  * Sleeping method. Returns true if sleeping condition are given.
  */
bool p_sleep(const sleep_config_t *config)
{
	switch(config->type)
 8012370:	7803      	ldrb	r3, [r0, #0]
 8012372:	3b01      	subs	r3, #1

/**
  * Sleeping method. Returns true if sleeping condition are given.
  */
bool p_sleep(const sleep_config_t *config)
{
 8012374:	b570      	push	{r4, r5, r6, lr}
 8012376:	4604      	mov	r4, r0
	switch(config->type)
 8012378:	2b09      	cmp	r3, #9
 801237a:	d806      	bhi.n	801238a <p_sleep+0x1a>
 801237c:	e8df f003 	tbb	[pc, r3]
 8012380:	074f470f 	.word	0x074f470f
 8012384:	0f0f0f57 	.word	0x0f0f0f57
 8012388:	0f0f      	.short	0x0f0f
		case SLEEP_WHEN_SAT_NOT_VIS:
			TRACE_WARN("Sleeping method not implemented");
			return false;

		case SLEEP_DISABLED:
			return false;
 801238a:	2000      	movs	r0, #0
	}
	return false;
}
 801238c:	bd70      	pop	{r4, r5, r6, pc}

		case SLEEP_WHEN_VSOL_BELOW_THRES:
			return getSolarVoltageMV() < config->vsol_thres;

		case SLEEP_WHEN_VBAT_ABOVE_THRES:
			return getBatteryVoltageMV() > config->vbat_thres;
 801238e:	f7f8 fb6f 	bl	800aa70 <getBatteryVoltageMV>
 8012392:	8863      	ldrh	r3, [r4, #2]
 8012394:	4283      	cmp	r3, r0
 8012396:	bf2c      	ite	cs
 8012398:	2000      	movcs	r0, #0
 801239a:	2001      	movcc	r0, #1
 801239c:	bd70      	pop	{r4, r5, r6, pc}
		case SLEEP_WHEN_CHARGING:
		case SLEEP_WHEN_INSIDE_ITU1:
		case SLEEP_WHEN_INSIDE_ITU2:
		case SLEEP_WHEN_INSIDE_ITU3:
		case SLEEP_WHEN_SAT_NOT_VIS:
			TRACE_WARN("Sleeping method not implemented");
 801239e:	4828      	ldr	r0, [pc, #160]	; (8012440 <p_sleep+0xd0>)
 80123a0:	4e28      	ldr	r6, [pc, #160]	; (8012444 <p_sleep+0xd4>)
 80123a2:	f7fc fda5 	bl	800eef0 <chMtxLock>
 80123a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80123aa:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 80123ae:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80123b0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80123b2:	4b25      	ldr	r3, [pc, #148]	; (8012448 <p_sleep+0xd8>)
 80123b4:	4925      	ldr	r1, [pc, #148]	; (801244c <p_sleep+0xdc>)
 80123b6:	4826      	ldr	r0, [pc, #152]	; (8012450 <p_sleep+0xe0>)
 80123b8:	fb05 f404 	mul.w	r4, r5, r4
 80123bc:	fba6 e404 	umull	lr, r4, r6, r4
 80123c0:	0ba4      	lsrs	r4, r4, #14
 80123c2:	fba3 e304 	umull	lr, r3, r3, r4
 80123c6:	fba6 6202 	umull	r6, r2, r6, r2
 80123ca:	099b      	lsrs	r3, r3, #6
 80123cc:	fb05 4313 	mls	r3, r5, r3, r4
 80123d0:	0b92      	lsrs	r2, r2, #14
 80123d2:	f000 f985 	bl	80126e0 <chprintf.constprop.35>
 80123d6:	4a1f      	ldr	r2, [pc, #124]	; (8012454 <p_sleep+0xe4>)
 80123d8:	491f      	ldr	r1, [pc, #124]	; (8012458 <p_sleep+0xe8>)
 80123da:	481d      	ldr	r0, [pc, #116]	; (8012450 <p_sleep+0xe0>)
 80123dc:	f000 f980 	bl	80126e0 <chprintf.constprop.35>
 80123e0:	2322      	movs	r3, #34	; 0x22
 80123e2:	4a1e      	ldr	r2, [pc, #120]	; (801245c <p_sleep+0xec>)
 80123e4:	491e      	ldr	r1, [pc, #120]	; (8012460 <p_sleep+0xf0>)
 80123e6:	481a      	ldr	r0, [pc, #104]	; (8012450 <p_sleep+0xe0>)
 80123e8:	f000 f97a 	bl	80126e0 <chprintf.constprop.35>
 80123ec:	491d      	ldr	r1, [pc, #116]	; (8012464 <p_sleep+0xf4>)
 80123ee:	4818      	ldr	r0, [pc, #96]	; (8012450 <p_sleep+0xe0>)
 80123f0:	f000 f976 	bl	80126e0 <chprintf.constprop.35>
 80123f4:	491c      	ldr	r1, [pc, #112]	; (8012468 <p_sleep+0xf8>)
 80123f6:	4816      	ldr	r0, [pc, #88]	; (8012450 <p_sleep+0xe0>)
 80123f8:	f000 f972 	bl	80126e0 <chprintf.constprop.35>
 80123fc:	491b      	ldr	r1, [pc, #108]	; (801246c <p_sleep+0xfc>)
 80123fe:	4814      	ldr	r0, [pc, #80]	; (8012450 <p_sleep+0xe0>)
 8012400:	f000 f96e 	bl	80126e0 <chprintf.constprop.35>
 8012404:	480e      	ldr	r0, [pc, #56]	; (8012440 <p_sleep+0xd0>)
 8012406:	f7fc fd13 	bl	800ee30 <chMtxUnlock>
 801240a:	2000      	movs	r0, #0
 801240c:	bd70      	pop	{r4, r5, r6, pc}
bool p_sleep(const sleep_config_t *config)
{
	switch(config->type)
	{
		case SLEEP_WHEN_VBAT_BELOW_THRES:
			return getBatteryVoltageMV() < config->vbat_thres;
 801240e:	f7f8 fb2f 	bl	800aa70 <getBatteryVoltageMV>
 8012412:	8863      	ldrh	r3, [r4, #2]
 8012414:	4283      	cmp	r3, r0
 8012416:	bf94      	ite	ls
 8012418:	2000      	movls	r0, #0
 801241a:	2001      	movhi	r0, #1
 801241c:	bd70      	pop	{r4, r5, r6, pc}

		case SLEEP_WHEN_VSOL_BELOW_THRES:
			return getSolarVoltageMV() < config->vsol_thres;
 801241e:	f7f8 fb17 	bl	800aa50 <getSolarVoltageMV>
 8012422:	88a3      	ldrh	r3, [r4, #4]
 8012424:	4283      	cmp	r3, r0
 8012426:	bf94      	ite	ls
 8012428:	2000      	movls	r0, #0
 801242a:	2001      	movhi	r0, #1
 801242c:	bd70      	pop	{r4, r5, r6, pc}

		case SLEEP_WHEN_VBAT_ABOVE_THRES:
			return getBatteryVoltageMV() > config->vbat_thres;

		case SLEEP_WHEN_VSOL_ABOVE_THRES:
			return getSolarVoltageMV() > config->vsol_thres;
 801242e:	f7f8 fb0f 	bl	800aa50 <getSolarVoltageMV>
 8012432:	88a3      	ldrh	r3, [r4, #4]
 8012434:	4283      	cmp	r3, r0
 8012436:	bf2c      	ite	cs
 8012438:	2000      	movcs	r0, #0
 801243a:	2001      	movcc	r0, #1
 801243c:	bd70      	pop	{r4, r5, r6, pc}
 801243e:	bf00      	nop
 8012440:	20027b2c 	.word	0x20027b2c
 8012444:	d1b71759 	.word	0xd1b71759
 8012448:	10624dd3 	.word	0x10624dd3
 801244c:	08013c50 	.word	0x08013c50
 8012450:	20027e60 	.word	0x20027e60
 8012454:	08013cb0 	.word	0x08013cb0
 8012458:	08013c5c 	.word	0x08013c5c
 801245c:	0801620c 	.word	0x0801620c
 8012460:	08013c78 	.word	0x08013c78
 8012464:	08013d00 	.word	0x08013d00
 8012468:	08017470 	.word	0x08017470
 801246c:	08013cac 	.word	0x08013cac

08012470 <getFrequency>:

uint32_t getFrequency(freuquency_config_t *config)
{
	uint32_t (*fptr)(void);

	switch(config->type) {
 8012470:	7803      	ldrb	r3, [r0, #0]
 8012472:	b15b      	cbz	r3, 801248c <getFrequency+0x1c>
 8012474:	2b01      	cmp	r3, #1
 8012476:	d106      	bne.n	8012486 <getFrequency+0x16>

	return true;
}

uint32_t getFrequency(freuquency_config_t *config)
{
 8012478:	b510      	push	{r4, lr}
	uint32_t (*fptr)(void);

	switch(config->type) {
		case FREQ_DYNAMIC: // Dynamic frequency determination
			fptr = config->method;
			uint32_t ret = (*fptr)();
 801247a:	6883      	ldr	r3, [r0, #8]
 801247c:	4604      	mov	r4, r0
 801247e:	4798      	blx	r3
			if(!ret) // Use default frequency
 8012480:	b918      	cbnz	r0, 801248a <getFrequency+0x1a>
				return config->hz;
 8012482:	6860      	ldr	r0, [r4, #4]
 8012484:	bd10      	pop	{r4, pc}

		case FREQ_STATIC: // Static frequency
			return config->hz;

		default:
			return 0;
 8012486:	2000      	movs	r0, #0
 8012488:	4770      	bx	lr
	}
}
 801248a:	bd10      	pop	{r4, pc}
			if(!ret) // Use default frequency
				return config->hz;
			return ret;

		case FREQ_STATIC: // Static frequency
			return config->hz;
 801248c:	6840      	ldr	r0, [r0, #4]

		default:
			return 0;
	}
}
 801248e:	4770      	bx	lr

08012490 <chSchWakeupS.constprop.97>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8012490:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8012492:	4c1a      	ldr	r4, [pc, #104]	; (80124fc <chSchWakeupS.constprop.97+0x6c>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8012494:	4605      	mov	r5, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 8012496:	f7fc f983 	bl	800e7a0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 801249a:	6823      	ldr	r3, [r4, #0]
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 801249c:	69a0      	ldr	r0, [r4, #24]

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 801249e:	42a3      	cmp	r3, r4
 80124a0:	d003      	beq.n	80124aa <chSchWakeupS.constprop.97+0x1a>
 80124a2:	689b      	ldr	r3, [r3, #8]
 80124a4:	6882      	ldr	r2, [r0, #8]
 80124a6:	429a      	cmp	r2, r3
 80124a8:	d322      	bcc.n	80124f0 <chSchWakeupS.constprop.97+0x60>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80124aa:	2300      	movs	r3, #0
 80124ac:	626b      	str	r3, [r5, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80124ae:	6883      	ldr	r3, [r0, #8]
 80124b0:	68aa      	ldr	r2, [r5, #8]
 80124b2:	429a      	cmp	r2, r3
 80124b4:	d917      	bls.n	80124e6 <chSchWakeupS.constprop.97+0x56>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 80124b6:	f7fc fa93 	bl	800e9e0 <chSchReadyI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80124ba:	2301      	movs	r3, #1
 80124bc:	f885 3020 	strb.w	r3, [r5, #32]
 80124c0:	8f23      	ldrh	r3, [r4, #56]	; 0x38
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80124c2:	61a5      	str	r5, [r4, #24]
 80124c4:	07db      	lsls	r3, r3, #31
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 80124c6:	4606      	mov	r6, r0
 80124c8:	d401      	bmi.n	80124ce <chSchWakeupS.constprop.97+0x3e>
 80124ca:	f7fc f8f1 	bl	800e6b0 <_trace_switch.part.0.lto_priv.108>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80124ce:	f3ef 8309 	mrs	r3, PSP
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80124d2:	69f2      	ldr	r2, [r6, #28]
 80124d4:	3b24      	subs	r3, #36	; 0x24
 80124d6:	429a      	cmp	r2, r3
 80124d8:	d80d      	bhi.n	80124f6 <chSchWakeupS.constprop.97+0x66>
 80124da:	4631      	mov	r1, r6
 80124dc:	4628      	mov	r0, r5
  }
}
 80124de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80124e2:	f7ed bedd 	b.w	80002a0 <_port_switch>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
 80124e6:	4628      	mov	r0, r5
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 80124e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
 80124ec:	f7fc ba78 	b.w	800e9e0 <chSchReadyI>
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80124f0:	4803      	ldr	r0, [pc, #12]	; (8012500 <chSchWakeupS.constprop.97+0x70>)
 80124f2:	f7fc f935 	bl	800e760 <chSysHalt>
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80124f6:	4803      	ldr	r0, [pc, #12]	; (8012504 <chSchWakeupS.constprop.97+0x74>)
 80124f8:	f7fc f932 	bl	800e760 <chSysHalt>
 80124fc:	20027edc 	.word	0x20027edc
 8012500:	0801750c 	.word	0x0801750c
 8012504:	08015c54 	.word	0x08015c54
	...

08012510 <chTMStartMeasurementX.constprop.94>:
 8012510:	4b01      	ldr	r3, [pc, #4]	; (8012518 <chTMStartMeasurementX.constprop.94+0x8>)
 8012512:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8012514:	6083      	str	r3, [r0, #8]
 8012516:	4770      	bx	lr
 8012518:	e0001000 	.word	0xe0001000
 801251c:	00000000 	.word	0x00000000

08012520 <chThdDequeueNextI.constprop.90>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8012520:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8012522:	6803      	ldr	r3, [r0, #0]

  if (queue_notempty(tqp)) {
 8012524:	4298      	cmp	r0, r3
 8012526:	d009      	beq.n	801253c <chThdDequeueNextI.constprop.90+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8012528:	681a      	ldr	r2, [r3, #0]
 801252a:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 801252c:	6050      	str	r0, [r2, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 801252e:	f893 2020 	ldrb.w	r2, [r3, #32]
 8012532:	2a04      	cmp	r2, #4
 8012534:	d003      	beq.n	801253e <chThdDequeueNextI.constprop.90+0x1e>
 8012536:	4805      	ldr	r0, [pc, #20]	; (801254c <chThdDequeueNextI.constprop.90+0x2c>)
 8012538:	f7fc f912 	bl	800e760 <chSysHalt>
 801253c:	bd08      	pop	{r3, pc}

  tp->u.rdymsg = msg;
 801253e:	2200      	movs	r2, #0
 8012540:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8012542:	4618      	mov	r0, r3
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8012544:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8012548:	f7fc ba4a 	b.w	800e9e0 <chSchReadyI>
 801254c:	080175bc 	.word	0x080175bc

08012550 <chEvtBroadcastFlagsI.constprop.89>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8012550:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8012554:	4e1f      	ldr	r6, [pc, #124]	; (80125d4 <chEvtBroadcastFlagsI.constprop.89+0x84>)
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8012556:	4680      	mov	r8, r0
  event_listener_t *elp;

  chDbgCheckClassI();
 8012558:	f7fc f97a 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);

  elp = esp->next;
 801255c:	f856 4f04 	ldr.w	r4, [r6, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8012560:	42b4      	cmp	r4, r6
 8012562:	d029      	beq.n	80125b8 <chEvtBroadcastFlagsI.constprop.89+0x68>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8012564:	2700      	movs	r7, #0
 8012566:	e002      	b.n	801256e <chEvtBroadcastFlagsI.constprop.89+0x1e>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8012568:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 801256a:	42b4      	cmp	r4, r6
 801256c:	d024      	beq.n	80125b8 <chEvtBroadcastFlagsI.constprop.89+0x68>
  /*lint -restore*/
    elp->flags |= flags;
 801256e:	68e3      	ldr	r3, [r4, #12]
 8012570:	ea48 0303 	orr.w	r3, r8, r3
 8012574:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8012576:	f1b8 0f00 	cmp.w	r8, #0
 801257a:	d002      	beq.n	8012582 <chEvtBroadcastFlagsI.constprop.89+0x32>
 801257c:	6922      	ldr	r2, [r4, #16]
 801257e:	4213      	tst	r3, r2
 8012580:	d0f2      	beq.n	8012568 <chEvtBroadcastFlagsI.constprop.89+0x18>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 8012582:	6865      	ldr	r5, [r4, #4]
 8012584:	f8d4 9008 	ldr.w	r9, [r4, #8]
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
 8012588:	f7fc f962 	bl	800e850 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 801258c:	b1f5      	cbz	r5, 80125cc <chEvtBroadcastFlagsI.constprop.89+0x7c>

  tp->epending |= events;
 801258e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8012590:	f895 2020 	ldrb.w	r2, [r5, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8012594:	ea49 0303 	orr.w	r3, r9, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8012598:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 801259a:	636b      	str	r3, [r5, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 801259c:	d00e      	beq.n	80125bc <chEvtBroadcastFlagsI.constprop.89+0x6c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 801259e:	2a0b      	cmp	r2, #11
 80125a0:	d1e2      	bne.n	8012568 <chEvtBroadcastFlagsI.constprop.89+0x18>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80125a2:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 80125a4:	ea32 0303 	bics.w	r3, r2, r3
 80125a8:	d1de      	bne.n	8012568 <chEvtBroadcastFlagsI.constprop.89+0x18>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80125aa:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 80125ac:	4628      	mov	r0, r5
 80125ae:	f7fc fa17 	bl	800e9e0 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 80125b2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80125b4:	42b4      	cmp	r4, r6
 80125b6:	d1da      	bne.n	801256e <chEvtBroadcastFlagsI.constprop.89+0x1e>
 80125b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 80125bc:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80125be:	4213      	tst	r3, r2
 80125c0:	d0d2      	beq.n	8012568 <chEvtBroadcastFlagsI.constprop.89+0x18>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80125c2:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 80125c4:	4628      	mov	r0, r5
 80125c6:	f7fc fa0b 	bl	800e9e0 <chSchReadyI>
 80125ca:	e7f2      	b.n	80125b2 <chEvtBroadcastFlagsI.constprop.89+0x62>
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 80125cc:	4802      	ldr	r0, [pc, #8]	; (80125d8 <chEvtBroadcastFlagsI.constprop.89+0x88>)
 80125ce:	f7fc f8c7 	bl	800e760 <chSysHalt>
 80125d2:	bf00      	nop
 80125d4:	20027e60 	.word	0x20027e60
 80125d8:	08017540 	.word	0x08017540
 80125dc:	00000000 	.word	0x00000000

080125e0 <rtc_lld_get_time.constprop.54>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_get_time(RTCDriver *rtcp, RTCDateTime *timespec) {
 80125e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80125e4:	4606      	mov	r6, r0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80125e6:	f3ef 8711 	mrs	r7, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 80125ea:	b90f      	cbnz	r7, 80125f0 <rtc_lld_get_time.constprop.54+0x10>
 80125ec:	f7fc fda8 	bl	800f140 <chSysGetStatusAndLockX.part.1.lto_priv.109>
 80125f0:	4b33      	ldr	r3, [pc, #204]	; (80126c0 <rtc_lld_get_time.constprop.54+0xe0>)
 80125f2:	681a      	ldr	r2, [r3, #0]
  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();

  /* Synchronization with the RTC and reading the registers, note
     DR must be read last.*/
  while ((rtcp->rtc->ISR & RTC_ISR_RSF) == 0)
 80125f4:	68d3      	ldr	r3, [r2, #12]
 80125f6:	069b      	lsls	r3, r3, #26
 80125f8:	d5fc      	bpl.n	80125f4 <rtc_lld_get_time.constprop.54+0x14>
    ;
#if STM32_RTC_HAS_SUBSECONDS
  ssr = rtcp->rtc->SSR;
 80125fa:	f8d2 8028 	ldr.w	r8, [r2, #40]	; 0x28
#endif /* STM32_RTC_HAS_SUBSECONDS */
  tr  = rtcp->rtc->TR;
 80125fe:	6814      	ldr	r4, [r2, #0]
  dr  = rtcp->rtc->DR;
 8012600:	6855      	ldr	r5, [r2, #4]
  rtcp->rtc->ISR &= ~RTC_ISR_RSF;
 8012602:	68d3      	ldr	r3, [r2, #12]
 8012604:	f023 0320 	bic.w	r3, r3, #32
 8012608:	60d3      	str	r3, [r2, #12]
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 801260a:	b90f      	cbnz	r7, 8012610 <rtc_lld_get_time.constprop.54+0x30>
 801260c:	f7fc fdb0 	bl	800f170 <chSysRestoreStatusX.part.2.lto_priv.110>
 8012610:	4b2c      	ldr	r3, [pc, #176]	; (80126c4 <rtc_lld_get_time.constprop.54+0xe4>)
 * @notapi
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
 8012612:	482d      	ldr	r0, [pc, #180]	; (80126c8 <rtc_lld_get_time.constprop.54+0xe8>)
 8012614:	4f2d      	ldr	r7, [pc, #180]	; (80126cc <rtc_lld_get_time.constprop.54+0xec>)

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8012616:	f896 e002 	ldrb.w	lr, [r6, #2]
 801261a:	f3c4 4203 	ubfx	r2, r4, #16, #4
 801261e:	fb03 f202 	mul.w	r2, r3, r2
 * @notapi
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
 8012622:	f3c4 5301 	ubfx	r3, r4, #20, #2
 8012626:	fb00 2203 	mla	r2, r0, r3, r2
 801262a:	f004 030f 	and.w	r3, r4, #15
 801262e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8012632:	fb00 2003 	mla	r0, r0, r3, r2
 8012636:	f3c4 3102 	ubfx	r1, r4, #12, #3
 801263a:	fb07 0701 	mla	r7, r7, r1, r0
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 801263e:	4b24      	ldr	r3, [pc, #144]	; (80126d0 <rtc_lld_get_time.constprop.54+0xf0>)
 8012640:	f3c4 2003 	ubfx	r0, r4, #8, #4
 8012644:	f64e 2260 	movw	r2, #60000	; 0xea60
 8012648:	f3c4 1102 	ubfx	r1, r4, #4, #3
 801264c:	fb02 7400 	mla	r4, r2, r0, r7
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8012650:	f3c5 3000 	ubfx	r0, r5, #12, #1
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 8012654:	f242 7710 	movw	r7, #10000	; 0x2710
 8012658:	fb03 f208 	mul.w	r2, r3, r8
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 801265c:	0083      	lsls	r3, r0, #2
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 801265e:	fb07 4401 	mla	r4, r7, r1, r4
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8012662:	4418      	add	r0, r3
 8012664:	7871      	ldrb	r1, [r6, #1]
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 8012666:	6877      	ldr	r7, [r6, #4]
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8012668:	f3c5 2303 	ubfx	r3, r5, #8, #4
 801266c:	eb03 0040 	add.w	r0, r3, r0, lsl #1
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 8012670:	f502 2279 	add.w	r2, r2, #1019904	; 0xf9000

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8012674:	f3c5 1301 	ubfx	r3, r5, #4, #2
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 8012678:	f024 4478 	bic.w	r4, r4, #4160749568	; 0xf8000000
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 801267c:	f360 0103 	bfi	r1, r0, #0, #4
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8012680:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8012684:	f005 000f 	and.w	r0, r5, #15
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 8012688:	f602 4218 	addw	r2, r2, #3096	; 0xc18
 801268c:	eb04 2292 	add.w	r2, r4, r2, lsr #10

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8012690:	eb00 0443 	add.w	r4, r0, r3, lsl #1
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8012694:	f3c5 5303 	ubfx	r3, r5, #20, #4
 8012698:	eb03 0083 	add.w	r0, r3, r3, lsl #2
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 801269c:	f362 071a 	bfi	r7, r2, #0, #27
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 80126a0:	f3c5 4303 	ubfx	r3, r5, #16, #4
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
                     ((dr >> RTC_DR_DU_OFFSET) & 15);
  timespec->dayofweek = (dr >> RTC_DR_WDU_OFFSET) & 7;
 80126a4:	0b6a      	lsrs	r2, r5, #13
 80126a6:	f362 1147 	bfi	r1, r2, #5, #3

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 80126aa:	f364 0e04 	bfi	lr, r4, #0, #5
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 80126ae:	eb03 0340 	add.w	r3, r3, r0, lsl #1
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 80126b2:	6077      	str	r7, [r6, #4]
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
                     ((dr >> RTC_DR_DU_OFFSET) & 15);
  timespec->dayofweek = (dr >> RTC_DR_WDU_OFFSET) & 7;
 80126b4:	7071      	strb	r1, [r6, #1]

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 80126b6:	f886 e002 	strb.w	lr, [r6, #2]
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 80126ba:	7033      	strb	r3, [r6, #0]
 80126bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80126c0:	20028798 	.word	0x20028798
 80126c4:	0036ee80 	.word	0x0036ee80
 80126c8:	02255100 	.word	0x02255100
 80126cc:	000927c0 	.word	0x000927c0
 80126d0:	fffffc18 	.word	0xfffffc18
	...

080126e0 <chprintf.constprop.35>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80126e0:	b40e      	push	{r1, r2, r3}
 80126e2:	b500      	push	{lr}
 80126e4:	b082      	sub	sp, #8
 80126e6:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 80126e8:	4805      	ldr	r0, [pc, #20]	; (8012700 <chprintf.constprop.35+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80126ea:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80126ee:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80126f0:	f7f9 fc16 	bl	800bf20 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80126f4:	b002      	add	sp, #8
 80126f6:	f85d eb04 	ldr.w	lr, [sp], #4
 80126fa:	b003      	add	sp, #12
 80126fc:	4770      	bx	lr
 80126fe:	bf00      	nop
 8012700:	20027e60 	.word	0x20027e60
	...

08012710 <disk_read.constprop.33>:
    BYTE *buff,        /* Data buffer to store read data */
    DWORD sector,    /* Sector address (LBA) */
    UINT count        /* Number of sectors to read (1..255) */
)
{
  switch (pdrv) {
 8012710:	b108      	cbz	r0, 8012716 <disk_read.constprop.33+0x6>
    if (sdcRead(&SDCD1, sector, buff, count))
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
 8012712:	2004      	movs	r0, #4
}
 8012714:	4770      	bx	lr


/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */

DRESULT disk_read (
 8012716:	b538      	push	{r3, r4, r5, lr}
)
{
  switch (pdrv) {
#if HAL_USE_MMC_SPI
  case MMC:
    if (blkGetDriverState(&MMCD1) != BLK_READY)
 8012718:	4d0d      	ldr	r5, [pc, #52]	; (8012750 <disk_read.constprop.33+0x40>)
 801271a:	792b      	ldrb	r3, [r5, #4]
 801271c:	2b05      	cmp	r3, #5
 801271e:	d001      	beq.n	8012724 <disk_read.constprop.33+0x14>
      return RES_NOTRDY;
 8012720:	2003      	movs	r0, #3
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
}
 8012722:	bd38      	pop	{r3, r4, r5, pc}
 8012724:	460c      	mov	r4, r1
  switch (pdrv) {
#if HAL_USE_MMC_SPI
  case MMC:
    if (blkGetDriverState(&MMCD1) != BLK_READY)
      return RES_NOTRDY;
    if (mmcStartSequentialRead(&MMCD1, sector))
 8012726:	4628      	mov	r0, r5
 8012728:	4611      	mov	r1, r2
 801272a:	f7f8 fd19 	bl	800b160 <mmcStartSequentialRead>
 801272e:	b938      	cbnz	r0, 8012740 <disk_read.constprop.33+0x30>
      return RES_ERROR;
    while (count > 0) {
      if (mmcSequentialRead(&MMCD1, buff))
 8012730:	4621      	mov	r1, r4
 8012732:	4628      	mov	r0, r5
 8012734:	f7f8 fcdc 	bl	800b0f0 <mmcSequentialRead>
 8012738:	b910      	cbnz	r0, 8012740 <disk_read.constprop.33+0x30>
    (uint8_t)(0x40U | MMCSD_CMD_STOP_TRANSMISSION), 0, 0, 0, 0, 1, 0xFF
  };

  osalDbgCheck(mmcp != NULL);

  if (mmcp->state != BLK_READING) {
 801273a:	792b      	ldrb	r3, [r5, #4]
 801273c:	2b06      	cmp	r3, #6
 801273e:	d001      	beq.n	8012744 <disk_read.constprop.33+0x34>
#if HAL_USE_MMC_SPI
  case MMC:
    if (blkGetDriverState(&MMCD1) != BLK_READY)
      return RES_NOTRDY;
    if (mmcStartSequentialRead(&MMCD1, sector))
      return RES_ERROR;
 8012740:	2001      	movs	r0, #1
 8012742:	bd38      	pop	{r3, r4, r5, pc}
 8012744:	4628      	mov	r0, r5
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
}
 8012746:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801274a:	f7f8 bc41 	b.w	800afd0 <mmcStopSequentialRead.part.5.lto_priv.111>
 801274e:	bf00      	nop
 8012750:	20028764 	.word	0x20028764
	...

08012760 <chThdCreateFromHeap.constprop.87>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8012760:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8012764:	b087      	sub	sp, #28
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
  heap_header_t *qp, *hp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
 8012766:	2800      	cmp	r0, #0
 8012768:	d072      	beq.n	8012850 <chThdCreateFromHeap.constprop.87+0xf0>
 801276a:	f100 0807 	add.w	r8, r0, #7
 801276e:	4607      	mov	r7, r0

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8012770:	4855      	ldr	r0, [pc, #340]	; (80128c8 <chThdCreateFromHeap.constprop.87+0x168>)
 8012772:	4615      	mov	r5, r2
 8012774:	460e      	mov	r6, r1
 8012776:	461c      	mov	r4, r3
 8012778:	f7fc fbba 	bl	800eef0 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 801277c:	f8df e15c 	ldr.w	lr, [pc, #348]	; 80128dc <chThdCreateFromHeap.constprop.87+0x17c>
  while (H_NEXT(qp) != NULL) {
 8012780:	f8de 2000 	ldr.w	r2, [lr]
 8012784:	ea4f 08d8 	mov.w	r8, r8, lsr #3
 8012788:	b1ca      	cbz	r2, 80127be <chThdCreateFromHeap.constprop.87+0x5e>
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 801278a:	f8d2 c004 	ldr.w	ip, [r2, #4]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 801278e:	f102 030f 	add.w	r3, r2, #15

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8012792:	f10c 0101 	add.w	r1, ip, #1
 8012796:	00c9      	lsls	r1, r1, #3

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8012798:	f023 0307 	bic.w	r3, r3, #7

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 801279c:	1850      	adds	r0, r2, r1

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 801279e:	3b08      	subs	r3, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 80127a0:	4283      	cmp	r3, r0

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80127a2:	f102 0908 	add.w	r9, r2, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 80127a6:	d205      	bcs.n	80127b4 <chThdCreateFromHeap.constprop.87+0x54>
 80127a8:	3908      	subs	r1, #8
 80127aa:	1ad0      	subs	r0, r2, r3
 80127ac:	4408      	add	r0, r1
 80127ae:	10c0      	asrs	r0, r0, #3
 80127b0:	4540      	cmp	r0, r8
 80127b2:	d253      	bcs.n	801285c <chThdCreateFromHeap.constprop.87+0xfc>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 80127b4:	4696      	mov	lr, r2
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80127b6:	f8de 2000 	ldr.w	r2, [lr]
 80127ba:	2a00      	cmp	r2, #0
 80127bc:	d1e5      	bne.n	801278a <chThdCreateFromHeap.constprop.87+0x2a>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80127be:	f8df 9118 	ldr.w	r9, [pc, #280]	; 80128d8 <chThdCreateFromHeap.constprop.87+0x178>
 80127c2:	f109 0010 	add.w	r0, r9, #16
 80127c6:	f7fc fb33 	bl	800ee30 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 80127ca:	f8d9 3000 	ldr.w	r3, [r9]
 80127ce:	2b00      	cmp	r3, #0
 80127d0:	d078      	beq.n	80128c4 <chThdCreateFromHeap.constprop.87+0x164>
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
 80127d2:	f108 0001 	add.w	r0, r8, #1
 80127d6:	00c0      	lsls	r0, r0, #3
 80127d8:	2108      	movs	r1, #8
 80127da:	4798      	blx	r3
    if (hp != NULL) {
 80127dc:	2800      	cmp	r0, #0
 80127de:	d071      	beq.n	80128c4 <chThdCreateFromHeap.constprop.87+0x164>
      H_HEAP(hp) = heapp;
 80127e0:	f8c0 9000 	str.w	r9, [r0]
      H_SIZE(hp) = size;
 80127e4:	6047      	str	r7, [r0, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 80127e6:	f100 0808 	add.w	r8, r0, #8
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
 80127ea:	f1b8 0f00 	cmp.w	r8, #0
 80127ee:	d069      	beq.n	80128c4 <chThdCreateFromHeap.constprop.87+0x164>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 80127f0:	4447      	add	r7, r8
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 80127f2:	2380      	movs	r3, #128	; 0x80
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80127f4:	4547      	cmp	r7, r8
 80127f6:	9303      	str	r3, [sp, #12]
 80127f8:	9702      	str	r7, [sp, #8]
 80127fa:	e88d 0140 	stmia.w	sp, {r6, r8}
 80127fe:	9504      	str	r5, [sp, #16]
 8012800:	9405      	str	r4, [sp, #20]
    *startp++ = v;
 8012802:	bf88      	it	hi
 8012804:	2355      	movhi	r3, #85	; 0x55
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8012806:	d903      	bls.n	8012810 <chThdCreateFromHeap.constprop.87+0xb0>
    *startp++ = v;
 8012808:	f808 3b01 	strb.w	r3, [r8], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 801280c:	4547      	cmp	r7, r8
 801280e:	d1fb      	bne.n	8012808 <chThdCreateFromHeap.constprop.87+0xa8>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8012810:	2320      	movs	r3, #32
 8012812:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8012816:	f7fc fab3 	bl	800ed80 <_dbg_check_lock>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 801281a:	4668      	mov	r0, sp
 801281c:	f7fc f828 	bl	800e870 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 8012820:	2301      	movs	r3, #1
 8012822:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8012826:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 8012828:	f7ff fe32 	bl	8012490 <chSchWakeupS.constprop.97>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 801282c:	f7fc fa98 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8012830:	4b26      	ldr	r3, [pc, #152]	; (80128cc <chThdCreateFromHeap.constprop.87+0x16c>)
 8012832:	681a      	ldr	r2, [r3, #0]
 8012834:	429a      	cmp	r2, r3
 8012836:	d004      	beq.n	8012842 <chThdCreateFromHeap.constprop.87+0xe2>
 8012838:	6999      	ldr	r1, [r3, #24]
 801283a:	6893      	ldr	r3, [r2, #8]
 801283c:	688a      	ldr	r2, [r1, #8]
 801283e:	429a      	cmp	r2, r3
 8012840:	d309      	bcc.n	8012856 <chThdCreateFromHeap.constprop.87+0xf6>
 8012842:	2300      	movs	r3, #0
 8012844:	f383 8811 	msr	BASEPRI, r3
 8012848:	4620      	mov	r0, r4
  chSysUnlock();

  return tp;
}
 801284a:	b007      	add	sp, #28
 801284c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
  heap_header_t *qp, *hp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
 8012850:	481f      	ldr	r0, [pc, #124]	; (80128d0 <chThdCreateFromHeap.constprop.87+0x170>)
 8012852:	f7fb ff85 	bl	800e760 <chSysHalt>
 8012856:	481f      	ldr	r0, [pc, #124]	; (80128d4 <chThdCreateFromHeap.constprop.87+0x174>)
 8012858:	f7fb ff82 	bl	800e760 <chSysHalt>

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 801285c:	429a      	cmp	r2, r3
 801285e:	d21b      	bcs.n	8012898 <chThdCreateFromHeap.constprop.87+0x138>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8012860:	ebc9 0103 	rsb	r1, r9, r3
 8012864:	10c9      	asrs	r1, r1, #3
        if (bpages > pages) {
 8012866:	4540      	cmp	r0, r8
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8012868:	6051      	str	r1, [r2, #4]
        if (bpages > pages) {
 801286a:	d90b      	bls.n	8012884 <chThdCreateFromHeap.constprop.87+0x124>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 801286c:	f108 0e01 	add.w	lr, r8, #1
 8012870:	eb03 01ce 	add.w	r1, r3, lr, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 8012874:	ea6f 0808 	mvn.w	r8, r8
 8012878:	4440      	add	r0, r8
 801287a:	6048      	str	r0, [r1, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 801287c:	6810      	ldr	r0, [r2, #0]
 801287e:	f843 003e 	str.w	r0, [r3, lr, lsl #3]
          H_NEXT(hp) = fp;
 8012882:	6011      	str	r1, [r2, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;
 8012884:	4a14      	ldr	r2, [pc, #80]	; (80128d8 <chThdCreateFromHeap.constprop.87+0x178>)
          H_NEXT(qp) = fp;
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 8012886:	605f      	str	r7, [r3, #4]
      H_HEAP(hp) = heapp;
 8012888:	4698      	mov	r8, r3

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 801288a:	f102 0010 	add.w	r0, r2, #16
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;
 801288e:	f848 2b08 	str.w	r2, [r8], #8

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 8012892:	f7fc facd 	bl	800ee30 <chMtxUnlock>
 8012896:	e7a8      	b.n	80127ea <chThdCreateFromHeap.constprop.87+0x8a>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 8012898:	45c4      	cmp	ip, r8
 801289a:	d00e      	beq.n	80128ba <chThdCreateFromHeap.constprop.87+0x15a>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 801289c:	f108 0801 	add.w	r8, r8, #1
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80128a0:	eb02 00c8 	add.w	r0, r2, r8, lsl #3
 80128a4:	eba1 01c8 	sub.w	r1, r1, r8, lsl #3
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
 80128a8:	6813      	ldr	r3, [r2, #0]
 80128aa:	f842 3038 	str.w	r3, [r2, r8, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80128ae:	10c9      	asrs	r1, r1, #3
 80128b0:	6041      	str	r1, [r0, #4]
          H_NEXT(qp) = fp;
 80128b2:	4613      	mov	r3, r2
 80128b4:	f8ce 0000 	str.w	r0, [lr]
 80128b8:	e7e4      	b.n	8012884 <chThdCreateFromHeap.constprop.87+0x124>
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 80128ba:	6813      	ldr	r3, [r2, #0]
 80128bc:	f8ce 3000 	str.w	r3, [lr]
 80128c0:	4613      	mov	r3, r2
 80128c2:	e7df      	b.n	8012884 <chThdCreateFromHeap.constprop.87+0x124>
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
 80128c4:	2000      	movs	r0, #0
 80128c6:	e7c0      	b.n	801284a <chThdCreateFromHeap.constprop.87+0xea>
 80128c8:	20027e50 	.word	0x20027e50
 80128cc:	20027edc 	.word	0x20027edc
 80128d0:	080174f8 	.word	0x080174f8
 80128d4:	08017594 	.word	0x08017594
 80128d8:	20027e40 	.word	0x20027e40
 80128dc:	20027e48 	.word	0x20027e48

080128e0 <i2cStart.constprop.66>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 80128e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 80128e4:	4c81      	ldr	r4, [pc, #516]	; (8012aec <i2cStart.constprop.66+0x20c>)
 80128e6:	7823      	ldrb	r3, [r4, #0]
 80128e8:	1e5a      	subs	r2, r3, #1
 80128ea:	2a01      	cmp	r2, #1
 80128ec:	d904      	bls.n	80128f8 <i2cStart.constprop.66+0x18>
 80128ee:	2b05      	cmp	r3, #5
 80128f0:	d002      	beq.n	80128f8 <i2cStart.constprop.66+0x18>
 80128f2:	487f      	ldr	r0, [pc, #508]	; (8012af0 <i2cStart.constprop.66+0x210>)
 80128f4:	f7fb ff34 	bl	800e760 <chSysHalt>
 80128f8:	2320      	movs	r3, #32
 80128fa:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80128fe:	f7fc fa3f 	bl	800ed80 <_dbg_check_lock>
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8012902:	7822      	ldrb	r2, [r4, #0]
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8012904:	4b7b      	ldr	r3, [pc, #492]	; (8012af4 <i2cStart.constprop.66+0x214>)
 8012906:	6063      	str	r3, [r4, #4]
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8012908:	f240 4056 	movw	r0, #1110	; 0x456
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 801290c:	f240 4116 	movw	r1, #1046	; 0x416
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8012910:	2a01      	cmp	r2, #1
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8012912:	62a0      	str	r0, [r4, #40]	; 0x28
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8012914:	6261      	str	r1, [r4, #36]	; 0x24
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8012916:	6b65      	ldr	r5, [r4, #52]	; 0x34
 8012918:	4e74      	ldr	r6, [pc, #464]	; (8012aec <i2cStart.constprop.66+0x20c>)
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 801291a:	d05c      	beq.n	80129d6 <i2cStart.constprop.66+0xf6>
 801291c:	4f76      	ldr	r7, [pc, #472]	; (8012af8 <i2cStart.constprop.66+0x218>)
 801291e:	4a77      	ldr	r2, [pc, #476]	; (8012afc <i2cStart.constprop.66+0x21c>)
 8012920:	4619      	mov	r1, r3
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8012922:	4628      	mov	r0, r5
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8012924:	f04f 0c01 	mov.w	ip, #1
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8012928:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 801292a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 801292c:	f8d6 8000 	ldr.w	r8, [r6]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8012930:	f8d3 e000 	ldr.w	lr, [r3]
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 8012934:	4e72      	ldr	r6, [pc, #456]	; (8012b00 <i2cStart.constprop.66+0x220>)
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8012936:	f105 0310 	add.w	r3, r5, #16
 801293a:	f8c8 3008 	str.w	r3, [r8, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 801293e:	f8ce 3008 	str.w	r3, [lr, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8012942:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
 8012946:	f8c5 e000 	str.w	lr, [r5]
  dp->CR1 = 0;
 801294a:	2300      	movs	r3, #0
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 801294c:	f44f 6e10 	mov.w	lr, #2304	; 0x900
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 8012950:	42b7      	cmp	r7, r6
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 8012952:	602b      	str	r3, [r5, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8012954:	f8c5 e004 	str.w	lr, [r5, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 8012958:	d811      	bhi.n	801297e <i2cStart.constprop.66+0x9e>
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 801295a:	f8d0 e004 	ldr.w	lr, [r0, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 801295e:	4f67      	ldr	r7, [pc, #412]	; (8012afc <i2cStart.constprop.66+0x21c>)
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8012960:	f64f 76c0 	movw	r6, #65472	; 0xffc0
 8012964:	ea0e 0606 	and.w	r6, lr, r6
 8012968:	6046      	str	r6, [r0, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 801296a:	6846      	ldr	r6, [r0, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 801296c:	42ba      	cmp	r2, r7
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 801296e:	f046 061a 	orr.w	r6, r6, #26
 8012972:	6046      	str	r6, [r0, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8012974:	dc06      	bgt.n	8012984 <i2cStart.constprop.66+0xa4>
    /* Configure clock_div in standard mode.*/
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");
 8012976:	f1bc 0f01 	cmp.w	ip, #1
 801297a:	f000 8088 	beq.w	8012a8e <i2cStart.constprop.66+0x1ae>
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 801297e:	4861      	ldr	r0, [pc, #388]	; (8012b04 <i2cStart.constprop.66+0x224>)
 8012980:	f7fb feee 	bl	800e760 <chSysHalt>
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
 8012984:	4e60      	ldr	r6, [pc, #384]	; (8012b08 <i2cStart.constprop.66+0x228>)
 8012986:	42b2      	cmp	r2, r6
 8012988:	dd62      	ble.n	8012a50 <i2cStart.constprop.66+0x170>
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");

  dp->CCR = regCCR;
 801298a:	61c3      	str	r3, [r0, #28]
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 801298c:	780a      	ldrb	r2, [r1, #0]
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 801298e:	6803      	ldr	r3, [r0, #0]
  switch (opmode) {
 8012990:	2a02      	cmp	r2, #2
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8012992:	b29b      	uxth	r3, r3
  switch (opmode) {
 8012994:	f000 8096 	beq.w	8012ac4 <i2cStart.constprop.66+0x1e4>
 8012998:	2a03      	cmp	r2, #3
 801299a:	f000 8090 	beq.w	8012abe <i2cStart.constprop.66+0x1de>
 801299e:	2a01      	cmp	r2, #1
 80129a0:	d102      	bne.n	80129a8 <i2cStart.constprop.66+0xc8>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 80129a2:	f023 030a 	bic.w	r3, r3, #10
 80129a6:	b29b      	uxth	r3, r3
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  }
  dp->CR1 = regCR1;
 80129a8:	6003      	str	r3, [r0, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 80129aa:	682b      	ldr	r3, [r5, #0]
 80129ac:	f043 0301 	orr.w	r3, r3, #1
 80129b0:	602b      	str	r3, [r5, #0]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 80129b2:	2302      	movs	r3, #2
 80129b4:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80129b6:	f7fc f9d3 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80129ba:	4b54      	ldr	r3, [pc, #336]	; (8012b0c <i2cStart.constprop.66+0x22c>)
 80129bc:	681a      	ldr	r2, [r3, #0]
 80129be:	429a      	cmp	r2, r3
 80129c0:	d004      	beq.n	80129cc <i2cStart.constprop.66+0xec>
 80129c2:	6999      	ldr	r1, [r3, #24]
 80129c4:	6893      	ldr	r3, [r2, #8]
 80129c6:	688a      	ldr	r2, [r1, #8]
 80129c8:	429a      	cmp	r2, r3
 80129ca:	d375      	bcc.n	8012ab8 <i2cStart.constprop.66+0x1d8>
 80129cc:	2300      	movs	r3, #0
 80129ce:	f383 8811 	msr	BASEPRI, r3
 80129d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      bool b;

      rccResetI2C2();
 80129d6:	4f4e      	ldr	r7, [pc, #312]	; (8012b10 <i2cStart.constprop.66+0x230>)
      b = dmaStreamAllocate(i2cp->dmarx,
 80129d8:	6af0      	ldr	r0, [r6, #44]	; 0x2c

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      bool b;

      rccResetI2C2();
 80129da:	6a3b      	ldr	r3, [r7, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 80129dc:	4a4d      	ldr	r2, [pc, #308]	; (8012b14 <i2cStart.constprop.66+0x234>)

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      bool b;

      rccResetI2C2();
 80129de:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80129e2:	2100      	movs	r1, #0
 80129e4:	623b      	str	r3, [r7, #32]
 80129e6:	6239      	str	r1, [r7, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 80129e8:	4633      	mov	r3, r6
 80129ea:	2105      	movs	r1, #5
 80129ec:	f7fa f920 	bl	800cc30 <dmaStreamAllocate>
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 80129f0:	bb58      	cbnz	r0, 8012a4a <i2cStart.constprop.66+0x16a>
      b = dmaStreamAllocate(i2cp->dmatx,
 80129f2:	4633      	mov	r3, r6
 80129f4:	4a48      	ldr	r2, [pc, #288]	; (8012b18 <i2cStart.constprop.66+0x238>)
 80129f6:	6b30      	ldr	r0, [r6, #48]	; 0x30
 80129f8:	2105      	movs	r1, #5
 80129fa:	f7fa f919 	bl	800cc30 <dmaStreamAllocate>
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 80129fe:	bb20      	cbnz	r0, 8012a4a <i2cStart.constprop.66+0x16a>
      rccEnableI2C2(FALSE);
 8012a00:	6c3b      	ldr	r3, [r7, #64]	; 0x40

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8012a02:	4a46      	ldr	r2, [pc, #280]	; (8012b1c <i2cStart.constprop.66+0x23c>)
 8012a04:	6871      	ldr	r1, [r6, #4]
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8012a06:	6a70      	ldr	r0, [r6, #36]	; 0x24
      b = dmaStreamAllocate(i2cp->dmatx,
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
 8012a08:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8012a0c:	643b      	str	r3, [r7, #64]	; 0x40
 8012a0e:	2750      	movs	r7, #80	; 0x50
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8012a10:	2302      	movs	r3, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8012a12:	f882 7321 	strb.w	r7, [r2, #801]	; 0x321
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8012a16:	f8c2 3184 	str.w	r3, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8012a1a:	6053      	str	r3, [r2, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8012a1c:	f882 7322 	strb.w	r7, [r2, #802]	; 0x322
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8012a20:	2704      	movs	r7, #4
 8012a22:	f8c2 7184 	str.w	r7, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8012a26:	6057      	str	r7, [r2, #4]
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8012a28:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8012a2a:	684a      	ldr	r2, [r1, #4]
 8012a2c:	f891 c008 	ldrb.w	ip, [r1, #8]
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8012a30:	f040 6060 	orr.w	r0, r0, #234881024	; 0xe000000
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8012a34:	f043 6360 	orr.w	r3, r3, #234881024	; 0xe000000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8012a38:	f440 3040 	orr.w	r0, r0, #196608	; 0x30000
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8012a3c:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8012a40:	6270      	str	r0, [r6, #36]	; 0x24
 8012a42:	1e57      	subs	r7, r2, #1
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8012a44:	62b3      	str	r3, [r6, #40]	; 0x28
 8012a46:	6b70      	ldr	r0, [r6, #52]	; 0x34
 8012a48:	e76e      	b.n	8012928 <i2cStart.constprop.66+0x48>
      rccResetI2C2();
      b = dmaStreamAllocate(i2cp->dmarx,
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 8012a4a:	4835      	ldr	r0, [pc, #212]	; (8012b20 <i2cStart.constprop.66+0x240>)
 8012a4c:	f7fb fe88 	bl	800e760 <chSysHalt>
    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
 8012a50:	f1ac 0302 	sub.w	r3, ip, #2
 8012a54:	2b01      	cmp	r3, #1
 8012a56:	d892      	bhi.n	801297e <i2cStart.constprop.66+0x9e>
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 8012a58:	f1bc 0f02 	cmp.w	ip, #2
 8012a5c:	d038      	beq.n	8012ad0 <i2cStart.constprop.66+0x1f0>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
 8012a5e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8012a62:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8012a66:	4e2f      	ldr	r6, [pc, #188]	; (8012b24 <i2cStart.constprop.66+0x244>)
 8012a68:	fbb6 f3f2 	udiv	r3, r6, r2
 8012a6c:	fb02 f203 	mul.w	r2, r2, r3
 8012a70:	1ab6      	subs	r6, r6, r2
 8012a72:	2e00      	cmp	r6, #0
 8012a74:	d183      	bne.n	801297e <i2cStart.constprop.66+0x9e>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 8012a76:	b29b      	uxth	r3, r3
      regCCR |= I2C_CCR_DUTY;
 8012a78:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    }

    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 8012a7c:	4313      	orrs	r3, r2
 8012a7e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8012a82:	ea6f 4353 	mvn.w	r3, r3, lsr #17

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 8012a86:	2208      	movs	r2, #8
 8012a88:	b29b      	uxth	r3, r3
 8012a8a:	6202      	str	r2, [r0, #32]
 8012a8c:	e77d      	b.n	801298a <i2cStart.constprop.66+0xaa>
  if (clock_speed <= 100000) {
    /* Configure clock_div in standard mode.*/
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
 8012a8e:	0052      	lsls	r2, r2, #1
 8012a90:	4e24      	ldr	r6, [pc, #144]	; (8012b24 <i2cStart.constprop.66+0x244>)
 8012a92:	fbb6 f3f2 	udiv	r3, r6, r2
 8012a96:	fb02 f203 	mul.w	r2, r2, r3
 8012a9a:	1ab6      	subs	r6, r6, r2
 8012a9c:	2e00      	cmp	r6, #0
 8012a9e:	f47f af6e 	bne.w	801297e <i2cStart.constprop.66+0x9e>
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8012aa2:	b29b      	uxth	r3, r3

    osalDbgAssert(clock_div >= 0x04,
 8012aa4:	2b03      	cmp	r3, #3
 8012aa6:	f67f af6a 	bls.w	801297e <i2cStart.constprop.66+0x9e>
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8012aaa:	221b      	movs	r2, #27

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8012aac:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8012ab0:	6202      	str	r2, [r0, #32]

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8012ab2:	f4bf af64 	bcs.w	801297e <i2cStart.constprop.66+0x9e>
 8012ab6:	e768      	b.n	801298a <i2cStart.constprop.66+0xaa>
 8012ab8:	481b      	ldr	r0, [pc, #108]	; (8012b28 <i2cStart.constprop.66+0x248>)
 8012aba:	f7fb fe51 	bl	800e760 <chSysHalt>
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8012abe:	f043 030a 	orr.w	r3, r3, #10
 8012ac2:	e771      	b.n	80129a8 <i2cStart.constprop.66+0xc8>
 8012ac4:	f023 0308 	bic.w	r3, r3, #8
 8012ac8:	b29b      	uxth	r3, r3
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8012aca:	f043 0302 	orr.w	r3, r3, #2
 8012ace:	e76b      	b.n	80129a8 <i2cStart.constprop.66+0xc8>
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
 8012ad0:	eb02 0642 	add.w	r6, r2, r2, lsl #1
 8012ad4:	4a13      	ldr	r2, [pc, #76]	; (8012b24 <i2cStart.constprop.66+0x244>)
 8012ad6:	fbb2 f3f6 	udiv	r3, r2, r6
 8012ada:	fb06 f603 	mul.w	r6, r6, r3
 8012ade:	1b92      	subs	r2, r2, r6
 8012ae0:	2a00      	cmp	r2, #0
 8012ae2:	f47f af4c 	bne.w	801297e <i2cStart.constprop.66+0x9e>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 8012ae6:	b29b      	uxth	r3, r3
 8012ae8:	e7c8      	b.n	8012a7c <i2cStart.constprop.66+0x19c>
 8012aea:	bf00      	nop
 8012aec:	200287cc 	.word	0x200287cc
 8012af0:	0801755c 	.word	0x0801755c
 8012af4:	08017550 	.word	0x08017550
 8012af8:	0001869f 	.word	0x0001869f
 8012afc:	000186a0 	.word	0x000186a0
 8012b00:	003d08ff 	.word	0x003d08ff
 8012b04:	08017580 	.word	0x08017580
 8012b08:	00061a80 	.word	0x00061a80
 8012b0c:	20027edc 	.word	0x20027edc
 8012b10:	40023800 	.word	0x40023800
 8012b14:	0800bc91 	.word	0x0800bc91
 8012b18:	0800b761 	.word	0x0800b761
 8012b1c:	e000e100 	.word	0xe000e100
 8012b20:	080175ac 	.word	0x080175ac
 8012b24:	018cba80 	.word	0x018cba80
 8012b28:	08017534 	.word	0x08017534
 8012b2c:	00000000 	.word	0x00000000

08012b30 <spiExchange.constprop.47>:
 * @param[in] txbuf     the pointer to the transmit buffer
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
 8012b30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                 const void *txbuf, void *rxbuf) {

  osalDbgCheck((spip != NULL) && (n > 0U) &&
 8012b32:	b168      	cbz	r0, 8012b50 <spiExchange.constprop.47+0x20>
 8012b34:	4615      	mov	r5, r2
 8012b36:	b15a      	cbz	r2, 8012b50 <spiExchange.constprop.47+0x20>
 8012b38:	460e      	mov	r6, r1
 8012b3a:	b149      	cbz	r1, 8012b50 <spiExchange.constprop.47+0x20>
 8012b3c:	4604      	mov	r4, r0
 8012b3e:	2320      	movs	r3, #32
 8012b40:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8012b44:	f7fc f91c 	bl	800ed80 <_dbg_check_lock>
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8012b48:	481c      	ldr	r0, [pc, #112]	; (8012bbc <spiExchange.constprop.47+0x8c>)
 8012b4a:	7803      	ldrb	r3, [r0, #0]
 8012b4c:	2b02      	cmp	r3, #2
 8012b4e:	d002      	beq.n	8012b56 <spiExchange.constprop.47+0x26>
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {

  osalDbgCheck((spip != NULL) && (n > 0U) &&
 8012b50:	481b      	ldr	r0, [pc, #108]	; (8012bc0 <spiExchange.constprop.47+0x90>)
 8012b52:	f7fb fe05 	bl	800e760 <chSysHalt>
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 8012b56:	6843      	ldr	r3, [r0, #4]
 8012b58:	681b      	ldr	r3, [r3, #0]
 8012b5a:	2b00      	cmp	r3, #0
 8012b5c:	d1f8      	bne.n	8012b50 <spiExchange.constprop.47+0x20>
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8012b5e:	f100 0220 	add.w	r2, r0, #32
 8012b62:	ca8c      	ldmia	r2, {r2, r3, r7}

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8012b64:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8012b66:	6812      	ldr	r2, [r2, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8012b68:	681b      	ldr	r3, [r3, #0]
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 8012b6a:	60d5      	str	r5, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8012b6c:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8012b70:	f447 6580 	orr.w	r5, r7, #1024	; 0x400
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8012b74:	2703      	movs	r7, #3
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8012b76:	6054      	str	r4, [r2, #4]
 8012b78:	7007      	strb	r7, [r0, #0]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 8012b7a:	6015      	str	r5, [r2, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8012b7c:	60de      	str	r6, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8012b7e:	605c      	str	r4, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8012b80:	6019      	str	r1, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 8012b82:	6811      	ldr	r1, [r2, #0]
 8012b84:	f041 0101 	orr.w	r1, r1, #1
 8012b88:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(spip->dmatx);
 8012b8a:	681a      	ldr	r2, [r3, #0]
 8012b8c:	f042 0201 	orr.w	r2, r2, #1
 8012b90:	601a      	str	r2, [r3, #0]
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {

  return chThdSuspendS(trp);
 8012b92:	3008      	adds	r0, #8
 8012b94:	f7fb fe44 	bl	800e820 <chThdSuspendS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8012b98:	f7fc f8e2 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8012b9c:	4b09      	ldr	r3, [pc, #36]	; (8012bc4 <spiExchange.constprop.47+0x94>)
 8012b9e:	681a      	ldr	r2, [r3, #0]
 8012ba0:	429a      	cmp	r2, r3
 8012ba2:	d004      	beq.n	8012bae <spiExchange.constprop.47+0x7e>
 8012ba4:	6999      	ldr	r1, [r3, #24]
 8012ba6:	6893      	ldr	r3, [r2, #8]
 8012ba8:	688a      	ldr	r2, [r1, #8]
 8012baa:	429a      	cmp	r2, r3
 8012bac:	d303      	bcc.n	8012bb6 <spiExchange.constprop.47+0x86>
 8012bae:	2300      	movs	r3, #0
 8012bb0:	f383 8811 	msr	BASEPRI, r3
 8012bb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012bb6:	4804      	ldr	r0, [pc, #16]	; (8012bc8 <spiExchange.constprop.47+0x98>)
 8012bb8:	f7fb fdd2 	bl	800e760 <chSysHalt>
 8012bbc:	2002879c 	.word	0x2002879c
 8012bc0:	08017528 	.word	0x08017528
 8012bc4:	20027edc 	.word	0x20027edc
 8012bc8:	0801751c 	.word	0x0801751c
 8012bcc:	00000000 	.word	0x00000000

08012bd0 <wdgReset.constprop.41>:
 *
 * @param[in] wdgp      pointer to the @p WDGDriver object
 *
 * @api
 */
void wdgReset(WDGDriver *wdgp) {
 8012bd0:	b508      	push	{r3, lr}
 8012bd2:	2320      	movs	r3, #32
 8012bd4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8012bd8:	f7fc f8d2 	bl	800ed80 <_dbg_check_lock>

  osalDbgCheck(wdgp != NULL);

  osalSysLock();
  osalDbgAssert(wdgp->state == WDG_READY, "not ready");
 8012bdc:	4b0e      	ldr	r3, [pc, #56]	; (8012c18 <wdgReset.constprop.41+0x48>)
 8012bde:	781a      	ldrb	r2, [r3, #0]
 8012be0:	2a02      	cmp	r2, #2
 8012be2:	d002      	beq.n	8012bea <wdgReset.constprop.41+0x1a>
 8012be4:	480d      	ldr	r0, [pc, #52]	; (8012c1c <wdgReset.constprop.41+0x4c>)
 8012be6:	f7fb fdbb 	bl	800e760 <chSysHalt>
 *
 * @notapi
 */
void wdg_lld_reset(WDGDriver * wdgp) {

  wdgp->wdg->KR = KR_KEY_RELOAD;
 8012bea:	689b      	ldr	r3, [r3, #8]
 8012bec:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8012bf0:	601a      	str	r2, [r3, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8012bf2:	f7fc f8b5 	bl	800ed60 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8012bf6:	4b0a      	ldr	r3, [pc, #40]	; (8012c20 <wdgReset.constprop.41+0x50>)
 8012bf8:	681a      	ldr	r2, [r3, #0]
 8012bfa:	429a      	cmp	r2, r3
 8012bfc:	d004      	beq.n	8012c08 <wdgReset.constprop.41+0x38>
 8012bfe:	6999      	ldr	r1, [r3, #24]
 8012c00:	6893      	ldr	r3, [r2, #8]
 8012c02:	688a      	ldr	r2, [r1, #8]
 8012c04:	429a      	cmp	r2, r3
 8012c06:	d303      	bcc.n	8012c10 <wdgReset.constprop.41+0x40>
 8012c08:	2300      	movs	r3, #0
 8012c0a:	f383 8811 	msr	BASEPRI, r3
 8012c0e:	bd08      	pop	{r3, pc}
 8012c10:	4804      	ldr	r0, [pc, #16]	; (8012c24 <wdgReset.constprop.41+0x54>)
 8012c12:	f7fb fda5 	bl	800e760 <chSysHalt>
 8012c16:	bf00      	nop
 8012c18:	20028804 	.word	0x20028804
 8012c1c:	080175a0 	.word	0x080175a0
 8012c20:	20027edc 	.word	0x20027edc
 8012c24:	080174ec 	.word	0x080174ec
	...

08012c30 <str_replace>:
#include "sleep.h"
#include "chprintf.h"
#include <string.h>
#include <math.h>

void str_replace(char *string, uint32_t size, char *search, char *replace) {
 8012c30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012c34:	b083      	sub	sp, #12
 8012c36:	468b      	mov	fp, r1
	for(uint32_t i=0; string[i] != 0; i++) { // Find search string
 8012c38:	7801      	ldrb	r1, [r0, #0]
#include "sleep.h"
#include "chprintf.h"
#include <string.h>
#include <math.h>

void str_replace(char *string, uint32_t size, char *search, char *replace) {
 8012c3a:	af02      	add	r7, sp, #8
	for(uint32_t i=0; string[i] != 0; i++) { // Find search string
 8012c3c:	b3b1      	cbz	r1, 8012cac <str_replace+0x7c>
 8012c3e:	4692      	mov	sl, r2
 8012c40:	7812      	ldrb	r2, [r2, #0]
 8012c42:	4680      	mov	r8, r0
 8012c44:	ebc0 0908 	rsb	r9, r0, r8
		uint32_t j=0;
		for(j=0; search[j] != 0; j++)
 8012c48:	2a00      	cmp	r2, #0
 8012c4a:	d03b      	beq.n	8012cc4 <str_replace+0x94>
			if(string[i+j] != search[j])
 8012c4c:	f898 1000 	ldrb.w	r1, [r8]
 8012c50:	4291      	cmp	r1, r2
 8012c52:	d12f      	bne.n	8012cb4 <str_replace+0x84>
 8012c54:	4656      	mov	r6, sl
 8012c56:	46c6      	mov	lr, r8
 8012c58:	2500      	movs	r5, #0
 8012c5a:	e003      	b.n	8012c64 <str_replace+0x34>
 8012c5c:	f81e cf01 	ldrb.w	ip, [lr, #1]!
 8012c60:	45a4      	cmp	ip, r4
 8012c62:	d127      	bne.n	8012cb4 <str_replace+0x84>
#include <math.h>

void str_replace(char *string, uint32_t size, char *search, char *replace) {
	for(uint32_t i=0; string[i] != 0; i++) { // Find search string
		uint32_t j=0;
		for(j=0; search[j] != 0; j++)
 8012c64:	f816 4f01 	ldrb.w	r4, [r6, #1]!
 8012c68:	3501      	adds	r5, #1
 8012c6a:	2c00      	cmp	r4, #0
 8012c6c:	d1f6      	bne.n	8012c5c <str_replace+0x2c>
			if(string[i+j] != search[j])
				break;
		if(search[j] == 0) { // String found, replace it
			string[i] = 0;
			char temp[size-i-j];
 8012c6e:	ebc9 020b 	rsb	r2, r9, fp
 8012c72:	1b52      	subs	r2, r2, r5
 8012c74:	461e      	mov	r6, r3
 8012c76:	1dd3      	adds	r3, r2, #7
 8012c78:	f023 0307 	bic.w	r3, r3, #7
	for(uint32_t i=0; string[i] != 0; i++) { // Find search string
		uint32_t j=0;
		for(j=0; search[j] != 0; j++)
			if(string[i+j] != search[j])
				break;
		if(search[j] == 0) { // String found, replace it
 8012c7c:	46ea      	mov	sl, sp
			string[i] = 0;
			char temp[size-i-j];
 8012c7e:	ebad 0d03 	sub.w	sp, sp, r3
 8012c82:	ab02      	add	r3, sp, #8
		uint32_t j=0;
		for(j=0; search[j] != 0; j++)
			if(string[i+j] != search[j])
				break;
		if(search[j] == 0) { // String found, replace it
			string[i] = 0;
 8012c84:	f04f 0e00 	mov.w	lr, #0
			char temp[size-i-j];
			memcpy(temp, &string[i+j], size-i-j);
 8012c88:	eb05 0109 	add.w	r1, r5, r9
 8012c8c:	4604      	mov	r4, r0
 8012c8e:	4401      	add	r1, r0
		uint32_t j=0;
		for(j=0; search[j] != 0; j++)
			if(string[i+j] != search[j])
				break;
		if(search[j] == 0) { // String found, replace it
			string[i] = 0;
 8012c90:	f888 e000 	strb.w	lr, [r8]
			char temp[size-i-j];
			memcpy(temp, &string[i+j], size-i-j);
 8012c94:	4618      	mov	r0, r3
 8012c96:	f7ee fcfb 	bl	8001690 <memcpy>
			chsnprintf(string, size, "%s%s%s", string, replace, temp);
 8012c9a:	9600      	str	r6, [sp, #0]
 8012c9c:	9001      	str	r0, [sp, #4]
 8012c9e:	4659      	mov	r1, fp
 8012ca0:	4623      	mov	r3, r4
 8012ca2:	4620      	mov	r0, r4
 8012ca4:	4a08      	ldr	r2, [pc, #32]	; (8012cc8 <str_replace+0x98>)
 8012ca6:	f7f9 fac3 	bl	800c230 <chsnprintf>
 8012caa:	46d5      	mov	sp, sl
			return;
		}
	}
}
 8012cac:	3704      	adds	r7, #4
 8012cae:	46bd      	mov	sp, r7
 8012cb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#include "chprintf.h"
#include <string.h>
#include <math.h>

void str_replace(char *string, uint32_t size, char *search, char *replace) {
	for(uint32_t i=0; string[i] != 0; i++) { // Find search string
 8012cb4:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8012cb8:	2900      	cmp	r1, #0
 8012cba:	d0f7      	beq.n	8012cac <str_replace+0x7c>
 8012cbc:	ebc0 0908 	rsb	r9, r0, r8
		uint32_t j=0;
		for(j=0; search[j] != 0; j++)
 8012cc0:	2a00      	cmp	r2, #0
 8012cc2:	d1c3      	bne.n	8012c4c <str_replace+0x1c>
 8012cc4:	4615      	mov	r5, r2
 8012cc6:	e7d2      	b.n	8012c6e <str_replace+0x3e>
 8012cc8:	080175d0 	.word	0x080175d0
 8012ccc:	00000000 	.word	0x00000000

08012cd0 <replace_placeholders>:
}

/**
  * Replaces placeholders with variables
  */
void replace_placeholders(char* fskmsg, uint16_t size, trackPoint_t *tp) {
 8012cd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012cd4:	b087      	sub	sp, #28
 8012cd6:	4614      	mov	r4, r2
 8012cd8:	4605      	mov	r5, r0
 8012cda:	468a      	mov	sl, r1
	char buf[16];
	chsnprintf(buf, sizeof(buf), "%d", tp->id);
 8012cdc:	6813      	ldr	r3, [r2, #0]
 8012cde:	4ac1      	ldr	r2, [pc, #772]	; (8012fe4 <replace_placeholders+0x314>)
	str_replace(fskmsg, size, "<ID>", buf);
	chsnprintf(buf, sizeof(buf), "%04d-%02d-%02d", tp->time.year, tp->time.month, tp->time.day);
	str_replace(fskmsg, size, "<DATE>", buf);
	chsnprintf(buf, sizeof(buf), "%02d:%02d:%02d", tp->time.hour, tp->time.minute, tp->time.second);
	str_replace(fskmsg, size, "<TIME>", buf);
	chsnprintf(buf, sizeof(buf), "%d.%05d", tp->gps_lat/10000000, ((tp->gps_lat > 0 ? 1:-1)*tp->gps_lat%10000000)/100);
 8012ce0:	4ec1      	ldr	r6, [pc, #772]	; (8012fe8 <replace_placeholders+0x318>)
 8012ce2:	f8df 9368 	ldr.w	r9, [pc, #872]	; 801304c <replace_placeholders+0x37c>
 8012ce6:	f8df 8368 	ldr.w	r8, [pc, #872]	; 8013050 <replace_placeholders+0x380>
	str_replace(fskmsg, size, "<ALT>", buf);
	chsnprintf(buf, sizeof(buf), "%d", tp->gps_sats);
	str_replace(fskmsg, size, "<SATS>", buf);
	chsnprintf(buf, sizeof(buf), "%d", tp->gps_ttff);
	str_replace(fskmsg, size, "<TTFF>", buf);
	chsnprintf(buf, sizeof(buf), "%d.%02d", tp->adc_battery/1000, (tp->adc_battery%1000)/10);
 8012cea:	f8df b368 	ldr.w	fp, [pc, #872]	; 8013054 <replace_placeholders+0x384>
 8012cee:	4fbf      	ldr	r7, [pc, #764]	; (8012fec <replace_placeholders+0x31c>)
/**
  * Replaces placeholders with variables
  */
void replace_placeholders(char* fskmsg, uint16_t size, trackPoint_t *tp) {
	char buf[16];
	chsnprintf(buf, sizeof(buf), "%d", tp->id);
 8012cf0:	a802      	add	r0, sp, #8
 8012cf2:	2110      	movs	r1, #16
 8012cf4:	f7f9 fa9c 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<ID>", buf);
 8012cf8:	ab02      	add	r3, sp, #8
 8012cfa:	4651      	mov	r1, sl
 8012cfc:	4628      	mov	r0, r5
 8012cfe:	4abc      	ldr	r2, [pc, #752]	; (8012ff0 <replace_placeholders+0x320>)
 8012d00:	f7ff ff96 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%04d-%02d-%02d", tp->time.year, tp->time.month, tp->time.day);
 8012d04:	79e1      	ldrb	r1, [r4, #7]
 8012d06:	79a2      	ldrb	r2, [r4, #6]
 8012d08:	88a3      	ldrh	r3, [r4, #4]
 8012d0a:	9101      	str	r1, [sp, #4]
 8012d0c:	9200      	str	r2, [sp, #0]
 8012d0e:	a802      	add	r0, sp, #8
 8012d10:	4ab8      	ldr	r2, [pc, #736]	; (8012ff4 <replace_placeholders+0x324>)
 8012d12:	2110      	movs	r1, #16
 8012d14:	f7f9 fa8c 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<DATE>", buf);
 8012d18:	ab02      	add	r3, sp, #8
 8012d1a:	4651      	mov	r1, sl
 8012d1c:	4628      	mov	r0, r5
 8012d1e:	4ab6      	ldr	r2, [pc, #728]	; (8012ff8 <replace_placeholders+0x328>)
 8012d20:	f7ff ff86 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%02d:%02d:%02d", tp->time.hour, tp->time.minute, tp->time.second);
 8012d24:	7aa1      	ldrb	r1, [r4, #10]
 8012d26:	7a62      	ldrb	r2, [r4, #9]
 8012d28:	7a23      	ldrb	r3, [r4, #8]
 8012d2a:	9101      	str	r1, [sp, #4]
 8012d2c:	9200      	str	r2, [sp, #0]
 8012d2e:	a802      	add	r0, sp, #8
 8012d30:	4ab2      	ldr	r2, [pc, #712]	; (8012ffc <replace_placeholders+0x32c>)
 8012d32:	2110      	movs	r1, #16
 8012d34:	f7f9 fa7c 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<TIME>", buf);
 8012d38:	4ab1      	ldr	r2, [pc, #708]	; (8013000 <replace_placeholders+0x330>)
 8012d3a:	4651      	mov	r1, sl
 8012d3c:	ab02      	add	r3, sp, #8
 8012d3e:	4628      	mov	r0, r5
 8012d40:	f7ff ff76 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d.%05d", tp->gps_lat/10000000, ((tp->gps_lat > 0 ? 1:-1)*tp->gps_lat%10000000)/100);
 8012d44:	6920      	ldr	r0, [r4, #16]
 8012d46:	2800      	cmp	r0, #0
 8012d48:	bfcc      	ite	gt
 8012d4a:	2201      	movgt	r2, #1
 8012d4c:	f04f 32ff 	movle.w	r2, #4294967295
 8012d50:	fb00 f302 	mul.w	r3, r0, r2
 8012d54:	fb86 1203 	smull	r1, r2, r6, r3
 8012d58:	17d9      	asrs	r1, r3, #31
 8012d5a:	ebc1 52a2 	rsb	r2, r1, r2, asr #22
 8012d5e:	fb09 3212 	mls	r2, r9, r2, r3
 8012d62:	fb88 1302 	smull	r1, r3, r8, r2
 8012d66:	17d2      	asrs	r2, r2, #31
 8012d68:	ebc2 1263 	rsb	r2, r2, r3, asr #5
 8012d6c:	fb86 1300 	smull	r1, r3, r6, r0
 8012d70:	17c0      	asrs	r0, r0, #31
 8012d72:	9200      	str	r2, [sp, #0]
 8012d74:	ebc0 53a3 	rsb	r3, r0, r3, asr #22
 8012d78:	4aa2      	ldr	r2, [pc, #648]	; (8013004 <replace_placeholders+0x334>)
 8012d7a:	a802      	add	r0, sp, #8
 8012d7c:	2110      	movs	r1, #16
 8012d7e:	f7f9 fa57 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<LAT>", buf);
 8012d82:	4651      	mov	r1, sl
 8012d84:	4628      	mov	r0, r5
 8012d86:	ab02      	add	r3, sp, #8
 8012d88:	4a9f      	ldr	r2, [pc, #636]	; (8013008 <replace_placeholders+0x338>)
 8012d8a:	f7ff ff51 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d.%05d", tp->gps_lon/10000000, ((tp->gps_lon > 0 ? 1:-1)*tp->gps_lon%10000000)/100);
 8012d8e:	6963      	ldr	r3, [r4, #20]
 8012d90:	4a9c      	ldr	r2, [pc, #624]	; (8013004 <replace_placeholders+0x334>)
 8012d92:	2b00      	cmp	r3, #0
 8012d94:	bfcc      	ite	gt
 8012d96:	2101      	movgt	r1, #1
 8012d98:	f04f 31ff 	movle.w	r1, #4294967295
 8012d9c:	fb03 fe01 	mul.w	lr, r3, r1
 8012da0:	fb86 010e 	smull	r0, r1, r6, lr
 8012da4:	ea4f 70ee 	mov.w	r0, lr, asr #31
 8012da8:	ebc0 51a1 	rsb	r1, r0, r1, asr #22
 8012dac:	fb09 e111 	mls	r1, r9, r1, lr
 8012db0:	fb88 e001 	smull	lr, r0, r8, r1
 8012db4:	17c9      	asrs	r1, r1, #31
 8012db6:	fb86 e603 	smull	lr, r6, r6, r3
 8012dba:	ebc1 1160 	rsb	r1, r1, r0, asr #5
 8012dbe:	17db      	asrs	r3, r3, #31
 8012dc0:	ebc3 53a6 	rsb	r3, r3, r6, asr #22
 8012dc4:	9100      	str	r1, [sp, #0]
 8012dc6:	a802      	add	r0, sp, #8
 8012dc8:	2110      	movs	r1, #16
 8012dca:	f7f9 fa31 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<LON>", buf);
 8012dce:	ab02      	add	r3, sp, #8
 8012dd0:	4651      	mov	r1, sl
 8012dd2:	4628      	mov	r0, r5
 8012dd4:	4a8d      	ldr	r2, [pc, #564]	; (801300c <replace_placeholders+0x33c>)
	str_replace(fskmsg, size, "<CHARGE>", buf);
	chsnprintf(buf, sizeof(buf), "%d.%03d", tp->adc_discharge/1000, (tp->adc_discharge >= 0 ? 1 : -1) * (tp->adc_discharge%1000));
	str_replace(fskmsg, size, "<DISCHARGE>", buf);
	chsnprintf(buf, sizeof(buf), "%d", tp->int_press/10);
	str_replace(fskmsg, size, "<IPRESS>", buf);
	chsnprintf(buf, sizeof(buf), "%d.%d", tp->int_temp/100, (tp->int_temp%100)/10);
 8012dd6:	f8df 9280 	ldr.w	r9, [pc, #640]	; 8013058 <replace_placeholders+0x388>
	chsnprintf(buf, sizeof(buf), "%02d:%02d:%02d", tp->time.hour, tp->time.minute, tp->time.second);
	str_replace(fskmsg, size, "<TIME>", buf);
	chsnprintf(buf, sizeof(buf), "%d.%05d", tp->gps_lat/10000000, ((tp->gps_lat > 0 ? 1:-1)*tp->gps_lat%10000000)/100);
	str_replace(fskmsg, size, "<LAT>", buf);
	chsnprintf(buf, sizeof(buf), "%d.%05d", tp->gps_lon/10000000, ((tp->gps_lon > 0 ? 1:-1)*tp->gps_lon%10000000)/100);
	str_replace(fskmsg, size, "<LON>", buf);
 8012dda:	f7ff ff29 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d", tp->gps_alt);
 8012dde:	69a3      	ldr	r3, [r4, #24]
 8012de0:	4a80      	ldr	r2, [pc, #512]	; (8012fe4 <replace_placeholders+0x314>)
 8012de2:	a802      	add	r0, sp, #8
 8012de4:	2110      	movs	r1, #16
 8012de6:	f7f9 fa23 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<ALT>", buf);
 8012dea:	ab02      	add	r3, sp, #8
 8012dec:	4651      	mov	r1, sl
 8012dee:	4628      	mov	r0, r5
 8012df0:	4a87      	ldr	r2, [pc, #540]	; (8013010 <replace_placeholders+0x340>)
 8012df2:	f7ff ff1d 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d", tp->gps_sats);
 8012df6:	7f23      	ldrb	r3, [r4, #28]
 8012df8:	4a7a      	ldr	r2, [pc, #488]	; (8012fe4 <replace_placeholders+0x314>)
 8012dfa:	a802      	add	r0, sp, #8
 8012dfc:	2110      	movs	r1, #16
 8012dfe:	f7f9 fa17 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<SATS>", buf);
 8012e02:	ab02      	add	r3, sp, #8
 8012e04:	4651      	mov	r1, sl
 8012e06:	4628      	mov	r0, r5
 8012e08:	4a82      	ldr	r2, [pc, #520]	; (8013014 <replace_placeholders+0x344>)
 8012e0a:	f7ff ff11 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d", tp->gps_ttff);
 8012e0e:	7f63      	ldrb	r3, [r4, #29]
 8012e10:	4a74      	ldr	r2, [pc, #464]	; (8012fe4 <replace_placeholders+0x314>)
 8012e12:	a802      	add	r0, sp, #8
 8012e14:	2110      	movs	r1, #16
 8012e16:	f7f9 fa0b 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<TTFF>", buf);
 8012e1a:	4628      	mov	r0, r5
 8012e1c:	ab02      	add	r3, sp, #8
 8012e1e:	4651      	mov	r1, sl
 8012e20:	4a7d      	ldr	r2, [pc, #500]	; (8013018 <replace_placeholders+0x348>)
 8012e22:	f7ff ff05 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d.%02d", tp->adc_battery/1000, (tp->adc_battery%1000)/10);
 8012e26:	8c21      	ldrh	r1, [r4, #32]
 8012e28:	4a7c      	ldr	r2, [pc, #496]	; (801301c <replace_placeholders+0x34c>)
 8012e2a:	fbab 0301 	umull	r0, r3, fp, r1
 8012e2e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8012e32:	099b      	lsrs	r3, r3, #6
 8012e34:	fb06 1113 	mls	r1, r6, r3, r1
 8012e38:	b289      	uxth	r1, r1
 8012e3a:	fba7 0101 	umull	r0, r1, r7, r1
 8012e3e:	08c9      	lsrs	r1, r1, #3
 8012e40:	9100      	str	r1, [sp, #0]
 8012e42:	a802      	add	r0, sp, #8
 8012e44:	2110      	movs	r1, #16
 8012e46:	f7f9 f9f3 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<VBAT>", buf);
 8012e4a:	4628      	mov	r0, r5
 8012e4c:	ab02      	add	r3, sp, #8
 8012e4e:	4651      	mov	r1, sl
 8012e50:	4a73      	ldr	r2, [pc, #460]	; (8013020 <replace_placeholders+0x350>)
 8012e52:	f7ff feed 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d.%02d", tp->adc_solar/1000, (tp->adc_solar%1000)/10);
 8012e56:	8be1      	ldrh	r1, [r4, #30]
 8012e58:	4a70      	ldr	r2, [pc, #448]	; (801301c <replace_placeholders+0x34c>)
 8012e5a:	fbab 0301 	umull	r0, r3, fp, r1
 8012e5e:	099b      	lsrs	r3, r3, #6
 8012e60:	fb06 1113 	mls	r1, r6, r3, r1
 8012e64:	b289      	uxth	r1, r1
 8012e66:	fba7 0101 	umull	r0, r1, r7, r1
 8012e6a:	08c9      	lsrs	r1, r1, #3
 8012e6c:	9100      	str	r1, [sp, #0]
 8012e6e:	a802      	add	r0, sp, #8
 8012e70:	2110      	movs	r1, #16
 8012e72:	f7f9 f9dd 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<VSOL>", buf);
 8012e76:	ab02      	add	r3, sp, #8
 8012e78:	4651      	mov	r1, sl
 8012e7a:	4628      	mov	r0, r5
 8012e7c:	4a69      	ldr	r2, [pc, #420]	; (8013024 <replace_placeholders+0x354>)
 8012e7e:	f7ff fed7 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d.%03d", tp->adc_charge/1000, (tp->adc_charge >= 0 ? 1 : -1) * (tp->adc_charge%1000));
 8012e82:	f9b4 1022 	ldrsh.w	r1, [r4, #34]	; 0x22
 8012e86:	4a68      	ldr	r2, [pc, #416]	; (8013028 <replace_placeholders+0x358>)
 8012e88:	fb8b 3001 	smull	r3, r0, fp, r1
 8012e8c:	17cb      	asrs	r3, r1, #31
 8012e8e:	ebc3 13a0 	rsb	r3, r3, r0, asr #6
 8012e92:	2900      	cmp	r1, #0
 8012e94:	fb06 1113 	mls	r1, r6, r3, r1
 8012e98:	bfac      	ite	ge
 8012e9a:	2001      	movge	r0, #1
 8012e9c:	f04f 30ff 	movlt.w	r0, #4294967295
 8012ea0:	b209      	sxth	r1, r1
 8012ea2:	fb00 f101 	mul.w	r1, r0, r1
 8012ea6:	9100      	str	r1, [sp, #0]
 8012ea8:	b21b      	sxth	r3, r3
 8012eaa:	a802      	add	r0, sp, #8
 8012eac:	2110      	movs	r1, #16
 8012eae:	f7f9 f9bf 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<CHARGE>", buf);
 8012eb2:	ab02      	add	r3, sp, #8
 8012eb4:	4651      	mov	r1, sl
 8012eb6:	4628      	mov	r0, r5
 8012eb8:	4a5c      	ldr	r2, [pc, #368]	; (801302c <replace_placeholders+0x35c>)
 8012eba:	f7ff feb9 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d.%03d", tp->adc_discharge/1000, (tp->adc_discharge >= 0 ? 1 : -1) * (tp->adc_discharge%1000));
 8012ebe:	f9b4 1024 	ldrsh.w	r1, [r4, #36]	; 0x24
 8012ec2:	4a59      	ldr	r2, [pc, #356]	; (8013028 <replace_placeholders+0x358>)
 8012ec4:	fb8b 3b01 	smull	r3, fp, fp, r1
 8012ec8:	17cb      	asrs	r3, r1, #31
 8012eca:	ebc3 1bab 	rsb	fp, r3, fp, asr #6
 8012ece:	2900      	cmp	r1, #0
 8012ed0:	fb06 161b 	mls	r6, r6, fp, r1
 8012ed4:	bfac      	ite	ge
 8012ed6:	2301      	movge	r3, #1
 8012ed8:	f04f 33ff 	movlt.w	r3, #4294967295
 8012edc:	b236      	sxth	r6, r6
 8012ede:	fb03 f606 	mul.w	r6, r3, r6
 8012ee2:	9600      	str	r6, [sp, #0]
 8012ee4:	fa0f f38b 	sxth.w	r3, fp
 8012ee8:	a802      	add	r0, sp, #8
 8012eea:	2110      	movs	r1, #16
 8012eec:	f7f9 f9a0 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<DISCHARGE>", buf);
 8012ef0:	4651      	mov	r1, sl
 8012ef2:	ab02      	add	r3, sp, #8
 8012ef4:	4628      	mov	r0, r5
 8012ef6:	4a4e      	ldr	r2, [pc, #312]	; (8013030 <replace_placeholders+0x360>)
 8012ef8:	f7ff fe9a 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d", tp->int_press/10);
 8012efc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8012efe:	4a39      	ldr	r2, [pc, #228]	; (8012fe4 <replace_placeholders+0x314>)
 8012f00:	fba7 1303 	umull	r1, r3, r7, r3
 8012f04:	08db      	lsrs	r3, r3, #3
 8012f06:	a802      	add	r0, sp, #8
 8012f08:	2110      	movs	r1, #16
 8012f0a:	f7f9 f991 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<IPRESS>", buf);
 8012f0e:	ab02      	add	r3, sp, #8
 8012f10:	4651      	mov	r1, sl
 8012f12:	4628      	mov	r0, r5
 8012f14:	4a47      	ldr	r2, [pc, #284]	; (8013034 <replace_placeholders+0x364>)
 8012f16:	f7ff fe8b 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d.%d", tp->int_temp/100, (tp->int_temp%100)/10);
 8012f1a:	f9b4 102e 	ldrsh.w	r1, [r4, #46]	; 0x2e
 8012f1e:	4a46      	ldr	r2, [pc, #280]	; (8013038 <replace_placeholders+0x368>)
 8012f20:	fb88 3001 	smull	r3, r0, r8, r1
 8012f24:	17cb      	asrs	r3, r1, #31
 8012f26:	ebc3 1360 	rsb	r3, r3, r0, asr #5
 8012f2a:	2664      	movs	r6, #100	; 0x64
 8012f2c:	fb06 1113 	mls	r1, r6, r3, r1
 8012f30:	b209      	sxth	r1, r1
 8012f32:	fb89 e001 	smull	lr, r0, r9, r1
 8012f36:	17c9      	asrs	r1, r1, #31
 8012f38:	ebc1 01a0 	rsb	r1, r1, r0, asr #2
 8012f3c:	b209      	sxth	r1, r1
 8012f3e:	9100      	str	r1, [sp, #0]
 8012f40:	b21b      	sxth	r3, r3
 8012f42:	a802      	add	r0, sp, #8
 8012f44:	2110      	movs	r1, #16
 8012f46:	f7f9 f973 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<ITEMP>", buf);
 8012f4a:	4651      	mov	r1, sl
 8012f4c:	ab02      	add	r3, sp, #8
 8012f4e:	4628      	mov	r0, r5
 8012f50:	4a3a      	ldr	r2, [pc, #232]	; (801303c <replace_placeholders+0x36c>)
 8012f52:	f7ff fe6d 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d", tp->int_hum/10);
 8012f56:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8012f58:	4a22      	ldr	r2, [pc, #136]	; (8012fe4 <replace_placeholders+0x314>)
 8012f5a:	fba7 1303 	umull	r1, r3, r7, r3
 8012f5e:	08db      	lsrs	r3, r3, #3
 8012f60:	a802      	add	r0, sp, #8
 8012f62:	2110      	movs	r1, #16
 8012f64:	f7f9 f964 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<IHUM>", buf);
 8012f68:	4651      	mov	r1, sl
 8012f6a:	ab02      	add	r3, sp, #8
 8012f6c:	4628      	mov	r0, r5
 8012f6e:	4a34      	ldr	r2, [pc, #208]	; (8013040 <replace_placeholders+0x370>)
 8012f70:	f7ff fe5e 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d", tp->ext_press/10);
 8012f74:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8012f76:	4a1b      	ldr	r2, [pc, #108]	; (8012fe4 <replace_placeholders+0x314>)
 8012f78:	fba7 1303 	umull	r1, r3, r7, r3
 8012f7c:	08db      	lsrs	r3, r3, #3
 8012f7e:	a802      	add	r0, sp, #8
 8012f80:	2110      	movs	r1, #16
 8012f82:	f7f9 f955 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<EPRESS>", buf);
 8012f86:	ab02      	add	r3, sp, #8
 8012f88:	4651      	mov	r1, sl
 8012f8a:	4628      	mov	r0, r5
 8012f8c:	4a2d      	ldr	r2, [pc, #180]	; (8013044 <replace_placeholders+0x374>)
 8012f8e:	f7ff fe4f 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d.%d", tp->ext_temp/100, (tp->ext_temp%100)/10);
 8012f92:	f9b4 1036 	ldrsh.w	r1, [r4, #54]	; 0x36
 8012f96:	4a28      	ldr	r2, [pc, #160]	; (8013038 <replace_placeholders+0x368>)
 8012f98:	fb88 3801 	smull	r3, r8, r8, r1
 8012f9c:	17cb      	asrs	r3, r1, #31
 8012f9e:	ebc3 1368 	rsb	r3, r3, r8, asr #5
 8012fa2:	fb06 1613 	mls	r6, r6, r3, r1
 8012fa6:	b236      	sxth	r6, r6
 8012fa8:	fb89 1906 	smull	r1, r9, r9, r6
 8012fac:	17f6      	asrs	r6, r6, #31
 8012fae:	ebc6 06a9 	rsb	r6, r6, r9, asr #2
 8012fb2:	b236      	sxth	r6, r6
 8012fb4:	9600      	str	r6, [sp, #0]
 8012fb6:	b21b      	sxth	r3, r3
 8012fb8:	a802      	add	r0, sp, #8
 8012fba:	2110      	movs	r1, #16
 8012fbc:	f7f9 f938 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<ETEMP>", buf);
 8012fc0:	4651      	mov	r1, sl
 8012fc2:	ab02      	add	r3, sp, #8
 8012fc4:	4628      	mov	r0, r5
 8012fc6:	4a20      	ldr	r2, [pc, #128]	; (8013048 <replace_placeholders+0x378>)
 8012fc8:	f7ff fe32 	bl	8012c30 <str_replace>
	chsnprintf(buf, sizeof(buf), "%d", tp->ext_hum/10);
 8012fcc:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 8012fce:	4a05      	ldr	r2, [pc, #20]	; (8012fe4 <replace_placeholders+0x314>)
 8012fd0:	fba7 1303 	umull	r1, r3, r7, r3
 8012fd4:	08db      	lsrs	r3, r3, #3
 8012fd6:	a802      	add	r0, sp, #8
 8012fd8:	2110      	movs	r1, #16
 8012fda:	f7f9 f929 	bl	800c230 <chsnprintf>
	str_replace(fskmsg, size, "<EHUM>", buf);
 8012fde:	ab02      	add	r3, sp, #8
 8012fe0:	e03c      	b.n	801305c <replace_placeholders+0x38c>
 8012fe2:	bf00      	nop
 8012fe4:	08015410 	.word	0x08015410
 8012fe8:	6b5fca6b 	.word	0x6b5fca6b
 8012fec:	cccccccd 	.word	0xcccccccd
 8012ff0:	080175d8 	.word	0x080175d8
 8012ff4:	080175e0 	.word	0x080175e0
 8012ff8:	080175f0 	.word	0x080175f0
 8012ffc:	080175f8 	.word	0x080175f8
 8013000:	08017608 	.word	0x08017608
 8013004:	08017610 	.word	0x08017610
 8013008:	08017618 	.word	0x08017618
 801300c:	08017620 	.word	0x08017620
 8013010:	08017628 	.word	0x08017628
 8013014:	08017630 	.word	0x08017630
 8013018:	08017638 	.word	0x08017638
 801301c:	08017640 	.word	0x08017640
 8013020:	08017648 	.word	0x08017648
 8013024:	08017650 	.word	0x08017650
 8013028:	08017658 	.word	0x08017658
 801302c:	08017660 	.word	0x08017660
 8013030:	0801766c 	.word	0x0801766c
 8013034:	08017678 	.word	0x08017678
 8013038:	08017684 	.word	0x08017684
 801303c:	0801768c 	.word	0x0801768c
 8013040:	08017694 	.word	0x08017694
 8013044:	0801769c 	.word	0x0801769c
 8013048:	080176a8 	.word	0x080176a8
 801304c:	00989680 	.word	0x00989680
 8013050:	51eb851f 	.word	0x51eb851f
 8013054:	10624dd3 	.word	0x10624dd3
 8013058:	66666667 	.word	0x66666667
 801305c:	4651      	mov	r1, sl
 801305e:	4628      	mov	r0, r5
 8013060:	4a4f      	ldr	r2, [pc, #316]	; (80131a0 <replace_placeholders+0x4d0>)
 8013062:	f7ff fde5 	bl	8012c30 <str_replace>
	return crc;
}

void positionToMaidenhead(char m[], double lat, double lon)
{
	lon = lon + 180;
 8013066:	6960      	ldr	r0, [r4, #20]
 8013068:	f7ed fa8c 	bl	8000584 <__aeabi_i2d>
 801306c:	a346      	add	r3, pc, #280	; (adr r3, 8013188 <replace_placeholders+0x4b8>)
 801306e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013072:	f7ed fc17 	bl	80008a4 <__aeabi_ddiv>
 8013076:	2200      	movs	r2, #0
 8013078:	4b4a      	ldr	r3, [pc, #296]	; (80131a4 <replace_placeholders+0x4d4>)
 801307a:	f7ed f937 	bl	80002ec <__adddf3>
 801307e:	4606      	mov	r6, r0
	lat = lat + 90;
 8013080:	6920      	ldr	r0, [r4, #16]
	return crc;
}

void positionToMaidenhead(char m[], double lat, double lon)
{
	lon = lon + 180;
 8013082:	460f      	mov	r7, r1
	lat = lat + 90;
 8013084:	f7ed fa7e 	bl	8000584 <__aeabi_i2d>
 8013088:	a33f      	add	r3, pc, #252	; (adr r3, 8013188 <replace_placeholders+0x4b8>)
 801308a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801308e:	f7ed fc09 	bl	80008a4 <__aeabi_ddiv>
 8013092:	2200      	movs	r2, #0
 8013094:	4b44      	ldr	r3, [pc, #272]	; (80131a8 <replace_placeholders+0x4d8>)
 8013096:	f7ed f929 	bl	80002ec <__adddf3>

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
 801309a:	2200      	movs	r2, #0
}

void positionToMaidenhead(char m[], double lat, double lon)
{
	lon = lon + 180;
	lat = lat + 90;
 801309c:	4680      	mov	r8, r0
 801309e:	4689      	mov	r9, r1

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
 80130a0:	4b42      	ldr	r3, [pc, #264]	; (80131ac <replace_placeholders+0x4dc>)
 80130a2:	4630      	mov	r0, r6
 80130a4:	4639      	mov	r1, r7
 80130a6:	f7ed fbfd 	bl	80008a4 <__aeabi_ddiv>
 80130aa:	f7ed fd89 	bl	8000bc0 <__aeabi_d2uiz>
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));
 80130ae:	2200      	movs	r2, #0
 80130b0:	4b3f      	ldr	r3, [pc, #252]	; (80131b0 <replace_placeholders+0x4e0>)
void positionToMaidenhead(char m[], double lat, double lon)
{
	lon = lon + 180;
	lat = lat + 90;

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
 80130b2:	f100 0441 	add.w	r4, r0, #65	; 0x41
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));
 80130b6:	4649      	mov	r1, r9
 80130b8:	4640      	mov	r0, r8
void positionToMaidenhead(char m[], double lat, double lon)
{
	lon = lon + 180;
	lat = lat + 90;

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
 80130ba:	f88d 4008 	strb.w	r4, [sp, #8]
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));
 80130be:	f7ed fbf1 	bl	80008a4 <__aeabi_ddiv>
 80130c2:	f7ed fd7d 	bl	8000bc0 <__aeabi_d2uiz>

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
 80130c6:	2200      	movs	r2, #0
{
	lon = lon + 180;
	lat = lat + 90;

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));
 80130c8:	f100 0441 	add.w	r4, r0, #65	; 0x41

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
 80130cc:	4b37      	ldr	r3, [pc, #220]	; (80131ac <replace_placeholders+0x4dc>)
{
	lon = lon + 180;
	lat = lat + 90;

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));
 80130ce:	f88d 4009 	strb.w	r4, [sp, #9]

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
 80130d2:	4630      	mov	r0, r6
 80130d4:	4639      	mov	r1, r7
 80130d6:	f000 f8fb 	bl	80132d0 <fmod>
 80130da:	2200      	movs	r2, #0
 80130dc:	4b35      	ldr	r3, [pc, #212]	; (80131b4 <replace_placeholders+0x4e4>)
 80130de:	f7ed fab7 	bl	8000650 <__aeabi_dmul>
 80130e2:	f7ed fd6d 	bl	8000bc0 <__aeabi_d2uiz>
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));
 80130e6:	2200      	movs	r2, #0
 80130e8:	4b31      	ldr	r3, [pc, #196]	; (80131b0 <replace_placeholders+0x4e0>)
	lat = lat + 90;

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
 80130ea:	f100 0430 	add.w	r4, r0, #48	; 0x30
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));
 80130ee:	4649      	mov	r1, r9
 80130f0:	4640      	mov	r0, r8
	lat = lat + 90;

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
 80130f2:	f88d 400a 	strb.w	r4, [sp, #10]
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));
 80130f6:	f000 f8eb 	bl	80132d0 <fmod>
 80130fa:	f7ed fd61 	bl	8000bc0 <__aeabi_d2uiz>

	m[4] = ((uint8_t)'A') + ((uint8_t)((lon - ( ((uint8_t)(lon/2))*2)) / (5.0/60.0)));
 80130fe:	2200      	movs	r2, #0
 8013100:	4b2c      	ldr	r3, [pc, #176]	; (80131b4 <replace_placeholders+0x4e4>)

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));
 8013102:	f100 0430 	add.w	r4, r0, #48	; 0x30

	m[4] = ((uint8_t)'A') + ((uint8_t)((lon - ( ((uint8_t)(lon/2))*2)) / (5.0/60.0)));
 8013106:	4639      	mov	r1, r7
 8013108:	4630      	mov	r0, r6

	m[0] = ((uint8_t)'A') + ((uint8_t)(lon / 20));
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));
 801310a:	f88d 400b 	strb.w	r4, [sp, #11]

	m[4] = ((uint8_t)'A') + ((uint8_t)((lon - ( ((uint8_t)(lon/2))*2)) / (5.0/60.0)));
 801310e:	f7ed fa9f 	bl	8000650 <__aeabi_dmul>
 8013112:	f7ed fd55 	bl	8000bc0 <__aeabi_d2uiz>
 8013116:	b2c0      	uxtb	r0, r0
 8013118:	0040      	lsls	r0, r0, #1
 801311a:	f7ed fa33 	bl	8000584 <__aeabi_i2d>
 801311e:	4602      	mov	r2, r0
 8013120:	460b      	mov	r3, r1
 8013122:	4630      	mov	r0, r6
 8013124:	4639      	mov	r1, r7
 8013126:	f7ed f8df 	bl	80002e8 <__aeabi_dsub>
 801312a:	a319      	add	r3, pc, #100	; (adr r3, 8013190 <replace_placeholders+0x4c0>)
 801312c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013130:	f7ed fbb8 	bl	80008a4 <__aeabi_ddiv>
 8013134:	f7ed fd44 	bl	8000bc0 <__aeabi_d2uiz>
	m[5] = ((uint8_t)'A') + ((uint8_t)((lat - ( ((uint8_t)(lat/1))*1)) / (2.5/60.0)));
 8013138:	4649      	mov	r1, r9
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));

	m[4] = ((uint8_t)'A') + ((uint8_t)((lon - ( ((uint8_t)(lon/2))*2)) / (5.0/60.0)));
 801313a:	f100 0341 	add.w	r3, r0, #65	; 0x41
	m[5] = ((uint8_t)'A') + ((uint8_t)((lat - ( ((uint8_t)(lat/1))*1)) / (2.5/60.0)));
 801313e:	4640      	mov	r0, r8
	m[1] = ((uint8_t)'A') + ((uint8_t)(lat / 10));

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));

	m[4] = ((uint8_t)'A') + ((uint8_t)((lon - ( ((uint8_t)(lon/2))*2)) / (5.0/60.0)));
 8013140:	f88d 300c 	strb.w	r3, [sp, #12]
	m[5] = ((uint8_t)'A') + ((uint8_t)((lat - ( ((uint8_t)(lat/1))*1)) / (2.5/60.0)));
 8013144:	f7ed fd3c 	bl	8000bc0 <__aeabi_d2uiz>
 8013148:	b2c0      	uxtb	r0, r0
 801314a:	f7ed fa1b 	bl	8000584 <__aeabi_i2d>
 801314e:	4602      	mov	r2, r0
 8013150:	460b      	mov	r3, r1
 8013152:	4640      	mov	r0, r8
 8013154:	4649      	mov	r1, r9
 8013156:	f7ed f8c7 	bl	80002e8 <__aeabi_dsub>
 801315a:	a30f      	add	r3, pc, #60	; (adr r3, 8013198 <replace_placeholders+0x4c8>)
 801315c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013160:	f7ed fba0 	bl	80008a4 <__aeabi_ddiv>
 8013164:	f7ed fd2c 	bl	8000bc0 <__aeabi_d2uiz>

	m[6] = 0;
 8013168:	2400      	movs	r4, #0

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));

	m[4] = ((uint8_t)'A') + ((uint8_t)((lon - ( ((uint8_t)(lon/2))*2)) / (5.0/60.0)));
	m[5] = ((uint8_t)'A') + ((uint8_t)((lat - ( ((uint8_t)(lat/1))*1)) / (2.5/60.0)));
 801316a:	f100 0641 	add.w	r6, r0, #65	; 0x41
	chsnprintf(buf, sizeof(buf), "%d.%d", tp->ext_temp/100, (tp->ext_temp%100)/10);
	str_replace(fskmsg, size, "<ETEMP>", buf);
	chsnprintf(buf, sizeof(buf), "%d", tp->ext_hum/10);
	str_replace(fskmsg, size, "<EHUM>", buf);
	positionToMaidenhead(buf, tp->gps_lat/10000000.0, tp->gps_lon/10000000.0);
	str_replace(fskmsg, size, "<LOC>", buf);
 801316e:	ab02      	add	r3, sp, #8
 8013170:	4651      	mov	r1, sl
 8013172:	4628      	mov	r0, r5
 8013174:	4a10      	ldr	r2, [pc, #64]	; (80131b8 <replace_placeholders+0x4e8>)

	m[2] = ((uint8_t)'0') + ((uint8_t)(fmod(lon, 20)/2));
	m[3] = ((uint8_t)'0') + ((uint8_t)(fmod(lat, 10)/1));

	m[4] = ((uint8_t)'A') + ((uint8_t)((lon - ( ((uint8_t)(lon/2))*2)) / (5.0/60.0)));
	m[5] = ((uint8_t)'A') + ((uint8_t)((lat - ( ((uint8_t)(lat/1))*1)) / (2.5/60.0)));
 8013176:	f88d 600d 	strb.w	r6, [sp, #13]

	m[6] = 0;
 801317a:	f88d 400e 	strb.w	r4, [sp, #14]
	chsnprintf(buf, sizeof(buf), "%d.%d", tp->ext_temp/100, (tp->ext_temp%100)/10);
	str_replace(fskmsg, size, "<ETEMP>", buf);
	chsnprintf(buf, sizeof(buf), "%d", tp->ext_hum/10);
	str_replace(fskmsg, size, "<EHUM>", buf);
	positionToMaidenhead(buf, tp->gps_lat/10000000.0, tp->gps_lon/10000000.0);
	str_replace(fskmsg, size, "<LOC>", buf);
 801317e:	f7ff fd57 	bl	8012c30 <str_replace>
}
 8013182:	b007      	add	sp, #28
 8013184:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013188:	00000000 	.word	0x00000000
 801318c:	416312d0 	.word	0x416312d0
 8013190:	55555555 	.word	0x55555555
 8013194:	3fb55555 	.word	0x3fb55555
 8013198:	55555555 	.word	0x55555555
 801319c:	3fa55555 	.word	0x3fa55555
 80131a0:	080176b0 	.word	0x080176b0
 80131a4:	40668000 	.word	0x40668000
 80131a8:	40568000 	.word	0x40568000
 80131ac:	40340000 	.word	0x40340000
 80131b0:	40240000 	.word	0x40240000
 80131b4:	3fe00000 	.word	0x3fe00000
 80131b8:	080176b8 	.word	0x080176b8
 80131bc:	00000000 	.word	0x00000000

080131c0 <floor>:
 80131c0:	f3c1 520a 	ubfx	r2, r1, #20, #11
 80131c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80131c8:	f2a2 36ff 	subw	r6, r2, #1023	; 0x3ff
 80131cc:	2e13      	cmp	r6, #19
 80131ce:	460b      	mov	r3, r1
 80131d0:	460d      	mov	r5, r1
 80131d2:	4604      	mov	r4, r0
 80131d4:	4688      	mov	r8, r1
 80131d6:	4607      	mov	r7, r0
 80131d8:	dc1c      	bgt.n	8013214 <floor+0x54>
 80131da:	2e00      	cmp	r6, #0
 80131dc:	db3f      	blt.n	801325e <floor+0x9e>
 80131de:	4a3a      	ldr	r2, [pc, #232]	; (80132c8 <floor+0x108>)
 80131e0:	fa42 f906 	asr.w	r9, r2, r6
 80131e4:	ea01 0209 	and.w	r2, r1, r9
 80131e8:	4302      	orrs	r2, r0
 80131ea:	4686      	mov	lr, r0
 80131ec:	d017      	beq.n	801321e <floor+0x5e>
 80131ee:	a334      	add	r3, pc, #208	; (adr r3, 80132c0 <floor+0x100>)
 80131f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80131f4:	f7ed f87a 	bl	80002ec <__adddf3>
 80131f8:	2200      	movs	r2, #0
 80131fa:	2300      	movs	r3, #0
 80131fc:	f7ed fcbe 	bl	8000b7c <__aeabi_dcmpgt>
 8013200:	b120      	cbz	r0, 801320c <floor+0x4c>
 8013202:	2d00      	cmp	r5, #0
 8013204:	db40      	blt.n	8013288 <floor+0xc8>
 8013206:	ea28 0509 	bic.w	r5, r8, r9
 801320a:	2700      	movs	r7, #0
 801320c:	4638      	mov	r0, r7
 801320e:	4629      	mov	r1, r5
 8013210:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8013214:	2e33      	cmp	r6, #51	; 0x33
 8013216:	dd06      	ble.n	8013226 <floor+0x66>
 8013218:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 801321c:	d02f      	beq.n	801327e <floor+0xbe>
 801321e:	4620      	mov	r0, r4
 8013220:	4619      	mov	r1, r3
 8013222:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8013226:	f2a2 4213 	subw	r2, r2, #1043	; 0x413
 801322a:	f04f 39ff 	mov.w	r9, #4294967295
 801322e:	fa29 f902 	lsr.w	r9, r9, r2
 8013232:	ea10 0f09 	tst.w	r0, r9
 8013236:	d0f2      	beq.n	801321e <floor+0x5e>
 8013238:	a321      	add	r3, pc, #132	; (adr r3, 80132c0 <floor+0x100>)
 801323a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801323e:	f7ed f855 	bl	80002ec <__adddf3>
 8013242:	2200      	movs	r2, #0
 8013244:	2300      	movs	r3, #0
 8013246:	f7ed fc99 	bl	8000b7c <__aeabi_dcmpgt>
 801324a:	2800      	cmp	r0, #0
 801324c:	d0de      	beq.n	801320c <floor+0x4c>
 801324e:	2d00      	cmp	r5, #0
 8013250:	db20      	blt.n	8013294 <floor+0xd4>
 8013252:	4645      	mov	r5, r8
 8013254:	ea27 0709 	bic.w	r7, r7, r9
 8013258:	4638      	mov	r0, r7
 801325a:	4629      	mov	r1, r5
 801325c:	e7d8      	b.n	8013210 <floor+0x50>
 801325e:	a318      	add	r3, pc, #96	; (adr r3, 80132c0 <floor+0x100>)
 8013260:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013264:	f7ed f842 	bl	80002ec <__adddf3>
 8013268:	2200      	movs	r2, #0
 801326a:	2300      	movs	r3, #0
 801326c:	f7ed fc86 	bl	8000b7c <__aeabi_dcmpgt>
 8013270:	2800      	cmp	r0, #0
 8013272:	d0cb      	beq.n	801320c <floor+0x4c>
 8013274:	2d00      	cmp	r5, #0
 8013276:	db18      	blt.n	80132aa <floor+0xea>
 8013278:	2700      	movs	r7, #0
 801327a:	463d      	mov	r5, r7
 801327c:	e7c6      	b.n	801320c <floor+0x4c>
 801327e:	4602      	mov	r2, r0
 8013280:	460b      	mov	r3, r1
 8013282:	f7ed f833 	bl	80002ec <__adddf3>
 8013286:	e7cc      	b.n	8013222 <floor+0x62>
 8013288:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 801328c:	fa43 f606 	asr.w	r6, r3, r6
 8013290:	44b0      	add	r8, r6
 8013292:	e7b8      	b.n	8013206 <floor+0x46>
 8013294:	2e14      	cmp	r6, #20
 8013296:	d010      	beq.n	80132ba <floor+0xfa>
 8013298:	2301      	movs	r3, #1
 801329a:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 801329e:	fa03 f606 	lsl.w	r6, r3, r6
 80132a2:	1937      	adds	r7, r6, r4
 80132a4:	bf28      	it	cs
 80132a6:	4498      	addcs	r8, r3
 80132a8:	e7d3      	b.n	8013252 <floor+0x92>
 80132aa:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
 80132ae:	4b07      	ldr	r3, [pc, #28]	; (80132cc <floor+0x10c>)
 80132b0:	4322      	orrs	r2, r4
 80132b2:	bf18      	it	ne
 80132b4:	461d      	movne	r5, r3
 80132b6:	2700      	movs	r7, #0
 80132b8:	e7a8      	b.n	801320c <floor+0x4c>
 80132ba:	f105 0801 	add.w	r8, r5, #1
 80132be:	e7c8      	b.n	8013252 <floor+0x92>
 80132c0:	8800759c 	.word	0x8800759c
 80132c4:	7e37e43c 	.word	0x7e37e43c
 80132c8:	000fffff 	.word	0x000fffff
 80132cc:	bff00000 	.word	0xbff00000

080132d0 <fmod>:
 80132d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80132d4:	b08b      	sub	sp, #44	; 0x2c
 80132d6:	461d      	mov	r5, r3
 80132d8:	4680      	mov	r8, r0
 80132da:	4689      	mov	r9, r1
 80132dc:	4614      	mov	r4, r2
 80132de:	f000 f8d7 	bl	8013490 <__ieee754_fmod>
 80132e2:	4b2a      	ldr	r3, [pc, #168]	; (801338c <fmod+0xbc>)
 80132e4:	f993 a000 	ldrsb.w	sl, [r3]
 80132e8:	f1ba 3fff 	cmp.w	sl, #4294967295
 80132ec:	4606      	mov	r6, r0
 80132ee:	460f      	mov	r7, r1
 80132f0:	d02f      	beq.n	8013352 <fmod+0x82>
 80132f2:	4622      	mov	r2, r4
 80132f4:	462b      	mov	r3, r5
 80132f6:	4620      	mov	r0, r4
 80132f8:	4629      	mov	r1, r5
 80132fa:	f7ed fc49 	bl	8000b90 <__aeabi_dcmpun>
 80132fe:	bb40      	cbnz	r0, 8013352 <fmod+0x82>
 8013300:	4642      	mov	r2, r8
 8013302:	464b      	mov	r3, r9
 8013304:	4640      	mov	r0, r8
 8013306:	4649      	mov	r1, r9
 8013308:	f7ed fc42 	bl	8000b90 <__aeabi_dcmpun>
 801330c:	4683      	mov	fp, r0
 801330e:	bb00      	cbnz	r0, 8013352 <fmod+0x82>
 8013310:	2200      	movs	r2, #0
 8013312:	2300      	movs	r3, #0
 8013314:	4620      	mov	r0, r4
 8013316:	4629      	mov	r1, r5
 8013318:	f7ed fc08 	bl	8000b2c <__aeabi_dcmpeq>
 801331c:	b1c8      	cbz	r0, 8013352 <fmod+0x82>
 801331e:	4b1c      	ldr	r3, [pc, #112]	; (8013390 <fmod+0xc0>)
 8013320:	f8cd b020 	str.w	fp, [sp, #32]
 8013324:	2201      	movs	r2, #1
 8013326:	e9cd 8902 	strd	r8, r9, [sp, #8]
 801332a:	e9cd 4504 	strd	r4, r5, [sp, #16]
 801332e:	e88d 000c 	stmia.w	sp, {r2, r3}
 8013332:	f1ba 0f00 	cmp.w	sl, #0
 8013336:	d111      	bne.n	801335c <fmod+0x8c>
 8013338:	e9cd 8906 	strd	r8, r9, [sp, #24]
 801333c:	4668      	mov	r0, sp
 801333e:	f000 fb0f 	bl	8013960 <matherr>
 8013342:	b1b0      	cbz	r0, 8013372 <fmod+0xa2>
 8013344:	9b08      	ldr	r3, [sp, #32]
 8013346:	b9db      	cbnz	r3, 8013380 <fmod+0xb0>
 8013348:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801334c:	b00b      	add	sp, #44	; 0x2c
 801334e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013352:	4630      	mov	r0, r6
 8013354:	4639      	mov	r1, r7
 8013356:	b00b      	add	sp, #44	; 0x2c
 8013358:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801335c:	2200      	movs	r2, #0
 801335e:	2300      	movs	r3, #0
 8013360:	4610      	mov	r0, r2
 8013362:	4619      	mov	r1, r3
 8013364:	f7ed fa9e 	bl	80008a4 <__aeabi_ddiv>
 8013368:	f1ba 0f02 	cmp.w	sl, #2
 801336c:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8013370:	d1e4      	bne.n	801333c <fmod+0x6c>
 8013372:	f000 fb05 	bl	8013980 <__errno>
 8013376:	2321      	movs	r3, #33	; 0x21
 8013378:	6003      	str	r3, [r0, #0]
 801337a:	9b08      	ldr	r3, [sp, #32]
 801337c:	2b00      	cmp	r3, #0
 801337e:	d0e3      	beq.n	8013348 <fmod+0x78>
 8013380:	f000 fafe 	bl	8013980 <__errno>
 8013384:	9b08      	ldr	r3, [sp, #32]
 8013386:	6003      	str	r3, [r0, #0]
 8013388:	e7de      	b.n	8013348 <fmod+0x78>
 801338a:	bf00      	nop
 801338c:	20000c5c 	.word	0x20000c5c
 8013390:	080176c0 	.word	0x080176c0
	...

080133a0 <logf>:
 80133a0:	b570      	push	{r4, r5, r6, lr}
 80133a2:	b08a      	sub	sp, #40	; 0x28
 80133a4:	4604      	mov	r4, r0
 80133a6:	f000 f993 	bl	80136d0 <__ieee754_logf>
 80133aa:	4b31      	ldr	r3, [pc, #196]	; (8013470 <logf+0xd0>)
 80133ac:	f993 6000 	ldrsb.w	r6, [r3]
 80133b0:	1c73      	adds	r3, r6, #1
 80133b2:	4605      	mov	r5, r0
 80133b4:	d009      	beq.n	80133ca <logf+0x2a>
 80133b6:	4621      	mov	r1, r4
 80133b8:	4620      	mov	r0, r4
 80133ba:	f7ed ff49 	bl	8001250 <__aeabi_fcmpun>
 80133be:	b920      	cbnz	r0, 80133ca <logf+0x2a>
 80133c0:	2100      	movs	r1, #0
 80133c2:	4620      	mov	r0, r4
 80133c4:	f7ed ff38 	bl	8001238 <__aeabi_fcmpgt>
 80133c8:	b110      	cbz	r0, 80133d0 <logf+0x30>
 80133ca:	4628      	mov	r0, r5
 80133cc:	b00a      	add	sp, #40	; 0x28
 80133ce:	bd70      	pop	{r4, r5, r6, pc}
 80133d0:	4b28      	ldr	r3, [pc, #160]	; (8013474 <logf+0xd4>)
 80133d2:	9008      	str	r0, [sp, #32]
 80133d4:	4620      	mov	r0, r4
 80133d6:	9301      	str	r3, [sp, #4]
 80133d8:	f7ed f8e6 	bl	80005a8 <__aeabi_f2d>
 80133dc:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80133e0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80133e4:	4620      	mov	r0, r4
 80133e6:	b9be      	cbnz	r6, 8013418 <logf+0x78>
 80133e8:	4b23      	ldr	r3, [pc, #140]	; (8013478 <logf+0xd8>)
 80133ea:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80133ee:	2100      	movs	r1, #0
 80133f0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80133f4:	f7ed fef8 	bl	80011e8 <__aeabi_fcmpeq>
 80133f8:	2800      	cmp	r0, #0
 80133fa:	d031      	beq.n	8013460 <logf+0xc0>
 80133fc:	2302      	movs	r3, #2
 80133fe:	9300      	str	r3, [sp, #0]
 8013400:	4668      	mov	r0, sp
 8013402:	f000 faad 	bl	8013960 <matherr>
 8013406:	b198      	cbz	r0, 8013430 <logf+0x90>
 8013408:	9b08      	ldr	r3, [sp, #32]
 801340a:	b9b3      	cbnz	r3, 801343a <logf+0x9a>
 801340c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8013410:	f7ed fbf6 	bl	8000c00 <__aeabi_d2f>
 8013414:	b00a      	add	sp, #40	; 0x28
 8013416:	bd70      	pop	{r4, r5, r6, pc}
 8013418:	4b18      	ldr	r3, [pc, #96]	; (801347c <logf+0xdc>)
 801341a:	2200      	movs	r2, #0
 801341c:	2100      	movs	r1, #0
 801341e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8013422:	f7ed fee1 	bl	80011e8 <__aeabi_fcmpeq>
 8013426:	b168      	cbz	r0, 8013444 <logf+0xa4>
 8013428:	2302      	movs	r3, #2
 801342a:	429e      	cmp	r6, r3
 801342c:	9300      	str	r3, [sp, #0]
 801342e:	d1e7      	bne.n	8013400 <logf+0x60>
 8013430:	f000 faa6 	bl	8013980 <__errno>
 8013434:	2322      	movs	r3, #34	; 0x22
 8013436:	6003      	str	r3, [r0, #0]
 8013438:	e7e6      	b.n	8013408 <logf+0x68>
 801343a:	f000 faa1 	bl	8013980 <__errno>
 801343e:	9b08      	ldr	r3, [sp, #32]
 8013440:	6003      	str	r3, [r0, #0]
 8013442:	e7e3      	b.n	801340c <logf+0x6c>
 8013444:	2301      	movs	r3, #1
 8013446:	2e02      	cmp	r6, #2
 8013448:	9300      	str	r3, [sp, #0]
 801344a:	d10b      	bne.n	8013464 <logf+0xc4>
 801344c:	f000 fa98 	bl	8013980 <__errno>
 8013450:	2321      	movs	r3, #33	; 0x21
 8013452:	6003      	str	r3, [r0, #0]
 8013454:	480a      	ldr	r0, [pc, #40]	; (8013480 <logf+0xe0>)
 8013456:	f000 fa8b 	bl	8013970 <nan>
 801345a:	e9cd 0106 	strd	r0, r1, [sp, #24]
 801345e:	e7d3      	b.n	8013408 <logf+0x68>
 8013460:	2301      	movs	r3, #1
 8013462:	9300      	str	r3, [sp, #0]
 8013464:	4668      	mov	r0, sp
 8013466:	f000 fa7b 	bl	8013960 <matherr>
 801346a:	2800      	cmp	r0, #0
 801346c:	d1f2      	bne.n	8013454 <logf+0xb4>
 801346e:	e7ed      	b.n	801344c <logf+0xac>
 8013470:	20000c5c 	.word	0x20000c5c
 8013474:	080176c8 	.word	0x080176c8
 8013478:	c7efffff 	.word	0xc7efffff
 801347c:	fff00000 	.word	0xfff00000
 8013480:	080144f8 	.word	0x080144f8
	...

08013490 <__ieee754_fmod>:
 8013490:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013494:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
 8013498:	ea52 0609 	orrs.w	r6, r2, r9
 801349c:	d020      	beq.n	80134e0 <__ieee754_fmod+0x50>
 801349e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80134a2:	4f82      	ldr	r7, [pc, #520]	; (80136ac <__ieee754_fmod+0x21c>)
 80134a4:	ea81 0806 	eor.w	r8, r1, r6
 80134a8:	45b8      	cmp	r8, r7
 80134aa:	dc19      	bgt.n	80134e0 <__ieee754_fmod+0x50>
 80134ac:	4257      	negs	r7, r2
 80134ae:	4317      	orrs	r7, r2
 80134b0:	f8df b210 	ldr.w	fp, [pc, #528]	; 80136c4 <__ieee754_fmod+0x234>
 80134b4:	ea49 77d7 	orr.w	r7, r9, r7, lsr #31
 80134b8:	455f      	cmp	r7, fp
 80134ba:	4694      	mov	ip, r2
 80134bc:	d810      	bhi.n	80134e0 <__ieee754_fmod+0x50>
 80134be:	45c8      	cmp	r8, r9
 80134c0:	461d      	mov	r5, r3
 80134c2:	4682      	mov	sl, r0
 80134c4:	4604      	mov	r4, r0
 80134c6:	4696      	mov	lr, r2
 80134c8:	dc12      	bgt.n	80134f0 <__ieee754_fmod+0x60>
 80134ca:	db0f      	blt.n	80134ec <__ieee754_fmod+0x5c>
 80134cc:	4290      	cmp	r0, r2
 80134ce:	d30d      	bcc.n	80134ec <__ieee754_fmod+0x5c>
 80134d0:	d10e      	bne.n	80134f0 <__ieee754_fmod+0x60>
 80134d2:	4b77      	ldr	r3, [pc, #476]	; (80136b0 <__ieee754_fmod+0x220>)
 80134d4:	0ff6      	lsrs	r6, r6, #31
 80134d6:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 80134da:	e893 0003 	ldmia.w	r3, {r0, r1}
 80134de:	e005      	b.n	80134ec <__ieee754_fmod+0x5c>
 80134e0:	f7ed f8b6 	bl	8000650 <__aeabi_dmul>
 80134e4:	4602      	mov	r2, r0
 80134e6:	460b      	mov	r3, r1
 80134e8:	f7ed f9dc 	bl	80008a4 <__aeabi_ddiv>
 80134ec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80134f0:	f5b8 1f80 	cmp.w	r8, #1048576	; 0x100000
 80134f4:	da0e      	bge.n	8013514 <__ieee754_fmod+0x84>
 80134f6:	f1b8 0f00 	cmp.w	r8, #0
 80134fa:	f040 809b 	bne.w	8013634 <__ieee754_fmod+0x1a4>
 80134fe:	f1ba 0f00 	cmp.w	sl, #0
 8013502:	4653      	mov	r3, sl
 8013504:	496b      	ldr	r1, [pc, #428]	; (80136b4 <__ieee754_fmod+0x224>)
 8013506:	dd09      	ble.n	801351c <__ieee754_fmod+0x8c>
 8013508:	005b      	lsls	r3, r3, #1
 801350a:	2b00      	cmp	r3, #0
 801350c:	f101 31ff 	add.w	r1, r1, #4294967295
 8013510:	dcfa      	bgt.n	8013508 <__ieee754_fmod+0x78>
 8013512:	e003      	b.n	801351c <__ieee754_fmod+0x8c>
 8013514:	ea4f 5128 	mov.w	r1, r8, asr #20
 8013518:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
 801351c:	f5b9 1f80 	cmp.w	r9, #1048576	; 0x100000
 8013520:	da0e      	bge.n	8013540 <__ieee754_fmod+0xb0>
 8013522:	f1b9 0f00 	cmp.w	r9, #0
 8013526:	f040 809e 	bne.w	8013666 <__ieee754_fmod+0x1d6>
 801352a:	f1bc 0f00 	cmp.w	ip, #0
 801352e:	4663      	mov	r3, ip
 8013530:	4f60      	ldr	r7, [pc, #384]	; (80136b4 <__ieee754_fmod+0x224>)
 8013532:	dd09      	ble.n	8013548 <__ieee754_fmod+0xb8>
 8013534:	005b      	lsls	r3, r3, #1
 8013536:	2b00      	cmp	r3, #0
 8013538:	f107 37ff 	add.w	r7, r7, #4294967295
 801353c:	dcfa      	bgt.n	8013534 <__ieee754_fmod+0xa4>
 801353e:	e003      	b.n	8013548 <__ieee754_fmod+0xb8>
 8013540:	ea4f 5729 	mov.w	r7, r9, asr #20
 8013544:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 8013548:	4b5b      	ldr	r3, [pc, #364]	; (80136b8 <__ieee754_fmod+0x228>)
 801354a:	4299      	cmp	r1, r3
 801354c:	db55      	blt.n	80135fa <__ieee754_fmod+0x16a>
 801354e:	f3c8 0313 	ubfx	r3, r8, #0, #20
 8013552:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8013556:	4a58      	ldr	r2, [pc, #352]	; (80136b8 <__ieee754_fmod+0x228>)
 8013558:	4297      	cmp	r7, r2
 801355a:	db5d      	blt.n	8013618 <__ieee754_fmod+0x188>
 801355c:	f3c5 0513 	ubfx	r5, r5, #0, #20
 8013560:	f445 1580 	orr.w	r5, r5, #1048576	; 0x100000
 8013564:	1bc9      	subs	r1, r1, r7
 8013566:	e007      	b.n	8013578 <__ieee754_fmod+0xe8>
 8013568:	ea52 0300 	orrs.w	r3, r2, r0
 801356c:	d013      	beq.n	8013596 <__ieee754_fmod+0x106>
 801356e:	0fc3      	lsrs	r3, r0, #31
 8013570:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8013574:	0044      	lsls	r4, r0, #1
 8013576:	3901      	subs	r1, #1
 8013578:	ebce 0004 	rsb	r0, lr, r4
 801357c:	1b5a      	subs	r2, r3, r5
 801357e:	b189      	cbz	r1, 80135a4 <__ieee754_fmod+0x114>
 8013580:	4574      	cmp	r4, lr
 8013582:	bf38      	it	cc
 8013584:	f102 32ff 	addcc.w	r2, r2, #4294967295
 8013588:	2a00      	cmp	r2, #0
 801358a:	daed      	bge.n	8013568 <__ieee754_fmod+0xd8>
 801358c:	0fe2      	lsrs	r2, r4, #31
 801358e:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8013592:	0064      	lsls	r4, r4, #1
 8013594:	e7ef      	b.n	8013576 <__ieee754_fmod+0xe6>
 8013596:	4b46      	ldr	r3, [pc, #280]	; (80136b0 <__ieee754_fmod+0x220>)
 8013598:	0ff6      	lsrs	r6, r6, #31
 801359a:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
 801359e:	e896 0003 	ldmia.w	r6, {r0, r1}
 80135a2:	e7a3      	b.n	80134ec <__ieee754_fmod+0x5c>
 80135a4:	4574      	cmp	r4, lr
 80135a6:	4615      	mov	r5, r2
 80135a8:	bf38      	it	cc
 80135aa:	f102 35ff 	addcc.w	r5, r2, #4294967295
 80135ae:	2d00      	cmp	r5, #0
 80135b0:	bfac      	ite	ge
 80135b2:	ebce 0404 	rsbge	r4, lr, r4
 80135b6:	461d      	movlt	r5, r3
 80135b8:	ea55 0304 	orrs.w	r3, r5, r4
 80135bc:	d0eb      	beq.n	8013596 <__ieee754_fmod+0x106>
 80135be:	4a3f      	ldr	r2, [pc, #252]	; (80136bc <__ieee754_fmod+0x22c>)
 80135c0:	4295      	cmp	r5, r2
 80135c2:	dc08      	bgt.n	80135d6 <__ieee754_fmod+0x146>
 80135c4:	0fe3      	lsrs	r3, r4, #31
 80135c6:	eb03 0545 	add.w	r5, r3, r5, lsl #1
 80135ca:	4295      	cmp	r5, r2
 80135cc:	f107 37ff 	add.w	r7, r7, #4294967295
 80135d0:	ea4f 0444 	mov.w	r4, r4, lsl #1
 80135d4:	ddf6      	ble.n	80135c4 <__ieee754_fmod+0x134>
 80135d6:	4b38      	ldr	r3, [pc, #224]	; (80136b8 <__ieee754_fmod+0x228>)
 80135d8:	429f      	cmp	r7, r3
 80135da:	da4d      	bge.n	8013678 <__ieee754_fmod+0x1e8>
 80135dc:	4a36      	ldr	r2, [pc, #216]	; (80136b8 <__ieee754_fmod+0x228>)
 80135de:	1bd2      	subs	r2, r2, r7
 80135e0:	2a14      	cmp	r2, #20
 80135e2:	dc53      	bgt.n	801368c <__ieee754_fmod+0x1fc>
 80135e4:	f1c2 0320 	rsb	r3, r2, #32
 80135e8:	fa05 f303 	lsl.w	r3, r5, r3
 80135ec:	40d4      	lsrs	r4, r2
 80135ee:	4323      	orrs	r3, r4
 80135f0:	4115      	asrs	r5, r2
 80135f2:	ea45 0106 	orr.w	r1, r5, r6
 80135f6:	4618      	mov	r0, r3
 80135f8:	e778      	b.n	80134ec <__ieee754_fmod+0x5c>
 80135fa:	4c2f      	ldr	r4, [pc, #188]	; (80136b8 <__ieee754_fmod+0x228>)
 80135fc:	1a64      	subs	r4, r4, r1
 80135fe:	2c1f      	cmp	r4, #31
 8013600:	dc2b      	bgt.n	801365a <__ieee754_fmod+0x1ca>
 8013602:	f1c4 0320 	rsb	r3, r4, #32
 8013606:	fa08 f804 	lsl.w	r8, r8, r4
 801360a:	fa2a f303 	lsr.w	r3, sl, r3
 801360e:	ea43 0308 	orr.w	r3, r3, r8
 8013612:	fa0a f404 	lsl.w	r4, sl, r4
 8013616:	e79e      	b.n	8013556 <__ieee754_fmod+0xc6>
 8013618:	4827      	ldr	r0, [pc, #156]	; (80136b8 <__ieee754_fmod+0x228>)
 801361a:	1bc0      	subs	r0, r0, r7
 801361c:	281f      	cmp	r0, #31
 801361e:	dc15      	bgt.n	801364c <__ieee754_fmod+0x1bc>
 8013620:	f1c0 0220 	rsb	r2, r0, #32
 8013624:	fa09 f500 	lsl.w	r5, r9, r0
 8013628:	fa2c f202 	lsr.w	r2, ip, r2
 801362c:	4315      	orrs	r5, r2
 801362e:	fa0c fe00 	lsl.w	lr, ip, r0
 8013632:	e797      	b.n	8013564 <__ieee754_fmod+0xd4>
 8013634:	ea4f 23c8 	mov.w	r3, r8, lsl #11
 8013638:	2b00      	cmp	r3, #0
 801363a:	491f      	ldr	r1, [pc, #124]	; (80136b8 <__ieee754_fmod+0x228>)
 801363c:	f77f af6e 	ble.w	801351c <__ieee754_fmod+0x8c>
 8013640:	005b      	lsls	r3, r3, #1
 8013642:	2b00      	cmp	r3, #0
 8013644:	f101 31ff 	add.w	r1, r1, #4294967295
 8013648:	dcfa      	bgt.n	8013640 <__ieee754_fmod+0x1b0>
 801364a:	e767      	b.n	801351c <__ieee754_fmod+0x8c>
 801364c:	4d1c      	ldr	r5, [pc, #112]	; (80136c0 <__ieee754_fmod+0x230>)
 801364e:	1bed      	subs	r5, r5, r7
 8013650:	fa0c f505 	lsl.w	r5, ip, r5
 8013654:	f04f 0e00 	mov.w	lr, #0
 8013658:	e784      	b.n	8013564 <__ieee754_fmod+0xd4>
 801365a:	4b19      	ldr	r3, [pc, #100]	; (80136c0 <__ieee754_fmod+0x230>)
 801365c:	1a5b      	subs	r3, r3, r1
 801365e:	fa0a f303 	lsl.w	r3, sl, r3
 8013662:	2400      	movs	r4, #0
 8013664:	e777      	b.n	8013556 <__ieee754_fmod+0xc6>
 8013666:	4f14      	ldr	r7, [pc, #80]	; (80136b8 <__ieee754_fmod+0x228>)
 8013668:	ea4f 23c9 	mov.w	r3, r9, lsl #11
 801366c:	005b      	lsls	r3, r3, #1
 801366e:	2b00      	cmp	r3, #0
 8013670:	f107 37ff 	add.w	r7, r7, #4294967295
 8013674:	dcfa      	bgt.n	801366c <__ieee754_fmod+0x1dc>
 8013676:	e767      	b.n	8013548 <__ieee754_fmod+0xb8>
 8013678:	f5a5 1580 	sub.w	r5, r5, #1048576	; 0x100000
 801367c:	432e      	orrs	r6, r5
 801367e:	f207 37ff 	addw	r7, r7, #1023	; 0x3ff
 8013682:	ea46 5307 	orr.w	r3, r6, r7, lsl #20
 8013686:	4620      	mov	r0, r4
 8013688:	4619      	mov	r1, r3
 801368a:	e72f      	b.n	80134ec <__ieee754_fmod+0x5c>
 801368c:	2a1f      	cmp	r2, #31
 801368e:	dc07      	bgt.n	80136a0 <__ieee754_fmod+0x210>
 8013690:	f1c2 0320 	rsb	r3, r2, #32
 8013694:	409d      	lsls	r5, r3
 8013696:	40d4      	lsrs	r4, r2
 8013698:	ea45 0304 	orr.w	r3, r5, r4
 801369c:	4635      	mov	r5, r6
 801369e:	e7a8      	b.n	80135f2 <__ieee754_fmod+0x162>
 80136a0:	4b07      	ldr	r3, [pc, #28]	; (80136c0 <__ieee754_fmod+0x230>)
 80136a2:	1bdb      	subs	r3, r3, r7
 80136a4:	fa45 f303 	asr.w	r3, r5, r3
 80136a8:	4635      	mov	r5, r6
 80136aa:	e7a2      	b.n	80135f2 <__ieee754_fmod+0x162>
 80136ac:	7fefffff 	.word	0x7fefffff
 80136b0:	080176d0 	.word	0x080176d0
 80136b4:	fffffbed 	.word	0xfffffbed
 80136b8:	fffffc02 	.word	0xfffffc02
 80136bc:	000fffff 	.word	0x000fffff
 80136c0:	fffffbe2 	.word	0xfffffbe2
 80136c4:	7ff00000 	.word	0x7ff00000
	...

080136d0 <__ieee754_logf>:
 80136d0:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 80136d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80136d8:	b36a      	cbz	r2, 8013736 <__ieee754_logf+0x66>
 80136da:	2800      	cmp	r0, #0
 80136dc:	4601      	mov	r1, r0
 80136de:	4603      	mov	r3, r0
 80136e0:	db4a      	blt.n	8013778 <__ieee754_logf+0xa8>
 80136e2:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 80136e6:	da3b      	bge.n	8013760 <__ieee754_logf+0x90>
 80136e8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80136ec:	db3c      	blt.n	8013768 <__ieee754_logf+0x98>
 80136ee:	2400      	movs	r4, #0
 80136f0:	4a8c      	ldr	r2, [pc, #560]	; (8013924 <__ieee754_logf+0x254>)
 80136f2:	f3c3 0516 	ubfx	r5, r3, #0, #23
 80136f6:	442a      	add	r2, r5
 80136f8:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
 80136fc:	15db      	asrs	r3, r3, #23
 80136fe:	f082 507e 	eor.w	r0, r2, #1065353216	; 0x3f800000
 8013702:	3b7f      	subs	r3, #127	; 0x7f
 8013704:	4423      	add	r3, r4
 8013706:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 801370a:	4328      	orrs	r0, r5
 801370c:	eb03 54d2 	add.w	r4, r3, r2, lsr #23
 8013710:	f7ed faca 	bl	8000ca8 <__aeabi_fsub>
 8013714:	f105 030f 	add.w	r3, r5, #15
 8013718:	f3c3 0316 	ubfx	r3, r3, #0, #23
 801371c:	2b0f      	cmp	r3, #15
 801371e:	4606      	mov	r6, r0
 8013720:	dc31      	bgt.n	8013786 <__ieee754_logf+0xb6>
 8013722:	2100      	movs	r1, #0
 8013724:	f7ed fd60 	bl	80011e8 <__aeabi_fcmpeq>
 8013728:	2800      	cmp	r0, #0
 801372a:	f000 8092 	beq.w	8013852 <__ieee754_logf+0x182>
 801372e:	b94c      	cbnz	r4, 8013744 <__ieee754_logf+0x74>
 8013730:	2000      	movs	r0, #0
 8013732:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013736:	2100      	movs	r1, #0
 8013738:	f04f 404c 	mov.w	r0, #3422552064	; 0xcc000000
 801373c:	f7ed fc74 	bl	8001028 <__aeabi_fdiv>
 8013740:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013744:	4620      	mov	r0, r4
 8013746:	f7ed fb65 	bl	8000e14 <__aeabi_i2f>
 801374a:	4977      	ldr	r1, [pc, #476]	; (8013928 <__ieee754_logf+0x258>)
 801374c:	4605      	mov	r5, r0
 801374e:	f7ed fbb7 	bl	8000ec0 <__aeabi_fmul>
 8013752:	4976      	ldr	r1, [pc, #472]	; (801392c <__ieee754_logf+0x25c>)
 8013754:	4604      	mov	r4, r0
 8013756:	4628      	mov	r0, r5
 8013758:	f7ed fbb2 	bl	8000ec0 <__aeabi_fmul>
 801375c:	4601      	mov	r1, r0
 801375e:	4620      	mov	r0, r4
 8013760:	f7ed faa4 	bl	8000cac <__addsf3>
 8013764:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013768:	f04f 4198 	mov.w	r1, #1275068416	; 0x4c000000
 801376c:	f7ed fba8 	bl	8000ec0 <__aeabi_fmul>
 8013770:	f06f 0418 	mvn.w	r4, #24
 8013774:	4603      	mov	r3, r0
 8013776:	e7bb      	b.n	80136f0 <__ieee754_logf+0x20>
 8013778:	f7ed fa96 	bl	8000ca8 <__aeabi_fsub>
 801377c:	2100      	movs	r1, #0
 801377e:	f7ed fc53 	bl	8001028 <__aeabi_fdiv>
 8013782:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013786:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 801378a:	f7ed fa8f 	bl	8000cac <__addsf3>
 801378e:	4601      	mov	r1, r0
 8013790:	4630      	mov	r0, r6
 8013792:	f7ed fc49 	bl	8001028 <__aeabi_fdiv>
 8013796:	4681      	mov	r9, r0
 8013798:	4620      	mov	r0, r4
 801379a:	f7ed fb3b 	bl	8000e14 <__aeabi_i2f>
 801379e:	4649      	mov	r1, r9
 80137a0:	4682      	mov	sl, r0
 80137a2:	4648      	mov	r0, r9
 80137a4:	f7ed fb8c 	bl	8000ec0 <__aeabi_fmul>
 80137a8:	4601      	mov	r1, r0
 80137aa:	4683      	mov	fp, r0
 80137ac:	f7ed fb88 	bl	8000ec0 <__aeabi_fmul>
 80137b0:	495f      	ldr	r1, [pc, #380]	; (8013930 <__ieee754_logf+0x260>)
 80137b2:	4f60      	ldr	r7, [pc, #384]	; (8013934 <__ieee754_logf+0x264>)
 80137b4:	4680      	mov	r8, r0
 80137b6:	f7ed fb83 	bl	8000ec0 <__aeabi_fmul>
 80137ba:	495f      	ldr	r1, [pc, #380]	; (8013938 <__ieee754_logf+0x268>)
 80137bc:	f7ed fa76 	bl	8000cac <__addsf3>
 80137c0:	4641      	mov	r1, r8
 80137c2:	f7ed fb7d 	bl	8000ec0 <__aeabi_fmul>
 80137c6:	495d      	ldr	r1, [pc, #372]	; (801393c <__ieee754_logf+0x26c>)
 80137c8:	f7ed fa70 	bl	8000cac <__addsf3>
 80137cc:	4641      	mov	r1, r8
 80137ce:	f7ed fb77 	bl	8000ec0 <__aeabi_fmul>
 80137d2:	495b      	ldr	r1, [pc, #364]	; (8013940 <__ieee754_logf+0x270>)
 80137d4:	f7ed fa6a 	bl	8000cac <__addsf3>
 80137d8:	4659      	mov	r1, fp
 80137da:	f7ed fb71 	bl	8000ec0 <__aeabi_fmul>
 80137de:	4959      	ldr	r1, [pc, #356]	; (8013944 <__ieee754_logf+0x274>)
 80137e0:	4683      	mov	fp, r0
 80137e2:	4640      	mov	r0, r8
 80137e4:	f7ed fb6c 	bl	8000ec0 <__aeabi_fmul>
 80137e8:	4957      	ldr	r1, [pc, #348]	; (8013948 <__ieee754_logf+0x278>)
 80137ea:	f7ed fa5f 	bl	8000cac <__addsf3>
 80137ee:	4641      	mov	r1, r8
 80137f0:	f7ed fb66 	bl	8000ec0 <__aeabi_fmul>
 80137f4:	4955      	ldr	r1, [pc, #340]	; (801394c <__ieee754_logf+0x27c>)
 80137f6:	f7ed fa59 	bl	8000cac <__addsf3>
 80137fa:	4641      	mov	r1, r8
 80137fc:	f7ed fb60 	bl	8000ec0 <__aeabi_fmul>
 8013800:	4601      	mov	r1, r0
 8013802:	4658      	mov	r0, fp
 8013804:	f7ed fa52 	bl	8000cac <__addsf3>
 8013808:	f5c5 1357 	rsb	r3, r5, #3522560	; 0x35c000
 801380c:	442f      	add	r7, r5
 801380e:	f503 7322 	add.w	r3, r3, #648	; 0x288
 8013812:	431f      	orrs	r7, r3
 8013814:	2f00      	cmp	r7, #0
 8013816:	4680      	mov	r8, r0
 8013818:	dd65      	ble.n	80138e6 <__ieee754_logf+0x216>
 801381a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 801381e:	4630      	mov	r0, r6
 8013820:	f7ed fb4e 	bl	8000ec0 <__aeabi_fmul>
 8013824:	4631      	mov	r1, r6
 8013826:	f7ed fb4b 	bl	8000ec0 <__aeabi_fmul>
 801382a:	4605      	mov	r5, r0
 801382c:	2c00      	cmp	r4, #0
 801382e:	d132      	bne.n	8013896 <__ieee754_logf+0x1c6>
 8013830:	4629      	mov	r1, r5
 8013832:	4640      	mov	r0, r8
 8013834:	f7ed fa3a 	bl	8000cac <__addsf3>
 8013838:	4649      	mov	r1, r9
 801383a:	f7ed fb41 	bl	8000ec0 <__aeabi_fmul>
 801383e:	4601      	mov	r1, r0
 8013840:	4628      	mov	r0, r5
 8013842:	f7ed fa31 	bl	8000ca8 <__aeabi_fsub>
 8013846:	4601      	mov	r1, r0
 8013848:	4630      	mov	r0, r6
 801384a:	f7ed fa2d 	bl	8000ca8 <__aeabi_fsub>
 801384e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013852:	493f      	ldr	r1, [pc, #252]	; (8013950 <__ieee754_logf+0x280>)
 8013854:	4630      	mov	r0, r6
 8013856:	f7ed fb33 	bl	8000ec0 <__aeabi_fmul>
 801385a:	4601      	mov	r1, r0
 801385c:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
 8013860:	f7ed fa22 	bl	8000ca8 <__aeabi_fsub>
 8013864:	4631      	mov	r1, r6
 8013866:	4605      	mov	r5, r0
 8013868:	4630      	mov	r0, r6
 801386a:	f7ed fb29 	bl	8000ec0 <__aeabi_fmul>
 801386e:	4601      	mov	r1, r0
 8013870:	4628      	mov	r0, r5
 8013872:	f7ed fb25 	bl	8000ec0 <__aeabi_fmul>
 8013876:	4605      	mov	r5, r0
 8013878:	2c00      	cmp	r4, #0
 801387a:	d02e      	beq.n	80138da <__ieee754_logf+0x20a>
 801387c:	4620      	mov	r0, r4
 801387e:	f7ed fac9 	bl	8000e14 <__aeabi_i2f>
 8013882:	4929      	ldr	r1, [pc, #164]	; (8013928 <__ieee754_logf+0x258>)
 8013884:	4607      	mov	r7, r0
 8013886:	f7ed fb1b 	bl	8000ec0 <__aeabi_fmul>
 801388a:	4928      	ldr	r1, [pc, #160]	; (801392c <__ieee754_logf+0x25c>)
 801388c:	4604      	mov	r4, r0
 801388e:	4638      	mov	r0, r7
 8013890:	f7ed fb16 	bl	8000ec0 <__aeabi_fmul>
 8013894:	e014      	b.n	80138c0 <__ieee754_logf+0x1f0>
 8013896:	4924      	ldr	r1, [pc, #144]	; (8013928 <__ieee754_logf+0x258>)
 8013898:	4650      	mov	r0, sl
 801389a:	f7ed fb11 	bl	8000ec0 <__aeabi_fmul>
 801389e:	4629      	mov	r1, r5
 80138a0:	4604      	mov	r4, r0
 80138a2:	4640      	mov	r0, r8
 80138a4:	f7ed fa02 	bl	8000cac <__addsf3>
 80138a8:	4649      	mov	r1, r9
 80138aa:	f7ed fb09 	bl	8000ec0 <__aeabi_fmul>
 80138ae:	491f      	ldr	r1, [pc, #124]	; (801392c <__ieee754_logf+0x25c>)
 80138b0:	4607      	mov	r7, r0
 80138b2:	4650      	mov	r0, sl
 80138b4:	f7ed fb04 	bl	8000ec0 <__aeabi_fmul>
 80138b8:	4601      	mov	r1, r0
 80138ba:	4638      	mov	r0, r7
 80138bc:	f7ed f9f6 	bl	8000cac <__addsf3>
 80138c0:	4601      	mov	r1, r0
 80138c2:	4628      	mov	r0, r5
 80138c4:	f7ed f9f0 	bl	8000ca8 <__aeabi_fsub>
 80138c8:	4631      	mov	r1, r6
 80138ca:	f7ed f9ed 	bl	8000ca8 <__aeabi_fsub>
 80138ce:	4601      	mov	r1, r0
 80138d0:	4620      	mov	r0, r4
 80138d2:	f7ed f9e9 	bl	8000ca8 <__aeabi_fsub>
 80138d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80138da:	4601      	mov	r1, r0
 80138dc:	4630      	mov	r0, r6
 80138de:	f7ed f9e3 	bl	8000ca8 <__aeabi_fsub>
 80138e2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80138e6:	b17c      	cbz	r4, 8013908 <__ieee754_logf+0x238>
 80138e8:	490f      	ldr	r1, [pc, #60]	; (8013928 <__ieee754_logf+0x258>)
 80138ea:	4650      	mov	r0, sl
 80138ec:	f7ed fae8 	bl	8000ec0 <__aeabi_fmul>
 80138f0:	4641      	mov	r1, r8
 80138f2:	4604      	mov	r4, r0
 80138f4:	4630      	mov	r0, r6
 80138f6:	f7ed f9d7 	bl	8000ca8 <__aeabi_fsub>
 80138fa:	4649      	mov	r1, r9
 80138fc:	f7ed fae0 	bl	8000ec0 <__aeabi_fmul>
 8013900:	490a      	ldr	r1, [pc, #40]	; (801392c <__ieee754_logf+0x25c>)
 8013902:	4605      	mov	r5, r0
 8013904:	4650      	mov	r0, sl
 8013906:	e7c3      	b.n	8013890 <__ieee754_logf+0x1c0>
 8013908:	4601      	mov	r1, r0
 801390a:	4630      	mov	r0, r6
 801390c:	f7ed f9cc 	bl	8000ca8 <__aeabi_fsub>
 8013910:	4649      	mov	r1, r9
 8013912:	f7ed fad5 	bl	8000ec0 <__aeabi_fmul>
 8013916:	4601      	mov	r1, r0
 8013918:	4630      	mov	r0, r6
 801391a:	f7ed f9c5 	bl	8000ca8 <__aeabi_fsub>
 801391e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013922:	bf00      	nop
 8013924:	004afb20 	.word	0x004afb20
 8013928:	3f317180 	.word	0x3f317180
 801392c:	3717f7d1 	.word	0x3717f7d1
 8013930:	3e178897 	.word	0x3e178897
 8013934:	ffcf5c30 	.word	0xffcf5c30
 8013938:	3e3a3325 	.word	0x3e3a3325
 801393c:	3e924925 	.word	0x3e924925
 8013940:	3f2aaaab 	.word	0x3f2aaaab
 8013944:	3e1cd04f 	.word	0x3e1cd04f
 8013948:	3e638e29 	.word	0x3e638e29
 801394c:	3ecccccd 	.word	0x3ecccccd
 8013950:	3eaaaaab 	.word	0x3eaaaaab
	...

08013960 <matherr>:
 8013960:	2000      	movs	r0, #0
 8013962:	4770      	bx	lr
	...

08013970 <nan>:
 8013970:	2000      	movs	r0, #0
 8013972:	4901      	ldr	r1, [pc, #4]	; (8013978 <nan+0x8>)
 8013974:	4770      	bx	lr
 8013976:	bf00      	nop
 8013978:	7ff80000 	.word	0x7ff80000
 801397c:	00000000 	.word	0x00000000

08013980 <__errno>:
 8013980:	4b01      	ldr	r3, [pc, #4]	; (8013988 <__errno+0x8>)
 8013982:	6818      	ldr	r0, [r3, #0]
 8013984:	4770      	bx	lr
 8013986:	bf00      	nop
 8013988:	20000c58 	.word	0x20000c58
 801398c:	00000000 	.word	0x00000000

08013990 <memmove>:
 8013990:	4288      	cmp	r0, r1
 8013992:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013994:	d90d      	bls.n	80139b2 <memmove+0x22>
 8013996:	188b      	adds	r3, r1, r2
 8013998:	4298      	cmp	r0, r3
 801399a:	d20a      	bcs.n	80139b2 <memmove+0x22>
 801399c:	1881      	adds	r1, r0, r2
 801399e:	2a00      	cmp	r2, #0
 80139a0:	d051      	beq.n	8013a46 <memmove+0xb6>
 80139a2:	1a9a      	subs	r2, r3, r2
 80139a4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80139a8:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80139ac:	4293      	cmp	r3, r2
 80139ae:	d1f9      	bne.n	80139a4 <memmove+0x14>
 80139b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80139b2:	2a0f      	cmp	r2, #15
 80139b4:	d948      	bls.n	8013a48 <memmove+0xb8>
 80139b6:	ea41 0300 	orr.w	r3, r1, r0
 80139ba:	079b      	lsls	r3, r3, #30
 80139bc:	d146      	bne.n	8013a4c <memmove+0xbc>
 80139be:	f100 0410 	add.w	r4, r0, #16
 80139c2:	f101 0310 	add.w	r3, r1, #16
 80139c6:	4615      	mov	r5, r2
 80139c8:	f853 6c10 	ldr.w	r6, [r3, #-16]
 80139cc:	f844 6c10 	str.w	r6, [r4, #-16]
 80139d0:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 80139d4:	f844 6c0c 	str.w	r6, [r4, #-12]
 80139d8:	f853 6c08 	ldr.w	r6, [r3, #-8]
 80139dc:	f844 6c08 	str.w	r6, [r4, #-8]
 80139e0:	3d10      	subs	r5, #16
 80139e2:	f853 6c04 	ldr.w	r6, [r3, #-4]
 80139e6:	f844 6c04 	str.w	r6, [r4, #-4]
 80139ea:	2d0f      	cmp	r5, #15
 80139ec:	f103 0310 	add.w	r3, r3, #16
 80139f0:	f104 0410 	add.w	r4, r4, #16
 80139f4:	d8e8      	bhi.n	80139c8 <memmove+0x38>
 80139f6:	f1a2 0310 	sub.w	r3, r2, #16
 80139fa:	f023 030f 	bic.w	r3, r3, #15
 80139fe:	f002 0e0f 	and.w	lr, r2, #15
 8013a02:	3310      	adds	r3, #16
 8013a04:	f1be 0f03 	cmp.w	lr, #3
 8013a08:	4419      	add	r1, r3
 8013a0a:	4403      	add	r3, r0
 8013a0c:	d921      	bls.n	8013a52 <memmove+0xc2>
 8013a0e:	1f1e      	subs	r6, r3, #4
 8013a10:	460d      	mov	r5, r1
 8013a12:	4674      	mov	r4, lr
 8013a14:	3c04      	subs	r4, #4
 8013a16:	f855 7b04 	ldr.w	r7, [r5], #4
 8013a1a:	f846 7f04 	str.w	r7, [r6, #4]!
 8013a1e:	2c03      	cmp	r4, #3
 8013a20:	d8f8      	bhi.n	8013a14 <memmove+0x84>
 8013a22:	f1ae 0404 	sub.w	r4, lr, #4
 8013a26:	f024 0403 	bic.w	r4, r4, #3
 8013a2a:	3404      	adds	r4, #4
 8013a2c:	4423      	add	r3, r4
 8013a2e:	4421      	add	r1, r4
 8013a30:	f002 0203 	and.w	r2, r2, #3
 8013a34:	b162      	cbz	r2, 8013a50 <memmove+0xc0>
 8013a36:	3b01      	subs	r3, #1
 8013a38:	440a      	add	r2, r1
 8013a3a:	f811 4b01 	ldrb.w	r4, [r1], #1
 8013a3e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8013a42:	428a      	cmp	r2, r1
 8013a44:	d1f9      	bne.n	8013a3a <memmove+0xaa>
 8013a46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013a48:	4603      	mov	r3, r0
 8013a4a:	e7f3      	b.n	8013a34 <memmove+0xa4>
 8013a4c:	4603      	mov	r3, r0
 8013a4e:	e7f2      	b.n	8013a36 <memmove+0xa6>
 8013a50:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013a52:	4672      	mov	r2, lr
 8013a54:	e7ee      	b.n	8013a34 <memmove+0xa4>
 8013a56:	bf00      	nop
	...

08013a60 <memset>:
 8013a60:	b470      	push	{r4, r5, r6}
 8013a62:	0784      	lsls	r4, r0, #30
 8013a64:	d046      	beq.n	8013af4 <memset+0x94>
 8013a66:	1e54      	subs	r4, r2, #1
 8013a68:	2a00      	cmp	r2, #0
 8013a6a:	d041      	beq.n	8013af0 <memset+0x90>
 8013a6c:	b2cd      	uxtb	r5, r1
 8013a6e:	4603      	mov	r3, r0
 8013a70:	e002      	b.n	8013a78 <memset+0x18>
 8013a72:	1e62      	subs	r2, r4, #1
 8013a74:	b3e4      	cbz	r4, 8013af0 <memset+0x90>
 8013a76:	4614      	mov	r4, r2
 8013a78:	f803 5b01 	strb.w	r5, [r3], #1
 8013a7c:	079a      	lsls	r2, r3, #30
 8013a7e:	d1f8      	bne.n	8013a72 <memset+0x12>
 8013a80:	2c03      	cmp	r4, #3
 8013a82:	d92e      	bls.n	8013ae2 <memset+0x82>
 8013a84:	b2cd      	uxtb	r5, r1
 8013a86:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8013a8a:	2c0f      	cmp	r4, #15
 8013a8c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8013a90:	d919      	bls.n	8013ac6 <memset+0x66>
 8013a92:	f103 0210 	add.w	r2, r3, #16
 8013a96:	4626      	mov	r6, r4
 8013a98:	3e10      	subs	r6, #16
 8013a9a:	2e0f      	cmp	r6, #15
 8013a9c:	f842 5c10 	str.w	r5, [r2, #-16]
 8013aa0:	f842 5c0c 	str.w	r5, [r2, #-12]
 8013aa4:	f842 5c08 	str.w	r5, [r2, #-8]
 8013aa8:	f842 5c04 	str.w	r5, [r2, #-4]
 8013aac:	f102 0210 	add.w	r2, r2, #16
 8013ab0:	d8f2      	bhi.n	8013a98 <memset+0x38>
 8013ab2:	f1a4 0210 	sub.w	r2, r4, #16
 8013ab6:	f022 020f 	bic.w	r2, r2, #15
 8013aba:	f004 040f 	and.w	r4, r4, #15
 8013abe:	3210      	adds	r2, #16
 8013ac0:	2c03      	cmp	r4, #3
 8013ac2:	4413      	add	r3, r2
 8013ac4:	d90d      	bls.n	8013ae2 <memset+0x82>
 8013ac6:	461e      	mov	r6, r3
 8013ac8:	4622      	mov	r2, r4
 8013aca:	3a04      	subs	r2, #4
 8013acc:	2a03      	cmp	r2, #3
 8013ace:	f846 5b04 	str.w	r5, [r6], #4
 8013ad2:	d8fa      	bhi.n	8013aca <memset+0x6a>
 8013ad4:	1f22      	subs	r2, r4, #4
 8013ad6:	f022 0203 	bic.w	r2, r2, #3
 8013ada:	3204      	adds	r2, #4
 8013adc:	4413      	add	r3, r2
 8013ade:	f004 0403 	and.w	r4, r4, #3
 8013ae2:	b12c      	cbz	r4, 8013af0 <memset+0x90>
 8013ae4:	b2c9      	uxtb	r1, r1
 8013ae6:	441c      	add	r4, r3
 8013ae8:	f803 1b01 	strb.w	r1, [r3], #1
 8013aec:	42a3      	cmp	r3, r4
 8013aee:	d1fb      	bne.n	8013ae8 <memset+0x88>
 8013af0:	bc70      	pop	{r4, r5, r6}
 8013af2:	4770      	bx	lr
 8013af4:	4614      	mov	r4, r2
 8013af6:	4603      	mov	r3, r0
 8013af8:	e7c2      	b.n	8013a80 <memset+0x20>
 8013afa:	bf00      	nop
